<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「Luogu-T47720」孤立元</title>
    <url>/luogu-t47720-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/T47720">传送门</a></p>
<a id="more"></a>
<p>自己出的第一道<del>毒瘤</del>数论题。</p>
<p>对于每一个 $i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有 $i-1\notin B$ 且 $i+1\notin B$，而其他 $n-3$ 个数无论怎样都无法阻止 $i$ 对所有孤立元的和产生贡献，此时，其他 $n-3$ 个数中有且仅有 $m-1$ 个属于 $B$，其总方案数为 $C_{n-3}^{m-1}$。而对于 $1$ 和 $n$ 来说，它们只有 $1$ 个相邻的元素，因此方案数为 $C_{n-2}^{m-1}$。本题答案即为</p>
<script type="math/tex; mode=display">
\frac{\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}</script><p>将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式</p>
<script type="math/tex; mode=display">
\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\frac{m(n+1)(n-m)}{n(n-1)}</script><blockquote>
<p>Updated on 2018-10-10</p>
<p>之前公式写错了，分子上的 $m$ 全都漏掉了（</p>
<p>以及，我们还可以将上式继续整理：</p>
<script type="math/tex; mode=display">
\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}</script><p><del>以及，顺便测试了一下新的快读板子，然后发现 <code>#ifdef</code> 真没用也可能是我太菜了（</del></p>
<blockquote>
<p>Updated on 2018-10-16</p>
<p>好吧我当时并不会用 <code>#ifdef</code>（</p>
</blockquote>
<p>以及，标程经过一系列<del>丧心病狂的</del>卡常卡到了 $1861\text{ms}$，最慢的一个点只跑了 $300\text{ms}$ 不到。截至本日，另外两个切掉这道题的 $\text{dalao}$ 最慢的一个点也只跑了 $400\text{ms}$ 上下。我要不要考虑加强一波数据或者缩一波时限呢？<del>所以说为什么我当初在本地测的时候平均每个点 $500\text{ms}$，是我们机房的电脑太菜了吗（</del></p>
</blockquote>
<p>于是做法就有了，先 $O(n)$ 预处理一遍，然后单次询问即可 $O(1)$ 解决。</p>
<p>但是常数好像会很大，我原计划是要将数据范围开到 $10^{7}$ 级别的，然而自己写的标程都跑不过，于是只能一路削到现在的 $10^{6}$……</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P3924」康娜的线段树</title>
    <url>/luogu-p3924-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3924">传送门</a></p>
<a id="more"></a>
<p>读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：</p>
<blockquote>
<p>对于 $70\%$ 的数据，保证 $1\leqslant n,m\leqslant 10^{5}$。</p>
<p>对于 $100\%$ 的数据，保证 $1\leqslant n,m\leqslant 10^{6}$。</p>
</blockquote>
<p><del>也就是说，上述做法<strong>最多</strong>只能拿 $70$ 分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定 $70$ 分都拿不到了。</del></p>
<blockquote>
<p>Updated on 2018-10-09</p>
<p>不好意思时间复杂度算错了我太菜了。</p>
<p>但反正线段树需要卡常才能过（</p>
</blockquote>
<p>我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。</p>
<p>定义 $E_i$ 为叶子节点 $[i,i]$ 对答案的贡献，$c_i$ 为其所有祖先节点被访问的概率之和，不难发现 $c_ia_i=E_i$。我们只要预处理出 $c_i$，计算出 $\prod_{i=1}^{n}c_ia_i$，然后处理出 $c_i$ 的前缀和，每次操作直接查询操作区间内 $c_i$ 的和，再乘以他给的那个数，累加到答案上就可以了。</p>
<p>稍加分析，我们不难得出如下结论。设根节点深度为 $0$，则任意一个节点，就比如说 $x$，被访问的概率为 $2^{-dep[x]}$，其中 $dep[x]$ 表示 $x$ 的深度。而对于 $x$ 子树内的每一个叶子节点 $[i,i]$，我们执行一次 $c_i+=2^{-dep[x]}$ 即可。我们可以用一次类似于树形 DP 的 DFS 来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在 DFS 时，我们实际上修改的是 $c$ 数组的差分数组，DFS 结束后再还原出 $c$ 数组即可。</p>
<p>以及，最后一句话。</p>
<p>这道题卡精度。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>珂朵莉树学习笔记</title>
    <url>/chtholly-tree-learning-notes/</url>
    <content><![CDATA[<p><del>还有三周就是 NOIp 复赛了，我还在这学些乱七八糟的东西怕不是要凉。</del></p>
<p><del>话说上面那个数字是 3 你们看的出来吗，反正我在我的编辑器内看不出来。</del></p>
<p>总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。</p>
<a id="more"></a>
<p>我们先来看一道<del>毒瘤</del>例题，<a href="http://codeforces.com/contest/896/problem/C">「CF896C」Willem, Chtholly and Seniorious</a>。</p>
<p>如果只看前三个操作的话<del>，虽然我不会写也没写过</del>，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间 $10^{9}$ 次方和？认真的？</p>
<p>这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫 Old Driver Tree，简称 ODT。当然您也可以叫它 Chtholly Tree。从本质上来讲，珂朵莉树是一种基于 <code>std::set</code> 的暴力数据结构<del>，虽然您也可以手写一颗平衡树</del>，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：</p>
<blockquote>
<p>珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。</p>
</blockquote>
<p>那么怎么推平呢？不急，我们慢慢讲。</p>
<p>珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> l,r;</span><br><span class="line"> <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line"> <span class="comment">// 这里的 mutable 是为了让我们在之后的修改过程中可以修改 val 的值</span></span><br><span class="line"></span><br><span class="line"> node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line"> <span class="comment">// 调用时_r 或_val 不填的话默认 -1，为了后面 split 时方便</span></span><br><span class="line"> l=_l;</span><br><span class="line"> r=_r;</span><br><span class="line"> val=_val;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line"> <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以初始化了。对于这道题，我们可以像这样初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"> s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>初始化完了？</p>
<p>初始化完了。</p>
<p>然后就是珂朵莉树的核心操作<del>之一</del>，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::&lt;<span class="built_in">set</span>&gt;::<span class="function">iterator <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br></pre></td></tr></table></figure>
<p>作用是分离出一个左端点为 <code>pos</code> 的区间并返回它的迭代器。它的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="comment">// 上面这句手打非常麻烦，建议宏定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"> _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line"> <span class="comment">// 找第一个左端点大于等于 pos 的区间</span></span><br><span class="line"> <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line"> <span class="keyword">return</span> it;</span><br><span class="line"> <span class="comment">// 如果找到了一个左端点恰好为 pos 的区间，我们就不用 split 了，直接返回它的迭代器</span></span><br><span class="line"> --it;</span><br><span class="line"> <span class="comment">// 否则当前区间的左端点一定大于 pos，pos 这个位置一定在前一个区间内</span></span><br><span class="line"> <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line"> <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line"> s.erase(it);</span><br><span class="line"> s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line"> <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line"> <span class="comment">// 将区间[l,r]删除，并插入区间[l,pos) 和[pos,r]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。</p>
<p><code>insert</code> 函数的返回值类型是 <code>std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;</code><del>，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了</del>，因此我们需要加个 <code>.first</code>。</p>
<p><code>std::set</code> 内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似 $O(\operatorname{log}n)$ 的。</p>
<p>然后是一个同样很核心的操作，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure>
<p>将区间 $[l,r]$ 推平，全部赋成 $x$。它的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> <span class="comment">// 注意一定要先 split(r+1) 再 split(l)，因为如果 l 与 r+1 一开始恰好在同一区间内</span></span><br><span class="line"> <span class="comment">// 后 split(r+1)~~大概~~会修改树中左端点为 l 的区间的迭代器</span></span><br><span class="line"> s.erase(itl,itr);</span><br><span class="line"> <span class="comment">// 将[itl,itr) 内所有区间删除</span></span><br><span class="line"> s.insert(node(l,r,x));</span><br><span class="line"> <span class="comment">// 用一个大区间取代它们</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就完了？</p>
<p>这就完了。</p>
<p><code>assign</code> 操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得 <code>set</code> 的大小迅速减小，并最终趋于 $\operatorname{log}n$。本题的操作二就只需调用一次 <code>assign(l,r,x)</code> 即可。</p>
<p>然后是剩下的三个操作<del>，一个比一个暴力</del>。</p>
<p>操作一，一个一个区间地拿出来加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line"> p-&gt;val+=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这么几行？</p>
<p>就这么几行。</p>
<p>操作三，把所有区间取出来，然后直接调用 <code>std::sort</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> vec.clear();</span><br><span class="line"> <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line"> vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line"> <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line"> x-=vec[i].second;</span><br><span class="line"> <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> vec[i].first;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作四，暴力快速幂。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line"> res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？</p>
<p>这是我在 CodeForces 上的提交记录：</p>
<p><img src="https://i.loli.net/2018/10/14/5bc28b1443ea5.png" alt=""></p>
<p>这是我之前提到的那位<del>不愿意透露姓名的</del>珂学家的跑得最快的一次提交记录：</p>
<p><img src="https://i.loli.net/2018/10/14/5bc28c7ecfe96.png" alt=""></p>
<p><img src="https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg" alt=""></p>
<p>珂幻 .jpg</p>
<p>因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了<a href="http://codeforces.com/contest/915/problem/E">「CF915E」Physical Education Lessons</a>，然而……</p>
<p><img src="https://i.loli.net/2018/10/14/5bc297890bbc6.png" alt=""></p>
<blockquote>
<p>Updated on 2018-11-01</p>
<p>后来我卡了卡常数过了……</p>
<p>以及，删掉了某些内容（</p>
</blockquote>
<p>于是，接下来是珂朵莉树的完整板子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line"> <span class="keyword">char</span> str[size+<span class="number">1</span>],*head=str,*tail=str;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line"> tail=(head=str)+fread(str,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line"> <span class="keyword">if</span>(head==tail)</span><br><span class="line"> <span class="keyword">return</span> EOF;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> *head++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">char</span> c=gc();</span><br><span class="line"> <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line"> <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line"> sn=<span class="number">-1</span>,c=gc();</span><br><span class="line"> <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line"> x*=sn;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="string">' '</span>)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="built_in">putchar</span>(<span class="number">45</span>),x=-x;</span><br><span class="line"> <span class="keyword">if</span>(!x)</span><br><span class="line"> <span class="built_in">putchar</span>(<span class="number">48</span>);</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">int</span> digit[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line"> <span class="keyword">for</span>(;digit[<span class="number">0</span>];<span class="built_in">putchar</span>(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">putchar</span>(text);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,seed,maxval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> l,r;</span><br><span class="line"> <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line"> node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line"> l=_l;</span><br><span class="line"> r=_r;</span><br><span class="line"> val=_val;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> res=seed;</span><br><span class="line"> seed=(<span class="number">7L</span>L*seed+<span class="number">13</span>)%<span class="number">1000000007</span>;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; l,<span class="keyword">int</span>&amp; r)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> tmp=l;</span><br><span class="line"> l=r;</span><br><span class="line"> r=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(y==<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line"> <span class="keyword">int</span> res=cltpow(x,y&gt;&gt;<span class="number">1</span>,mod);</span><br><span class="line"> res=<span class="number">1L</span>L*res*res%mod;</span><br><span class="line"> <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line"> res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line"> <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"> _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line"> <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line"> <span class="keyword">return</span> it;</span><br><span class="line"> --it;</span><br><span class="line"> <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line"> <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line"> s.erase(it);</span><br><span class="line"> s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line"> <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line"> p-&gt;val+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAssign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">// 就是之前提到的 assign</span></span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> s.erase(itl,itr);</span><br><span class="line"> s.insert(node(l,r,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> vec.clear();</span><br><span class="line"> <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line"> vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line"> <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line"> x-=vec[i].second;</span><br><span class="line"> <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> vec[i].first;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"> _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line"> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line"> res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> cltstream::read(n);</span><br><span class="line"> cltstream::read(m);</span><br><span class="line"> cltstream::read(seed);</span><br><span class="line"> cltstream::read(maxval);</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"> s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"> <span class="keyword">int</span> opt=rnd()%<span class="number">4</span>+<span class="number">1</span>,l=rnd()%n+<span class="number">1</span>,r=rnd()%n+<span class="number">1</span>,x,y;</span><br><span class="line"> <span class="keyword">if</span>(l&gt;r)</span><br><span class="line"> swap(l,r);</span><br><span class="line"> <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line"> IntervalAdd(l,r,x);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line"> IntervalAssign(l,r,x);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"> x=rnd()%(r-l+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"> cltstream::write(IntervalXth(l,r,x),<span class="string">'\n'</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"> x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line"> y=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line"> cltstream::write(IntervalXpow(l,r,x,y),<span class="string">'\n'</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title>状态压缩动态规划学习笔记</title>
    <url>/status-compression-learning-notes/</url>
    <content><![CDATA[<p><del>把标签和分类连在一起读就是标题了（</del></p>
<p><del>好像上一篇珂朵莉树学习笔记也是这样（</del></p>
<p><del>马上就要复赛了，但反正我已经退役预定了来颓 blog 吧。</del></p>
<a id="more"></a>
<p>首先我们来看一道例题，<a href="https://www.luogu.org/problemnew/show/P1879">「USACO06NOV」玉米田 Corn Fields</a>。</p>
<p>首先，我们想到定义 <code>f[i][...]</code> 表示当前处理到第 $i$ 行，然后 blablabla 一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第 $i$ 行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……<code>f[i][0/1]...( 省略 10 个[0/1])...[0/1]</code>，后面 $12$ 维状态中第 $j+1$ 维表示的是第 $i$ 行第 $j$ 列是否种草。</p>
<p>但是等等……$13$ 维的状态……</p>
<p><img src="https://i.loli.net/2018/10/24/5bd07656b885a.jpg" alt=""></p>
<p>注意到，后面 $12$ 维状态只有 $0$ 和 $1$，于是我们就有了这么一个想法：把后 $12$ 维状态看成一个 $2$ 进制数，其中从右往左第 $i$ 位表示当前行第 $i$ 列是否种草，$1$ 表示种，$0$ 表示不种。在这一过程中，我们将后 $12$ 维状态「压缩」成了一个 $2$ 进制数，这也正是「状态压缩」这个名字的含义。</p>
<p>于是，现在我们定义 <code>f[i][S]</code> 表示当前处理到第 $i$ 行，其中第 $i$ 行的状态是 $S$ 的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义 <code>a[i]</code> 表示第 $i$ 行哪些格子能种草，$1$ 表示能，$0$ 表示不能。<code>valid[S]</code> 表示如果不考虑某些格子不能种草，状态 $S$ 是否合法，也就是是否不存在两个相邻的 $1$。<code>a[i]</code> 在读入时就可以处理出来，至于 <code>valid[S]</code>，我们可以通过这样的一个循环处理出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line"> valid[i]=valid[i&gt;&gt;<span class="number">1</span>]&amp;(~(i&amp;(i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>用人话来讲就是 <code>[S 是否合法]=[S&gt;&gt;1 是否合法]&amp;[S 与 S&gt;&gt;1 的最后一位是否不同为 1]</code>。</p>
<p>在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是 <code>(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line"> <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line"> f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line"> <span class="keyword">if</span>((j|a[i])==a[i]&amp;&amp;valid[j])</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line"> <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==<span class="number">0</span>)</span><br><span class="line"> (f[i][j]+=f[i<span class="number">-1</span>][k])%=mod;</span><br></pre></td></tr></table></figure>
<p>粗略计算的话，时间复杂度差不多是 $O(n4^m)$，最坏情况下差不多是 $12\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个 <code>if</code> 剪掉，因而实际运行跑得比谁都快（</p>
<p>为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，<a href="https://www.luogu.org/problemnew/show/P2704">「NOI2001」炮兵阵地</a>。</p>
<p>因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用 <code>f[i][S1][S2]</code> 表示当前处理到第 $i$ 行，第 $i-1$ 行状态为 $S1$，第 $i$ 状态为 $S2$ 时最多能放多少个炮兵部队。我们自然也需要记录 <code>a[i]</code> 和 <code>valid[S]</code>，不过，这次 <code>valid[s]</code> 的预处理过程差不多是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line"> valid[i]=(i&amp;<span class="number">1</span>)?valid[i&gt;&gt;<span class="number">3</span>]&amp;((~i)&gt;&gt;<span class="number">2</span>)&amp;((~i)&gt;&gt;<span class="number">1</span>):valid[i&gt;&gt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg" alt=""></p>
<p><del>看起来</del>有些<del>非常</del>复杂，用人话来讲就是……诶我当时是不是写错了（</p>
<p>……不好像又没写错……</p>
<p>好吧没写错。</p>
<p>如果 $S$ 的最后一位是 $1$，则 <code>[S 是否合法]=[S&gt;&gt;3 是否合法]&amp;[S 的倒数第 2 位和倒数第 3 位是否都为 0]</code>，否则 <code>[S 是否合法]=[S&gt;&gt;1 是否合法]</code>。</p>
<p>因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态 $S$ 在二进制下 $1$ 的个数，我们可以这样处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line"> cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>转移过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line"> <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line"> <span class="keyword">if</span>((j|a[<span class="number">2</span>])==a[<span class="number">2</span>]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==<span class="number">0</span>)</span><br><span class="line"> f[<span class="number">2</span>][i][j]=cnt[i]+cnt[j];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line"> <span class="keyword">if</span>((j|a[i<span class="number">-2</span>])==a[i<span class="number">-2</span>]&amp;&amp;valid[j])</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line"> <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span>&lt;&lt;m);++l)</span><br><span class="line"> <span class="keyword">if</span>((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==<span class="number">0</span>&amp;&amp;(l&amp;k)==<span class="number">0</span>)</span><br><span class="line"> f[i][k][l]=max(f[i][k][l],f[i<span class="number">-1</span>][j][k]+cnt[l]);</span><br></pre></td></tr></table></figure>
<p>时间复杂度差不多是 $O(n8^m)$，最坏情况下差不多是 $100\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是 $O(\text{won’t TLE})$（</p>
<p>我们再来看一个状压的应用，<a href="https://www.spoj.com/problems/MMINPAID/">「SP3953」MMINPAID - Paid Roads</a>，或者您也可以<del>反正我就是</del>在<a href="https://www.luogu.org/problemnew/show/SP3953">洛谷</a> 上提交。</p>
<p>大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个 $2$ 进制数内。定义 <code>dis[u][S]</code> 为只经过 $S$ 内的节点的前提下，从 $1$ 到 $u$ 的最小花费。对于 $u$ 发出的所有边的终点 $v$，<code>dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)</code>，其中 $cost$ 表示经过从 $u$ 到 $v$ 这条边的花费，当然这需要分情况讨论。</p>
<p>这样一来，我们只需要写一个可重复入队的堆优化 Dijkstra 就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。</p>
<p><del>我是不会说我把 impossible 打成 Impossible 然后交上去 WA 了一发的（</del></p>
<p>一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说 $n\leqslant 20$，就很有可能是状压题<del>或者也有可能是神仙剪枝题</del>。大部分状压的时间复杂度都不会直接是一个 $O(2^n)$，$O(n2^n)$ 或者说 $O(n^22^n)$ 大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。</p>
<p><img src="https://i.loli.net/2018/10/25/5bd13984b8601.jpg" alt=""></p>
<p>以上，我觉得我的状压讲的差不多了（</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2009」虔诚的墓主人</title>
    <url>/luogu-p2154-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2154">传送门</a></p>
<a id="more"></a>
<p>几个月前某学姐给我推荐的<del>毒瘤</del>题之一。然而我直到现在也只切掉两道<del>，我真是太菜了</del>。</p>
<p>首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为 $x$ 轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有 $L$ 棵常青树，往右数有 $R$ 棵常青树，往上数有 $U$ 棵常青树，往下数有 $D$ 棵常青树，其虔诚度就是</p>
<script type="math/tex; mode=display">
C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}</script><p>考虑到墓地不能和常青树重合，又有 $k\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第 $x$ 行，第 $y$ 列上有多少棵常青树，分别记为 $sumx[x]$，$sumy[y]$。然后我们令 $x$ 坐标为第一关键字，$y$ 坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第 $i$ 棵常青树，记 $cntx[x]$ 为前 $i-1$ 棵常青树中第 $x$ 行上有多少棵常青树，$cnty[y]$ 为前 $i-1$ 棵常青树中第 $y$ 列上有多少棵常青树，当前常青树坐标为 $(x[i],y[i])$。如果 $x[i]=x[i-1]$，则第 $i$ 棵常青树与第 $i-1$ 棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为</p>
<script type="math/tex; mode=display">
C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\sum\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})</script><p>怎么快速地查询与修改后面那个 $\Sigma$ 所涉及到的值？树状数组啊<del>当然如果您非要写些乱七八糟的数据结构也没人拦着您</del>。</p>
<p>坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NOIp</span>&#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> RP,score;</span><br><span class="line">&#125;;</span><br><span class="line">NOIp NOIp2018;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> NOIp2018.RP++;</span><br><span class="line"> NOIp2018.score++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及，明天就是 NOIp 初赛了，在那之后三周就是复赛，我还不想退役啊<del>但是我实在是太菜了</del>qaq。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>Luogu</tag>
        <tag>SDOI</tag>
        <tag>2009</tag>
        <tag>离散化</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2018游记」夢の終わるところ</title>
    <url>/noip-2018-notes/</url>
    <content><![CDATA[<p><del>€€£：禁赛警告。</del></p>
<a id="more"></a>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>自从一周前放假回来以后，我就开始一颓不振：</p>
<p><img src="https://i.loli.net/2018/11/09/5be4e6d8c122f.png" alt=""></p>
<p>明天就是 NOIp2018 复赛了，大概算是我人生中的第四场 NOIp 了。上午我和平时一样在颓废<del>，同时看着其他 dalao 随手切神仙题</del>。然后我看到 yemdalao 写了一篇<a href="https://www.cnblogs.com/taduro/p/9933329.html">NOIp2018<del>禁赛记</del>游记</a><del>，想着禁赛真有趣</del>，我就写下了这篇游记。</p>
<blockquote>
<p>其他 dalao 都在机房补文化课而我在颓 blog（</p>
<p>于是，此处以下，Updated on 2018-11-12。</p>
<blockquote>
<p>Updated on 2018-11-14</p>
<p>看了其他 dalao 的 blog 发现自己写得实在是太菜了，于是大改一波。</p>
<p>但就算这样好像也没什么可写的。看到其他 dalao 用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃</p>
</blockquote>
</blockquote>
<p>中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了 CYYZ 大概 15 点了。</p>
<p>然后一抽考场发现是外校，赛前先 <code>rp--</code>。</p>
<p>然后和 wzxdalao 分到了一个宿舍。听说他被 mhr 学长奶了一路，我大概是被传染了吧（</p>
<p>下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉 rp 被补回来了（</p>
<p>除那之外就没啥了，算是颓了一个下午。</p>
<p>晚上试机，庆幸自己用的是 Win7，然后对面机房就是 XP，下午的 rp 看来补得有效（</p>
<p>试机就 xjb 打了个 st 表，还有我平时用的快读板子，当时是都存到 E 盘了，说不定明天会用得上。</p>
<p>反正板子是不可能打炸的，这辈子都不可能的。</p>
<p>因为某些原因，试机时间被推迟了，回来已经过了 10 点，就直接睡了。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬 .jpg。不过还好，我被允许先进考场了。</p>
<p>然后一打开 E 盘发现被清了，只有题目。</p>
<p>Day1 的解压密码是不是就我一个人不懂啊（</p>
<p>那么于是，到了 8：30，我点开今天的题目，定神一看……</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5019">T1</a></h2><p>智障单调栈，有不开数组的做法，不过我懒得细想了，反正 <code>score+=100</code>。</p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5020">T2</a></h2><p>稍微想一想不难想到完全背包，<code>score+=100</code>。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5021">T3</a></h2><p>神仙树上操作……切不动切不动。我就打了 $m=1$ 的 20 分和树是一条链中的 5 分。</p>
<p>估分 100+100+25=225。</p>
<p>出考场后……啥啥啥，今天考了三道原题？爆破！把 NOIp 爆破掉，并从此以后不再接受 CCF 的公开赛！（</p>
<p>前两题没什么意外的。不过，是不是是个人 T3 就能骗到 55 分啊（</p>
<p>那我可真是太菜了（</p>
<p>下午日常发呆，然后晚上是快乐的颓废时间。</p>
<p>中午买的零食一个下午就全吃完了（</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>早上莫名起不来，然后就没吃早饭。</p>
<p>这次我东西是真的带全了（</p>
<p>Day2 的解压密码依然不懂，然后是今天的题目：</p>
<h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5022">T1</a></h2><p>NOIp 开始考基环树了么……不过还算简单，找到环以后暴力断边然后 dfs 即可。听 crydalao 说有 $O(n)$ 的做法，不过他调了两个小时还是放弃了。</p>
<p>现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点 <code>std::sort</code> 一遍。然后维护一个邻接矩阵处理断边（</p>
<p>为什么不直接用邻接矩阵呢（</p>
<h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5023">T2</a></h2><p>神仙结论题……切不动切不动。随便打了个爆搜找到了 $n=2$ 和 $n=3$ 时的规律。虽然说 $n=1$ 时规律很明显，然而我当时智障忘判断了（</p>
<h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5024">T3</a></h2><p>究极神仙题，读完题 yy 出 ddp，然而不会，只拿了 $O(nm)$ 的 44 分。</p>
<p>估分 100+65+44=204（不存在的，肯定比这个低）。</p>
<p>这么两天算下来，乐观估计的话，差不多有 100+100+25+100+65+44=434 分，保守估计应该不会掉到 400 分以下，应该算是稳了吧……</p>
<p>不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（</p>
<p>好像其他 dalao 们都有这样那样乱七八糟的地方出锅了啊……</p>
<p>下午请假回家开心地颓废。</p>
<h1 id="Extra-Notes"><a href="#Extra-Notes" class="headerlink" title="Extra Notes"></a>Extra Notes</h1><p>果然是等到 NOIp 结束后才更新的。</p>
<p>以及，我比较菜，第一次写游记，写的<del>可能</del>一定很菜，所以……算了，告辞。</p>
<blockquote>
<p>Updated on 2018-11-26</p>
<p>好像有些晚的更新。</p>
<p>出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（</p>
<p>具体成绩差不多是 100+100+20+100+65+36=421。</p>
<p>以上。</p>
</blockquote>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>NOIp</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5009」毒瘤分块题</title>
    <url>/luogu-p5009-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5009">传送门</a></p>
<a id="more"></a>
<p>从来没做过这么毒瘤的题 qaq</p>
<p>就算看了题解现在还是一脸懵逼 qaq</p>
<p>首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树 qaq</p>
<p>对 $v$ 的修改相对来说比较简单，我们来重点看对 $a$ 和 $b$ 的修改。假设在某个时刻 $t_1$，我们将某个 $a_i$ 加上了 $x$，然后又在某个时刻 $t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是 $v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对 $v$ 的修改比较简单，我们可以通过修改 $v$ 将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个 $v_i^\prime$ 使得 $v_i^\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将 $v_i$ 修改至 $v_i^\prime$，然后查询的时候我们就可以直接返回 $v_i^\prime+t_2(a_i+x)b_i$ 了。不难发现 $v_i^\prime=v_i-t_1xb_i$。</p>
<p>需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内 $a$ 的总修改值是 $x$，$b$ 的总修改值是 $y$，那么在某一时刻 $t$，该区间内所有值的和应该是 $\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$。现在我们考虑将 $a$ 加上 $z$，此时 $\Sigma v_i^\prime+t\Sigma (a_i+x+z)(b_i+y)=\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$，即 $\Sigma v_i^\prime=\Sigma v_i-tz\Sigma (b_i+y)$。</p>
<p>不过，上式中 $tz\Sigma (b_i+y)$ 的 $(b_i+y)$ 指的是修改后的 $b_i$ 的值，我们是肯定不能在下推标记时存储每一个历史版本的 $b_i$ 的。我们考虑拆括号，将上式拆成 $tz\Sigma b_i+tzy$，其中 $tzy$ 是一个常数，我们可以直接累加入标记。而至于 $tz\Sigma b_i$，考虑到每层节点的 $\Sigma b_i$ 都不同，我们可以维护一个 $B$，意思是 $\Sigma v_i+=B\Sigma b_i$，每次修改时 $B+=tz$。当然，我们还需要一个标记来记录对 $a$ 自身的修改。对 $b$ 的修改也是类似的。</p>
<p>然后是毒瘤的下推标记。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];</span><br><span class="line"><span class="comment">// 就是上面这句 qaq 现在还是一脸懵逼 qaq</span></span><br><span class="line">A[son]+=A[father];</span><br><span class="line">B[son]+=B[father];</span><br><span class="line">adda[son]+=adda[father];</span><br><span class="line">addb[son]+=addf[father];</span><br></pre></td></tr></table></figure>
<p>其实我也不知道我上面在扯些啥，所以以下是代码<del>，反正应该没人能看懂我的清奇写法（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 100000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> sumv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],suma[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sumb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sump[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> A[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],B[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> addv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],adda[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],addb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> ln,<span class="keyword">int</span> rn)</span></span>&#123;</span><br><span class="line">     sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addv[cur]%mod)%mod;</span><br><span class="line">     sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*ln%mod)%mod;</span><br><span class="line">     suma[cur&lt;&lt;<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*adda[cur]%mod)%mod;</span><br><span class="line">     sumb[cur&lt;&lt;<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addb[cur]%mod)%mod;</span><br><span class="line">     addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">     A[cur&lt;&lt;<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">     B[cur&lt;&lt;<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">     adda[cur&lt;&lt;<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">     addb[cur&lt;&lt;<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">     sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addv[cur]%mod)%mod;</span><br><span class="line">     sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*rn%mod)%mod;</span><br><span class="line">     suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*adda[cur]%mod)%mod;</span><br><span class="line">     sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addb[cur]%mod)%mod;</span><br><span class="line">     addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">     addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">     A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">     B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">     adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">     addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">     A[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">     sumv[cur]=(sumv[cur&lt;&lt;<span class="number">1</span>]+sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">     suma[cur]=(suma[cur&lt;&lt;<span class="number">1</span>]+suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">     sumb[cur]=(sumb[cur&lt;&lt;<span class="number">1</span>]+sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">     sump[cur]=(sump[cur&lt;&lt;<span class="number">1</span>]+sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">         cltstream::read(sumv[cur]);</span><br><span class="line">         cltstream::read(suma[cur]);</span><br><span class="line">         cltstream::read(sumb[cur]);</span><br><span class="line">         sumv[cur]=(sumv[cur]%mod+mod)%mod;</span><br><span class="line">         suma[cur]=(suma[cur]%mod+mod)%mod;</span><br><span class="line">         sumb[cur]=(sumb[cur]%mod+mod)%mod;</span><br><span class="line">         sump[cur]=<span class="number">1L</span>L*suma[cur]*sumb[cur]%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         build(cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">         build(cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">         pushUp(cur);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)</span><br><span class="line">         <span class="keyword">return</span> (sumv[cur]+<span class="number">1L</span>L*t*sump[cur]%mod)%mod;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">         pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">         <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">             res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>,l,mid))%mod;</span><br><span class="line">         <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">             res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r))%mod;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyV</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">         sumv[cur]=(sumv[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">         addv[cur]=(addv[cur]+x)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">         <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">             modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">         <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">             modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">         pushUp(cur);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyA</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">         sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">         suma[cur]=(suma[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">         sump[cur]=(sump[cur]+<span class="number">1L</span>L*sumb[cur]*x%mod)%mod;</span><br><span class="line">         B[cur]=(B[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">         addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*addb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">         adda[cur]=(adda[cur]+x)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">         <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">             modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">         <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">             modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">         pushUp(cur);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyB</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">         sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*suma[cur]%mod+mod)%mod)%mod;</span><br><span class="line">         sumb[cur]=(sumb[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">         sump[cur]=(sump[cur]+<span class="number">1L</span>L*suma[cur]*x%mod)%mod;</span><br><span class="line">         A[cur]=(A[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">         addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*adda[cur]%mod+mod)%mod)%mod;</span><br><span class="line">         addb[cur]=(addb[cur]+x)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">         <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">             modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">         <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">             modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">         pushUp(cur);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">         <span class="keyword">int</span> opt,t,l,r,x;</span><br><span class="line">         cltstream::read(opt);</span><br><span class="line">         cltstream::read(t);</span><br><span class="line">         cltstream::read(l);</span><br><span class="line">         cltstream::read(r);</span><br><span class="line">         <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                 cltstream::write(query(l,r,t,<span class="number">1</span>,<span class="number">1</span>,n),<span class="number">10</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                 cltstream::read(x);</span><br><span class="line">                 modifyA(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                 cltstream::read(x);</span><br><span class="line">                 modifyB(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                 cltstream::read(x);</span><br><span class="line">                 modifyV(l,r,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概是我太菜了不适合做这种毒瘤题吧 qaq</p>
<p><img src="https://i.loli.net/2018/11/08/5be38edf529ca.jpg" alt=""></p>
<p>距 <strong>在 NOIp2018 爆零</strong> 还剩 <strong>1 天</strong>。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>总算是搞出来了一个自己觉得海星的 blog……</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P4900」食堂</title>
    <url>/luogu-p4900-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4900">传送门</a></p>
<a id="more"></a>
<p><del>闲着没事写篇题解（</del></p>
<p>简单来说，就是要求</p>
<script type="math/tex; mode=display">
\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\pmod{998244353}</script><p>其中 $\lbrace x\rbrace$ 表示取 $x$ 的小数部分。</p>
<p>稍加思索，我们不难发现</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\\
\equiv&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\\
\equiv&\sum\limits_{i=1}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}-\sum\limits_{i=1}^{A-1}\sum\limits_{j=1}^{i}i\%j\times j^{-1}
\pmod{998244353}
\end{aligned}</script><p>因此，我们只需要关注下式的值</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}</script><p>我们可以参考一下<a href="https://www.luogu.org/problemnew/show/P3708">这道题</a></p>
<p>在这道题中，我们定义了</p>
<script type="math/tex; mode=display">
f(x)=\sum\limits_{i=1}^{n}x\%i</script><p>首先，如果不考虑 $x\%i=0$ 的情况，我们有</p>
<script type="math/tex; mode=display">
x\%i=(x-1)\%i+1</script><script type="math/tex; mode=display">
f(x)=f(x-1)+n</script><p>如果 $x\%i=0$，我们需要从 $f(x)$ 中减去 $i$，而所有满足该条件的 $i$ 的和就是 $x$ 的约数和，因此</p>
<script type="math/tex; mode=display">
f(x)=f(x-1)+n-\sigma(x)</script><p>我们可以类似地定义</p>
<script type="math/tex; mode=display">
g(x)=\sum\limits_{i=1}^{n}x\%i\times i^{-1}\pmod{998244353}</script><script type="math/tex; mode=display">
h(x)=\sum\limits_{i\mid x}i\times i^{-1}\equiv\sum\limits_{i\mid x}1\equiv d(x)\pmod{998244353}</script><p>从而我们有</p>
<script type="math/tex; mode=display">
g(x)\equiv g(x-1)+\sum\limits_{i=1}^{n}i^{-1}-d(x)\pmod{998244353}</script><p>然而我们需要的是</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>其中</p>
<script type="math/tex; mode=display">
ans(x)=\sum\limits_{i=1}^{x}x\%i\times i^{-1}\pmod{998244353}</script><p>不难发现当 $i&lt;j$ 时 $i\%j=i$，从而</p>
<script type="math/tex; mode=display">
\begin{aligned}
&g(x)-ans(x)\\
\equiv&\sum\limits_{i=x+1}^{n}x\%i\times i^{-1}\\
\equiv&\sum\limits_{i=x+1}^{n}x\times i^{-1}
\pmod{998244353}
\end{aligned}</script><p>最终，我们得到</p>
<script type="math/tex; mode=display">
ans(x)\equiv g(x)-x\sum\limits_{i=x+1}^{n}i^{-1}</script><script type="math/tex; mode=display">
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\equiv\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>把上面这一坨东西预处理出来，我们就可以 $O(1)$ 地处理所有询问了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>一些乱七八糟的数论</title>
    <url>/number-theory-learning-notes/</url>
    <content><![CDATA[<p>最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。</p>
<p><del>抄袭来源</del>参考文献：</p>
<ul>
<li><a href="https://lx-2003.blog.luogu.org/mobius-inversion">铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演</a></li>
<li><a href="https://www.luogu.org/blog/54745/dls-tql">浅谈杜教筛</a></li>
<li><a href="https://lx-2003.blog.luogu.org/dujiao-sieve">铃悬的数学小讲堂——杜教筛</a></li>
</ul>
<a id="more"></a>
<h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><h2 id="定义与相关性质"><a href="#定义与相关性质" class="headerlink" title="定义与相关性质"></a>定义与相关性质</h2><p>数论函数就是定义域为 $\mathbb{N}^{+}$ 的函数。</p>
<p>两个数论函数相加，就是简单地把函数值相加。</p>
<script type="math/tex; mode=display">
(f+g)(n)=f(n)+g(n)</script><p>数乘也是类似的。</p>
<script type="math/tex; mode=display">
(\alpha f)(n)=\alpha f(n)</script><p>点积也是类似的。</p>
<script type="math/tex; mode=display">
(f\cdot g)(n)=f(n)g(n)</script><p><del>好像没啥用。</del></p>
<p>在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：</p>
<script type="math/tex; mode=display">
(f\times g)(n)=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})</script><p>或者说：</p>
<script type="math/tex; mode=display">
(f\times g)(n)=\sum\limits_{ij=n}f(i)g(j)</script><p>它具有以下的一些性质：</p>
<p>交换律，即 $f\times g=g\times f$。</p>
<p>这很明显。</p>
<p>结合律，即 $(f\times g)\times h=f\times(g\times h)$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
((f\times g)\times h)(n)&=\sum\limits_{ij=n}(\sum\limits_{kl=i}f(k)g(l))h(j)\\
&=\sum\limits_{ijk=n}f(i)g(j)h(k)
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
(f\times(g\times h))(n)&=\sum\limits_{ij=n}f(i)(\sum\limits_{kl=j}g(k)h(l))\\
&=\sum\limits_{ijk=n}f(i)g(j)h(k)
\end{aligned}</script><p>分配率，即 $(f+g)\times h=f\times h+g\times h$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
((f+g)\times h)(n)&=\sum\limits_{ij=n}(f+g)(i)h(j)\\
&=\sum\limits_{ij=n}f(i)h(j)+g(i)h(j)\\
&=(f\times h)(n)+(g\times h)(n)
\end{aligned}</script><p>单位元为 $\epsilon(n)=[n=1]$，$f\times\epsilon =f$。</p>
<p>这也很明显。</p>
<p>对于任意一个满足 $f(1)\neq 0$ 的函数 $f$，都存在唯一的一个函数 $g$ 使得 $f\times g=\epsilon$。这时我们称 $g$ 是 $f$ 的逆。</p>
<p>我们可以这样定义一个函数的逆：</p>
<script type="math/tex; mode=display">
g(n)=\cfrac{\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})}{f(1)}</script><p>这样我们就有</p>
<script type="math/tex; mode=display">
\begin{aligned}
(f\times g)(n)&=\sum_{i\mid n}f(i)g(\cfrac{n}{i})\\
&=f(1)g(n)+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\
&=\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\
&=\epsilon(n)
\end{aligned}</script><h2 id="积性函数与完全积性函数"><a href="#积性函数与完全积性函数" class="headerlink" title="积性函数与完全积性函数"></a>积性函数与完全积性函数</h2><p>如果一个数论函数 $f$ 满足</p>
<script type="math/tex; mode=display">
\forall x,y\in\mathbb{N}^{+}\wedge x\perp y\;\;f(xy)=f(x)f(y)</script><p>我们就说 $f$ 是一个积性函数。</p>
<p>特别的，如果上式去掉 $x\perp y$ 仍成立，则称 $f$ 是一个完全积性函数。</p>
<p>很明显地，任意一个积性函数 $f$ 一定有 $f(1)=1$，这样才能有 $f(1\times n)=f(1)\times f(n)=f(n)$。</p>
<p>常见的完全积性函数有 $\epsilon,id^{k}$。$\epsilon$ 在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。</p>
<p>常见的积性函数有 $\varphi,d,\sigma$。$\varphi(n)$ 的值等于小于等于 $n$ 且与 $n$ 互质的正整数的数量。$d(n)$ 和 $\sigma(n)$ 的值分别等于 $n$ 的约数个数和约数和。</p>
<p>关于 $\varphi$ 的积性，我并不会证（</p>
<p>我们来分析 $d$ 的积性。首先，根据唯一分解定理，$n$ 的每个因数都可以唯一地分解成 $n$ 所有质因子的非负整数次幂乘积。不妨设</p>
<script type="math/tex; mode=display">
n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中 $p_{i}$ 都是质数，所有 $r_{i}$ 都是正整数。对于每一个 $p_{i}$，它的指数有 $(r_{i}+1)$ 种取值，因而我们有</p>
<script type="math/tex; mode=display">
d(n)=\prod\limits_{i=1}^{N}(r_{i}+1)</script><p>我们再假设有一个 $m$，且</p>
<script type="math/tex; mode=display">
m=\prod\limits_{i=1}^{M}q_{i}^{s_{i}}</script><p>如果说 $n\perp m$，肯定有</p>
<script type="math/tex; mode=display">
\forall i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z}\;\;p_{i}\neq q_{j}</script><p>于是我们就有</p>
<script type="math/tex; mode=display">
nm=(\prod\limits_{i=1}^{N}p_{i}^{r_{i}})(\prod\limits_{j=1}^{M}q_{j}^{s_{j}})</script><script type="math/tex; mode=display">
\begin{aligned}
d(nm)&=(\prod\limits_{i=1}^{N}(r_{i}+1))(\prod\limits_{j=1}^{M}(s_{j}+1))\\
&=d(n)d(m)
\end{aligned}</script><p>不妨再反过来考虑。如果说 $n\not\perp m$，那么一定存在一对 $(i,j)(i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z})$，使得 $p_{i}=q_{j}$。那么 $d(n)d(m)$ 就会有一个因子是 $(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$ 中对应的项应该是 $r_{i}+s_{j}+1$。因而此时 $d(nm)\neq d(n)d(m)$。</p>
<p>我们再来分析 $\sigma$ 的积性。还是设</p>
<script type="math/tex; mode=display">
n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中 $p_{i}$ 都是质数，所有 $r_{i}$ 都是正整数。与 $d$ 不同的是，现在我们是要用 $p_{i}$ 乘出 $n$ 的因数，$p_{i}$ 在此过程中可以产生的贡献为 $p_{i}^x(x\in [0,r_{i}]\cap\mathbb{Z})$。我们可以把这想象成一个 $N$ 个数组，第 $i$ 个数组的长度为 $r_{i}+1$，第 $j$ 个元素为 $p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是</p>
<script type="math/tex; mode=display">
\prod\limits_{i=1}^{N}\sum\limits_{j=0}^{r_{i}}p_{i}^{j}</script><p>这正是 $\sigma(n)$ 的值。</p>
<p>接下来的过程就与上文证明 $d$ 的积性如出一辙了，在此不再重复。</p>
<p>现在我们来分析，两个积性函数的卷积是否也是积性函数。<del>虽然说都这么问了肯定就是了。</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
(f\times g)(n)(f\times g)(m)&=(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\
&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(i)g(\cfrac{n}{i})f(j)g(\cfrac{m}{j})\\
&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(ij)g(\cfrac{nm}{ij})\\
&=\sum\limits_{k\mid nm}f(k)g(\cfrac{nm}{k})\\
&=(f\times g)(nm)
\end{aligned}</script><p>关于上面的第四个等号。时刻注意 $n\perp m$，在这种前提下，我们枚举到的 $i$ 和 $j$ 一定也是互质的，那么 $ij$ 的所有值一定是互不相同的。这从 $d(nm)=d(n)d(m)$ 这一等式中也能看出。</p>
<p>再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。</p>
<p>设有一个积性函数 $f$，它的逆是 $g$。</p>
<p>当 $nm=1$ 时，$g(1)=1$。</p>
<p>当 $nm&gt;1$ 时，我们假设对于任意 $n^{\prime}m^{\prime}&lt;nm$，都有 $g(n^{\prime}m^{\prime})=g(n^{\prime})g(m^{\prime})$。此时</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(nm)&=-\sum\limits_{k\mid nm,k\neq 1}f(k)g(\cfrac{nm}{k})\\
&=-\sum\limits_{i\mid n,j\mid m,ij\neq 1}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\
&=g(n)g(m)-\sum\limits_{i\mid n,j\mid m}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\
&=g(n)g(m)-(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\
&=g(n)g(m)-\epsilon(n)\epsilon(m)\\
&=g(n)g(m)
\end{aligned}</script><p><del>其实上面这些全都是抄来的（</del></p>
<h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="正向反演"><a href="#正向反演" class="headerlink" title="正向反演"></a>正向反演</h2><p>定义 $\mu$ 为 $1$ 的逆。也就是说，$\mu\times 1=\epsilon$。</p>
<p>如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：</p>
<blockquote>
<p>首先地，$\mu(1)=1$。当 $n&gt;1$ 时，如果 $n$ 的所有质因子互不相同，设其有 $k$ 个质因子，那么 $\mu(n)=(-1)^{k}$。否则，$\mu(n)=0$。</p>
</blockquote>
<p>那么，这两种定义等价吗？</p>
<p>考虑到 $\mu$ 是一个积性函数，对于任意一个 $n&gt;1$，如果我们把它分解成</p>
<script type="math/tex; mode=display">
n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>我们就有</p>
<script type="math/tex; mode=display">
\mu(n)=\prod\limits_{i=1}^{N}\mu(p_{i}^{r_{i}})</script><p>因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。</p>
<p>设有一个质数 $p$。不难发现</p>
<script type="math/tex; mode=display">
\mu(p)=-\mu(1)=-1</script><script type="math/tex; mode=display">
\mu(p^{2})=-\mu(1)-\mu(p)=-1+1=0</script><script type="math/tex; mode=display">
\mu(p^{3})=-\mu(1)-\mu(p)-\mu(p^{2})=-1+1+0=0</script><script type="math/tex; mode=display">
\vdots</script><p>至此，不难看出上文给出的两种定义是等价的。</p>
<p>那么这个东西有什么用呢？</p>
<p>我们设</p>
<script type="math/tex; mode=display">
F(n)=\sum\limits_{i\mid n}f(i)</script><p>或者等价地说，$F=f\times 1$。我们可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
F&=f\times 1\\
F\times\mu&=f\times 1\times\mu\\
F\times\mu&=f
\end{aligned}</script><p>像这样，如果说 $F$ 相对好求，而 $f$ 相对难求，我们就可以通过上式来减小我们求解 $f$ 的难度。具体地说</p>
<script type="math/tex; mode=display">
f(n)=\sum\limits_{i\mid n}F(i)\mu(\cfrac{n}{i})</script><h2 id="反向反演"><a href="#反向反演" class="headerlink" title="反向反演"></a>反向反演</h2><p>有些时候我们还需要用到像下面这样反过来的莫比乌斯反演</p>
<script type="math/tex; mode=display">
F(n)=\sum\limits_{n\mid d}f(d)⇔f(n)=\sum\limits_{n\mid d}F(d)\mu(\cfrac{d}{n})</script><p>我们可以定义一种新的运算</p>
<script type="math/tex; mode=display">
(f\otimes g)(n)=\sum\limits_{n\mid d}f(d)g(\cfrac{d}{n})</script><p>我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有</p>
<script type="math/tex; mode=display">
F=f\otimes 1⇔F\otimes\mu=f</script><p>于是就有了上面的反向反演。</p>
<blockquote>
<p>Updated on 2018-12-03</p>
<p>例题……还是算了吧（</p>
<p>发现反演常用的套路都忘的差不多了，还是别丢人了（</p>
</blockquote>
<h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><h2 id="实现与模板题"><a href="#实现与模板题" class="headerlink" title="实现与模板题"></a>实现与模板题</h2><p>接下来才是主要内容。</p>
<p>现在，我们要求一个积性函数的前 $n$ 项和。$n\leqslant 10^{10}$。</p>
<p>我们定义</p>
<script type="math/tex; mode=display">
S(n)=\sum\limits_{i=1}^{n}f(i)</script><p>再拿来一个积性函数 $g$，然后把它与 $f$ 卷积并求前缀和。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}(f\times g)(i)&=\sum_{i=1}^{n}\sum_{j\mid i}f(j)g(\cfrac{i}{j})\\
&=\sum_{i=1}^{n}g(i)\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}f(j)\\
&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)
\end{aligned}</script><p>然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（</p>
<p>因为 $g$ 也是积性函数，有 $g(1)=1$，所以</p>
<script type="math/tex; mode=display">
\begin{aligned}
S(n)&=g(1)S(n)\\
&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\\
&=\sum_{i=1}^{n}(f\times g)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)
\end{aligned}</script><p>就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。</p>
<p>如果说我们选择的 $g$ 可以让我们迅速地求出 $f\times g$ 和 $g$ 的前缀和，我们就可以做到快速求 $f$ 的前缀和了。</p>
<p>关于后面的 $g(i)S(\lfloor\cfrac{n}{i}\rfloor)$，如果直接暴力算复杂度会是 $O(n)$ 的，在大部分情况下，这是无法接受的。</p>
<p>我们来分析一下 $\lfloor\cfrac{n}{i}\rfloor$。如果 $1\leqslant i\leqslant\sqrt{n}$，因为 $i$ 只有 $\sqrt{n}$ 种不同的取值，$\lfloor\cfrac{n}{i}\rfloor$ 同样也只有 $\sqrt{n}$ 种不同的取值。如果 $\sqrt{n}&lt;i\leqslant n$，$1\leqslant\lfloor\cfrac{n}{i}\rfloor&lt;\sqrt{n}$，又因为要向下取整，自然也只有 $\sqrt{n}$ 种不同的取值。如果我们能够把 $\lfloor\cfrac{n}{i}\rfloor$ 相同的 $i$ 一起计算，就能够将时间杂度优化到 $O(\sqrt{n})$。</p>
<p>大体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">     r=n/(n/l);</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 $r$ 的这个上界是怎么来的，我并不会证（</p>
<p>这样一来，要计算 $S(n)$，我们需要调用所有的 $\lfloor\cfrac{n}{x}\rfloor$，分别是 $\lfloor\cfrac{n}{1}\rfloor,\lfloor\cfrac{n}{2}\rfloor,\cdots,\lfloor\cfrac{n}{\sqrt{n}}\rfloor,\sqrt{n},\sqrt{n}-1,\cdots,1$。单独计算一个 $S(n)$ 的时间复杂度很明显是 $O(\sqrt{n})$ 的。那么这样一来，总体的时间复杂度就是</p>
<script type="math/tex; mode=display">
\begin{aligned}
O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{i}+\sqrt{\lfloor\cfrac{n}{i}\rfloor})&=O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{i}\rfloor})\\
&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{x}\rfloor}dx)\\
&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\cfrac{n}{x}}dx)\\
&=O(2n^{\frac{1}{2}}(n^{\frac{1}{4}}-1))\\
&=O(n^{\frac{3}{4}})
\end{aligned}</script><p>因为相比之下 $\sqrt{\lfloor\cfrac{n}{i}\rfloor}$ 很明显要大一些，我们就可以将 $\sqrt{i}$ 舍去。然后去掉取整符号并用积分近似。</p>
<p>这个实现方法还可以优化。具体来讲，我们先线性筛出前 $m$ 项，然后再用杜教筛。这么做的时间复杂度是 $O(m+\cfrac{n}{\sqrt{m}})$，当 $m=n^{\frac{2}{3}}$ 时取得最小值 $O(n^{\frac{2}{3}})$。</p>
<p>举个例子，就比如说我们要求</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{n}\varphi(i)</script><p>我们取 $f=\varphi,g=1$，这样根据 $\varphi$ 的性质，$f\times g=id$。不难看出 $g$ 与 $f\times g$ 的前缀和都可以 $O(1)$ 求。具体的代码实现差不多长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n&lt;=maxn)</span><br><span class="line">         <span class="keyword">return</span> phi[n];</span><br><span class="line">     <span class="comment">//phi 是提前线性筛好的前缀和</span></span><br><span class="line">     <span class="keyword">if</span>(ans.count(n))</span><br><span class="line">         <span class="keyword">return</span> ans[n];</span><br><span class="line">     <span class="comment">//ans 用来实现记忆化的哈希表，比如说 unordered_map</span></span><br><span class="line">     re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1L</span>L*n*(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     <span class="comment">//f*g 的前缀和</span></span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="comment">// 注意要从 2 开始</span></span><br><span class="line">         r=n/(n/l);</span><br><span class="line">         res-=(r-l+<span class="number">1</span>)*getSum(n/l);</span><br><span class="line">         <span class="comment">//r-l+1 是 g 的前缀和</span></span><br><span class="line">         <span class="comment">// 像这样递归 + 记忆化求解 f 的前缀和</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans[n]=res;</span><br><span class="line">     <span class="comment">// 返回的时候不要忘记存一下</span></span><br><span class="line">     <span class="comment">// 就比如说我就忘过一次（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及，不用哈希表也是可以的。因为我们查询的数都是形如 $\lfloor\cfrac{n}{x}\rfloor$ 的，当这个值大于 $n^{\frac{2}{3}}$，即 $x&lt;n^{\frac{1}{3}}$ 时，我们才会到哈希表里查询。因此我们可以令 <code>ans[x]</code> 表示 $S(\lfloor\cfrac{n}{x}\rfloor)$。具体代码我就不写了（</p>
<p>再举个例子，求</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{n}\mu(i)</script><p>取 $f=\mu,g=1,f\times g=\epsilon$。代码和上面差不多。</p>
<p>如果您理解了上面两个函数，这道<a href="https://www.luogu.org/problemnew/show/P4213">模板题</a> 您就可以切了。</p>
<h2 id="其他题"><a href="#其他题" class="headerlink" title="其他题"></a>其他题</h2><h3 id="「Luogu-P3768」简单的数学题"><a href="#「Luogu-P3768」简单的数学题" class="headerlink" title="「Luogu-P3768」简单的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3768">「Luogu-P3768」简单的数学题</a></h3><p>快乐地推式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum\limits_{i=1}^{n}i\sum\limits_{j=1}^{n}j\text{gcd}(i,j)&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j[i\perp j]\\
&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j\sum\limits_{x\mid i,x\mid j}\mu(x)\\
&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}x^{2}\mu(x)\text{Sum}^{2}(\lfloor\cfrac{n}{dx}\rfloor)\\
&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\sum\limits_{j\mid i}j\mu(\cfrac{i}{j})\\
&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\varphi(i)
\end{aligned}</script><p>其中</p>
<script type="math/tex; mode=display">
\text{Sum}(n)=\sum\limits_{i=1}^{n}i</script><p>最后一步是因为</p>
<script type="math/tex; mode=display">
\begin{aligned}
id\times\mu&=\varphi\times 1\times\mu\\
&=\varphi\times\epsilon\\
&=\varphi
\end{aligned}</script><p>理解不了上面的式子的话就多看看吧（</p>
<p>不难发现我们是要求 $f(n)=n^{2}\varphi(n)$ 的前缀和，那么，我们该怎么选取 $g$ 呢？</p>
<p><del>枚举瞎蒙（</del></p>
<p>考虑 $g(n)=n^{2}$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(f\times g)(n)&=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})\\
&=\sum\limits_{i\mid n}i^{2}\varphi(i)\cfrac{n^{2}}{i^{2}}\\
&=n^{2}\sum\limits_{i\mid n}\varphi(i)\\
&=n^{3}
\end{aligned}</script><p><del>其实我都不知道我当时是怎么想到这种操作的（</del></p>
<p>然后就和上面一样了。</p>
<h3 id="「Luogu-U18201」分析矿洞"><a href="#「Luogu-U18201」分析矿洞" class="headerlink" title="「Luogu-U18201」分析矿洞"></a><a href="https://www.luogu.org/problemnew/show/U18201">「Luogu-U18201」分析矿洞</a></h3><p>不知道从哪翻出来的题（</p>
<p>是某场个人邀请赛的 $\text{T}1$<del>，从某种意义上也能看出那场比赛有多么神仙</del>。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\varphi(\text{gcd}^{2}(i,j))&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}[i\perp j]\\
&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{x\mid i,x\mid j}\mu(x)\\
&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\lfloor\cfrac{n}{dx}\rfloor^{2}\\
&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}\varphi(j^{2})\mu(\cfrac{i}{j})\\
&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}j\varphi(j)\mu(\cfrac{i}{j})
\end{aligned}</script><p>设 $f_1(n)=n\varphi(n),f_2(n)=\mu(n)$，考虑筛 $f=f_1\times f_2$ 的前缀和。然而，与上面的其它题不同，并不存在一个 $g$ 使我们能够 $O(1)$ 地求出 $g$ 和 $f\times g$ 的前缀和。一种较优的方案是，令 $g=1$，$f\times g=(id\cdot\varphi)\times\mu\times 1=id\cdot\varphi$，这样，我们还需要筛出 $f_1(n)=n\varphi(n)$ 的前缀和。</p>
<p>怎么办？</p>
<p>再套一层杜教筛！</p>
<p>然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（</p>
<p>以及，像这种 $n$ 爆了 <code>int</code> 的，一定要注意经常取模。<del>因为这个 WA 了好几次（</del></p>
<p>最后，源文件 $17\text{KB}​$ 祭，blog 翻页祭。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>「未来算法Episode I」严格根号分块实现树套树</title>
    <url>/future-algorithm-ep1/</url>
    <content><![CDATA[<p>分块天下第一！！！！！！！！！</p>
<a id="more"></a>
<p>我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。</p>
<p><a href="https://www.luogu.org/record/show?rid=14518116"><img src="https://i.loli.net/2018/12/08/5c0bb272768cf.png" alt=""></a></p>
<p><img src="https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg" alt=""></p>
<p>我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。</p>
<p>先退一步来说，假如说我们去掉操作 $3$，剩下的操作都可以用主席树来完成。</p>
<p>然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次 $O(n\operatorname{log}n)$ 的。</p>
<p>那我们就在外层套个树状数组，把修改 $O(n\operatorname{log}n)$ 查询 $O(\operatorname{log}n)$ 均摊成全部 $O(\operatorname{log}^{2}n)$。</p>
<p>然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。</p>
<p>考虑<del>无敌的</del>分块。</p>
<p>一般我们想到的分块就是在块内维护 <code>std::set</code>。这样操作 $3$ 可以做到 $O(\operatorname{log}\sqrt{n})$，操作 $1$、$4$、$5$ 可以做到 $O(\sqrt{n}\operatorname{log}\sqrt{n})$。至于操作 $2$，我们在外层套一个二分，然后检查二分到的数的排名是不是 $k$，时间复杂度 $O(\operatorname{log}10^{9}\sqrt{n}\operatorname{log}\sqrt{n})$。</p>
<p>然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。</p>
<p>我们来看一下<a href="https://www.luogu.org/space/show?uid=56384"><strong>Shadowice1984</strong></a>dalao 在他的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119">另一篇题解</a> 中做出的评价：</p>
<blockquote>
<p>这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到 $O(\operatorname{log}n)$ 的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个 $\text{log}$ 之内。</p>
<p>但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是 $O(\sqrt{n})$ 而不是 $O(\operatorname{log}n)$，这意味着分块其实和 $\text{log}$ 的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入 $\text{log}$ 的数据结构的话在绝大部分情况下都会使复杂度凭空多出个 $\text{log}$ 来，这在强调常数的根号算法中绝对是致命的。</p>
</blockquote>
<p>我也是从这位 dalao 的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380">blog</a> 里看到了严格根号分块实现树套树这种未来算法。</p>
<p>主要思想其实不难理解，既然分块和 $\text{log}$ 不适合放在一起，我们就再套个分块，或者说，把值域也分成块。</p>
<p>定义 <code>cnt1[i][j]</code> 表示前 $i$ 个块内有多少个元素的值在第 $j$ 个块内，<code>cnt2[i][j]</code> 表示前 $i$ 个块内有多少个 $j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是 $O((n+m)\sqrt{n})$ 的。</p>
<p>然后我们来分析每个操作该怎么实现：</p>
<ol>
<li>首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。</li>
<li>还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组 <code>tmp1</code> 和 <code>tmp2</code> 来保存边角块的信息。</li>
<li>直接 $O(\sqrt{n})$ 暴力重构两个 <code>cnt</code> 就好。</li>
<li>需要两个类似于操作 $2$ 的临时数组，存储的信息也是类似的。首先在给定数所在值域块内<strong>从后往前扫</strong>，找到答案直接退出。否则还是<strong>从后往前扫所有值域块</strong>，找到第一个非空的块然后进去找。</li>
<li>操作 $4$ 换个方向即可。</li>
</ol>
<p>综上所述，该算法的时间复杂度为 $O((n+m)\sqrt{n}+m\sqrt{n+m})$。当 $n$，$m$ 取到极限值时，差不多是 $38172068$，相比之下 $O(m\operatorname{log}^{2}n)\approx 12183043$。看起来好像比不过树套树，实际上开个 $\text{O}2$ 跑得比谁都快，正如一开始那张图所示。</p>
<p>不过代码写出来有点长的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxs 230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(a) ((a)&amp;(-(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,sq1,sq2;</span><br><span class="line"><span class="keyword">int</span> id1[maxn+<span class="number">1</span>],id2[maxn+maxm+<span class="number">1</span>],p[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">1</span>],opt[maxm+<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> cnt1[maxs+<span class="number">1</span>][(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],cnt2[maxs+<span class="number">1</span>][maxn+maxm+<span class="number">1</span>],tmp1[(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],tmp2[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     <span class="keyword">for</span>(;(sq1+<span class="number">1</span>)*(sq1+<span class="number">1</span>)&lt;=n;++sq1);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         id1[i]=(i<span class="number">-1</span>)/sq1+<span class="number">1</span>;</span><br><span class="line">         cltstream::read(a[i]);</span><br><span class="line">         p[++p[<span class="number">0</span>]]=a[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">         cltstream::read(opt[i][<span class="number">0</span>]);</span><br><span class="line">         cltstream::read(opt[i][<span class="number">1</span>]);</span><br><span class="line">         cltstream::read(opt[i][<span class="number">2</span>]);</span><br><span class="line">         <span class="keyword">if</span>(opt[i][<span class="number">0</span>]!=<span class="number">3</span>)</span><br><span class="line">             cltstream::read(opt[i][<span class="number">3</span>]);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             p[++p[<span class="number">0</span>]]=opt[i][<span class="number">2</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">std</span>::sort(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">     p[<span class="number">0</span>]=<span class="built_in">std</span>::unique(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>)-p<span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;(sq2+<span class="number">1</span>)*(sq2+<span class="number">1</span>)&lt;=p[<span class="number">0</span>];++sq2);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p[<span class="number">0</span>];++i)</span><br><span class="line">         id2[i]=(i<span class="number">-1</span>)/sq2+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         a[i]=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,a[i])-p;</span><br><span class="line">         ++cnt1[id1[i]][id2[a[i]]];</span><br><span class="line">         ++cnt2[id1[i]][a[i]];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=id1[n];++i)&#123;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]];++j)</span><br><span class="line">             cnt1[i][j]+=cnt1[i<span class="number">-1</span>][j];</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[<span class="number">0</span>];++j)</span><br><span class="line">             cnt2[i][j]+=cnt2[i<span class="number">-1</span>][j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">         re <span class="keyword">int</span> l,r,x,ans=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">switch</span>(opt[i][<span class="number">0</span>])&#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                 l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line">                 <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)</span><br><span class="line">                         ans+=(a[j]&lt;x);</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)</span><br><span class="line">                         ans+=(a[j]&lt;x);</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;id2[x];++j)</span><br><span class="line">                         ans+=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j];</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>;j&lt;x;++j)</span><br><span class="line">                         ans+=cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j];</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)</span><br><span class="line">                         ans+=(a[j]&lt;x);</span><br><span class="line">                 cltstream::write(ans+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                 l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=opt[i][<span class="number">3</span>];</span><br><span class="line">                 <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line">                         <span class="keyword">if</span>(x&gt;cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                             x-=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j];</span><br><span class="line">                         <span class="keyword">else</span>&#123;</span><br><span class="line">                             <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line">                                 <span class="keyword">if</span>(x&gt;cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                     x-=cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k];</span><br><span class="line">                                 <span class="keyword">else</span>&#123;</span><br><span class="line">                                     cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line">                                     <span class="keyword">break</span>;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line">                         <span class="keyword">if</span>(x&gt;tmp1[j])</span><br><span class="line">                             x-=tmp1[j];</span><br><span class="line">                         <span class="keyword">else</span>&#123;</span><br><span class="line">                             <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line">                                 <span class="keyword">if</span>(x&gt;tmp2[k])</span><br><span class="line">                                     x-=tmp2[k];</span><br><span class="line">                                 <span class="keyword">else</span>&#123;</span><br><span class="line">                                     cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line">                                     <span class="keyword">break</span>;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                 l=opt[i][<span class="number">1</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">2</span>])-p;</span><br><span class="line">                 <span class="keyword">for</span>(re <span class="keyword">int</span> j=id1[l];j&lt;=id1[n];++j)&#123;</span><br><span class="line">                     --cnt1[j][id2[a[l]]];</span><br><span class="line">                     ++cnt1[j][id2[x]];</span><br><span class="line">                     --cnt2[j][a[l]];</span><br><span class="line">                     ++cnt2[j][x];</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[l]=x;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                 l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line">                 <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                         <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">                             ans=j;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                         <span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                             <span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line">                                 <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                     ans=k;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                         <span class="keyword">if</span>(tmp2[j])</span><br><span class="line">                             ans=j;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                         <span class="keyword">if</span>(tmp1[j])</span><br><span class="line">                             <span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line">                                 <span class="keyword">if</span>(tmp2[k])</span><br><span class="line">                                     ans=k;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 cltstream::write(ans?p[ans]:<span class="number">-2147483647</span>,<span class="number">10</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                 l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::upper_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line">                         <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">                             ans=j;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line">                         <span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                             <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line">                                 <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                     ans=k;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                         ++tmp1[id2[a[j]]];</span><br><span class="line">                         ++tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line">                         <span class="keyword">if</span>(tmp2[j])</span><br><span class="line">                             ans=j;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line">                         <span class="keyword">if</span>(tmp1[j])</span><br><span class="line">                             <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line">                                 <span class="keyword">if</span>(tmp2[k])</span><br><span class="line">                                     ans=k;</span><br><span class="line">                     <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                         --tmp1[id2[a[j]]];</span><br><span class="line">                         --tmp2[a[j]];</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 cltstream::write(ans?p[ans]:<span class="number">2147483647</span>,<span class="number">10</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我还没写啥呢咋就 $12\text{KB}$ 了（</p>
<p>这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法 Episode II」也说不定（</p>
]]></content>
      <categories>
        <category>未来算法</category>
      </categories>
      <tags>
        <tag>树套树</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>「多项式学习笔记Part I」最基本的多项式乘法</title>
    <url>/polynomial-learning-notes-pt1/</url>
    <content><![CDATA[<p>最近正好月考，然而并不想去月考，于是来颓 blog 吧。</p>
<a id="more"></a>
<p>给你一个 $n-1$ 次多项式 $F(x)$ 和一个 $m-1$ 次多项式 $G(x)$，让你求 $(F\times G)(x)$ 的各项系数。$n,m\leqslant 10^{6}$。</p>
<p>我们不妨将 $F(x)$ 的 $i$ 次项系数记为 $F[i]$</p>
<script type="math/tex; mode=display">
F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">
G(x)=\sum\limits_{i=0}^{m-1}G[i]x^{i}</script><script type="math/tex; mode=display">
(F\times G)(x)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}</script><script type="math/tex; mode=display">
(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>不难发现直接暴力算是 $O(n^{2})$ 的，因此我们需要优化。</p>
<p>不过为了优化，我们得先扯远点。</p>
<h1 id="点值表达"><a href="#点值表达" class="headerlink" title="点值表达"></a>点值表达</h1><p>如果我们选取 $n$ 个点 $(x_{0},y_{0}),(x_{1},y_{1}),\cdots,(x_{n-1},y_{n-1})$，并且其中 $x_{i}$ 两两不同，我们就可以唯一地确定出一个 $n-1$ 次多项式。</p>
<p>就比如说</p>
<script type="math/tex; mode=display">
(0,2),(1,7),(2,4)</script><p><del>瞎写的（</del></p>
<p>我们可以列出如下的三元一次方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
&\text{C}=2\\
&\text{A}+\text{B}+\text{C}=7\\
&4\text{A}+2\text{B}+\text{C}=4
\end{cases}</script><p>解得</p>
<script type="math/tex; mode=display">
\begin{cases}
&\text{A}=-4\\
&\text{B}=9\\
&\text{C}=2
\end{cases}</script><p>注意到 $(F\times G)(x)=F(x)G(x)$<del>（废话）</del>，我们只要知道了 $F(x)$ 和 $G(x)$ 的点值表达，就可以 $O(n)$ 的计算出 $(F\times G)(x)$ 的点值表达了。因为 $(F\times G)(x)$ 的次数是 $n+m-2$，我们选出前 $n+m-1$ 个自然数即可。</p>
<p>但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要 $O(n^{2})$ 转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（</p>
<p>于是我们还需要优化，于是我们还需要再扯远一点。</p>
<h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>对，你没看错，扯到复数了。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说</p>
<script type="math/tex; mode=display">
x^{2}+1=0</script><p>我们知道，它的判别式是 $\Delta=b^{2}-4ac=-4\lt 0$，因此它没有实数根。</p>
<p>于是我们就定义了虚数单位 $i$，并规定 $i^{2}=-1$。形如 $x+yi$ 这样的数被称为复数。它的模长被定义为它到原点的距离，即 $\sqrt{x^{2}+y^{2}}$；幅角被定义为与 $x$ 轴正半轴的夹角，即 $\operatorname{tan}^{-1}\cfrac{y}{x}$。</p>
<p>因为 $i$ 不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$ 就是实轴，$y$ 轴就是虚轴，$x+yi$ 就对应了点 $(x,y)$。</p>
<p><img src="https://i.loli.net/2018/12/19/5c1a46b4d785b.png" alt=""></p>
<p>上图展示了 $4+i$ 和 $3+4i$。</p>
<p>复数的运算其实没什么出乎意料的：</p>
<script type="math/tex; mode=display">
(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i</script><script type="math/tex; mode=display">
(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i</script><script type="math/tex; mode=display">
(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i</script><script type="math/tex; mode=display">
\begin{aligned}
\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\
&=\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\
&=\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i
\end{aligned}</script><p>我们来单独考虑一下复数相乘的几何意义。</p>
<p>假设我们有两个复数 $c_{1}$，$c_{2}$，它们的模长分别是 $r_{1}$，$r_{2}$，幅角分别是 $\alpha_{1}$，$\alpha_{2}$。不难发现我们有</p>
<script type="math/tex; mode=display">
c_{1}=r_{1}(\operatorname{cos}\alpha_{1}+i\operatorname{sin}\alpha_{1})</script><script type="math/tex; mode=display">
c_{2}=r_{2}(\operatorname{cos}\alpha_{2}+i\operatorname{sin}\alpha_{2})</script><script type="math/tex; mode=display">
\begin{aligned}
c_{1}c_{2}&=r_{1}r_{2}(\cos\alpha_{1}+i\sin\alpha_{1})(\cos\alpha_{2}+i\sin\alpha_{2})\\
&=r_{1}r_{2}(\cos\alpha_{1}\cos\alpha_{2}+i\cos\alpha_{1}\sin\alpha_{2}+i\sin\alpha_{1}\cos\alpha_{2}-\sin\alpha_{1}\sin\alpha_{2})\\
&=r_{1}r_{2}[\cos(\alpha_{1}+\alpha_{2})+i\sin(\alpha_{1}+\alpha_{2})]
\end{aligned}</script><p>总结成一句话，就是「模长相乘，幅角相加」。</p>
<h2 id="单位圆与单位根"><a href="#单位圆与单位根" class="headerlink" title="单位圆与单位根"></a>单位圆与单位根</h2><p>单位圆就是指半径为 $1$ 的圆。不过一般我们都是把它画在原点的。</p>
<p><img src="https://i.loli.net/2018/12/20/5c1b06e5602fa.png" alt=""></p>
<p>考虑这么一个方程</p>
<script type="math/tex; mode=display">
x^{n}=1</script><p>它的所有复数根。</p>
<p>因为复数相乘意味着模长相乘，如果一个复数的 $n$ 次方等于 $1$，它自身的模长也应该是 $1$。如果它的幅角是 $a$，我们应该有</p>
<script type="math/tex; mode=display">
2\pi\mid na</script><script type="math/tex; mode=display">
\cfrac{2\pi}{n}\mid a</script><p>不难想象出我们有 $n$ 个这样的复数，它们的幅角通式是 $\cfrac{2k\pi}{n}(k\in[0,n)\cap\mathbb{Z})$。我们称其中幅角等于 $\cfrac{2\pi}{n}$ 的复数，即 $\cos\cfrac{2\pi}{n}+i\sin\cfrac{2\pi}{n}$ 为 $n$ 次单位根 $\omega_{n}$，我们就可以把这 $n$ 个复数表示为 $\omega_{n}^{k}(k\in[0,n)\cap\mathbb{Z})$。</p>
<p>它有如下的一些性质</p>
<script type="math/tex; mode=display">
\omega_{2n}^{2k}=\omega_{n}^{k}</script><p>因为它们的模长都是 $1$，幅角相等就相等了。</p>
<p>然后就没了，读者自证不难（</p>
<script type="math/tex; mode=display">
\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}</script><p>因为 $\omega_{n}^{\frac{n}{2}}$ 的幅角是 $\cfrac{2\times\frac{n}{2}\pi}{n}=\pi$，不难发现它就是 $-1$ 了。</p>
<h1 id="快速傅里叶变换（Fast-Fourier-Transformation）"><a href="#快速傅里叶变换（Fast-Fourier-Transformation）" class="headerlink" title="快速傅里叶变换（Fast Fourier Transformation）"></a>快速傅里叶变换（Fast Fourier Transformation）</h1><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>那么问题来了，我们刚才扯了这么些，有什么用呢？</p>
<p>就是说，有个叫「让 · 巴普蒂斯 · 约瑟夫 · 傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出 $n$ 次单位根想要求点值表达。</p>
<p>首先，我们通过在高次补 $0$ 的方式，将这个多项式的项数（也就是次数 $+1$）补到 $2$ 的非负整数次幂。</p>
<p>然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F_{1}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i]x^{i}\\
&=F[0]x^{0}+F[2]x^{1}+\cdots+F[n-2]x^{\frac{n}{2}-1}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
F_{2}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i+1]x^{i}\\
&=F[1]x^{0}+F[3]x^{1}+\cdots+F[n-1]x^{\frac{n}{2}-1}
\end{aligned}</script><p>于是我们有</p>
<script type="math/tex; mode=display">
F(x)=F_{1}(x^{2})+xF_{2}(x^{2})</script><p>现在我们假设 $0\leqslant k&lt;\cfrac{n}{2}$，将 $x=\omega_{n}^{k}$ 和 $x=\omega_{n}^{k+\frac{n}{2}}$ 代入</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(\omega_{n}^{k})&=F_{1}(\omega_{n}^{2k})+\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\
&=F_{1}(\omega_{\frac{n}{2}}^{k})+\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
F(\omega_{n}^{k+\frac{n}{2}})&=F_{1}(\omega_{n}^{2k+n})+\omega_{n}^{k+\frac{n}{2}}F_{2}(\omega_{n}^{2k+n})\\
&=F_{1}(\omega_{n}^{2k})-\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\
&=F_{1}(\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})
\end{aligned}</script><p>我们注意到，如果说我们求出了 $F_{1}(x)$ 和 $F_{2}(x)$ 的点值表达，我们就能够 $O(n)$ 地求出 $F(x)$ 的点值表达了。至此，我们不难想到分治，边界条件就是 $n=1$，这时什么也不用做直接返回即可。</p>
<p>简单地贴一下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="built_in">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">complex</span> F1[n&gt;&gt;<span class="number">1</span>],F2[n&gt;&gt;<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line"> 	 F1[i]=F[<span class="number">2</span>*i];</span><br><span class="line"> F2[i]=F[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line"> work(F1,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line"> work(F2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line"> complex unit(cos(2*Pi/n),sin(2*Pi/n)),tmp=1;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i,tmp=tmp*unit)&#123;</span><br><span class="line"> 	 <span class="built_in">complex</span> w=F2[i+(n&gt;&gt;<span class="number">1</span>)]*tmp;</span><br><span class="line"> F[i]=F1[i]+w;</span><br><span class="line"> F[i+(n&gt;&gt;<span class="number">1</span>)]=F1[i]-w;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，以上代码是我现写出来的，<del>保证其不正确性</del>不保证其正确性。</p>
<p>不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，<code>F</code> 数组的每一个位置上实际存的是几次项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7</span><br><span class="line">0 2 4 6|1 3 5 7</span><br><span class="line">0 4|2 6|1 5|3 7</span><br><span class="line">0|4|2|6|1|5|3|7</span><br></pre></td></tr></table></figure>
<p>写成二进制看看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">位置（十进制）</th>
<th style="text-align:center">位置（二进制）</th>
<th style="text-align:center">次数（十进制）</th>
<th style="text-align:center">次数（二进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$000$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$000$</td>
</tr>
<tr>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$001$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$100$</td>
</tr>
<tr>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$010$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$010$</td>
</tr>
<tr>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$011$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$110$</td>
</tr>
<tr>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$100$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$001$</td>
</tr>
<tr>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$101$</td>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$101$</td>
</tr>
<tr>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$110$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$011$</td>
</tr>
<tr>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$111$</td>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$111$</td>
</tr>
</tbody>
</table>
</div>
<p>注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后 $\operatorname{log}n$ 位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。</p>
<p>我们可以 $O(n)$ 地处理处每个数的镜像：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">     rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是 $i$ 这个数除了最后一位以外的所有位的镜像；右边特判了一下 $i$ 的最后一位是否为 $1$，如果是的话，就在最高位补一个 $1$。</p>
<p>接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="built_in">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="function"><span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">             <span class="function"><span class="built_in">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                 <span class="built_in">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                 F[j+p]=F[j]-tmp;</span><br><span class="line">                 F[j]=F[j]+tmp;</span><br><span class="line">                 cur=cur*unit;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么现在还差最后一步，将点值表达转回系数表达。我们将 $F(\omega_{n}^{0}),F(\omega_{n}^{1}),\cdots,F(\omega_{n}^{n-1})$ 分别记为 $y_{0},y_{1},\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
&(\omega_{n}^{0})^{0}&(\omega_{n}^{0})^{1}&\cdots&(\omega_{n}^{0})^{n-1}&\\
&(\omega_{n}^{1})^{0}&(\omega_{n}^{1})^{1}&\cdots&(\omega_{n}^{1})^{n-1}\\
&\vdots&\vdots&\ddots&\vdots\\
&(\omega_{n}^{n-1})^{0}&(\omega_{n}^{n-1})^{1}&\cdots&(\omega_{n}^{n-1})^{n-1}\\
\end{bmatrix}
\begin{bmatrix}
&F[0]&\\
&F[1]\\
&\vdots\\
&F[n-1]
\end{bmatrix}
=\begin{bmatrix}
&y_{0}&\\
&y_{1}\\
&\vdots\\
&y_{n-1}
\end{bmatrix}</script><p>我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
&\frac{1}{n}(\omega_{n}^{0})^{0}&\frac{1}{n}(\omega_{n}^{0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{0})^{n-1}&\\
&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\
&\vdots&\vdots&\ddots&\vdots\\
&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\
\end{bmatrix}</script><p>现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为 $A$，第二个矩阵为 $B$，$A\times B=C$。不难发现 $A[i][j]=\omega_{n}^{ij}$，$B[i][j]=\cfrac{1}{n}\omega_{n}^{-ij}$，我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
C[i][j]&=\sum\limits_{k=0}^{n-1}A[i][k]B[k][j]\\
&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{ik-kj}
\end{aligned}</script><p>若 $i=j$，不难发现此时 $C[i][j]=1$。</p>
<p>否则，即 $i\neq j$，设 $i-j=l$，我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
C[i][j]&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{lk}\\
&=\cfrac{\omega_{n}^{ln}-1}{n(\omega_{n}^{l}-1)}\\
&=\cfrac{1-1}{n(\omega_{n}^{l}-1)}\\
&=0
\end{aligned}</script><p>综上所述，矩阵 $C$ 是单位矩阵，因此矩阵 $B$ 是矩阵 $A$ 的逆矩阵。</p>
<p>因此我们有</p>
<script type="math/tex; mode=display">
\begin{bmatrix}&\frac{1}{n}(\omega_{n}^{-0})^{0}&\frac{1}{n}(\omega_{n}^{-0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-0})^{n-1}&\\&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\\end{bmatrix}\begin{bmatrix}&y_{0}&\\&y_{1}\\&\vdots\\&y_{n-1}\end{bmatrix}=\begin{bmatrix}&F[0]&\\&F[1]\\&\vdots\\&F[n-1]\end{bmatrix}</script><p>注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的 $\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$ 换成 $\omega_{n}^{0},\omega_{n}^{-1},\cdots,\omega_{n}^{-n+1}$，然后对着点值表达来一遍 FFT，然后再除以 $n$，就得到了原多项式的系数了。</p>
<p>注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),tp*<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后调用时再传一个参数 <code>tp</code> 进去。<code>tp=1</code> 表示是系数转点值，<code>tp=-1</code> 表示是点值转系数。</p>
<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">     <span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">         r=_r;</span><br><span class="line">         c=_c;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">complex</span> F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">    _tp tmp=x;</span><br><span class="line">     x=y;</span><br><span class="line">     y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="built_in">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),tp*<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">             <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                 <span class="keyword">register</span> <span class="built_in">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                 F[j+p]=F[j]-tmp;</span><br><span class="line">                 F[j]=F[j]+tmp;</span><br><span class="line">                 cur=cur*unit;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">     ++n;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;F[i].r);</span><br><span class="line">     ++m;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[i].r);</span><br><span class="line">     <span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">     FAQ(F,<span class="number">1</span>);</span><br><span class="line">     FAQ(G,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F[i]=F[i]*G[i];</span><br><span class="line">     FAQ(F,<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%0.0lf "</span>,F[i].r/n);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>不要问我 <code>cltstream</code> 哪去了（</del></p>
<p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P3803">板子题</a> 了。</p>
<p>其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（</p>
<p>最好还是自己写吧（</p>
<p>什么？想知道是哪道题？往下看（</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="「ZJOI2014」力"><a href="#「ZJOI2014」力" class="headerlink" title="「ZJOI2014」力"></a><a href="https://www.luogu.org/problemnew/show/P3338">「ZJOI2014」力</a></h3><p>这是一道裸的卷积题。</p>
<p>考虑两个长度为 $n$ 的数组 $F$ 和 $G$，现在我们想求一个数组 $H$，它满足</p>
<script type="math/tex; mode=display">
H[i]=\sum\limits_{j=0}^{i}F[j]G[i-j]=\sum\limits_{0\leqslant j<n,0\leqslant k<n,j+k=i}F[j]G[k]</script><p>在本页面往上翻，翻到这个式子：</p>
<script type="math/tex; mode=display">
(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>发现了吗？这两个过程其实是一样的。</p>
<p>于是，我们如下构造两个多项式</p>
<script type="math/tex; mode=display">
F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">
G(x)=\sum\limits_{i=0}^{n-1}G[i]x^{i}</script><p>然后直接一波 FFT 套上去，输出次数最低的 $n$ 项的系数就好。</p>
<p>那么这题呢？首先我们把 $j\lt i$ 和 $j\gt i$ 分开计算。</p>
<p>先考虑 $j\lt i$，令 $F[i]=q_{i}$，$G[i]=\begin{cases}&amp;\cfrac{1}{i^{2}}\;\;&amp;(i\gt 0)\\&amp;0&amp;(i=0)\end{cases}$，那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
E_{i}&=\sum_{j=0}^{i-1}F[j]G[i-j]\\
&=\sum_{j=0}^{i}F[j]G[i-j]
\end{aligned}</script><p>直接套板子就行。</p>
<p>对于 $j&gt;i$ 的情况，我们将数组 $F$ 左右翻转，然后继续套板子就行（</p>
<p>具体还是看代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>\lt cstdio&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">     <span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">         r=_r;</span><br><span class="line">         c=_c;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">complex</span> F1[maxn+<span class="number">1</span>],F2[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">    _tp tmp=x;</span><br><span class="line">     x=y;</span><br><span class="line">     y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="built_in">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),tp*<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">             <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                 <span class="keyword">register</span> <span class="built_in">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                 F[j+p]=F[j]-tmp;</span><br><span class="line">                 F[j]=F[j]+tmp;</span><br><span class="line">                 cur=cur*unit;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;F1[i].r);</span><br><span class="line">         F2[n-i<span class="number">-1</span>].r=F1[i].r;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">         G[i]=<span class="number">1.0</span>/i/i;</span><br><span class="line">     <span class="keyword">for</span>(m=n,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">     FAQ(G,<span class="number">1</span>);</span><br><span class="line">     FAQ(F1,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F1[i]=F1[i]*G[i];</span><br><span class="line">     FAQ(F1,<span class="number">-1</span>);</span><br><span class="line">     FAQ(F2,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F2[i]=F2[i]*G[i];</span><br><span class="line">     FAQ(F2,<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,(F1[i].r-F2[m-i<span class="number">-1</span>].r)/n);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数论变换（Number-Theoretic-Transformation）"><a href="#数论变换（Number-Theoretic-Transformation）" class="headerlink" title="数论变换（Number-Theoretic Transformation）"></a>数论变换（Number-Theoretic Transformation）</h1><p>注意到朴素的 FFT 使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用 <code>double</code> 存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完 FFT 却会出现小数。</p>
<p>这就启示我们，能不能用其他的什么东西替换掉单位复根。</p>
<p>设有两个互质的正整数 $a$ 和 $p$，最小的使得 $a^{k}\equiv 1\pmod{p}$ 的 $k$ 被称为 $a$ 模 $p$ 的阶，记作 $\delta_{p}(a)$。</p>
<p>如果说 $\delta_{p}(a)=\varphi(p)$，我们就称 $a$ 是模 $p$ 的一个原根。</p>
<p>现在我们找一个质数 $p=an+1$，其中 $a$ 是一个正整数，$n$ 是 $2$ 的非负整数次幂。然后我们找到它的原根 $g$，并定义 $\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：</p>
<p>$\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$ 互不相同。这是为了保证点值表达的合法。</p>
<p>虽然我不会证，不过我们的确有 $g^{0},g^{1},\cdots,g^{n-1}$ 在模 $p$ 意义下互不相同，$a$ 次幂自然也一样。</p>
<blockquote>
<p>Updated on 2019-03-17</p>
<p>似乎这么证明有些问题？</p>
<p>原根的这个性质实际上是 $g^{0},g^{1},\cdots,g^{p-2}$ 在模 $p$ 意义下互不相同。因此如果 $(n-1)a&lt;p-1$，那么上面的结论就是正确的。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(n-1)a&=na-a\\
&=p-1-\cfrac{p-1}{n}\\
&\lt p-1
\end{aligned}</script><p>以上。</p>
</blockquote>
<p>$\omega_{2n}^{2k}=\omega_{n}^{k}$。这是为了让我们可以分治。</p>
<p>根据定义，$\omega_{2n}=g^{\frac{a}{2}}$，就是将现在的 $p$ 进一步拆成 $\cfrac{a}{2}\cdot2n+1$。不难发现</p>
<script type="math/tex; mode=display">
\omega_{2n}^{2k}=g^{\frac{a}{2}\cdot{2}k}=g^{ak}=\omega_{n}^{k}</script><p>因而原根有上述性质。</p>
<p>$\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}$，或者说 $\omega_{n}^{\frac{n}{2}}=-1$。这同样是为了让我们可以分治。</p>
<p>因为 $p=an+1$，根据费马小定理，我们有</p>
<script type="math/tex; mode=display">
\omega_{n}^{n}\equiv g^{an}\equiv g^{p-1}\equiv 1\pmod{p}</script><p>因而 $\omega_{n}^{\frac{n}{2}}\equiv\pm 1\pmod{p}$。又因为 $\omega_{n}^{0}=1$，而 $\omega_{n}^{\frac{n}{2}}\not\equiv\omega_{n}^{0}\pmod{p}$，我们就得到 $\omega_{n}^{\frac{n}{2}}\equiv -1\pmod{p}$。</p>
<p>若 $k\neq 0$，$\sum_{i=0}^{n-1}(\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。</p>
<p>以上，我们成功地用原根取代了单位复根。一般情况下，我们会取 $p=998244353=7\times 17\times 2^{23}+1$，它的原根是 $3$。</p>
<p>需要注意的是，我们还有一个可以优化的小细节。注意到 $\omega_{n}=g^{a}=g^{\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于 $998244353$ 来说，我们需要预处理 $\omega_{2},\omega_{4},\cdots,\omega_{2^{23}}$。注意到</p>
<script type="math/tex; mode=display">
\omega_{2^{23}}=3^{7\times 17}=3^{119}</script><script type="math/tex; mode=display">
\omega_{2^{k}}=\omega_{2^{k+1}}^{2}</script><p>我们一遍快速幂算出 $\omega_{2^{23}}$ 然后倒着推出剩下的即可。</p>
<p>关于 $\omega_{n}^{-k}$，注意到它就是 $\omega_{n}^{k}$ 在模 $998244353$ 意义下的逆元。那么我们把上面两个式子中的 $3$ 换成它在模 $998244353$ 意义下的逆元即可，这个数是 $332748118$。</p>
<p>然后我们把 FFT 板子里的单位复根全部换成原根，运算换成模意义下的就行了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">         <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">             res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">         x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">         y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                 re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                 F[j]=(x+y)%mod;</span><br><span class="line">                 F[j+p]=(x-y+mod)%mod;</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">     unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">             unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     ++n;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         cltstream::read(F[i]);</span><br><span class="line">     ++m;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">         cltstream::read(G[i]);</span><br><span class="line">     <span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">     NTT(F,<span class="number">0</span>);</span><br><span class="line">     NTT(G,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">     NTT(F,<span class="number">1</span>);</span><br><span class="line">     n=cltpow(n,mod<span class="number">-2</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">         cltstream::write(<span class="number">1L</span>L*F[i]*n%mod,i&lt;m<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>关于最优化分块时间复杂度的研究报告</title>
    <url>/sqrt-decomposition-complexity-optimization/</url>
    <content><![CDATA[<p>最近在刷 Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。</p>
<a id="more"></a>
<p>假设我们有一个长度为 $n$ 的序列，块的大小是 $x$，令 $y=\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是 $\text{A}x+\text{B}y$。根据均值不等式</p>
<script type="math/tex; mode=display">
\cfrac{1}{2}(x+y)\geqslant\sqrt{xy}</script><p>我们有</p>
<script type="math/tex; mode=display">
\text{A}x+\text{B}y\geqslant2\sqrt{\text{AB}n}</script><p>当且仅当 $x=\sqrt{\cfrac{\text{B}}{\text{A}}n}$ 时取等号。此时时间复杂度最小，为 $O(\sqrt{\text{AB}n})$。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>研究报告</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>关于块状分块的研究报告</title>
    <url>/block-decomposition/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c7bacb7aaaff099cb249d3f93689318a1c3852d7ef28476761ee22beb9aa2660">db88ea21dde1523cc6d4f97d6db5a895331a20ae7c4b3e1920a46894d67c16158b8748430d3e479e2f382bde45c84473a4260a618622b3ba92370399f561cf3fbc452ed39122bd7c3b6c208a6af237caf522c9e4ebc12f3d079cdad60cc0bb172da3827cab3a174918a0aaf3fa7b8f28f3f22714e65b0de09795f1747f6c421e1e5efb57ed2618bce8145a16277110a4f83b75242d75bf01c7afcf6f2992f0ded31e1782efd7f917e1539531734198a3208bf349aaa7805d7f7102c66ef7b8f37a56a48e559835a4e45e39d05a3fe27e4479296a346f8ed861e20f8f984a2f00a067d37e5df033d0e7371b03c7d5f9d5740ccdd3bc5937aa9fd55bc31e9fd37bde00d3a075fca0cd268a383ea7daf7761d1f88fc2206b7bf1ab20beb062aea20509cb83868af50cd2e6ade15a91cf44e44f06f8ec4fbded9ed3a92a7d64b574688840f0fb0857c874a70f9fe558a0ab6ce35711bef45cec0fce6a79079fa83c9385c76be0abf612e463932ba8385b43b81369cd113c0f0e5ebb6636b98d662aaa572d006d09ae91e8d68c5b71612832ac71f347593700537d646b0539853f174de04566ed2f2d293ebbcc9b09f17bcbea4d562141619ebf80641c98fb5b556a6b52a6e9965a6c626783b88df343b721722cb4ccc2b2611670bc23ecce9565216a43431e99634923a26a392d4071abf6e21b9cbcd9487f0ba7b32b412093c2c95e0ec90f985d4d9bc0584f3f1eafc60e128a8bfb944b99ebc4ec7c81b7e0ea8441baaf40ef7c9a493a1fc3e6077fb99e169d763d8659b5440246f969b9b7da8b58966d68dc4dbd870524079566fd9c45903fbcaeeb363b30d77e2ededc951b2027a347a782e217ba65b521ae8fecf8eb48139bd1c1863164a81e7af23dc0e3615037fb53b9e61bda7d9512520613fe8649bc84797d3c5e69f4e87a320a13697d32ef8ad47bf6cbbc8d407a4c030c74170bae40193d31f6a10c5e0c4e99a8bdf87a5c000d407ef4b369ccbf60661f248fac9245f8830c97a88860cb30ee5e4cbd772262c247a99cdfe7e986398482be08b541efc7eab4e5ef82627bb6ecd1c6d8e848cb782bc48f4ba2223427d395cbd2ebae18b0f7b6d08d84797b1e9af8add984021069ac6d7110420815bccf7c787c0121fee072e18a8297b7e10cc6418288d24ec167d8cfda2469b44f68d2ed9912729b8917ab72cefc1d26012a9d3e5bc8da585511b46999bfc27e55e9525158101bd591cb37479c16ccf0ded6b4ace6104de3c8ce104489ca6203bf816794b14f16985f7fb14501939b7c79cb5f28552410a05877a78de6931b8aa3d15b062be7edac97a0a1bb48ffb8158c4d876d5f0f1fbc6d0f9f069bb11130cd43754cdadca186676e9b2eaa1c71d5f8667f60d145c3f4f78540886df4cdb8546ef7ab17201f3b0a1048ad39ff6668e0af5f480baaa0eedb3e9e9b354eb132f184509be4ba3ef92254d2f0f42196de0af8c85da0c9e2c63034431bebdd212cbc6c8bd69ffe3658b23627690a3bbcb767dd926ada35c30f7b5d8b520c0036875c6d8fdcaacebc6b7185c546a5cd4f702bde044305c1d12cf82fee49b77c7908170b8a9e6e531a38a4991d0c9c01ec3685029cf1eadb30dbd182d9e329e220f794640038fc8a909459761198724a9156dadcd16fb557b04c3b43344fb1b2d086bed85edca7acb06b3ef7c35bb00fe52d17fb75eecc65d2765d025d84c5a8534c326a42b982a63fa20b25d97198015835a2432d12ed408dce51c36f55a8cd97595d4c8a4865f65e3313eb8b9da99e4bcaaf6e51efec2e32806421abf63d9c63fa5da42c8633070dfc48fced18adf3b2dc11ebada9db8a4c5c3773dbb9a3231c64251a0a09dab0814e9c9a72ef64affcebff2ff77618fe95182ed5a819f747dbd16d2794d2fd7ce170574ad996d00118141738a81851cd32a1a4622687654cceb614ac4f5818f0c9cbc2d88b08f2653d05686908abbff6817356bce1f4a5504e05cdadaf635bf76b5f9add973c7628e58f74320831e70339dc222a2ed1a695d375243af20cde6dc329bef06e4d3b353ebfd08fcee7a214dbd58af38d13c2cf8b543cb8371659dc4d0a0da6908973d47b2c1541b788765d10e3beef4fba870184d3643051ca324eba826349709c93bb879d832656d809670bee23322d1b71c6c7757086269a8cfda5b4928acc4dad9370ae61323c1775bcb91eadcdedfa17a8cdeb8d243e53ffd912e2676914f9b2144c0d2cee4d60cebe033a61216eda5313a6d40f61429335831cfbcf73d785f25f8f8961a97ebd8b45480ecfeae6523dfdb33bf63289d820d5513376e417394df15a9bbc438184546febc1eae1c2b6d2dabefc73ab6b3336db07e6669d031bf6b14586179b5ce154f3c1e65d616dd7cc938e98fa42c8717bb25f2f8ab9e6c0a18647ceec273fa16be68b8e2e4836f28a2df3a2b4e79ba3aa4d3b0c1aa31d51f24ae942478b9145151c7037a71fb38d9b3bb4dbecfe95c7b728d6a94f409d3bc7f5eec33f17eae9b31d2521c1650e02293e20f8aa8a9fb4d0bdfc2b7a76e1f7545f912d7940bbbff707c4add4cfe5fe8083f1eaf3de600e3fa64b87a4964a6fb0f222c2eef4ecf742da97d795f7fc32f9561c96c854ff14ec0bda8eb6dc753fdbcd9f01fd20eb98a85f16ab61d64ca54efab988db14c6ea72e0f784eef631ad22854a598e0140d9a1d9a8f8f48fa7b82442b03b671cdb981a5f618912b79c6c50e39a1d1905dd334f95afa10cbc14714638e672ff7e61ec89affc0743f9201f09cf5ffc5d52608128fb02ec588f06d61ada9300ab756604a35f2f67ecd0866caa675bdf1b971eebac860d087b431189a21a927893e0dfb42d9a1dc0fc8dc3a0c4ec2ddcc8fec225957d6d807bf34bb09c283f83b5cb96cb025258162ee12e06286d52cfb44437e907cc7274889ec4a6edd36626a4091627c9f79890f4c2e3dd72302961a2a5311f6b503dc3f02194431a8d3a4310fbeafa3d722303ea3a2b4015a1933484d9186d0097b72242f6cf9f1794a44e366b33edd46df93f7a4ef31db646446671ef54d5770481f05cd93d06ed2b6d78baf4ee740e73fa592145ea3b66d2e7c28b4fd9e1e14facb8a2717a54157aae9b1272424441c33</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码继续阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>研究报告</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>块状分块</tag>
      </tags>
  </entry>
  <entry>
    <title>「多项式学习笔记Part II」多项式的进阶操作</title>
    <url>/polynomial-learning-notes-pt2/</url>
    <content><![CDATA[<p>以下，如果不特别声明，则所有运算在模 $998244353$ 意义下进行。</p>
<a id="more"></a>
<h3 id="接下来的前置知识"><a href="#接下来的前置知识" class="headerlink" title="接下来的前置知识"></a>接下来的前置知识</h3><h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><p>说实话，其实我也不是很能理解这个东西（</p>
<p>我就凭感觉 xjb 扯了（</p>
<p>现在我们有一个函数 $f(x)$，我们想要用一个多项式 $g(x)$ 来近似 $x$ 在 $x_{0}$ 附近时 $f(x)$ 的取值。</p>
<p>我们令</p>
<script type="math/tex; mode=display">
g(x)=\sum\limits_{i=0}^{n}g[i](x-x_{0})^{i}</script><p>我们想要让 $x\rightarrow x_{0}$ 时，$g$ 在 $x$ 处的各阶导数与 $f$ 在 $x_{0}$ 处的各阶导数分别相等。</p>
<p>我们先考虑 $0$ 阶，也就是原函数。因为 $x\rightarrow x_{0}$，所有包含 $x-x_{0}$ 的项都可以忽略，因此我们有</p>
<script type="math/tex; mode=display">
g[0]=f(x_{0})</script><p>然后是 $1$ 阶</p>
<script type="math/tex; mode=display">
g^{\prime}(x)=\sum\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\prime}(x_{0})</script><p>再然后是 $2$ 阶</p>
<script type="math/tex; mode=display">
g^{\prime\prime}(x)=\sum\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\prime\prime}(x_{0})</script><p>最后是 $3$ 阶</p>
<script type="math/tex; mode=display">
g^{\prime\prime\prime}(x)=\sum\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\prime\prime\prime}(x_{0})</script><p>我们发现 $g[n]$ 有如下的规律</p>
<script type="math/tex; mode=display">
g[n]=\cfrac{f^{(n)}(x_{0})}{n!}</script><p>综上所述</p>
<script type="math/tex; mode=display">
g(x)=\sum\limits_{i=0}^{n}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><p><del>应该吧（</del></p>
<h4 id="多项式牛顿迭代"><a href="#多项式牛顿迭代" class="headerlink" title="多项式牛顿迭代"></a>多项式牛顿迭代</h4><p>考虑一个 $n-1$ 次多项式 $F(x)$，我们希望求出一个多项式 $G(x)$，使得</p>
<script type="math/tex; mode=display">
F(G(x))\equiv 0\pmod{x^{n}}</script><p>我们采用倍增的思想，假设我们已经求出了一个 $G_{0}$ 使得</p>
<script type="math/tex; mode=display">
F(G_{0})\equiv 0\pmod{x^{t}}</script><p>我们希望求出一个 $G$ 使得</p>
<script type="math/tex; mode=display">
F(G)\equiv 0\pmod{x^{2t}}</script><p>我们将 $F$ 在 $G_{0}$ 这里进行泰勒展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(G)&=F(G_{0})\\
&+F^{\prime}(G_{0})(G-G_{0})\\
&+\cfrac{F^{\prime\prime}(G_{0})}{2}(G-G_{0})^{2}\\
&+\cdots\end{aligned}</script><p>注意到</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(G)-F(G_{0})&\equiv 0\pmod{x^{t}}\\
G-G_{0}&\equiv 0\pmod{x^{t}}
\end{aligned}</script><p>也就是说 $G-G_{0}$ 的最低非零系数的项数大于等于 $t$，$(G-G_{0})^{k}$ 的最低非零系数的项数大于等于 $kt$，从而我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(G)&\equiv F(G_{0})+F^{\prime}(G_{0})(G-G_{0})\pmod{x^{2t}}\\
F^{\prime}(G_{0})G&\equiv F^{\prime}(G_{0})G_{0}-F(G_{0})\pmod{x^{2t}}\\
G&\equiv G_{0}-\cfrac{F(G_{0})}{F^{\prime}(G_{0})}\pmod{x^{2t}}
\end{aligned}</script><p>然后我们就一直倍增，倍增到 $t\geqslant n$ 为止，此时 $G_{0}$ 即为所求多项式。</p>
<h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a><a href="https://www.luogu.org/problemnew/show/P4238">多项式求逆</a></h3><p>给你一个 $n-1$ 次多项式 $F(x)$，让你求出一个多项式 $G(x)$，使得</p>
<script type="math/tex; mode=display">
F(x)\times G(x)\equiv 1\pmod{x^{n}}</script><p>假设我们已经求出了 $G_{0}$ 使得</p>
<script type="math/tex; mode=display">
F\times G_{0}\equiv 1\pmod{x^{t}}</script><p>我们希望找到一个 $G$ 使得</p>
<script type="math/tex; mode=display">
F\times G\equiv 1\pmod{x^{2t}}</script><p>据说能用牛顿迭代推，然而我不会（</p>
<p>考虑正常一点的方式<del>，虽然说还是倍增</del>。</p>
<script type="math/tex; mode=display">
\begin{aligned}
F\times G-F\times G_{0}&\equiv 0\pmod{x^{t}}\\
G-G_{0}&\equiv 0\pmod{x^{t}}\\
(G-G_{0})^{2}&\equiv 0\pmod{x^{2t}}\\
G^{2}-2GG_{0}+G_{0}^{2}&\equiv 0\pmod{x^{2t}}
\end{aligned}</script><p>两边同时乘 $F$</p>
<script type="math/tex; mode=display">
\begin{aligned}
G-2G_{0}+FG_{0}^{2}&\equiv 0\pmod{x^{2t}}\\
G&\equiv 2G_{0}-FG_{0}^{2}\pmod{x^{2t}}
\end{aligned}</script><p>边界条件也很明显，就是当 $t=1$ 时，$G[0]\equiv F[0]^{-1}$。</p>
<p>说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（</p>
<p>关于代码……现在还不是时候（</p>
<p>后面有一道超级综合题在等着我们（</p>
<h3 id="多项式对数函数"><a href="#多项式对数函数" class="headerlink" title="多项式对数函数"></a><a href="https://www.luogu.org/problemnew/show/P4725">多项式对数函数</a></h3><p>给你一个 $n-1$ 次多项式 $F(x)$，让你求出一个多项式 $G(x)$，使得</p>
<script type="math/tex; mode=display">
G(x)\equiv\ln F(x)\pmod{x^{n}}</script><p>对上式两边求导</p>
<script type="math/tex; mode=display">
G^{\prime}\equiv F^{\prime}\ln^{\prime}F\pmod{x^{n}}</script><p>又因为</p>
<script type="math/tex; mode=display">
\ln^{\prime}x=\frac{1}{x}</script><p>我们就得到</p>
<script type="math/tex; mode=display">
G^{\prime}\equiv\cfrac{F^{\prime}}{F}\pmod{x^{n}}</script><p>求导 + 求逆 + 不定积分即可。</p>
<h3 id="多项式指数函数"><a href="#多项式指数函数" class="headerlink" title="多项式指数函数"></a><a href="https://www.luogu.org/problemnew/show/P4726">多项式指数函数</a></h3><p>超级综合题来了。</p>
<p>给你一个 $n-1$ 次多项式 $F(x)$，让你求出一个多项式 $G(x)$，使得</p>
<script type="math/tex; mode=display">
G(x)\equiv e^{F(x)}\pmod{x^{n}}</script><p>首先</p>
<script type="math/tex; mode=display">
\ln G-F\equiv 0\pmod{x^{n}}</script><p>我们把 $F$ 看成是常数项，定义函数</p>
<script type="math/tex; mode=display">
A(G)=\ln G-F</script><script type="math/tex; mode=display">
A^{\prime}(G)=\ln^{\prime}G=\cfrac{1}{G}</script><p>套牛顿迭代</p>
<script type="math/tex; mode=display">
\begin{aligned}
G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\
&\equiv G_{0}(1-\ln G_{0}+F)\pmod{x^{2t}}
\end{aligned}</script><p>然后把以上提到的所有板子全都复制过来就行了（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>],tmp3[maxn+<span class="number">1</span>],tmp4[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">         <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">             res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">         x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">         y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                 re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                 F[j]=(x+y)%mod;</span><br><span class="line">                 F[j+p]=(x-y+mod)%mod;</span><br><span class="line">             &#125;</span><br><span class="line">     re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">             tmp1[k]=F[k];</span><br><span class="line">         NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">         NTT(G,j,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">             G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">         NTT(G,j,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">             G[k]=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">             tmp1[k]=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">         G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">     Inv(F,tmp2,n);</span><br><span class="line">     re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">     NTT(G,N,<span class="number">0</span>);</span><br><span class="line">     NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">     NTT(G,N,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">         G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">     G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">         G[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         tmp2[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         Ln(G,tmp3,i);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">             tmp4[k]=F[k];</span><br><span class="line">         NTT(tmp3,j,<span class="number">0</span>);</span><br><span class="line">         NTT(tmp4,j,<span class="number">0</span>);</span><br><span class="line">         NTT(G,j,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">             G[k]=((<span class="number">1L</span>L-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod;</span><br><span class="line">         NTT(G,j,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">             tmp3[k]=tmp4[k]=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">     unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">             unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">         inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         cltstream::read(F[i]);</span><br><span class="line">     Exp(F,G,n);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         cltstream::write(G[i],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式开平方根"><a href="#多项式开平方根" class="headerlink" title="多项式开平方根"></a>多项式开平方根</h3><p>给你一个 $n-1$ 次多项式 $F(x)$，让你求出一个多项式 $G(x)$，使得</p>
<script type="math/tex; mode=display">
G^{2}(x)\equiv F(x)\pmod{x^{n}}</script><p>牛顿迭代吼啊！</p>
<script type="math/tex; mode=display">
A(G)=G^{2}-F</script><script type="math/tex; mode=display">
A^{\prime}(G)=2G</script><script type="math/tex; mode=display">
\begin{aligned}
G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\
&\equiv G_{0}-\cfrac{G_{0}^{2}-F}{2G_{0}}\\
&\equiv\cfrac{G_{0}^{2}+F}{2G_{0}}\\
&=\cfrac{1}{2}(G_{0}+\cfrac{F}{G_{0}})\pmod{x^{2t}}
\end{aligned}</script><p><del>复制粘贴吼啊！</del></p>
<h3 id="我刚才都学了些啥破玩意"><a href="#我刚才都学了些啥破玩意" class="headerlink" title="我刚才都学了些啥破玩意"></a>我刚才都学了些啥破玩意</h3><p><a href="http://codeforces.com/contest/438/problem/E">一道例题</a>。</p>
<p><a href="https://www.luogu.org/problemnew/show/CF438E">Remote Judge</a>。</p>
<p>这是读题前的我：</p>
<p><img src="https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif" alt=""></p>
<p>这是读题后的我：</p>
<p><img src="https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg" alt=""></p>
<p>这是知道了这题正解是多项式开平方根后的我：</p>
<p><img src="https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg" alt=""></p>
<p>我……我怕不是学了个假的多项式哦（</p>
<p>厚颜无耻地抄题解（</p>
<p>首先我们搞出生成函数（然而并不是很懂）</p>
<script type="math/tex; mode=display">
G(x)=\sum\limits_{i=0}^{m}G[i]x^{i}</script><p>其中</p>
<script type="math/tex; mode=display">
G[i]=[i\in\{c_{1},c_{2},\cdots,c_{n}\}]</script><p>定义 $F[i]$ 表示权值为 $i$ 的神犇二叉树的数量，我们有</p>
<script type="math/tex; mode=display">
F[0]=1</script><script type="math/tex; mode=display">
F[x]=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]</script><p>就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。</p>
<p>然后是一些神仙操作</p>
<script type="math/tex; mode=display">
\begin{aligned}
F[x]&=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]\\
&=\sum\limits_{i=0}^{x}G[i]F^{2}[x-i]\\
&=(GF^{2})[x]
\end{aligned}</script><p>令人窒息（</p>
<p>然后我们就有</p>
<script type="math/tex; mode=display">
GF^{2}+1=F</script><p>但是为什么要 $+1$？因为 $F(0)=F[0]=1$ 而 $G(0)=G[0]=0$。</p>
<p>于是解上面这个一元二次方程，我们得到</p>
<script type="math/tex; mode=display">
F=\cfrac{1\pm\sqrt{1-4G}}{2G}</script><p>但是这个形式还是不是很好搞，我们将分子分母同时乘 $(1\mp\sqrt{1-4G})$，然后化简一波</p>
<script type="math/tex; mode=display">
F=\cfrac{2}{1\mp\sqrt{1-4G}}</script><p>如果根号前取负，代入 $x=0$，分母就减成 $0$ 了；而如果取正，我们就得到很健康的 $\cfrac{2}{2}=1$。综上所述</p>
<script type="math/tex; mode=display">
F=\cfrac{2}{1+\sqrt{1-4G}}</script><p>本来接下来应该有代码实现的，但是<del>我拒绝</del>咕咕咕。</p>
<p><del>其实是调不出来了（</del></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>题目组试题选讲</title>
    <url>/timuzu-solutions/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="15f45d9391ab72ab35c07adeceb9fd7dac4c5ceda7cc67c1bed94f0c6dc499da">39c32e27a93b45abda723b50a96178dff13d54f3e6a396d6ce96140a006d6cad17d6dfff6507efae5a5bf041a25f046793e6e6509a451f93fe04fc87bc2c4332662b80c89907c65dd3356e18d4d0485f8ac63cb4dc10f759faeb9d4352bb31a2b984fbbacf4df0ff579a754841f1a651c51f0c8f20b24336eb9dadbf7c637aebc27b01af560bb6bd596f9eab7c94c28e81c53a2a39811081dd7e8136866c8e1033da4046266d761416ea9c1fdd2c634f5c9e9154ab12483232c794f7fee7d4ca1e4ba3289198cf974b205259cdd879e83d8b142ca8208dd8e1fd564669800c9c29e896ae16ce6d5337895620e2569eca3beb31ebf996a570ba8ff214bef0cbb521a69b60aac910a0d38ab9613006c5b9f4d48938e38901d4a0ad3164a0e984333227e6350f047692304e9abac419c338188a7298da99f6346d33e51cfad0f310545e89c22d204465fb657d39fb3d18983b62ef31427566fd06dea02804e9294bb0e81f527a2cff6e7286eb4fc6da9713906876d2166965831eb398b39d1acf75fa9bfa4cebc5eb5164c2e2d89b76e5204a243354879ec8e51d272af36f1116ac94cd505c9f0f3825075d314c6a73f7563e349f4bf6ec68a2dc9bc7ea239aa5a10b859df62b2e89dcc80d2a021663f227a6743253646a8e120525b5a08dedc4534a81164dd5d72bbf44db2c9583e9d99673eab3cd763a837fb298ecad3e0a8c9f0b3fb51f88d89de6ec7182d1d0b811b998a2ebb4aa83c2902539c5352af669be7cf54684d211062431bf84fe99a5cd8a91ee55656da62f5642fb29c439a0a1b91cd92cda8c80a946d55ed7f3214139299277c57ad83d14d58be495a59fddd03e23a7df43d62cc53a8a586f3c5ae74f28580200d8da2bed2a79a3f86f29d254f5598b90d67583c9d9a7db1f803da31b9db995f93449256ce59cc144e165b849c52590c0e8d4d990afc378a581aacf2a2a5ae5bc8cf69dc07992ace8963f0cd23ef2afa819dad8201ca4b6e67344604af29da375eaa5c08f942a4c060d1e9e4bc06180ef251212b6f903ecdcba531b22b59975e5bb53bf886386ef67058272bc6d912da5151531b43772f4de650bd66d7dec81e3bbf33784a5333d7008f649ce95dfb291cf2d9ba3d517ccbaf6cb3a1957eb409b14f606abb2415f596996724f15c02442a619f66705aa2127f79aa86fdd37fec30c75c3afa785c258e27da1999c7fd3620abdaca7b202b4eadb96bb8627fac1236ee710964ce57892c1d0beb43d80a1ab548d6498680648f934db37b8e651f7c999b05135f83cd62215ec2ab4f9bbee2fcc5f3feb2dfdbb6af4e776ac64f7a68f24e1dc3bbe8c8cdb9083710ead263a6da04279260904def19424bd24ea298dbdea98ad9643013e92b8974498df1f0642ddba8b0f9cfba2a679a2ef8d343d64867cbd6fc98c340b2e16485c8665a6c08ac4f01ac17e7a8af7c43208e65f0d1e9ef8d8eba7913e73a517ad28ed09002abb155a496baa2fbf704c8e6719c8112887d4acb9d0faabfa698f8acbf7038f09ffb39cdde7377d25bb371383d8fd984e85be7395b02c0bc493a1f0977f6dfc2efef7da0f4c356ed596b647303e557e3723eadc1895b2f333245be2439c1bb8208e0e3eca260765c57a7a6bddb62532edbb77aeb82d2711559a9dfb13ca834eef480779fadfac320f8ca5d5b1fae5bbccb5b91ee78291c9f6acc6c1a13454f0e27c2b7c2955521ca3d6e615172e2d29bbb4b5e7cb56bd5f2eadbffa746ee292204426598c7d45f213ad7b46cbd649c7b9629460d2bc70fd228e575364db1d6bc791a8f6fd3e55e23fd04ecb5cfead63567cb519ffe1818e49b10835627ed40c2dbeea3d7b9cef52be4efd098f808bc789e64b01b218fd4067cef033717f4c41cab7a330daeebf43b19e0c1ab9b8b0d0092b11bb1a061bf8ea9aa0f481a12ae697673a27b2c0a6ac567f3dac0a007604e96ab7084e54d0c6648a163484ab51deee048818eb70461c9bb572b1a4d12d0c251f5ecfc794ebcd28fb1f3a13bc678337b63e007366c710012541bad68059c2ba65dc161d1871685d26679c9bc0cfa40a60d5cf8b0fd891c89fe9d3417cdfad209a752b0e577b386dd2a7c7887f2eb045d1a0e322266982284afac00b91182b8ba9e79661bff329f95ca2168b3e9aaf361948dd9e5614bc5b8f9bac1388e6d9d40da8288794a0640e686df622dea4b7615f6e512d6181ab67d0d7b1180e7118c2d278dbdfa7d154f862bf91fe04be23a353206e7101276814b525c0fdb0db83492d363b85318d07a6e121baab69cc141dca028cfbe31544cf03b910c146f8cc8c6978a31a229b9b483515a493f68af80678d4d2ec23f1493eae5c9e4406a6ff9724988d1bce340d875a4dc922c843d14c50801e561aee745070b404e05ca4cc8897bf4a31d865357c909de447b82d651760901a1cd7e8c393bce580ee20375891cc1f74834f5e259b41e4b20535b28ab40e999353d918fbbb12b7cada115931f000a155484ab59be958a34981d5cc7cbaad17161204f941e0d66f7a3b6f3d5c0ab179ec3513b37c325ac67f7623293a4977f33160b0d4f6d8658751d3324db77c5097b1d781cfd1c9951eaa62bde89afc2e435773f9041ddeaf619aadb8b4615becdad691995bd7edf28a7453144be4f5f05c0070233f9cf4293aeb3283a110563b0ebc6215fd39fc929d7ae5e27624fc7f2470b615d292f797552c861c83d2a2888c60a7c98c655c31e5a1df17732e0f9e682fef2fbdfeea2df398bf0659c1027df13d0b69d13720d748ba03d6d72584c278dcd684a7b609204fe86fa351c254c64cf28871685dee058228e33163a976c4613056fd0c4f3ee9075d44e738b0903bbe3310b0a3f87fd863654c81016db5b4f3b421785b6854ac01e2788c20d2ba8022e0b39e57d1f35724e62f0108ab3f698d4d8870143bd871ae049cc7971f0343c09470ab20bb0b3b6bac2dfd83d5c61ef7ae617d377d4edd6f5a24a5bba28b7fbc6f6ce382b857cc9193cc2074f1802ca25de0ea3b58f293de5c4e5f6c22c49cda6d4130acb74cbef8ade305996c8fc9c5faff894d1a288f6b5cbf12499e888eeee4db4afac856a0e6c81af12177f3b58edb1767cc5acd42008f8a3d7a509aabb3144853e2f5fcb013617d1746bd7771129814d4d4e5e3dd58fa3748c0d915d38b82b335558c143715e87257289e490966ddd6ace3c7948fd5afc344d57003cc4936a85b2c63b201c3f852a9935e8bdd06b45cb9c43dff37f9ddfc9aaae3f2b6fa35bfefdfb60b0ef4a18fec6a2332249cdc0e7595b8a77a2ac72a573df7dfc1d386d3683beb6374ae19582dfcc3c94c264248e759e260c458288571a05d3d3af768680aa297ebbaadea5efad4893a09225bdeca30c37a22f9322de1344a7c15b1e03924c260fb72c5cfcba5aea6ba48b9192da475b3bc81d0583d79ba4b16ec06c6ff2df5cc4f58419001d064a500ca5257c6ae57cb1de690984ef97afc75f5c8e1220b31d690ef762842c01740cffd7ce741f6fe2d228fe213ea7ab7733e85d4e042da5f13f3e588676dc0a5bc4326281abf86345e6cd1c72e5533c0ec3b910161f27045a1154a87a4efa4d7714d66353144cf4c2bfec747463d42720e85f78f33c21ff304ba1d91435e550143c3002a4f3449328d66251308443e48e3ac93a75b87fe3cee22de268c76ced54ff1fefeaa0d47a176eb85893aea6973bae88c54aab6a9aa37005ca8a2871155e8a30bc77e862c81ae60781806559979ca71fe22f1e2811943d385273bee6c2f81ab35e35c1b2ffdbd097f69aa5d97c963ff5d8cea08e2bfd8381927590756b15624414db05916b216bd04c2c47e00952d01b4b53a43ff4327794667aea372f2253efdcdef81ec1c4e0282ad1b22a55c41ec15b818bbc3f77f2b06e8644ea1f053756213f029428af8784a41f6e6a5e1eef4436cb2488663ccbac7f390af14cab441cb5dd1fb8c045427fef1c1ec3177fe145a055309a09586dc62964950274cf54c39dc8461ff85f8c9f39c9df11d06abece821a0dc4020733dade12a47a1b0a001571d08753644fe79611bfba573998b1c0fe2063a8f17a75beb6c528544cb80d7a7729514395801cc8a5672e16ca3f01210a59888bbb4c5da767a6c04a1083126d199e9a75fa6477a47067608959cf8d7f74469c31ee9916a284cfcd0d3e39e16054441b5e49c0caaface91c08dc63c26602fb1c82ea6d1f79471810fe9fa4ea9c889470963c497311d177d60a6447e333750317679a9d028fedb4e28637d9ef511948b95c80820831414150933e34aaeceaed3f3fc73cbadf41515e1aafd68e7b9e9c17bd8a883bc596e0358cda0a13bdaafe1fe924d6f8e238f515a1d4d9309c211c4b56a59e54b4d19029652eaa5fe77d286f470dbd01a58298d744f60636c3942109cb1dcc42226370e09be29808991c365516668065a3e666d3e689a5191be0461b2ac322a4352bcabf05b4c3b0cf76a598e6d971128fb2439b9b9e729a49e67de8fbfd4a3ec8eeef15b33c0a758bcae19218d477f4c03b2529e9e1eab1d5654056a6cb44492310bd3241a46ca8bea3d75b08b1dada20bb9057d20eafdd4793a8df2eec5c41b92c49f4caac251dc3b34bc921d9c312c6ef817682f42f32fe530aacd6b002e83a47a43282d167e17d7f1134da1f6def90eec9062fd1ed39e23765ff636b0701399389b00ba9e2b4b5a2ed68847567948c8c2899d340bc9dbeba7965b459832e80eb2f19e6ce198b9371bd9ec71ed3774b364e84ebb48b99c81dd2abd644d278ce412e55b9e5487ba12f056dc5bb9a1d23dfc0c778e42e7115844bea1844295c073f8f7292ff9adafe3361c58aa3a9d41c2bb1e4c89b63c2bf63222c50cd4903b62004ebea49094b10ad3a8af5d73af02de8041a08fe4bb3486caffbc1baa9e5876450cebb7ebb037be19ac6f0d3908a6ebd20a65863efb1c7af54225f4f9d0dcceeae2eeba88eea29d52b3149c12db70ddd6fd93186c63d735a009c4e740f8a484fb1f8ed1fac90f4fd02afc63fd5a77f854a6a9a94750e6726e1f7ec95a408b7a1fe2d1df195b6e8268ae2e92e84a04b9ae715fb57b32fb6d7603aeff033ae89ea6ae383ff42b0db6880cdd8f2796968e2aafd055871c771c0919b3fc02076a9edfad1f71e080b509e7fc87cefba5c2fed35ca90f89e72211dd980453d94b76fe80dd01c5b65aedadc659a4de0ab18549aeee57bca5c9f5718451ba73f25459b8f07aab191c124e72a0041ee63382cc809acd58f1fcdd93c153135324ea294ca2fc6e133480861c3095d21469560e06302fcf6439a510b09d0d7f7c45d805f052d6f203196abb5dca8ecedc58c890a63d682348208b5288594fbd5e1e8adc02f98c3c109b73d4a1dff327882559dbab14d0f7e92083dfe5719a2f33ac8459b80c3822cec2b4a41a1ddba0d90951f59a638bd09202b18db4fd0ffe4b8e5c10f3fd5d8305c65374ee577973cac10ed37c8fabbadcfdffec4999f5f3572a0c8eba9fad2f90630d9c2dc92ff2006710803e212f314e229fe646f762c708a244831591628048e79d2ccaa64bb9852f6e4eaaf09bd0816dd31a20cf5ae3dac4007d739d2faee1aa1ae6239e0bffc869a9fbbbf38c478579d703fb5a4ad99f900f6d757bba8aa3800bd8cf1391e2ee4a4175a21f952abc0dab12fb3fd38f70bfc7015a8628c808da707684727a665722df35577b8aef4453b783fb7c82484dadb9ed7dc2a68a55aaaadc809c9ba5e58c08a82114f3bba0344a7c5e83fa5d4586cf472912ae0a4eff24e5e6e6c31d5540dca05ea1135392f469c01e938d3bcf517eb8d4679cb4385dca076685d73bc660baec4368f57f7fe0515307a4a382972f9e076f226e026fff8b8634342945582bad057b2abbbed07acf8d514a461755fb96e845935db6b0901644333c3c3d10e89318f49449f4956df0615b5fb5cd1b06dcb89eb3fe377da9493d85c8225cf31e10a381357ac45073c4f40f03072c03ed478e99fc059ac304fb687afac71d95acc6412b90bfde16d7009e6c2f32454b92ff5600d8dece09ea65ae2e5c45161a9a9b5b86fe5c08017082b0a63b39b5cf731b0e9a8ca5b1ab33a3faac77a35b8a8e3bf0ae00418ab07f1b0e3e4e8c17b32ef6e7f4c8b8e9818468d92c154e5bccba5374ac22629731cb5d1f71a2d63dc4d02b1a27183cf22d3f5ddf1ec7375b38b3fea7ebd329d9db6b795deab4edd87093ea36503d927201ac8ed7c13de91fd46c9a25cc5c2d126084092ecb87dbcf96ccd27b7e97018fc3b87eb47315f0f5cd8d4020ace635a7743502992028c80d716273bc40b56f5dd5e8d5ca12556ebd51a5060f84254883a69f1272460ac6779470943b4cc6c6d2c433889ae3980810b35fc0904ab9c922f4cca36b862a426ead3e32a0c04b69ba7b25446f7721035735528160509f903efaf37eb8987cad0640c5858db0d2adcedf3af48ed674539b3a2d621d05d5268b092f9ea636ad93b9112621b788485129a3bb990ccc56e1942663eba4b00a541e76672de4d9e24ce6086b182b489d347a59b5b4d3e1a4343fe5cba24551721cdc9bdb69d919bedb0bfcde78991ed4519076623fee6ecdf0c6069dd059d1f21549615e6c585197ef7af2119d3b6c7be1c4aa18f549474210f674ea14e3b63ebddae9c45d198d6a25353a82bf6efc442f6dde0d7bb814ff1dbec80ba6c134b8876363961e3c44abfe5087d24bc2f09977b0eba49437302f9d22a5995b8219e372598f12a173d8904485647da052f2da6ac4717a48585ab87166f973663247f7be65c37f80c066e1191f7d25af50e7dff044fe2aa15616a0d6206874ace260ac3a89f81b8731a58812a9348a42af81fe604b9cb1829a817142adf5da59db6e0aed629c4a2ed31ad493054606d24354f49d6610d76d6152422fd03f9864afc6671edfb101c66dc1f9299680d1c2cc74d55acef5906a420cf7bc3c98b91b332c0bed60d65a3e2652611a1b3cf977da7bcb2d4075f5813302284fd8fbcc24b075d2d6ace833dfcd1545d8a79e67933bb2dedc3edc0a2bf485e41051f4b77d96deb831ec7c2fa050ad0469629a4de0e7ae06e9c261941b442ff604ec6a5c28cd887117f0cb4a6869d321edfa8f6273080d33cf9c7c74e21c6b4ce2fb415e6cba66b1b3453c168f34c018eb4623ff36d60d905950aa6ce11332b11ee754ee7de816b9799c71b4a78925da227808a9b44b081c3d76f3427497462aedbac3a01a0092eb1e86a96bfe9d75fb5222ae2735ac87466ba04e410be67a4f8850bee1575ec45d44bef4e9b7978f87d8c5e1db05e32a1c5777c02a0340328c7fed8abae88f811860099e2895b0df1b5776b9e651c94307659857cfe47450a7f00863efc09835228580559a1899919099d8506ee576617d117e0879cd71afe4af10f6900b6649c3d4d60d4e2bc5aff05a329d7bb1e901c339973f4191bdc2b4b49cb9edaab9a553a06737b2dc8af9267922929682970cd34743ff849e1d45554d2c00e812b0d41729c3c8455d2cca4fc3a7262ef5581880ab3afd4bf210e5cd43d3acd10e0de29f51592f2cbd094fb3adb705e6ed9bb538d09780b7250f3b995d7e9a87e571ea8036c07b960c315488c8bb27cf7cf1034a74469b91482b4bf7233ada82efb6564996951e76d221d90690cf553c51e2a7190923f8cfb1819ff49e1423ee0a40b3530645a4e3fb502f2d4db73daf344f396de616913f61700a8063c66cd5fa97392139cde4bd57cf358a19359d3bcebaf53e275e49317d59441213dc81cd19f4f68d2f21d55e47222774bdba125564e941634e1260693a1f09b80bdbb0859a13ce3a215a145585986c98639e0565177ca5e86b660a0a2b7c29b7971f486edb4ddf69610e344a1513d778a4135b288b374f4ed09aee0e1311bfe208cee26f2effb4d25d76dc9a69a34092106d80a9d804691cc7c98855f6a048e096225debf91ba126fb8572a8914e403e3c7c335d1b5c536c7a3fe0fbe4a792e0076eff4607a7b7d3e075c9503ff119b01f1c658acfe1cf2ea0508f8c915d6494ac02bbfa7436306667495770d1b3c637fd17a0425947f7d4879a41e2602eebe55ce0458d183e4bf365099c6f035d7b02fe5f44ae031e7a3ddd562cbf64d38625c1f7dd987b0503bda53e5b3a7100611848feb84d0d82d67df0ffcc357ee4a8a708f97cc191ce2216b51bbe7e9bf7923e98d3d9025d4f5bf95afab8b513d520be896c1a64e551017084284de94758c5b1efe8faca4b56a9060b7da8f46a29db227453962ebf6c8f7abfd2fe5e1e7b9ef4ca56fe3b7e37cd6f9e400018e1473dde8c387386d46e715cd25d612eac3afc7ecb120c5344c2f1aef47e799bf4df9275cd5edfcb3034184e4ac9eafb4f3c066333aedebbb8c4642679b56c3410cc2c72d90cbaaebc9f2a9dc45d9dc209f87570789a30b832e2b42c9bb302a504e168ccbd962a893f2e90e9394f327dc00a34e56b4a0099c71e3d04fa2d7607f47d610e6a7342b1ca2593b288ec23fc832867a421a2a20e225a16fab60824c0814397cab31411b1319432b95caf2b3f15d6c1a5f2086616506c24e53073e533c635bd2973a120e08327e2de75111b6cef851d4ee4b17d65f1c504dc09ba4f7b9b469e50861ea0ae5d4ff7c352c519ffe2ef4d0cc5d8beb71b836c819853688160ce3b9f86ad088a9489fa20d013ff3bbddfabc8c3c0ef4e5e7a44385631f3261197b819606524dae6c2bc2b747a90df1d4b30c5f597a8cf3a9bea05469043688f1b4917f543af1cb28ac7c70d7fb51481de6898ee1fa3c7e0ce1adf2e484623a2fe4d33114244a64f7ad85067f8e9ea64993362f52e5cd4069a58e0c2491c062d7e14fd1499bb7b54b3ddf7777f1986921fb105531f2de8c3f17aa29c3e5b7a941754325f8ecc6167813756ff3469cf415991c7bd6719ac9c579a35e37596dd0482ada32d0e443cb2cbb9f710233ddf78aed8a025bca3bc2cecdde8dff5785ed34e84e9d5f6ab616e79972f10679e609208a5ccb75ccce15ae5904385296fb970ce34de3253e1e6c788788324b4f1bee6e299027c73b3d2a69bda98ca77779938226ddd667556d4af000f4e1545681aa499d0655eeccd350e332d9b4a05abc5ff7902219a833e8b4b2c4c07b8658953205c71ce154df0d0cede57aceb387b7754aac26c33115c2ca3484d0da12bbff5ca81325dee69a5b6207b6b781dba62d045e153a909c226d28a938ef59eb2482af88a71895b5a08924d188af2a2781d6702f3c3b313d346d90b90224d0724c375acb0e52ee7cf2c5d94aad929004a7630dae38caa483ce9b9e9920425a14d01b1afed18aeec67ac025b7dfc478172ccb07ed81c662ae57f113c87e524060535e410123191635b962e71809e25d7c40ac72c157bd197b8691207d6c4c278ef12b1eba0eda2bcbd216aafd976eb857fe164b5b1ab1178b7a7882730ec9cffb606b6aabd8e84fc347221be69a05d492f425ff99857538d269212d879a9d157f1fe0aced08a75b1d39a5e2de13457f4f9b19bb61695bc7a0c1ca91d287468d93c1ce33e81e2c944ea059a96c25c0b806b3d6aa89fe63f0622ebb25765f86a6805cd1532ebb8b72c16a80e0bb92215a2e50237d7505e6560a03b09e0fabb1cd58102b1fd2288ccabdfad77b70637562babdee9b6c3b779a55120a70c3189b1bdb538596525e0f35ca96c8b076ac0ac1d02c6334e85e2497638f6d71838db73f7beb57877d4e5d5c815cf4d0a25450cce1e4b8700064cb045edfbb32727b83e6e24f88f90dda75efec498920d765fb2d343423955a34b9757efca0466637820ed340fc482884f18aad8bf597bc7dd33d10e2b0fac52208d0be8fcaca767b4f5478baf1b2d4a3c5dd1eb915c89cd45346f942a78e1a7a93307f7bd8de7ec5e3a085d89dc2cd0448c5221c26197d1ffc32bee9a98dbb83b104e1ee6314bfcdb6514f72a28f31fa38a5ef9b53802d373d8769b6f9b4511bd7d4c85ed9b0ff620d74264ff2c86371f36956177b802217b588e86fe58a54e8f1c3aacabde53497b5825add682e885d2e8f911a6780faa3f27ff19f5103c9216e8c56ac458e9190147b5079ffb4e2bbc3545ac28bf6cd7738d72875fd5bbd1549fc166595359266e075990a77864750aae472483a18733c33e4391b357d5a8cf91dedd973b08ea2e04e94b5f88580ba8eb94bd4f44cd15c81d9042c9046cfe7377d1e8751c157bae10a46b10196f6efacd6b143dec55c949b12081d7fae2b2f3e9633e51e4f4e42b52c76c52ceee2df2a890f89c10b112dfeec49da8238a79a77af99b6634c3d7e79bc0b9a97420cb313481d95d18e59cf028f3e68a05338c90763ab50b5149e07ddf122bc00c85dc33d72077e72e7fb8920b2c123a2f219ba9702591a86a0ffe1a3e1a2595264702da7e472d1a3e408fd539414f751b887900608170b375945718f6e8020b249331e947126915cef89355c13060575ff3d5654e824409041a1f3be50cd94337de36ec348ba651fbb872eec07279669d640e0d436ff3fb3507932d11b90ff95565ba55a87d4686c4fe9911aedccde8920155a146708c0744c25cd1a28dbca790239a5fddf169730d8b864bbf3f689986d3899707f81e95980d742c5bbfa25bb670b8a3309c6a7cf8b414ec23d269cb3eddbddab7fc609a1188950379f79dd92e7ae60e2bb0a5fabdef0fdb3a67991e43325d081cea07fb2914dcc58f839af3bb1f7857f4ad578637b14564a2ce3ff82aad3c211835dd7bdc368bf86162d5e7e039c5e0985d77b332f78f9c9d0d5267e3bebacb3d8893dcc128afcf397f03a859f49a65a8638533bd84a54b157f8bcf31ed5b6b61020190d27d5901ae7bc2d511e8f874ab585825d6d74642f3411ed6a38f60fb44a50322e5c94c46af098b21ecc306022fff884cc31031f887cdee0b927ed2ecacb1094ce470a8723e3bd348720076f9308b87fd681585e061973443a923e2d9b90626111bead1383c87f45f105d17be85cf51daed0aad5a294e4aeabc7ba2670005f9bf6045e274e0061d90931ebe8982662d81e1913cb8799d5da2084682a8b7b77daca67ece33a032c3fcd459b2f069f14ecf4c213a51471cfdd214ebf8ba19348c1cc42c3384f37c2494b9be27b9b7a497f3e5f0787a86febaa417d535435ad486e7efedf1ee74a88bc99c85ea52eba239f2a58477fc3f1d49341ac76b637ffd497b4c01811206b56208ae124fef57c623bbcdd19f28543c131be8ae6b344df87ff03a91136d92fe39130de0fd09064ceac24f15bbe9fbd070a31e27e1c1aa4706e0f2d54f9af0d59872cc9b6a9b0b1e556e7a00ef4031093bdd435002454e2867afee0db287a2c2e4d8ddda45ab19f3c216f0ad7a2584f11d8b0bff31e61325ebc0c62a892a97ece6457f021bd99b1212fbcdfc4a1f19d22ba160b26c8dda81c2466457a1aed22ccef1f656f74755ed07e9f55a3e6cdeadc9cc4c6874a4c997c410489dbf4205fff7d46211d58d9223b8f0bc77e7556baecc70d1311dde6097852270c73225b934ece712a9bfe24b225b6b97f86f7865eda0ea2652e60fab41928f5b1f087edb917dade12293704820e6c498a464249d180ba5bd36fc1353c5b5db1c84aa26934f2193e9c0cda884a7edc2680ff73ebf6a9f6d5e72874ed17cbb3d2c2a70507d553231b7794b52f2efa4e961656825a2187ff466c17f21e1429fe63f77b6222d644ee538c91b14b0c1cb009181b7d4cd1b971346184dfd3c4cec78271e9513750414054f54780924503aef992c7f638fb9790d5c239fb47da1eba60bc390b8df05d7e2315935c862ca556d5ef00ea0d3a495f528c080083c6ae49bd49845817bb82bee4663560a9d8039bb6a571f41b2176daf83b23b8c6ee405e308d10b3dfa01473b279df07ba79df27feed9b3e61c863ee807af69a5d94f6c870524c31e7590369488ba10929aff64ed2077a577319ca02220b0198b477c583be7956baa82d906a756f6b5fdd02fc74c58af5bc7f4b4f98650f43c9c51d5a82d9f1d65b66ca52fdf9605330766a9c1db301f0e650133962ce2c40dd632ce6281ab5365fd867cc666f36382e894ea6c2ec51f201103ee0f611c3a389bc8842301b1ebaf24763375a2488dcaf607dedc0bbac0febeec197c4c703e75f2af763acd5d13206dbbf273844f8891a813fd4eeb2004de4b7c0e0316ba94c8d80d839fbfae876910831ef44a5d93e7c4dcc081456213e314c72b101d322bf909f88f99339627559a968fa5f337d5f59845c5b5e45118a28e4261da721c5693cc70dbd66ccdcf28bd9a2ffafc297bf2f7eae224d6e86efa8c1b8f4f699eefc9e479d4d54557bba88abf14cf655cba0093441ee9db3779947ee6da958f932863f635a44f2add3406d79afba54becb9748e902e204c70d633d51e577642921d2d596caca8c67ec8c3e9f9a8cc6e7f5d5d0e668c263169e6f01565ff52f2a7cb25be1b60f311d5228af4d998d48e13e5bda92ea181c25a94e1fa8209a57a155cad4072621eb70eb4977631fc683b187eee6573a1d4a9f00fa8195bff8ad4caa86dd3855502ab012bdc4133520d95c724da5091f2381e3dbdcb507a0fb6688a4c2fdc46234c3d9f469a76923fac8823510d63256299b1a2ab242a52c8510292f7af7902bd101aca183e7c0940755117e07bcd3db0a7ebd8573cf1c4fb44c2a66e8a2904272bd3f248dff5a50e8fda470207df26d001f0fe7139515b95378a6fdcbc9f0269c7689a273b341c7befff6ce4b57c4692c7cc1e06a00a2966b3033541acfedec39b82319a015e47741c1ddec48a5c5cef8ebe6fb372d4158a373d1b1c406c40392a1503d1b28a8f700c46de170b763d0aa3763934e4833ee48e2ceba47cbe1afedd62c01ec1929c4825bef2c0714e52d6b78cc31c3c1abcf84338bf96d08c6dc87787c2844d791f81b9db8ee6637bfaed123939f64ba93e4641b3770c27e94a5271520958a4f211cab0b223283aaeb456aa668f7096de90265d8d0b04cc122021f4145433e3dc59b8fa373ef79811eac61c0506ff944871782d9e594573ea07cf66caba254262a05546c65dd59a25f1cb9dd615cff15d7176033fb3dc2001a79478c102d04c0329c1f6be03bee3ee64e8e8a0a30aa354436098935e288c682db2ef4ced37945f77ce25dead5d383a82d8d01714c672356fc8788fc087767c756dcad6bf13c343befc381c6b747c394015fa3671ca2511846cf39db4ccd65e2a96aac51741aae17402aadb3f48b9075ca1dba0a91c3606239f26f3662d464d275d47eeafcbf64e2b34095b1ea181730602d3d37671c79c3629d2ac323da8fd8a89b1b08266cd6fb91eff9c0890a6992cc66f0c7dc5aab16760c07d9015c6a9bc49cebba8fba848aa6ab17196feca9d0b2bff9449cf66bd6ad9b8914aac8ab7c30391c0fc5066304946a87bf7088a43e885585d339510388f5f42c47e8609de25a675a68133d0d0893ae472b97cd8830949953fc7fa4515d17e0b5ef22d87efff3f3e6a4a3359bc121eaec2f3063ee392ef93dd94acedce61610d86c21367fa7e146b8a4452ae320f5161805f5ee0a58e8f228a8cadd741f2129165694b3f905c309c50efec115167e3994ef95057b855f24469741f8ae76cbbf1223fe03d5c6e2a0ea7e5343897a734b176708c0a6a5ca649765fe3043f52697beabc47d47b12e0d8b9b77323e005ff8c90aa78934fcd77e3258c9f8253c576c9c940e38e199b931203e1cc5b3c922eced57d6fb8ef82aa0855b3bc3d8d6aa3537d58b878aa7ca32ae618eb2207e8040ad0037341f90c17ca1e695612898c018a3dc360cd586b5b67bd8c890f9925e992fb0ac2b92725cd48a63a7f22af80987dc5c38ba8050846b4a1b756a67593166e5214268b80646cc6c9b9a94f7c0b4e7e76d7342d5023c46f57c85dd78ae4f0cef11a941704fdca0725c0af54a7068cc7dd9b7417d7ae6f5def23f3a9c626f84f182701c1127d97a6ed06aa000e9dbd0f3d91522ceb8009fa2ecc34a0e37088e2a9206184a47fc054b1ff055c26c36093ab40b30944ddbb9252105e3f22c4808025ad3a8d348aaba5fd66d2b8855bec2e3ac1bf044614b034cb2bbe070130faa5ef223a1e9b953c87d9600ef7681c8a7f9b68fbb38d6796267f4e1925ddc7f4f4bc0dfc66c0de2f882e972fd987da16e172cb32f5d0d051de6cb34ca029a71dbfec5bd6c24c46d75b89d5ff69f13ed415961a143ecab34a24e7c75578f405b09416781289f16627292d5d2326349042c72833ffea30d5b02f96d3f3887633ef48b0477c7ed75403b3981a2f9ec5e9dc6dc61f66ae65ef5200ab98861c211246fd0d1e9dbfc2ea09a2076554928691cb380488a6089d16e1f39bddb5e7461d15e18ef35d32bdbf1221c651c24d322f5195e0242ba029865b91e218ac3e984f75b27f6b983bdb7158c160f798714422976f5cf4ac9614355659ec0dc51cc0c9bde02f1cd6f636ba44197fd87b3e84019336c340f4e4e0498b07b2f4cbffc8de6eab95b045e96f707465da030545639a2f85e27d9b7be5a7a4d60a815e8512d2040eb505ac823bb3b26000c2b0b762ecca6964d4357aff988db86768c54e19d1b1c33ccfda32acd2b8f7196fcf6f64968950d86ea6d7c7065f0fc03a633fd4fc83382dc2a6518cb2a4a7e99e500b2287f494ca8f85dab51e74a919d3430cb26623c7e7621efd877a9274fda785617e5ad512d9f31053bff6628b09027a9e5cb354d359bd170148f690f3f8ec6d0004dedfe408fd589c616c5dc3a21ca3f2df80b1450e995f260fb83572e992394b464f3c154539a43e9975635e03ad81ccc86e8b94e8fb780cef9686d87f55d254940a6d882747fae6b0cb4ffe81731817317cb2235feea7cc04006d2fb2e1d8e51e3e963b6f3ef0c6fabb92117c88e8e9d21b271f403a80587ca057e0dc621e607716962c18ec56dc203aa3909f299b17ee2b7e8ea7554b613b4ed6c3757b502e65e22af21b2657f67e185b85bc2f59662aa9f5f060bcd2c29e30b594437afc0178c35bd8571e1a9ae6fac2240f008e7e17288670baa47d8fcf0b1df5346bc2d37978e103305257b8103f2623835482466d873e3b95ca3e47e80af5815f7b88cc64351099f8d995157dce2365c24b6c98ad56b90ae046ad168ed6d56f984446e00f39b94376fb1f20e1c89839ee5484c09f8470589cb8058d79d010a97bb35e8070908c9aa38f8692630ff2c08ad3e3e34d875c265cdadd2672061dbd394d27b2bc4c7403f759137b4748d67258b50acc1f57e6af4a1670e75244b1512a61df4607ef662e6f8dc7429b4a9ea5d68051912852d2df17ced91ecd78cd4837562ae32274e87100bb39ba740657a1b9b771eb92a7e13b2d4ae19d3680b573b6f537f5534da190e1cbf7250555c30b0627a95052271952b2da65c18b2ee2115d27c5c5a4a18d23e5dfcb117b5e874ab5ed9d15454237dcace3d9a42f3ac6d70836ce63f912766f6620d885e47de397c8e0d9e46cf114d237a648d977f5fd95efa67a5f76d6134ece38d5a20f2dbe9d8346ec7f5311a5b95fa3f5dac179e56af3f3e3ff9e9dc3c575d2c9cdf41c3957f2d6b5b1721387a21dd6d1366998fc4be75f5cbfaafa522e5c1a07bc13cf5cc21a4033f07dfb2275bb217e45b109046320f877d99834992c448cbb5d49eee65f8f8ccfa98e1c856d97c2c7632dfafe2adc90d7fba7195948d64f70ae0d43e68278f9b9d7d0bd3adae16fdb2352f4c60505f3a77f492906f0e657afa8f4af1630bcd3caa36550acff3f1f865df02caa318d74fd49528ab86409480db886fe28454069d8d7447e0d698b759dd6381672274525c4db9dd384baf1715ebe755dcb81240680973639a8de7d936f9dd35e616941fa6b853d7d32a58138833348b2119c00803066c5fabd78f2fd0b8b08cb11451e7f157019f71afb713da13e323fdc4dd3e439bf33596bad48a8be494781625b1353cf6763f4a0d9fe18e00f4da30a2c0f13a604975992b97469f954be6c5e15b30a28d89f68c052ef5087ca945c5123bdf9f06764828e1bef341da351908e57adb697f6930f7e33eb7168eafe65a948c4b792542c8a8d9bbad467f76e695b3b8f61718fdb2c488b5b5e34b145b391e8d4f15734edec450a07ed4a4e0ca3e3c2bdf8bba1337022d1a39d2b2886af6c8b684da08818a861c290b40da192b497b543e95b9b7cbbcdc62af40de6b36bbf2a57e4b382cefe68c2a4503cdef714f65c41ff25c966e24a32cc14a5b339eb64f2d541b67d5e0116b23ab08576e8398e6feb96c44443c54e8e07d156df14d154d6f3b6f6566ad518d2df4421683b702e3f68061e4a9e131dd96c6782d9e8b0ef217da8fb3a6d08f46d861575ab83128971e3a81ba27e4d0d57cfa5feadce8601e8a9e3d2f24577dc61daf0667e84f8a1e9116985320333221daa9a5bd0b79835b6519abbf11d256211367bf6bb965a8372aab792a0814a4eae95398a084763c7c60951ce6e0bce4803cccc72bf616d8a6bd499cb1ca53da48d3078d80bbc4d9158eb34a1d4250c8e34f958a34880851276b7c5b229a6a63102f9322d50988517e15016ac3162b07e352abc3a3b4811078c752a60f407a555244a1bba4c279002dfaf9c33954cbbca232943a63ebe3ac32dde44258dd065eb6315a30b7bfb49c1e086f36a231d42d25a3ba034b7f29bbd2f577a544082d31b1f13150ebd48fe9dee27fdd37659517e30193e2c36dc673407a429aad2b6d204cfa603bbf9684df1336805837448c95d6d94eec5ca8de9c501168905f8d510477858c6a398c17aea9b74dda5d7f5ddb2f9748845be465236926a5a028f478982a88ca990467152512f9d11ee3cf9f0738c8d0f98e2b228a8e7280b1f807446f28da1d89a27a37c1234dcc9c3c9b9f8f70e2ba49712ffc5dfe131053e5804f4808d901396ccfa7747cd0424403e774992ae9a80d4372bec6e962504a846b05acc1d4fbe0629645e689b697e7677b17cae6cdf3b97432ae9f6ee52c4bab7354c17cd89b6a380fb3d8499d1fb2e98ec51a42bff37b3503aa18aff89e8b6d579aeab6b29d3a45c036dad58711a64a574baa49fd53b93dfac67f428c093dd3b32d55a98f6076f35b567ee9b9af15146b49cc9d44f5f8aa64b7165c52df2efca9a8e721ea8dc2387a1ef4d42a3aefaaaa9b53551eecac0eec201e9be43dbc91432db9cca83bb5d3bc4533680a301904219965f4ddc97ca433460a786e0b87f9dc2e628daf137d520a110b62eae94e4b2cd32c558b66461cbc2af8309dab479468c184521fe118877aa46b68d4bd6dd16fae18bc7332edca8d95e7ca3a98bcccbaade3a9295980ab4fefd10e0dd7aab38b86197e97885a26880e45629d2652c6b0be0331b865904245c2a738c6371cbaf00c855b93a3bc6d8e8d86cabcde4c79ebba52205299cf72895fd0436397199ca72b7ef81727b105ee021279953d2453048dc90ac6cf692cc9509e0bc5ddf45bc32c35dcfb31a4a348064bb991e5422a48cd08c60c88106ceb296350160e19fb6b7457098daadd955b9b1098b6be88ececbc59cdc3b92aa34f76c023dfa5fe2718987a9dd5fc6d903153be60c45704e9f8ca783c784b38e8f0a8e2d183e45079953283809b40d500bf5a10843b0c37c7f203919bb8a79afe669376615d70586c6969b0c11c7694f7be17ceb31357d4946578cb89d214e7b79bacb0e54177bd5356f16c37a7abd5a97bcf62e50c09325b1b5a981d1990907236073d5bd7e8b6db1823bdf63f5801bec7a0d90b3748646d9906811e7ed8c23e66e2326d8f5518f77068969ab893063ad9738ed8eee54bf81f53bdb1bc14c170d48a984a7b69e75cd8a7f1bbdb084e0108a9e56e41c257a52fe0f4ad2cb8502ef1ebf1fe8e2afd81ec86620d19e519cfcc838e5d89a78249a2b48c4ae6584f993e47db2b5f048f7e2670b9e004a3f5605d403dcce7ab9f3920ebd3341931f8ad122e0c81633b1ed5d526b582d355555aadb926bcae37c5f7c5b412e9e088d18f36d24406259c72df45e53a48a0db073e1322cd6d399ea70d6e5a2a6b6a6a68bc22518adf17485dd1d0f0ce7f0c2be10c0fd7ffe4d678e42f26460ddcc78bfaf957a535f4b141b045e0779f877371d2f5893e5862806b7506efccac822b37478e468ab78ed7491457a60b7f4f475229b0f1d72329c95a4fa37d4696e1c7e2fbbd1afca65639f51fb8f415895e14b0aa27f5929d72a6c927f0efc8fa77e01be20534d3cfa3373cf4ce94c3fd397c4b8e39527a88fc621eada31a194edcd688224c51802752edd406a92bf10f7944ce172f9b564ba38fd4502571037f5a1587c7e6294a3c6e8e74921ab7413b4e01a55097a9d91ed7fdedad845aeb5d0e57506dabb57ea1138de5fc8509adfd4b8177aecf657b40486947c2d477855c128f1473d5b728e85b5f75d022b2d5b718f5ac3addf5da7a16e60b08cd1733c869cf16c5024a7675a4e38d3d7f9c50392c04b360be2bb4a5044cf25af8b29657e25d9f2878531d5ac167cdcaa43c3fbea094deec25641e4b8c9ef969dd9c0e306eb4ac27a6cc50bbb09d767d850ae738aaf34d276085fb0bfb582a38282b5c3493cffa439924341ff1460b9474065b49a787b864310008f87c78d126a44dc0735a013114891ef4a352c0e509662c3ecdac4c3f35c7b00fcd649fd759b1d0168bb810ec4907625cac7f45c27e5d2b6db7304951e497e0c0ac2373319eeed9df6b790ccf12c2b565bacd51a924c1938a0ae7e03948e8983470f864ffbbc400451707d3783a360aa67f5a3570919e1eaa860cc97bff89b936c3b400b5e1a696558c561a12d61f9cee49a16b6862fef19833d58dc0cb1c732ba2b30bae34b1ac7a6269ab3b761dc2a0ce2fb38fd7dd2aabe67d352ea90562d2b9a2be940a37b5456dfabdaa4c692c07e3e3a8addc775658853572581c5e655883de16b425fa73d3eb6fc5fbedcdd30fcbaa5f8850d89e166e1d584fa8123f2dba4d33bd67c8ca96f31b7f2d29d58ca91201577efdde31eb58950d6ca435f1dbc89ddb446f95d82b04bc968deeebdad39c37782de98c3dcd7da1cbf728c5113c09561b3a4fbaea62155ed2da5f06fe972ac39b21e190047fdeb0f94fec2af05f2058e04fb2f11c50a856a3eaccd701e552c4bd16256ac31c18332ed8587668306c69645007d1c15b0336b17f45ce96e6ec23eb8c9ed88e9076350cfe6b8510f14b8fa5dad557d4b4714e67db3030fc982e881a41033ccf8ee5379979b7ae601d506326f3583fc715b50f5cdc3a91ee5ba343ce577131450eb6c06884ba375fd301b144379a8af76288d3fe36b924bc4a8c87cccea199f236878e096592bbfca30163790fe0c738d53d6b5bb1538137d2c7e6e5933755e50f56c193b29c7e95f3324b32a9b7cfc7f6a6bc51f070a95c8fe51f599046c48a6dca5b815ea65165c2118314d62e7e1c05ca82a91a14d93620dda85bceac591f4b51c8b48ed94e5a3475463ccbbae246eeae7fe773502c5ad11ed006efda90af2834be9dcacea58b30c8a39d73ac7b92e38a8fc705b410e2b30c9069b2c528dd5cfa2141ae16627c9ff3c64d2330e7d24a682acfa0c2e4ba063637727d2b296ce945f2cd719125777cb966a859aca766f13679fdbe965a83cff252a3a359a8754ccce039cfa92a8ebf789d4feffb1e4457eb81b461d07df9abf20fae89aea830889f1039716da6f3a5156a5685f27027295b1a9e4dd146792ad8a3aaf4b0a57995a09b59b67ebbaec06a101b133471af301b6ca56176c167468ecb21b598d7006aac6dd5fcf4afffe497c5a9faf354f0d8adcc4c0933ceeb3bb9912f08bf9234cf9bc95cff7305013c33eee8f291b262103741c5721d1a3c274a876f58483e3f21530409f57bb9437ca9a0a3d7754763c0a2945c1a28a7d78662af596aaab97438cd2ae3a1b4fc3111468c422efa9a34e8479ece1f771dcf06f205186b33c39595ef33ffe1b2e2280100907123d35177727a0c5445086709d020d8484f88ae0cd13b0e4c20847c82336ae9394b621f82cbff077e4dbe2c442586a381393fc653603ad73b4b71547ce091c546849cf87b274d93cdcf97806531bdd14aa75c9ac172f0df9fc2eea5cd5adaff9d469b49b4c534532b0c20ebe43755006f2f022f3fc124027aab06dd7aec1851d5a0d292d52785d2ac5e128e7244458f84dbb9d9da10f2806561aa7b39a91c61095f2dc5560d5b7a88504cd1b4037d3c21e6c00361c1bba8ae554e8e1f083d14d0626e1db02bf865b87413a27a1e500a293d820d4974aacca22cd9f523b473336cc26c7c05af7c28d446dc3ebbc50a1a670a9b62b87ed7fce9d4c89df4fa615b236cfa7426296f66855c35999a12a2d2b7a2cece16ce8da8c32028e23c5f121dc664fa49080f5504f952d2cf43a6f0a78b9d0947413a757d26c25858f8f57218ac7a94f25988ef719624d8e8e12452318e07e800f05014037ce1a56d5fbe78590216f2eade9fe82662229366a72717d0469bd6aa56bff0b3929cb7e9058184496c8541876a162f4bb999bf7b959c3cab8b774d706fe8f3811feb4051d0dab1607ae8bdf68fdc63f1cd5af0c5853451f81e34b365ae5330caeafb7dd4859392143a9abc5ac4692d362f3a634ab55732fb44d4c4c02c120f567f17a7d47118c556057a8214ca8e00b826709cb9edf92bd82a8154c82c53d6bef3ca8a4d4f5f5df739c12ab97d75b898d52a169153bc8c52f4b3727545bd96f4d11e4dc084123a312b47538ae11191514c60a1b4550a3deb1b036f07bfaf558b8759246edea166543649ea012f0e224d44635e6c0f8920cb0c9b0c1a879c84535cb5648f4705dadaf3efba7a810c34b940b1ba53cbf5ad3da860b4d3cbfaf17a5d5f591227c7bac108881af391514742ea9a2b86818b3b04fa11ef5bb6bdc18e8edb9486a1b544dd64e944fbbffc79563874334ebf0806d0874acc5632cb4e775d27ea9a9876be1f8f067493e2331feae367bb30d7838adfb8e679c745cac2503d63995d5dbda3e48318c1f83e7bc29b28d1a47338a2b9090a2d9f22d5e529c2f67287e6c67d6f1d3fa13af88800a45d8fd47c40ec1e376102c91db1e9f5a9d85bb33fcdb2c5e48e99aeaa58162c7f326514b6ea1af9b745e307e35028407b22df9271faf876d3a37ef9a029f7aca8408a46a8292139c40934b30ff5270d107855b9ada457754220a50c825e5bc86a6560d97aefd052cf92431034333c96a2ef07fc926087587135f3e7652bbd2e3d922eb3ee7d7154afad7e2ac3b68d9e14dcb941992c25e59d804fb679b5bb9e8b284fd06dbafaa9c9ff799625d64e7c9e11902c6da24f323572c9cc3101cf77e2ca73e00febc3acf3ff51d117c03123aaf0be1614de2d4b12aeb56b2c5eb127546e6e2cd206f54b3d2f99b41c1c0c7524046a5eadc8c95f75ac1600409e35425b483cbf183d63b4ca7e4b5509f8f36dc94e87f6d9ccf96b63f283bde821c04b45c89597ddba27834b99ac914b5975f7de938b508f9523713a69b63ced6088f37f88f25fa7d567cb0f09570efabfe4f2cfb0215c0db7b944dbb39ad10e89b7d515d4ced51a359d225799a6c55ed8c86b26b69ff2a50de4f50181498ec453333c6a42655bd14f72137287106e2dff761e64bf01095dc920d6cb89425f022d6de8eb82ae57a99d34ae340270d834ac108e623bd6a97e4c9036cf281e149a7f5248cd2570cb6c144c9fae6637533fa2e84b6f8ab9a7d69f44ee1e4f9113572894f929f5a61bedc56d6cb8524874a95cce2dd84ad68d6b3c62d83c5efa06c56d5e4e38cf0840be48651855a13e9391df500baa323d37785139574486ddad97563b8a0fe7691d3471dfb0ed8d306d0d016121da825f720547bb6b8fbc441d19633f2fb5c7a7545665e86a75996cf500fdc69c294913e21767a4b006bdef00b2ba87d0db0779cb828175c553696ceb7e94b588dc833a501460521f859fc4f3085e699bedd1f5480223925f8a5e180d51008692a6326e01935db5b717dfcd63006ee9659153b48f5e308ef8fccbf7bd9a0dc60ea2c8f125d048d24323d8c64b4d61f19364e15911e3f0e451ac549f2eb57d6ffe8dedcae53515136e471a67a610def76cf793b7a9ad3451cbfa0e8c11d40f2deba068e0e58fae975f41e9cecd9875d12522ced8ff25f3c91b34d29015146995019bfc70ea89c6aa346b46cb2174338844f8cf0753ce1def77e14f8d2ddf4f06ae7920c7db2db03aae4d8119b07d319dbe0600e407d1cf01e12607c8f4ff60d0f0b6913c636c5ad5e75b2902c772d1d371865777206bc44a348eda5bd14347960d8261fd738a02a1abacf2d3ff070599ecdf8f7bc7e51c3422705e20c3f74a0a0c7c7998a3bb535668b02bca281bef4b59ff3bf75e8508f6a2174720f1953b8b34b095e92651ab7adfb7c55644e4c1c563c3284ec1d276b2c7d801a9fe964f938a6cd7a2df1f37ae32efa58ea145dd1ea2d62cc60753a1ed67f41ede3bbd32475c6e8a41341cc3dd0de9baaebbb68cf48e45f287fdf0216d5522588c7385120c43328310891f1a37973eabe0ea5eeee86d74fabc9c4fe3dff5132680e74109f242a050599372cbf8ff10494734810e420b667d8b049ec41aa95426658734f01871caff7a0ceaf7879a6c0f80552206798e6132f442139a14aca98d538b997f476cf20c84b302565b356b1b0d49b379fc1e69e91f41b3d31db00f7ca9c97640dacfc869184617de92ef3ea154318d5efa91d681aa88f0e093d2151a81b2ec2e89d2940f6a028980711bccce7eea1218bde4a193c10761228d5e31b320437cfbd987c4b55d36165d8c46d2b173e02e4e132732e65a8b293786c0372f474d1d13da5e70e9c8e6f93fa55e6614fed6382178db27677044c4ce69b650149bac11eebf4d7ec7a8bb3774bf8225b79f72aebc134e1b5231be476ecea779de5215bee3465b761824fe7870bde2aa6aa6c5e1624e8ca6a85fdeb56c79a7acc3dedb5761ec8e0b15acc0138df3a5aa200f40be66b14048c9e01f8b1f87d47ea9af8e301054fbcdb7671b3b47b876e1fca765ab39ea7d04fd338d3922772c543359d33824078daa4e4a31d589921b1d0343f8782a1a77f872bb6f689dc9daa547628260075af4649068b4ddee97f0119ab144b61b1c25938caa30b8a7becddc9abafb1b4cfc339e1a2ad5859daf0e76ec3b3bfb9ce9062f103a3e9e8e19402e0b88e78ecf913db4c1b7dff5fcaf69f29e9308d6f858de26237878fbeed8021ee46c31dda9a1f56338c0e6fcff293bfb6437badac1c58b6c23160afb90d6f93f6a59e8f55d199d82a3f36703f94709997b1b51f9e4170628b6232398b61149f0724c29a084f916daddde54637aae8d9b00cb5d7cdd9578d9388e740a5f5ad880fcd6e89f93a8aac3ebd54bb934ccdc96f8a500337c3caf8ba7680d950e70e41d70ec2ca8bc3ba1a2f8346bc2781084a4c1bae51f49ab5a2ec8e2155e737b3c29d4a87a27842882028df73172d627a99007f4a7f83e055a1f5d0b996108208b91abb65b88a88aae07a3ce5a4ce9d01087fde958dd49522d827cd74be8abc1ba9086d2d2f8009fc5066503fd1e6acd59be9e00574a55bdf95b1d7c76b9ca36f65f52ce61b93ce315ea86c0b7c97c7ab59cdd8936d5e8b60250e28050cb9849bfd080b415797229722dc244c0164b801380b7519a349263efe2d5a2eb65961f82fad5e4f5ce8f4c353afaf6f98e75bd4fbe9a41060ef7c991a6dc04e13c8d3b8bae60a59724cfe41c506ff156dfe1fe63bd7c329c4bc74058e39d12d156a5aa178041ef4d87418695486a0999bb38223a17a810d748d3198eefbd4a04727e0fad6d83ab092694f2a4c1ced2ec93d75a0ca6bb75aae20f557d5c6de63809bdb371167b232fe1eb6e54d5ebbf9e8b49acec9fb4cbecb4f4b5417a9f301f50850172f47d56e8e327b9b6ccf24d4b309f5e7fffc0540c41576492347bb3cc2c6c6f14dddabc029afff7d67142835c71f42ed1aada8ccf9abea0d6c1a6db14a742d9ec4ad86049a9de8f094aeb3680f9fa870f4608201c7c62cbabb6468f30ffaef7ec04b2275ec95748d4e5d9b0f99b6bdafb6f5a1c9f8c85143b043823e856c61f5c0455a6a7cfb24506b3cc1cc6dce2eab24a832c62c16ee01d1b996422d3cca8ebb2ad5072887fcdf6aa45170e5ac1a674b32bbbc706566f641775a4675f2d08f84ad2a4c83a927c2b4027565125b2e3d328a0a943b464bf8becfb1378caba5cde1e35305ebdc356dda003c7bad94489b428f1959c6502c149c0d3dc2221de6586c31f4e35d1b39d1bf8f7e1683b32ece3ffd7a3418497bacee8ad1ff6dd3925ab1ce44a8bda9d912326755660704603ffc3879897fe569525243e200c31c581d7bf0288ed67c98317405c2b09e40ab2f7a37241fe8fc38d0b6fd0c0c6a08f229e346a802c12f1f745cb91ca1dd64d467c5c76fced01d90ecfa1cbad1cdff043c91306a75fe997c340a00cd72dfc817d1ceb11a93fe5b8af28261358e228de9adac474594c84b55a33ae890b21e9bd7a5292b842d49889cde999946a44638797665f65cd38a2154cb98c881e7dbc2fa8635e6c836d6a382dbf24cde493bdf7e63f12d3230dec5d885b94692ec43738837c6a7736db3ca973bb5c1acbedfbeadb09e1062fad60a5f08d09e935169e8c939d53521accc5dfc5bdd2bfe2e18ffc2f76e4bc150cf2318c905b8dc9c429448533bc3a55ebf28ef5960a8b8dcda9f7f40f2a02c7465fa57f429c00aedfc20f108eeba737ab274ad26223635d52154f4784852034aa055da4f6b7c5a80508e1784b1d9cc5a508e355231ec3eef29b8f1b9c35773203d431c3d823401f57e1543ece7d8727f946bb601ee9f426c578c91cd44d6dc7a49905f14a4221c6af59ce325f990f00847f1b21f5ee4f01b9d7fd46247317fb658d8331c5f5dc850e43f4f2ea315aa6a700023d6dd3c4e062f8bc8be43a87e947af5eb67fce79604d72d82a6e84ddc947b2f6cc01e985b93ef87c389f804db84a40d688df70cfdd5fb4690132ab71089543c81cd54ac1de68d4c2d0481ac2a75ad008b6cc3e7d5b2df9497a0a70503175b2d7e231806636e07a3673c9fc56114194d4d31fe9dcd672b6fe79e72d0a832b9e667dfd58a01403b692e0c3511e5a90f921ce12928d220b56077008cecd4574c2871b8b6290e7e5ba016b4f344579508b862aabb28caec86683f2aaff2d3f41bd3c9788343076e5cc392906679961962d7e24d41cb2d4004d13b17f6d417bb91ff6ebbc01461e775020bbb28aa9a12bf0fe8d487faae1f5587dbc0c96f5db1d3ccaf315bd825ba23f6b9d90905a13d19d6823a4f40b88f8dd3f4273d8fa5e8d381eddd9cc33df8618d757709f7677268f39ee56544424fe075f18c9adab74b1b28eae3cf59add7f27764d676a57487a05f3b038ef7c2e72c650479326895330b88795797ba705c3da64e6cb714dcac3b7381c1f3ad82f93f0a6c28ec4858c1c5a5c2712ec28e1300ef898171afcd8c39aca867a2977a62ec71b4ab206fa43f7ef7d0036a20ce82faf0fb358d806c103d8b05a670478dca127cf1cdce229cd314e44ee6851bd8480b7a3ccd0fc50e05ced8564abfea2cbe0220e220324fdd62151f6262511d631653a3c9423770e352106854979350241b3ee017b3d03234a68447ceabb54f7b8bd443409ca688e4c859a862d87d985f70488e667ac9811ccbcfb1796fea859dc094100d4c9290db15307a3d81ecb106b98b429de6969afb8847e30e44e84c16429eb10d9b583893609499b34bb391dc9bec06aaf1ce6c269ba3d588deb93460c307fa655425170424982c50ebe44376311b072f2f12e38afbb33841f4c471c64099c37f2fcc70b0185c6897ffbc5d90f7b5b5508ee24baadf25f69e11f99125a04e03605931215951f511f88b35d7d64e1a2cca1acf8339fae0c40b1d9e856256ee58bd51cfd94b09346e75501678d504f8a0c43fa3f8a01660b5528afb004dd582ff966cebd89ac0fb436cacb9d56c291de88d4361e74ed5dda06510bc3b3350c07e97cf140eb6abba98154ad119c04b72c8bfa638df996c5e5ef1284ce7de45761a12933528d222cbcf23287018fb5e133d6ef86bb80cb4e63e4161f1f3fdeee60706608f5b4188d64b61272bd6320a66556ee9127d8f7c127669dc003f452d8647bc788ada6df60e07b57e16881fb5d682a0907748ccd85c18dcb24045cd1562b11528e2c172a884d83b6ca8a0eed15ea79d460c422c13756fd1a8d5297e002d1e703f0ac10a0591251a055ccf0f09498977ee8a30dcabf84e057a20a06441e955c58a2e6c5d18a524af4f36253beca3299fcd9107c0087718916f9cfa8528c889af62dccae9621ea3a1345dd3384269b1a047537dc5ca45c35d3f324de7a672604c4065c72a8f28ec4af5300978b9edb31e7ee1963352ae9ee85b8a851e501bdb7bcaf9a1af15a4c1409f3d2c8a4cf6d0d6300e97fa645f87afc441cf44ff494fd34436bf1ef3e486d7fe137f6badff72e89a9f0801c7d366824db6f07fa72a8ea23f2473c317c13de1d4e67d5e1c18765e8b4f079e2933914214fe179a3e3b568a7f8e17700d280d3f259b44f2c4118b7ed5d976bd1888c7ce68edf74fcf1056d66b2ca7e0aa02a0e74ef9e2e3bfa9aa8f1883ea387db61ffa4a6b00323a35c6d3fcfb038a827e45f3b97c17935123dc26590c650f7946f72a051b5cae6bd8f5058d4aaae2c2e501bcbd66ca1451ccb9b7abcb503793a720538c77ca17da6eacceb72e68ee11f43be8dd5f6bf31afc4082d6fbbe56e8fa8b5871ddb33960406e578ef9f3e2ecbf1d83bea1a5b890963404c57a4dc44b6dda273f19bee2ce7735bdad6f2cd80f60f6b9a53b822a7acaedabf3ce21616d5cc1a4397d09f33fc99a22afc64c2dad1b2161592bbb0a47fd25cc82bb767a6cb007e1f251d31b5f48228dfb8684e5208088d593d708d54832628d4366d888a1df0ebe89473a0d76e13d480adcdce6ea6defb21f50e4671cd1f7730342d9bd4889fd8a6ac05892020ce574baffb2d52551f45cd193bc769b6cc204bcede69d776a6e1f56008659f7f809fd7ebb1424bf74c6c923fbaaf3a4a373c2204a6f93a4cbd17ae8c9b5048ec8d5d876a94fa360bc98b881fcc12a8751b86a9009e15c039740a0d01df02d5a86413ddc751fb4ebfb8015b5768887f76ca8f18586f8e400989638992add12c88721b41158adb05782664538964566eb7d47384f64ab86537a649cfc47383a692f161960d44633c685f6dff99914433a819a8f3896de6d7ab450ec09b6f37a2527b4159fe570e446d40e94e3a1305bee5e0121d0a55d7492bd26fccb5c124e40e650008169263d2d06763b0d743d4f72cb43a83b8136114aedfa4330612563657cbbaf9e158880962c4cc6dbce007474a1d63f6646a25fdc45ca58f48b15efca6350a5be86982c6f1c56bf4324331feb270a061c1b915874ddb127f584f79dd5ed8969466303f6e089f3a0c5c601e27db2d4c117ab3e0b3304cad17918dcfcb852c56aef8eb13d387c09502a3170a1974aaabc6796433b3e728f98e5f6236370088733a0c3a8e8e1f4ac9b28e1c98134caad24aff23c25ad13c2420cba12d5145ab5592bda59e73bad2b59594c06f9a15d0b5c4d13880697d4b3ea3635d7bba7646b1c2a2f7620f8151a0dcc4e032d904e027b1fd01d89be9719d3f557fcafa735e241e07717371bdf3db5d17b10fca5f4707ef720276b92ed153ff533ed30db1713def2d529f239aaabf41308de3ee764d32191df3a164ebaa7cecfe117c38b5f695a73ee18414d6fbf3de84bdda874667f88dcb7152f7c7fcf154fc7e35fc3cf1b5cc6b9fd0f40e54d07adb1800e8246ee2cbc0dd218726d846324497630494b1ad52fe7c94e10075d794a7938f619585fd7b98eea8671a8c3780a7be8d88198b965726c00444454a3c5679f77987002ccaeeaa21fd085c9d2aac4855b7a6e3245e4a7b4eb737847b71a13af60b9d5aa26357198595d20859139ad1fb5f7d4dbed50b9f81f8f701b0bdcea4525007b96c6f4c946ba4c71a076e1800b68af324b6fff76b4dc9d1176262d2642ecc0bb781230ea81cfc200d06e4ec6f276de79107cda3419f16d8bc024cc8109d6464fc661c9e4cbc2271c89d076f998c4c0d9333cc9f605fab4e6264d4a4034c5d29e6da659a93e0e38926276e6407785bd5133f2d1cc94ad4a1f69019fe54227be0947aa973efe9432dd247f5e28540a0a72c53fb347c961d516fc8ce3ffd2bc44d6fec7af50fecc5da4f3a691892301a1d9e2ca2584403baae0b9113f97ae4bcf67c4bfcd2c4b28dfb70063c8f68f4fef4d0f4378cf59793ef294b93fdd9436d783db3439104162b18555bf83affe69f212580dfa436bc57f91081f1c4fcc845c98815dbdd985ec24f3649d747f8e5b585aae2ad8df8cb9f6162b4a155fa047c361aad7360214728318f272b4eceb97d1225d4622368aee26fe2503b51c4529dbf541de25cd7cd3a79fd76ed42c6af89707493e9e94e9b86b5b5b3295f97d80f912f4246a220ec7d1efdbae1d4f5ec955daec82bc5ae3442fcf96db7141390eb888e799632aec56024819c0e7f499bd823472d475eaa5f7e21ed3a354f9666e88cc12c61a277a33853a0ed6559716e586a12af138ec7dd8e4ebc1887484770cc921494b8e5fa555037c448f9485c83020a3399a46c4c86b97ad94e89d398c8a588768267bb48acc218952838f3d86c63597f6dbf58c61701c63b6f2204e5834c49eae066691007f75fcc3b186448e39431f16fcf7bf3f5ac92ce822c505e39ac5787b7406a1643ab8c2b7faee4b260e80331dcdc25901ca97a6db8f7e77bfa2693924647a06382eea25dc8c917d8703f3010ccca4a39a9d649665756bc27595f7145605672a8c81ffecceb87fe85fa30fd0a8e2cfebf10a2009cd8d1188bd9a77a87dbe33753c0f279f5110bed28a15ef36e8b6c0639b799e33ee5949fe97bc3c6a4693bb75bf6adf09972753ea90d4ce274fa162de66f16b151d89bb7a5ed83910324cbd3ea45986bccfc00e82db9b8e454186a3f53b23dff5417f37dfaaa0bcdf26e8fd128115a8165c0565f6a53afb1182d72a7dd0be6d765e612943bf2fec566c48b5f455b71ff35dfcfc89802bb3ed8ca6ace60528d34d151ba1ebc4dbb1818df110c0384dd6fd280455c6a6140ee41789073c4a78acfce9ff7f5f7b7104e7b0c57da57c4519692b0407c273ef04114a17e802192ef46af67b12ee72e8a2e0a64893dee225e25996dc8bb26bb043496a09f4b01028aa3ac57a9fc85e9c06298ecd4706b5adcd792a991478791673a6eb206c54bc1550b5f3fc706ffea99761f5a28085f84af9d5d4018181a891dbfd2c6eb730be1b0187b60f0c7cbde0059e0fae8d682937fb809ed5a3f3651b698afd16848789a12197b9b0f87d359ce97883c38d1df66b5b74b076b8a12e9011659b2cec061db7ba294cfb88bb354f898182eae6384e9276d60c538e5daccfaac4deb718598577d74a74b86d11951cf5c776020cb283d2dc0f4a288005af2cc7ffe3c26001c7540a91243e33a929604d2782f0768b464d230a638e4ef93faf0f76d583112b951349e99e495011807ca935940ac4617f338d6b9203a0110f42e3005739f82ae91d2009310f0664f66dac0aeada34a6030b3de272f8e9ac2d5bed9a8d790df3dd81581fb5d66876bb9393ac7db51e4bbf41550d8407afe4b722e83a5cc47e072a45f76fa6d2e8bb1ff709cc4e7443f725536170ffeb84ba3e172d17813e974cbeb5d9edfba447fa6e8d14312707076ba5ea34aa0a25daca8afb82adc61b07206e85b9cda1263d0546f9bfe86496596b0f0a502446960d9f9c659fc36ab32866fdd5966c8ba619b6b430596122b15207f77f742d2eb2ec091390fdf31b00b14684e63ee534395f8949d489f7c524122a2eb1867c1ef3a2b547157b3daad8797720ceeab117b9bacba9884b050ef5a02864112393367de1ce21cff34c6a6ae54404d0c191a58329a73d644c81e5a467766ff1e774d39564dbba66743a752b1f8bb2617ea60697bf704fc7bdef9be69ffe714f57a3588bba2c4dc0bc1b43402ada528ac75c9a4dd2ee05304ce908b6fe1698dca1c544887e56f3eaf83f44e2ed1b2cd430aa24586e4ccb7ff2e1ee23fdb1beb7d8cbb84fab5eb54f128265f55df7cb1dddc2d9bd5df89ac1910b49c9d56826a26a5574f1ee1a491ba94c5fbb819b3913a58f70fb147346205cb00639bb4c0de5cf38227f9dd1dc966b36e42daab6111186169d5d0550c77ac0be75b005c6112add83805fa39e6aa8b5153b4e63904451a31e12cb310ae8b7f1f8d7d8b37bdb7fb95680a70a807f11b3897aaa8c13fb74c56cb27185357965bade03ec7e65b973a6585ef7afbf00a6ed9644d08b12998d689cf5957f37a7e4905d829f02572823b6771ef1be5b00eb3a018713bb6fe30164bcfbf0b97c1e0fbefe58e2e6c91cce626dab1c442dd4d90f4ca3d3a95c2da99bf0e5d7aa2977ed5b9ff85759b09ba9d174f44f4f476939b91a4b746ca1879e7ae65aaa287416992fd1033983a5c11514db20a8c4f907a88c28980fb33db00c7f6f111ca2554ae5a8af4e1e0ed0041d9030d32581e74fdfe444e81e821e99d3bd5f00f560a87de15227b17e03e21f1ed5f43b55c26ad25274c6274f3f7b232606f88678fac8b6c5d4569e5e045263c4174e9d93424b24fe6b850923087221835834ce34a41987cc1d348b9f30d9734ca40a855a408c1d69367e248ecb80e9063b311193b77d53268bd375991c0d0f9a5f6d04c428e6dae8cb4bec93c87a7ef4107b0de0848f204cec82a3daa17d880eaac1ce6ea11e95e9a8d9b9414ee4df63fe23db415477634f173a0219a17e3990b0f38519fad1a850d996545f31c0af12198d11930b84b1f6dcd6b40bd0d3773d089ca58dbaade243eafbf40f95256773eece814efc2ee01cbb24f3e715b83da2e1922063a85a7b58e12848a9439de0c6925c313db50b99535b0cd35e27b762a3029188a1ae8773aa817f0b6e3369d41dbfabfd10d0496711db162ed76a8eb2286d695e40ace7d745a436dd5bd4729f631a10ff4cba0b2444df743c000ef6a3aa7e4cf36a9dfd2b3ef488fc1117b1d0278a50dba8c896dbfc9fe374b129363649072e2271a3764a5741d146fc18b56d580c07776c5a2ec3d350d55ae3cbada45a89654bbdd5f93c1dd8ac5e5352662b5ad647d80c37c01e1e63b8d003508db97a27f47285929b3f9f7eaed3e597e91f5c2b3af16ea5cd2cbebcf8ac5c5c4e9e36824c89bf4b691e3f3a0b89eccd4ec61c21539a43631cfe84f6fae1329ee41fc743a0c96aaec25709ab0ffa59ecd3d92621f7d727d0836b190515d7b2e7c82f0ab7c4f9a3698446e6422d8054899afb458b8f2e627594d593a5b242ba4241966db59449ed7a5206aff09b7be787973d93be7286f74f90f7c91d50fd4945f8d5ad75735e5ade28edc5811cd95e8b163a0b060d845ae2c4c440fb63d71ad5b90b26d28e618e1d4787667f4d3167f946d40aaee712f40973e95d69bf3c1c7847b66be7841f9b7f6fe49d38199081856ccdb7ed183011b1e2595d24816eb95971788d40f76853fa54e985095f4baf7d6a8ceeb4494154aa3535187391cb936a89303a75b8f760a3f6689c0463d383e4664a52ee7bfca6ca354a258f0dc3149979cdd297fde756f0abccf90d58b49ce50fc6e44e39d775b1314d9c7a373c5cdaf82cc07a3315821ca129743814244cde9981154805b472ba6b1127889be10db07f9d0a6fdc0e5435a08bf311fa04c9351787262de9e1d9dd5e6dfa22fc57135a7675f3064d65e61ea6b0f712e19d2ce00cbcff4672692fe461c46eae69b802b9f44d51b566f9afbf38334d44f107f576b9834cd9e1db2a0473f796e73e96bf87ead27d458ee3c738dd89c65fa049f5ad7133a61bfad96581bda36d9eee245763b71f9e9959f90043ac85c5af0c8d7b01444bfb1fca30cfbddbd49b6ba8bf20d1e521f0fae02c2a8612a32efd63d2c1839874795179ea90f1864afcae1114097f4ebf863e89d8e6b840bf2976a7835c0bd97a1ad85e57a818fb16ab39024cd65cc80f7de361b81f65b2ad89e30159828ab95378d849f547d78af39ead70d67740d7993e157982bd09645060d60824e8dd133132dd7e7614a41f46e815f753a6db49aeafe5bfd480a002a382d57d738032eb9e1386a9a099a9871fa4b3a0b41baccb8e462d101df413caf9af2ee91f007d2ca970f9839611077eab6458f0e4598a2a7708eea735ff4edad212130432488d87fdff8fc5948e63d37e794f45c4d9e8a434412c526bf49701d2b77ebd0f401c847845cde95f62f42a02b49a1261e61de0dac1b418d59dcd7fc23fbed76899320e6130bf4ee2980b6f0e65118e861dda0382e6a6c29c658d993620963fa3140121acfa02ef2ee5259a541dda8effd5ad3a43ec36989eef0ad35686cc86ade3e16087d9d078f7103a8199269aa3e335fa1e2721fd849ea08148a32f3e1ff5526ad22d4f64882987e517a430c0be9f07cba17145703a1662ed61621a324c3a07b713855b052411392f8fec3e9e155ea7303f8219dec2f2b4675d62cd7cbbd28dd638a92ea36d7ff7a58cebf4a80b3998007162dc7cca0cafc6979d5f43225e8ea0bb0f3d0ac3da43b27cf204f379c6e60adbd89d2323da391b867cf1d6090f8c0b50e1f26a91f8bc7a130d2ee77d4b76d2d8c347047cb73566d1ff01d73b7547a59e2df2270ee6cd0a5ebb8972dbcea91cc1d80afe564ce1ada9f124aa7b14bc2572cafcfb5bdb274e48200bdcd6d79b326422f865ccbf1e8195fa613996bb82237d3c817367c5102c03645c543c143429080b9358ed9e6362f6c7b53ea15b16eaca7162b13578de565867fd61f46524150549594de91f90f40c3645d836367c2e02de24aea8ec45dd710f55704f7925b7b6275df465ed8c878f547c88e6b00ae64f9a9051127b398c6c605beca64018acb865a6b89c99af7cd600541c4fcba5df041688b34e6e6924cc2157144a6fc16a4349ceb971e1d8492376cca64dd467821c6a531ad0cb91c83f5bdb77f4f709d603cb10ad834c64c47689ac6ebd6596e6cd9cf100683d88a5f699dd0d6643950eba38d446c5e3f0da26824a55ca9d2e58f83784a7a3bb5bc4db3290e90e4524fd6b5975fc27fc64cd8f0925dba512febf0f1fb640d914adee6058b1bb18af2179c8a5751e8b353b022eed1bf26203097c00ca4563ae892fd5105ddfc798e9ef6a125fd26ccd82556735c5f35c0bd8b167d2b6f3d4c56c7e8e3ee38107d77b497a04361f41613f05fa678de3a7994b700d018d55e004f9bd354fdab32fc3b7b951fb0b81bafb5bf2531346250038cba5845c7ec0625149a1f7feb99a3a3208f15f04123d3e01484e08e7176a56892ab56bdb172f13cac3cf228c3ba8c089bf093eb8d908905d1eb15f9f2314e5d80f854e154bb5dd9c009861b6f68de78f346ed3d9f593ca3fd5c050a259b80bd05d6832cced9005a568c46257cf391c27ae84ab323ea427562d9f3090792824502f73535c44595f32f72ae2330a7f388e6b78c9b0e6f999ca7b7f17b3665f1844e795827a240264b1d15cf490b2f6edc3d301c8d12c878a4f64cd859474785f931a0aa62024d29a3254bbac2f225ee597e4b47336f7d299980f39d142d2e38664ed7ceecc16f6e5529bf5b4acd992b6a74eeeae49273118713f0fce9363c78064a7eed8e5aad1f8da9e4837fe55520206af3085a56cb94e954017fce669583ca0664eff1fb05e457b21443bac7414b243ab1dc4695fc0fa26f85d741cdc8eb4eab16c5cb73172026b4c963af3bd7f10e6ab559ba59112be4c2b9d1a09291670a66222b18c3f406289be392cb3529b6ef3d2ac14df3164316c80bba671ba96e2ce6c3265c2f5ab3631d01fef1578f889e15ccab15fa0eac6bc2b9a252affc7dd642f680a4d9a30d39f1ae6f290cc9f68625e5f6f93f80ede52e70b07a175d78ebd42fdb992b644a5ae0d24a4963862408a27d21622d5ec34e8b57b44dc97a2b59a9b41efa4e770c0cb633b74f5a217452574cd51c956f0e3feff16d75cf6652960b5fbda86f544886b3b91bde0959b934f997080a62e80bd87df8c93029f0fd4475e6ca86191e233b5ac4bfb18ac8bbf7507819facdffbefa0769209d91debfd9aa21013680c645f60b9eadb64ae64a9d8fb51e8f06a65dcf860a3257b2e751787193e064d9e0da206026617a16c44147617bfafbcfb1e9d92083ffb721576fd8bc23e5aa0f4494c3c06a682b21a471b7b6aaa18a7a2ba80a11cb8dd5d17226a7cbdc91e9482ec298748963523ce68989d915dd97bc9750b9b81618b7f60d34fec4958d0a46b8fedabb2c03df72a7a06e59cf30036c8c521da547b289a29f3777c882daad8b0a43370192bcf475eb9f4ab484ca535b6a16e02f519e35fd7e171f60d1fb1e3e9bffed60ed9eb9c6e75f2505669a7a72b06642cc7f92ad960654de2b86d07aa7573c1b8b7526606b008028eb8d673f4e8b2d71cc119bed8b826533c5cb4a023e320775d6a8ca768302db6dbc2a7d4b9673ebc9180c927bf3e7aaf7de943486279847aa16775c25f1639f035c04d535497c07655ef1ed9eff1a44d99828a1772ace99524557d9a428b2e008a1fe0b91cc89d1965dd7855f78e1a1b715166ef691013d71c11a77678e268ab9bb0afd49e24a1d2d9e625bf4238ad43d0ef6ca2d1cbfc8e8a64a68b475ee7ecaf84737b1a282c66ed55b6435cd294c7db5fbef0ba8f536dba743db1615c8ebe53d7a9d1d6726498aa34d34d0fd282787a6992c399fb8738403dfcecbe48c5d4ab678ff60e40c6484a336640438d14f338bbf36242da5b901418ca7ef9871fb5bef6da6f1d2fc081636bcf75cf767fdfa14f9e42b3048000f54d0a768f5b1b396855b3b1d901a3247bf5b504bf2fccf09c635278c322ecd8b655cc3caf94eb5175451b1b451027fa34cc5b1bc09c5a64f5c225d2b426def426db975c99e903779d6d2fd070635d04760f77a442ac5dbdb9424485fec979c4557bde6958c82445fb498f842092dc0cbe8c6cec34ebfdc5cafdaf50c3ccd882a0532da70f394fe2aa17b32fc34bf9c181f93a511ace954c78471d17033761b9c4a516829a85f3d614c7989079941a1160f2cc4c17cb22167a643a63994e3947e9b6ba9b322eeaec793508253cd0a36d24080e00892c76f41b2becccc49908909f291a4129352a0f2a12740aae3b3ea598a6e51b636de2773cd33c160baeb6d6cb910175cd4ba29539a89636d7834b9445341341cb9791f1394f5e145165199807dc485980dc8c17e91de52375802017a280418ae2348ac51d5e8ea0dcec8f4e9d4dc4d5dba0381a4fce83a9b870e6e05e64eff5080791f47b8af7d15686acfa03ce7619106f35ecf7cb0ef2aea63febc1bffeeea631a4305850cdd91ef81751b01ef4e266946d711cae523509942d21d360849c48737461f4e097ba16d37faf07dfc65b9e1254405cd1c17beab5639bbd072585c0195075c5566519ce2f37433e8acd1b0604521568c083b3a6dfdb1eba299844c411d200a490415edb4e808e5c17b27f7507ff33c7b9b3526154fbe934c9a610ee40170f400b78402f897daaaa26273b2f58aa449d9a208f39325600941293169868413eac65c2c3c587284ad49b397fed594ff47a6030891d6559ad094355cc954a41ccf958fea44caf1e70379fd6a297f1332ecc6f9011b3d74be20a2bba5da1d4f3b92b4ca2702061de4a1affc67f3ab83e12a2ac3051d21b736c81919fb2e71c8f50b7a45c1b368b1fb2d49710830f946b6aa1828c7f1b5d82b9c4fa69d591e30e2f582655eef1aa79d507ba58123457b48013ea65fe0e7911f4faa3b6242ecadeaac36d15708179ad09b0f0ecb503eaed1c185c0905899add8d3c7b9465bf88e699fcd973b5e509188bccf4db51990409b08e0af1a74468a892d55d83ef6b71aed27fd60382fa0fee31e84c66232d528923e89110321adcf54e919678d3537c8e6037d73affb3b0115293dd7eec68336ec6951a37480db6a807e81c05c7f5c47d159d800f3e26ec0fdf5dc74acd9fff9f17032a2deca9e13194bb8617e6ac39fcbd9df7bfcdc3da58597b2853b2c58b27b1113bee3f147c85d8a1b0038c18af7efb4d4e18deb7556450d573fb0030151fc0bc948e527ad0afa89c2457ca8d118bb8ea4757d0390eb19a59e13607fc8912f7384b6fb1a8182b6f71265a09c5ec7248bf870f79f06a6ecb649cf2d1b28e925d18c2956aa3cbcc7c2abdb450fa122ce2f8650ac613bcdb22692abc074bc11105aa57612c92ba4400b3852c76d73d0e978c1b751dd608dbb025ec42ed0bb09c2619d30f69a237074dc21c9e6c9c7a01c0d100e70c226d373185538da106f7f288ef07ccac3f851b5a8b6cb4dc5a45ec05367b56395324b49672e1f79b3cdb8c097d6e23547dd982335399097911dfa355d28df2a6b0745437e955014c40ec9f3d72cca94860891eb6779b3a000348e54067f3e918d39a203b34037fda61bab2b7c39c158e953a9e971055edf9fb6670477f395160a15445b1f5489d3a4f75c03324d4894213925e72f319e62011e44b509bf19c7f07e0c06db0e4af658bfb8e170b4d177df09ffb752d1c346468efa3001e8320aedc54dd279b800321004b760bf40551660980af3db971cf87e7bac9b82285578c00eb26cb1dd2ce13c92c4394e77f33e7f82efc6aeb398066ce55e1fcec67be56ac83bd6c66539e15d8dc85bc284f11a0a9abda3148bc0ccda424c4484b096447a476ac51e0ac369c19427b224211abf537a8035a309da1b0438670636baa32a1196ca73bf7dd16952fb984089588b70f0ba66894e67dbd1ded1b4b6bc7c6665866a8edeb6bf2fb5463eecb1b67effc5da365406a6f32228bc7e44b56c8dd83c8dc2f23f14fd1b9d7ea77be671eca28b90f6a3b8b69190d33d51f47add5ed4f5a8d356456702d4ab8f999cdd2a5c99b7cd42e97ac7324529ed63acdc528fb3c29b7e2fb3649155fd555d08151a63c701f0acd19c0a5fc366abef8a342dbdc4695f971379a32a8287cb1543781f4d5f93afbd310e9a18edf15b14ddfa12a792eb7a00cebaefca89db36211150feb0dd8aaa9a7b6e3bdb5569ba0696a92ce3c5dfea60f3fb95be8271bec1890cebef047e23d1e66d3f0718a44dcd87f622ef0d94b215d3039a08c99b2640ccfb3cee0b605765642cd3b0c51f451da86767411f1fe2b1dc6c163ca8cd7748224536752b8ee18408622ac604f74a5fe5b442c01fe40097be5e4aa9d0d4a083ec874b596761c73c243c88b13ffc709e0a431a6e3a29c3ec779b31220323df27e68c1fa44c0511410214088f603032930eba185fb0454dd5f18e85e286f9e5d4b47d572d53ec3a7f91b147dbb40806398f9a912fbc47e782e31a93f4eadae789b8979271d7d56b7b7c312c19a6a3fbead34e09da0a73fba626b38a207ab39c966404aa68cb1f6c410216a0f6f50897903443e15d3e71061b8ea26a8ff92992b2cbfaadddb394b8fef5292cee9cdb3a78019355cdb493d6a5287be49e493a702e73e60b1a99e7fcedbb7431d41a6c79006307082f3db5820d02733303efaded051dbded7695e3f4c0ddf57e45d738a5ed4813cf4ca5154171bd242d8a7e2601fd799af32b5150c8f741ced11242c46a9295a9dbd26b8fa5f3c59bb8ce73296cd33be2ad90de0eff8d507184a850865cc25fbbae4cdcb5b4d0d4c0ae7ebcf1b3a0302e3d935df31d38b157481eb43e1917a7089e0e8b1d154e1b7fb2e8f03589305b7ab7dc8bdec9fa2565ab45d3b0e5cfde86c60d750174272d45a43f46327e4c5beeed0399ec1e04c0260b337fa3b44c40ea4f0c634990e4da735d60e7832661233d40b0a38131ac7125791c995d8a95c51ec70c2d59e8c3d2e6c3ae21a9105d7dd4c7102f158b704b15808a591b74b06a8bc17bfbbca031d1e0bcf1fb795e1ad3fce723b96de93dd47585852f7beba5a71f28743ed341586f7ef956f9a985bfe90f80731d5b515b834ed64dcb9b971b9a41633a43c16396a9d42d23f423444aa194d8bc3b4ecb8be6e0ad1e2379d5de3d4e05326d302c0befd0a82cc1dc7ad8867b91b71ad47e2c121b4966e803fb5064f9cbbd5e420fe775d3b0e5c365a70af8bd56f0b4b1747df5dd82f22a8c85b4980f556a6650cdbce7c0ab17d3c88ec16e0e3eaaceae347c2e9044631828c09035b666a28cf11d3b9eb1775f6cb4f2a4d3757207c65ee9e7cb61434530da43452bbcc12cb31b7df0e43dd1a590854165250a781613d7b3eada3970723ce55590f2bc80ff9b6fc92e615f08658ddeb72997251f2c8aa64f8a384a5fb2255bc893721e88b0f1b14427382f4900bf7fe8cae20921f15ab8dfa6b10932ef49ccc1bb7dbd7bb2df10171ff62ac917a5a67f8a102fd1bb99ee41c111fcc77f1f6851fd623ad860e7e86765ac90d073a1a903047f55def6a472d0e33416a83c520f3e968f6be61b05c88150addb3212e453c8d51bf340f5cead7064d3150a9a572388abb5d57a0dc52f402b85c0e6ddedeecbab6e38ded7c4405cfc3a34764e24acaef71a3a8a28d647698c47c048511b20f1b8e2df2c0b0b091ffaeaf48350a349ecca4866e3f98649f21cfc6483cb34a0c7f3349a148beb7d0b033e90d07ff6a6304c628a90a0e16a6c78d5eb4049dc67d3d926dbc442eadedde1995ae22db30ea5feb4a23efac1331f6b21df4ba1719e1af97e1632846be26e30272d8d2b2da1d67da1999e8ac9aa1eabc7d9d5dc2b1b9400be8082fef149fcd08c816b47235b8c5b4442f629042297dc93d98fdee60efc31d9f8fdd51ed206918c5e658d0a5e7cc49084f083c7a1a32e2f996d0235d2f732cd55b16d2cb68133da3b81d2480bd93c4ae0242487f8eb6c66da8d78c5b50b448831861eac307cae704e7a0784490626582d36d421e75df797269fb826a5f241b115cc91bb8da7189074e1ee3a75d9aea49f2509080495d5d6ebaaa1e04733a75ad674d3c67c410e2bb3b1819e51d382e3276ef89d02ce0d089e28e6df55426f9526abc9e21ec7e3369aeb5d74d606a2ffe799076f3b569e8976aa02a017ef72de2e1a4549b27842da5d5879b7e5abcbd67d52de57bc6a6d3c84f124b68b3591e26cffe8b0d8cce192d56d59603e0bbecf44616bebc7201d949cf560cd1382073368833ae62f86dc7a6f29b0f139e12ed1b50779146a82480d84bd7e838b8c46233ef2b530ba8fdf485147d1eb0a3c71fe598b60b0b85688558fe607c6f7d27f630ccadcfd990af0de6794b9fd1cc8e347dad1ee0bf28b1c850a2e516d99308488c74915ef541d3258686932ac03ce9a0e4883bf4ad5c9396af2ce31b73cbfbf42a8a63f4d46e2946fa83e0a37beae1d7ebd83e2e59a9c777760f69d541bdcab3e8d62699b2a7ec86abe8770f7fb6aa8ca47630d6d9043649314ffae9b6e8a42f3a2c300d4eb2f7a63583352bda0238b8cc271ec49c343edb9ba4273d7f5061eb38757d9cf0cea4c57fd9e93d05374f1f6e7764be8311ae34eed3f5ae7485e228967a3db8093e305c4d046d3456565506c7208a2f8c10e24218385b302c1ed376ac4074698a2101375a04b801b35cfeef6e5d39bfeabaeb9aefe7e52f2ba058be681ff20c5b25deb97cc96ff0f201096fb751451e184eca7136f8887c6f95f91275d6b069471d21c99e3abbde622ab5a63f86ca9b2d5b49ea7e2b1a0d0969e396910117f24641b492e34a90083ff8d932fac055f2c0875bc917168b4e5162da81ac552b1764e5b81237a0fa4cf8104253fff33515a1b83d4efefb04810a0a2b6bc9c4971f9b5d2a5cb98530035c6579203bd4f62732828ca18b40cc872d62656f284f0598509f23637c54806502194172d40dc80e75ca4ccf08340a53b822e33a506d9bf1d277836488fb42d6e36760a6bbd7c90ddaffa25ddecb25a00be290cb6f1e647e28522735e16bf91fecd9f4b114bc5a7e008c4896037e21b6c81b4b19d1053d1420bff257666b5b0fbe80e36beab835f2582de20c0a092f95dfad5c90b401f3945fa8726af5ef675cf8aca318e32697923252d20c08254458fd45db43965fcb8fff4cfd6112b940233418b5d33909b32e00f5dc9e732c953004f15d03f4fd0e60ab93f94b1e6fd432e62653960d82bcd6d057ee964fcd13f00f430b011504e0876fe806485909a28892f2626e302e1253a2f95b96cd9e8e6d15d9a15e99f1c8e7432e5da0ebe432abe5c39643ddcb2c08e253591e76190225cb3ff58bf9f6ea6ffba3c8fbad794b8a4db599abff06f5a2b81120f0bb1c119b84817576417ea7b295ad26ec15df86f92c97b4c185e61ad84a2be2814d859743190ee1f7456d0f21af80da95c69aa448e0c43171003eefce53551d5116951ec742a4eb8cb8d8a099bbbfd63a591c13e77ea56a508734d6aa426b0248810bbd237a7de9c9f712505c6b82a2f6b2d53e16ffb674263e4d55308decd9a647b09d33fdd21ee089d7c6a2e72b80d1d86b11a13ccce6cd92358ee213ef5a7e09ceae56cacba7f7606cf74e7521a99de01aaf8fb6068643bf3f7cf448c349a200159d6a837f89a3532028f23388b33d57f3d3e1b573e60eaa17188b6cba0345eed4420130d193a5583a96dadf240cb9557410d415853905722c24e100b6caab2796cfc087c5cb416b29d4a631e648915edf05602d3eac771569260cc2702b3f2921e1a9bf9fa919ba084d60abb535f5a7475acad71030f0313251347912c1c78659db0029d25d9ae20b6bec849e81ab605f7690dfec6c2eb5d558bfe5dd8f8f149ad6e173e09343af54245bc8e8018994b437a7b672e981102f3615d76cbf91f683375c73b4863d69560f6ec27689bcf4792baacd1453c6d85d042df458da272946eed2e8634b14841923eef9f7c535d7aec58e63ac32fe48aba7549d51ac278016b7e42f6f7178273f80fd7164e9d532277975a388fc6050e889632ee072a8643a26f316f8e7043b98e59f1b72eeb9b1ae08986fb79d2cb19b5544b8ada2f551302cbb8f8c02c3c0e6fa1a5e6739c0eff6a2da89e32ec38036c7914443ea4a4b3f5bed492d57b0a0b9bf52ac92ace8b477d7a15a5c5e0a8fdcf40390d9e2488ab29620c714263836fdd54555b16ea076e58cb92560cd7f2064670d714519879d98001abfc53d8058df57fde6ae8a35080adbf296b9ee8dadd6ff1fc2219267e197e0b79b4adebc301ba4401234322ea8b415fc18fe5854d063b956df9eabb4097e9ec76624935cc91dbd2e47bedcab5b6ab15530761de3cd102f41a2eb88761c95ce5ef5100f3e9df1a4a2b382808ed2de8cba78231549e054bf8f5368b8ebfde47fcce570872a4780ef8e00348fb5138a6f86aa22700b747942b88dfd79057c1862b0bb3f669388d2abfa3180f5fe89340b1cfee7de15d49ab8e3238f6748f3e6f1b8c65272f5ccb0d996a51ddf810d52c13e0e77ae5c1a12cf4b8e388d81294de72dd1ab96c76275b049b0555864c53c5b0fcd51404b86e37fc8a3ddb8d03f0d3907268ca4f10baf664ee40d42a6d766eb80913f32572c28512bf34766648a18abc86b11d780f1eb28b62a0bee07bb13be3014e94e44190fb179a6ad181c09cd454f24924d36d8c74df93f3e4041f02d89feeabfe63b2e3a516aee297b2064520b433b84485b67d0f5683a49fb0eb020c2f90409408618894dd8d521d2f2f5881ac5da68b78e856eb0df2c6f1068c7444947de64595bf31380ba576cb3067f7f5cb940d8f1600f2b3f25de2697ccb170086f8c12462787c848f8db1a6d470068948e7074f0e4faa925aaa7cce04250d5f7253368e6183582c795fdb9d125a6b6ece14b9a8a472f2b08fc935283eb34e74e6683b53fc1ee8032f1a5e1ef0f03d91cdbbd6165a4ef53dfb0b316e1eb6137ad23904d895eea9bbc07223e70f2575158954c42e6412128e19a3f1d8695831b6b3b83c91b6efa308c11876dc23af23659da6e25bd0f1700e72eb745753c8c4b030783cc98a1b3be182b78a9d56456d95d1069ca5e7c0bd3c3d3c1cb9ddf1b031c04e0dd0860784fa5007e060ed9ba657e095e330ac13e9d5a2c4006f8203d693b8d0250ccd482e5228ea0fd98762e012620b90d8f8abd63b24d1e1302631d2b57e74f8e9cc7e64869fc531061650bcf7b9dba1107bf945bb6599499e08ce099ddc70de6adc7c9b2022104374686aa26bbcc2b84a691b83cab8bcc8fc67de5d6a9ed101db4eef750c86f5c8976393b75751b092399b3422493e17ac98f2577e26cd9903453c88685583f6c4b226410212b783e8c9df12ac949768ca45a740d21be4a811f19da942e54ef058de5859f4a3a00478ed67b375321db91ff8d7801bdefc5e90ca8fd667995bdf86afb8f968c940855ea5c43e3a0a2556d591c595b95801a4f21dc4ac5dff143bf3d2cf63c6c12acc4c9d927aeb91fe68e4617ccd318b784566d8ccb54923955cbeb26a88c800eceafd3671f5fd4ffe7c66141c88976e07f0e5b079e9bfa420154ae569ac6a0d0d547da881d433bcd6ff36babd8f476362890365a41399d7abb730c76e37194c2f1e4510cc42776dc71c3bc025b5e357e1e1498c24c718222cc93cdf6b1e163f51bff4741e063ab41d9734cee900fbea9e6b9cefd2167ba75213404fba6a2ddaad1bb6eee66cc9ddc32e35a6ee83f1e2920a862ac22a24095a58bb168a1c5de6e4c562ca9df7e98be0dd43ba016478e70dd7d4a974560e3368d21da753c64f6b7ec2424c1bb0613353f08d5b93fe3ebb7328605ebcf194d28ae9ee597e3615713e42a084c268f03c85dcea501d58f58e9b21117f7e8ded0b3ffa2706c8d0006f96188516e11cced05794adc4629cf3d432456d75226ba5e4c1c16d8c338d80b29581ab320543491f8051f455e4b5927b2059e6b37614e39479ebb75b2d9c3aa25f7fe3a90c08f04bb6f7c9a57ffbd0e722a70800fd2fd31ad3704db93abe4cc8987e0879a91419ff7d83173334f2f3736f94be4b3e1564e7509561692a96a2b225508900603fb0aba15039a3c17d75dd4b10885d2d1b2dcbc7e16573eedb1aed236c61ad4b4a3fb46efdeb1d0f9a36f6cf7f8f7b67ead34adfb7f28e5e8b45b16ca9b729d5eb50a560fc911f80bb457dd4605b5891b471fb44c40ecc12e89775a3e190888a9989a2288d4df22f1d678a8d9d9f8293e895455a94b6fc856251da32dd44beaa836282a26e85286371d5328f5b685a3f5122466115f845cf00a2cdb6e2b31a1a258b36a321241140d1891cb69611fc8fbbfbc071bd323222978c9c8bf94153b3eb16a040fde8f66851abb813d96110d990025335db9e07a4eb4d302da04814405ece46b85b5aac3e40fdece584dde27d69229d68b0de41351deaf01809db36374a9e603a50850a13e503fce037f0d8bb3048849f468373ca2219b70272299d32e0681d8ebef200a215356fbac3510442306232d9d13430e75726ba849ceec60c407ec58e99cb461865e251e8b5e825dd87e791f5c57783e1b7bf6dc7e08f16e06479782fc7ea1bea2ce7ed490e247f8b1738bd4e17e79e29b389c80a1323ec22847b719d4ad6b843e0533d2ab505c5f052b43080ac00bd1aaafab6f9c7ca80b72055ef1b093e366ece2184a6f77f3152feb4ee727c38921187873fb03b9a17c0b221746e43c2a9cddf698ccd165ad82e8fbebf3f44202aaa53ea7d3c84d8be53dd82ee8ea6b6de190814c294aab9dd5d926baa12b2692b234181684013f65abbdcad7322f79f1bd403037ec255eb56578b734120a81b44ff2965d6b412c327e58052b2f169db75b37d6e901c376320124106c9109ec6ea396686b1260bfb4a8737c7f41f54daba29c5837c6b72ef5341bcec6aa448d00c2eff72c71667a3fce0673094abff50b9d374cb500cb765c0973812f1cceff7bf8f0b4ae8747e8e29df99579b3e97b2e79ae37ede9e07fe1a759c15dc8b27951647d1be6b40f51e4509cbd5ca64bdf07bfd01a53bbe75849063eac23f2f7774ac87bcbbca944b932d90da0b3b97b3d8c9516545c547b037eb4296b14ee19e3dbac1e130754eee8580a476230d514c12b944fc837f0be527543f474b3d4ea0a0f42f36997f9c79273e3a4bd0dcd106a836f533090a73f2168b384c2515766786f6cbacc04dcd46b64e288239835545ca057074561539fe3f890b9d637090f55ce92e452c031069cb454102350b9fa3cd4154535cfee175732f03efebc84a676cf30361eed16ee50526c5c78dbf582f78e7597ee6dcb4de1b53fd6af2a4e800f211e62cec45b4c0b3e527e9d4ec45cba6ebe27778cd5f238ff23bb18dbbedf4c5da65f2ebd8bdb3a237e29b95a0cbcd169124a409aa321c2388a496b333cdfea7ad1d8a2ba0820dbffd03d502863ca695d5a4bf12864a0b33185b61ccafa830193ab6c5b39fed44b3a67b35b8c74ff3efb230c0a778d0878d9e865dabc11293a0d26c11e357c48af054d077be1cbf1134c43b7dd2af42c654db13053809260c879ad073326b00f421183e5b3af564e7a7831ddf6249633baa7e6568fcf0e48c456c7f03da822cea1896693bdd010dc88f0bed0d49304cf33db1cfa78906db1950f271e449ce163a38282cd74dd70c5928d18c549441b0569d3c4692cd24e8497bc911b94f896110803ce4562a2a15b249f218c7452ed6c54a60cb9c08a2d64a7658e8b561405918f449801411965624efba28c0fb1174d330de8f939f242d6e711f71dfdc60c4b8f13c6743871bc4f020f6e4b3ff67c3929e90094184a64daec97c7533c99aafff1ce58e9756e94bec8cedf80446c019b0f35d869dc0b8dc7250d592b1644d2cccf33a152d39fb596e707ccb3d255a5a4f59722a96be1696a63e0cd2fe53a3e2d8a65978a3b8f272486a4b9337034d370ad505d859dd6e8c56420d7eeccf957d13fc44ffc7f227e95847833787b6f4278bdd6eaeaff8b8fcbe9258896ac353c55e6fff13d30d0f988a03e68418ad83e14d2c2ecafe2a75469997e1c476f54092b4d614c50a6e3ac1d172997326ec987778d95f32a8974d8676cab7ed375851539a2b61ab65a0483b6a9f635e6b901e6500def68ea9c2756b8c45c29b982f1660864b1d4473100d12eede6c489662263b2f3dac861e27c381fcd7842c246a31d1655d07ce73a3daa8f060461b63922d40191ce06f28d87f01236a1dcd7ad66416b6c377c297c005b50875cd66de9c8fe05f28f4af6803bcfea884438da57ba459b6871990b888ef1726b43f9fcda55ef40ce0df5fcf29a17e93056db7eef9d18a023803f4265c3fafbac4b85a132607d3ce45856f68cab41d3b197b06bb810c05226e1c7c2ab50b950783ea8df9afaad850aef4281c483a3bebee7d5e2205798579d7f189af2ec80819480d695b4252949e08530bf7a2cf83fef0f10fbe697b0db971a7f5ebb00410db0a7805da24ad22cceb6e3a9acdaafa1f7974a98e44512f305662397e65e32f6c91a6d5d96734baf27d4a9e5940e8816171156bfddb59057691120d1ce96ca08bd5fedff4bfcccabf3626c14171115bd0ce71f5f9d85f9b118456729d557ba8a5137066d241dcce67094a3c0c117bace2bbf53ac8da336b73a9e2fc66073b8d650913b5b9f02b287efbeedd2e7a6b8365deb37870d417d9f16b7ea9ba387372d2abadd0b59acb02be2914001510a5bcf11e75845cf3e33dad8f43debe0283e7b79dc1722ac1c9f0c3ac571bc32d4597af122ac3ee603719c302623e3ffb5a0e21039d1200488365d29e96fd5fe5707cea1acbc997a132e92ea2f03a5f2d5ced3128025bebe568d2833f978ac219f43c4bc929b8b2b91cdd96188b3cf52412c19b0a3579deaa8975f0c1c6cb920cd026c98f53bd90c8e3cc3696edf6b3568613acba848e0113383858d6697991e6f53fbcae743f34fde0c225e974bbe5793edd759279a24fa24856b8bbd7d37a18fa8d1b3539182f45b73484cf70e41159173ec7f565f2ccaf820e69b4a476aebbab55e50bd4d8602d7153a29de5427604af966ff0d111e0f76b0229251d844d4968e8504b1ea187e98a489e788f905ecd98f323dc10ddab338c8b860aae07c869da9f9c05e4cb40bf1c18b9fd302a527fb674898bf4f4b683add35fed5f6587bf43f34add142331d91e39f9daa6b5bd4db49896ac2008b4f90d2f71f93e2c26c467dc947fd269e9e3ad91e28d97048f8e73aabfb1a57fe5fc8a741f10e5c55c84cf57697044ba6424cdd6d9c314b5fb11242b6c2aab7980a1e5950cba846452cdf57ff68346189ffeb86e0bac28957ab1e55ce846eaa406fe66a5a9b42204f2e93ee4f51609a876be3a9271d2f1f76e77c224cdf22462c268036b034e4da59f7ae3fda9142b34fbc802834c9edb526dd79b364860364196e8edbe9f7e1cb3154db3e9c107f5b1e24efd4a30ef774fdfc51096f96ed33480f1b39fc1b824b7a3ca986c0884f9c696ae3cea4a6cc5b976556474576f2bdebf87f49202ded5d907ccd103e98f5af5f31b745dd5ff5a4b96d24fbf0eeb532f44603195793135d5708a1376852c179fec8b5b62067cdac930e7ef255485c6f087ec5cc74f5d110ec0f3a976f8ef654837730d649a987801428f79ab1b0b02206b91842f635e3ec50bb6db95890ff91590e39ce8bd7fd73f269099a53c2a889f4a619f260502616c744ebaf3673b7908d3c4021bd347dec45aab392a4a1b7973d45ab5db5b8d3b4783150f7561a0273f996cafe0508775e3438bea40aff68e80b0a5c0f255782805ac14207a282154c878168a4d2f9c2dab3037de63c86caa50d5d7d3ceed150f148e5178c9d21dbf9d7d1441a3c952e6e314f7654063c9cc900b288524b54c80429d4d4bacdad22dcb67faa537241e9baf14f4645ebfcb556965c6f8df47480410248da378fbd85f8ed2327f534f8d58083048b5c26d7e512f0576962897c6c362eea1224ae9b10f6993f68202f324c6d613b138e5e376a1be34d482d90b3792325ac2515e243688a2cd11e7035891033f27acdc59a6cb2d42ba4cd480cc5e4a4595f7f526cfc2b95e5b7ffd426ea1786ba8d21b6aaf8e6a8a938064768ae945cfb6713c76375bcd4da42adbc295799577144b3292d5319aa1ef8308aa098aa17f39ced28ce688c5aea5b387c378dd9ea1410f78138400dd052c31393a0f8bb67d627a08ff311247f40d7f3e62107a9dc5653c05633dc54f306e901ab697340b28b5a5f1254834f884dcb0a060228485d48c0cf0caf2c33ca70e4b811f242326d82d9605521423a2b7f349e7293fea0a62a443d02da32bb01a4c9cbdec602f0f1367c267f4e5055cdb8dd56fc5b29e9084b0d25c9181972af8852a3ee0992772634479786fc00d9c52ddbe315a511cb0960b1d2309ae50db6fbd634f14beaca6d265a35ad19c8eb5a75fb359fd3076a21179f2ffb82838b1c110345f8570452313b2375b1f80d830ad81610e613fa648d1c4d840ac290edc30e4240aa371ca273b6e6df48c2e2a2debb089747ea089025987828882ac9f1b7dba5e4ee7c6a9b683cbfd49f0428e68c161410a00d8290853de6c38e91eb9dcb0814c445e063c956331ed8ad300786bb670a9eaa0f62273d7d6a41de1a54744ff9d06f1a1654d5e2756b2c8766b56ea7a067db453202a0281c16f16ec4a35e85e79baed25c318def881baf3488c47c18e18bffa35a237c6122a4de1ba84e3f7206309f5eeb0d402378438cbe7d69f67736215f0f1b64570cd9dfa8da4d9ff5159e65cc5d750bd374f5b60c165262a308379ebb4415d409d353c7d507111289c317a1166084d851eee4d02d7f925d84095d8aa091336525a4bc33490e3be7df59a13095868e35e54c37e67014bc35a235496fd64716fa53f6dc42c6b3b73cf8688fac4656c6f50ce0bb3758531ffb9f1b0a7fa73c1ac75cb5b4cd87b38a789ee3e8b313b51878efa5631787090d3277c570f16eca3d470837372e5b2783f31033a1edb314c161cdff0183a5a5e9d98f3f736d60c95016a9cf39a4068b9b22f4d8c73b80c09369c4561c927a84792be612eb7942085d28800bb906137f5be954e93a6fddbf804dae87fba8b5e1d6b9b83a7dc2dd288ce175c6c0b84b2c61ba8faa63f802a6c234cff3c1a934f4f26ff87899bbe0ecee8d1a504f9ab289fb7da16c5183ba67b58672a12ae1bce43061f197cc12fd81c8a0fd22a247083579692d5f0ca8ed80d1bf1e2de0f0c700e479bd189d1f93282650893a2032fdf6ae7497614ae9830865f8f3d7151c8f043455ab94fa8888a3704cc16bc72e9c5c02360ea106e8136f2f219f086c6ed389ac91cf22bc650008f850428b10a0f196a18bcac7416a1b4e02fb80466f1e785e0df40622bc804bda477d8403d6cdb31f428c4357c6cd64fbd353e2bf0b34e1f6cd971a2d3b1799a5964f8b15017b8d1c0a50d9546d3fcd6af1604047f3ad89f2c09cfafc6272fe1e7ab5c63f910ddd38d563ae6596fb71c3944aea3bf12124855f8fa293b8aff385e233d43af7e90e2c6c10daa7bcfd34d79d50ae3b1cf9cbf2a388e383f7748f95a08867c487578bf9ff90d5edd5eaf9bf55dcd10049ba11b5e14acfc4f9845a760d48e86535d6b75e23f4af6e457baca52103a670a308f0dcf4c8c16b4b98d08cb6a93038a9deec3eb379ec51fdd70dcb810f61b95a885389e5d8f26e42fa71a1418ef08f514aeba5da222a13b2f1f8ce76b1fadd1ead59cda0ab2eda0456483fbfa221cd06f42b0ebc9e22ae4b325ab94d21b3f7fa8c50db00a69e27f463cba47e7a8c8607c913ac5b0bd25f779808b9449d31970ad58898b95633bca0ea40fa0af0c698903bf0a58a1719ff3344ad2c0e260a7e2198dbd889eed580649d18e89ffff26704b11fd4aab2d21cdaf7ea2675074a300819402a433aeaefde60ebf415e9459ae9210996635a0494c66f5e62a1d70afe12290490a675778751b5fd81647a4d40cf0ad9e3abdc8243419bba56537c53434a6c2433c059badfdbfe503a69dcda5890f73959029be66b9e7153015965e763efd2867ed116106ab5160abfe28d80dc03f8653ff04e43cf573898e159a30db5ff17363d80152bc74db2553ad832faa130b11b1b4b6d11f20f2c4b5d13fd203dd21230b0ad43d020c91087feb7017a89d9b2e0975db1007bf6e5f20f70346c410d9e38cb6b1c64cf59a778fe9d0369d46c636db1cdb706ee48bdeb3a7d107837d47c805042606745725857280d445f22d6e51003fc179cc26b9196518027f5169c6046402d78f433eba962e339f13f80f3ff8c10f8b3fa612ebed763d426219d92313b4ce31993b4ea3575b56007ac74fbe57548c0440695611ad07094f32f5f6a79d1e394b0c57c61d8c54832b03823321d060d088956a7383692aa09e5f9d4372a55081a645c0d48f6b7dfa4510dbc61761efdd8a493c74b745a673b6f727be43f60305ebb8c2e0230b585a645af269a243111a3dafc0cdaeac017c8b2aa4a5f1b2603d02de426d87230e93a68db2dd3585655f61f190482d63ef25d99eafddd702f3cb8d1237f2b494071100bd6e59d7391f1b0bdfe2b0b4c191d1996b49cc31c96f37acd70a07cca3c8042c9692b94fa1016254673b9a261032afeb0f867431ea316e3370edec1408dfc36bf22ed3a72a3f6fd094bb497f8a52e30d028d4487e70dcd2b78024db6737f66588d8a8b7d73519dadfaaeccb1a2def2aceb7a9b615795bc03767c6c30c972cce70f2bdee784c08c1b5da50c810eeafbd31f17d4ea3c80491651a782027acedec9395fbf4462d1041031e937f4931ee45ecfa10e1dcd2be90716b097d8b74a45587f67249f34686a39f5e19f68a61b6b88f0126523ed57f7c273964bea018f286ee4b82860deaba01b9b80c3564e3b2df4d3d02bef3e520a1bd8f24e64cefea5e124adecb6192aa6286623719d1c7e03df181c39f57e6142de5e57f96736276b8aa81227e930dd5adf402018cbc4b2a3e2c663d591bd9d6f048a6adb88053bf7c7e41e62e4197d8a978240a17f5ba5fba8a1dad08e699e4379ba0785784c8df82bbbb94497479802d87495b777dbbe1f7d2c98bc7263dbb8d02699827fe4aac1fb7fb887168586d5debf314d7ffc0594877119c4fc2dee8a288f54929fbe86bc1ef72ee1e6446ff9d597798010c5a45b9a45acf26a72e6510763b2815e6b2d38ec2e08f71889d04958805592bfc7168e6f98ab4e22c5334cfb35508c8c28fce12b4c33d8b5097a333d27527760c109e730eb24444316ba7454809051b46cf18af69ae2d43510e08f80f447e29e8b9fd338eba070b82b57238a5505a0953d26081d6aa0f7d73089f49323c49a300b0ba8970c8dc2fbc982c1a1fd39c05ebaffe0560735bbd88810663aabfea7eb390cda5817e2cd986fdb13cf640071a6793b6560643f63af5c73b05c5a2cd35dcce47979fb3ebdc75c8ca80b1c40c9af497c144baec4b06d5151c5af9853824936ec925b57da936df468db3e79a932d9eed99840f62dc3612f1dfb7d3d033773e76b17477550e3414dffc77fa8812dd8bceff91ee4d61b1e788cfbac83d92c1f441af5feca452108a21abc23747f3a45da729d64818f366b344acc26860e812aae600aaa3a1d6801889faf3d2ff3508e7d99ce146741dc44f47c205ad632e3872054a9914a524e29a3f51f29715e64432b89c0ec7f8bd2ca3caaa66f31a626c1a0472b302df16753a31f8f1e124baec50bee5214ad97757e128e4891a6b653cff1bc00ea51e92058d6cb4b20d999d461dfdd1764127b7c6eccd3e055f44024bc62564fd36a76a2e52b78183a069eb84fe83323c0708a4c7d811a8b020999f29e5660c1816d2ce597ced64b1dd48dbdefedd03b5a432c5b9e595abe41f27cc9afe30b1da2bf61fa5286944f11980b94bc1874797ffbfebb07ff206d373ccb99d14b2a620b0a505b84d8bbd4f10f9d8bea21ebd4a4152efd6ccb051eaaba5735d236d5c816983bda7fba5fbfe082c0d6d360a8b82d0d2509eedc257c7e547e8bbff6ee5ed60189b4a8b608c40b80bd60c6539273c1deefd26e90863fdd364b6b0ba314c8fb4249ee8e4e4c615d1df06576c01c24f050beaf9471d816a2f81d8c186a6e1ff65cf4e74b403557fbc6ea9c50e22fe9a9587ce4a047da2af9ad4b0c69594b571fca1101e5cb24f885562d9355d6b2784c16badf2bf21a621cf977bf179330f10ecff27af58968cd21eddc31dc2b0e72639b6d8319fbf8e85c8891871e1dbf984c165756a7fde5e10cf4b98de94c9e2ce78d02db6a1d1a9352bd5529ccc2884a86d10ae47209def90b5e610e01f72b9bee4cec735360086943617e7059d57f1b544b48ff2540284b0e37343ed07920a97917c0fadc9caae97f97b53a62cda2a719493574c5720838094658ca964bbd99979b23f49973d4bc4c818c117a4e834204ba6e6021da4b176e95006cbc52e5b3dec264bed29c7ccf821bb7ec636d0d6bfe3146f9ef871db1b9bc1a9b6e5509dde071fb1968dd8238eb5f07151631c2ea5de048642e42b1726c158e0ce8e419465374c562127fc94e86239ba000e1c4d030054f5597596d0bcd35eb4767a4b5fd915d7ab8302cbbb6f71099020ede93b36f429279cbc5cdce25f79f8896703c9fb7477a0a6fa8253b71b8094bea3baecb61136344742b9c1d66e075dccb9f7fbcaae1ec9316e1e5d592cd99ed001cf7cede2fd53472a5f1ae0b34a84317f848191131747ddc06632093ec46ac326c976fe01bfdfad5c9a954801316182ad46772b708277bc523448e0507c437e51880995af455ad776d4477de44e41854edc46b94e3ca6abe296dea5e1a45b148460ab03155aee9c52eef933d4f15019e0dc9da28f5959a18936b59fe6226be603bcd265ae04f104413cfc61ce123b7eedb28b5c5643d2ae79cc450ff28ce104a2bad0db584b3658dca4dc7ca564e2bae3d0cc586e9c44c53c6fdc1e5bfa59059fda90e6e5f16b077e8f2d646a8d65d0e0b9492cb581027519be9374ce02bcf90ec8e59e6a837dac101c4c84933181b54a0e85a70b7054722fd5247a60bedab90177ceb12645dd81fec124a7f0753b389254aa41da5071ce1ee110e2ad5378e499b93d684a2cae8d9b282ab4d2b5a748bb89f80bc539634fcc5ad4c4db674f2426bd0eee96bbde059b970afc8f4c249d6d57a4fdf056bb16fce9b02109934f47f8cd23321476cd863ee0b0241c60d7c50d50b25c7611dd15d01b1480898bcdd4a9ae4dc6ea40551ad4f6923367ec4250d76946b19f284cb205cc9ba5c7ef8ffa78e1ae108b86fcb2ddbdcd54b1ee0db51c32197de6ebbee5249558aa9a9c516410e090e388a3c09c73beb3cbd2df679363ef4c44833ce9aa1f4b795b4f79e6e69d820e930c1c3f8fed5ab3b0631faff826729acf01a9521d493def56b98d284f69af3d78af9689a10d4856efd6a4dced87815e7c3718c46fa89282fa297202887162661e7bf9e2933254d5fd2c74e03d30afce7c3892a29a7690b8b2f01ca19bb34ffd8f3ab2c1f004dab91b56d63ba52ecdd53d0eb6f8f2a755b732bf8d2ed82ada7fdc5d3c6629230ab0ae55055c9ebfe2940303c46f2d7927238e0db5613fc9dab014652c757bc185ba725e553c19338f464153d1ad7dfcd3459c4dff958229aa8224b3afb2dbf0beb8d6dc2e9b655dbfe05f7e025ff9e94df9056f0de3d17c522b78e5cea94dc93dc4f37daa9b82fc8a50d92fe3819656007928a109b647e5545a188512338f750b8fb00af1028f37df65a413dbe616b02bb2aba4693cf6d13b48dc12a80c8a7cca02d99f600258dbb9e78bccbd161c8966b96a3919b357707285f258bd9cff694f64b48ffa4f5413aed5b1ff789bb4be228287715385e3187265feaa2e19be0569038377e151a276dbb58f4f2a4de1544aec98ad658057e58206f1cfdac64e027f3dc51c45472e12828690528bc46232043bb09ec8a8885846df45543ed4253fd92553de34afde8c35447020bc359077cb871ec4964e77bded44eb4cb09f89a102d00672c8aee86ccedb20328e1332f326d600aa2fc6bdc7629c637fd67d001e1de69f46858853a146350df0a9252cba0d7bc0726c9fb1919536d262157fd338b5b687c662d577102ebc1164eff0aa8394e1f49253321d0318e3756543237346eb1741fd223430fca669f9f0047f6ef4de089fb676af552b21f5afba40da34e1214a19266d2f91bbda0535048d69ca36217c120872595b3e75714017d19ea50fc4232c3aa68d279d944d5d384c40e0f5e40060b679e9770453838a1e3c99f949cf7b838dda7d3df25b3ec2d3305771e82560464e7446de7ac4f3824636d6e9251958c780af489aa3afc69ad71af500c94bf3b6abf01d7809e90c27ccd98176f2661ca92e20fdfdb01bdb381a7eb3187d3e6234d9990cc8b14d8c956d2223b6e3f40a0a528b9a3ade2bff6b0585c4a956984a71d3efce1b8499b9775dedccd57bd1bf49f91e92247abdea86f1b16293fd90534390297ae44ecd0e7994959f81b06eeda8ff7bc50f2b5d9053d30abcf354ca5a1173504d70921edbaf1d388245ccb0deea3bf38e1319ab9f52dc2d3819c6f0dd4454692b2e5497333e464567f7c23be84ae847c0dbb7a441f049f9205349a775cf70456a5c7be5a065b911f13f6ee0493a857f83c390936f5ce8691dfefb001e7f24469194a1c9a3833a1e08b462807b48e85343e499585e90181303552ff2473246391790bad95f8cc210dd9436691ef666fe80d23b15f5f3df78f44a0ac9db8bdaf0498bf1b4f8767164ac25d57c7529f7efef9b207c62f79d3219d411f87100bf9d8712974c231f7b41498e04db93d40968334be047eeaec5099fd8f5c19d03b9c04e3240623d84135fdb48ec35cd79621553d0eabf15eae91eabdc4080584ce56421ce0568d245a6f2dc2759c7b4a376f8cfc5e9d59169e6d780b48d22f7a4438073c0bbf70ddba7e7d3538914228f561e0f868d83075e9a8faff7ecffbc60e68023a4e1f8b20db1e39807c1bc7261299bb482683cdb6f60de12bdfbaf75854ed6fda669ca4b8dce6981a1f12e73627d3fcd8087b4f928333e0e6dfd69ba7d4d778ebd1f7030044880146e0e5138454ec63fd04a395fe64bce25527fa6846d3d0962b2590723856004f2fe36a89af13689ad811c477a696ef6a536c8dc198e2e7d45d6fda8dc2f3a6fc5b42952725169e56b3e30dd68deb698ca09a6dfcac5f743d625baae723587fd4f363b96d805c0ac1ea1f9c3ccd8234739a4cd0c8839ab0bab17bd66920abf27b5d3d5a11e03eac56a3b08879689184d966aee553f9e54ad4e7f9332b47cdb2b368c002e62573b314f372385e1eb2e0b7d5897c7bb15722fc37ad997ed0cfee2814003b75d695f03878a9db9b15754514b97ff27fbc76f8a1128310876367f435151b7a9c552d3b8ed4a0d6e6bbec394557119bcb1fcc6b4fd3ee7eea844ee593d2823630a103a95eebace4bad85bc568ed6f0c4956c2badec23fb57e963c88ac0c6173770a5c310348b0c8bea4fe972716ad7669779d71c7291a713e96d72d305cd91a4521be51ada5aab0bae095d389c8b4a7a2c308968542c0843270fe3ccab8cc452b25b32ee737c76bc2c014db0d601faaeb123bf46f651280224a6e0b3dcbb16af1be4c480296f6a2c963a81df6890fa5ce54ae8b4a5569eaabe98dfd71fe2ca7ff1cbf2a607e96e1949d71e57283b08b1d340ff3cff957bfa21b06b813bcc22c2132534e57c7382e4c10b27eb2a99d968cfef436cf1387965e959d358a89b93988cb536cfa1a5f4ba692fa54e08d5e7890a6be5a35d0476b5acafaead65d8faae2ce67795585d54e5703e776a3ca13a00380f6b7ebd6c43387e2e02b9e13c9363f1e472eda7eacd1be07db74379ccc14b3e12e09a8a16f578dea8d9fc9e24dd25539bfb13769b6d9f11773af2da001f291d84b3b8c9bca2d10728ea69089e7035f6613704f7387eb557adbc457cb551ed9cc76382f99ef33362b104f3b26e7fb662feb439cb676573e05e02ced429f3a0ddd6bca84822142f96777a166f32aead578d2ab5d5bce3de17a31bf43bbd7711b68f7adb57ba6e16f8152a5352155a5b3b3386a3f48d8b7bb2561fffadc97a4e8063890281d52381f3905fd6ea3b2c876ec39b287b8b81f90dd5f3264ebc45fed59d7d40a2662731442bcf9052ee6cfd86996f5395ba1c74e412e6eb858f0e96fc59be202214ea0d579bd9b0d16e08ab6ac3b2905ec1a67381e6985126f58e703a1da500154226db9f1c0f557135027fc84bb3f7f864a4c53aec614aa956ac15132e552c1d033ea4c6250bdec609aaeb46634f9c2b2783e9e4d518ab4a37392ff93ac7f8df54cd57c9dfe73d50dc85ee65691643b1e02ff9fca8fa4929de1f2e2e130cd81af49096c668f08ee40cb655bb8ca7b3aeb84e31f0001ef3b331c11996540b87c2842f91dbe76c5547962020d4bf5afe5cd9b89d48441dcd54231d15e049be79e8aa14f2e57624ce3d7af38514a517a8b0c4d1c16e2112d02203daf5347efeb29de568b5f789c3849a9f6bb7a5b4eda85d4d4e89e802517ceab1f5e65f153159aebe887d6767fb39a5633baf6a1af3e801a020a61889cacd4227e39559ba692f9e89376ad70376e246778ee9a60735482229b744dcbab0bb409855b4973779c8794bd7dbe5f7bdefb77c569902eadbef33f967e81ed93158a5b1a852fe0f8c0ab928a2c075d6e8612645316b9ef30e979aad4fa5a62d43e08644e1297142ed5824617f1ee4546fed155467a707f6bddffad3e7848ebe316f3bd92b5fefd8a0b22333feaac3dae3a5ad12ddd28f1c9606ba1750b041e31e2524b96bd9947b1c3862dcf64ef6abc23425d8fd058144ee9eccdae9a0f1652a1ad7a157edb6f98faa27827e9c49a5c4971c5dc39930783a41775a6d68d97f5300b71e9aef197a71c8e690de570c4770a208c95a7f9f1635d8845bffa9b9def7b6ed3484b02b3ee08c283d955be562141730cf1fa9fce3051219784d5aea63fa698a4417d21305e9ae03ee51c591e686e25a6c0ee97719d82377e2f87054390c719df1b14bd9ecae1497e5f6e36e843b71b2646c6fb58be91a0b7f2b7c75c88402ce639297db0f70acc994f100a0f3e621b9dc8346d78fb9858d518cad8cd231731d1006c448146ef03d64a7e00ddf8b5329354812c21b5abce31034aeb1257c15905c5012915e98e17b7fd2a2894e1e17895c71311c741b904a74526bbb82ff75a6ececac2b27dd3e340e9f5526debff4813941a15587cf4bf6138a5c0d396add08a69973ef64ea63602f1b12525dcb79627de5bd3007c0232314ab644a9ef45ea375e903cb2689453c8f84c4b0658a1a02dce325a671faefbaf91ba581288958b9a157a9424424014ec8635e36d819fb56a30e8a3b2fb9dcc85296e9d22b563c4feaff29ef83a0194e6ed411fb747902344041e8f8d8f12405035cb6df8ca11a9a0c31ae3f9819331ff221fbad55abb6e2caa5d8e34946b6bc8ab8ad847e63f13f83b1032cfcb6fa7f9b3bc34b92ec8dc73e8d224dfc7a0d59b5331783915da0b81ee70fee4f991e37cb61babc542c26ec7f347f2fb248ea4acb58aa1c76fe6a5b59217d0931ecbeef31f905b8c98783ddfb169bb1e1c4a6af93a260c8927fc073975aef1c18b2609bc899dbafad8f516a06761b5cf063448ed82aa76a336e4036916b24cd5e0a4231537394d683c299bf1fd435525dff8f1f7628b5a4741970a912d5c36bc2b0035ad8c261e995bb48d6d73f5f72ea5b1fea1d6338c6f4f51fbc37e33cc6717cab7efa037c391e0795cd8ab4369c34a6bb4f22b23a9b0a424db4cf76a30c1bd894c042d9ebdd58bb1e921ea25db43de5ec10e134085787af2b2df6f26ad9bfc4ed624346c284a09c9d1baa43a8c270bf80ab49a66f62a59f9e4fc00d7e7b3aa8e1dee9e310ba8d1e6e12d8a3cbb1bc83655cde9ee7b1f5623107d527c8612a3ce8610a6ad46bbde6de76d721a30723bbb22309328a5e6932e8b36b53e3173558c53a2b35beeee47901023fffc9d6eb36d4e572bca5363249c7af5b1dc73db6216d844ca26c22158f7fc4622b0d441f1433df92878b5104280ce132ca9efa2333e7f223ce3d25896dcb99489f43bf006e904618ede1ecc183fa9535caf960d47d94a41168f50da893e597f29007ff01a68bebb0deffe19f1476a2bda37d139c39051badc338dd5024a49e8f7a1daa8611025110f043c856f58c958d9ed5baf008002f113a5c5152173a6c788a437c3fcb8bad5d0b75ba4f680193f0ec0791e33d372c7d999213e3c03af806ed3010ab9cf765f669f0e32e96c9ad140a2565fec26fc53277d22874d01e97e8522b29994f2b82aa4555a45cdf0c6fc1447e689bfc5ada01b9eed4058f1b0dbad406360822832e33a21ca99bd3333063353a2739a93d5900017e0d06dc860dc86f948d1f4d236549888efee0673cc951eea4a6734b0ceaa45f22b640843c976f2a02eaa9a049f34e41db6aac32378a103ed61a0a91ba30594ae0c2e9c7a14f02daeec2259e614429c0adb69c8ad9cc3b825adc1bca2b00750b5bc86388a0e0401d08817f5d24b17ed258604e02c81ec1b52f447753cba7118ba01aefd5bfe70e7c1688bcc97bc0caa57db81214ab6a3b40e33c0cad0de51e5d904b4c512ece0db8b243a61e01627f792ab23de45c9abe796e9080b0ea1ba3cc5a1fdb29dd363eac8c5a44863a2c6c552ca82bda4be16d8aeb3508ddcf41e6c19bb82e5ce4b0912de647c6b518d2ad53e75b92fe9e9f2fb6722f52a90733e468d05fb121d0be1df4a49ab0daef9f5c6bda04c8f5f9f384375e2fcb43af2a2a77cb7e4ad16dec8d721e7154f430100cdda5ded44df33b4796a0c8e3e973214d0756cb0156cc3553be59b0b70ebd64b2bca8ae244f264249b2504f156467647c2d708358ad89790aa91e58a96ab59676fa4a9c5bee9eed7110e8b77700779bc75e65c44499cb57822320080bf7352085a0eedf09ad7e8aae0242d32d9a7df91035c327436ff8e0bec9ba798e8e39dc5787e12333e9dc92cf6c24f84d582003fd69df4e2ce4f87d7458eb5a4a0f2646ee0e044bfb7fe1b9ada11707411716778c7470df14960a8618b655f452a6783a3ddd7e3f5af1d1564f310fe843ab07ade85e8bba17fd3a1b6bb459501fb4d0dbbf2399bc8cec74060528ac5657af720b87bb5af1b5b225ecfdc2751c573e3c38765d453ff1f709642be4abd717417cdcd10447fd373abdabfb28d42ae487f19f898db10c183dee75396ba7ef689a5fb676e355da7b8786f7e397ceeff608cb9fdd0e56fe8aaca1020959c618e2cd46b506251391082af89506c599848ed40d83d40b2d44b7297b0ee809abea43b1bb428468d28546a68d78ab213e783d06a0dd0aca0e0cf2a2a89a3b387138f4fa245ff939eea294df973b9253371de04dbd5f6a6c650f9e60672344072d611cdb4a4d0c81b01badf49559c3eb410c9e1dd18499ed6a921090ab65982e1e1227d4c3b4c810cce2c7600745d8becab5d7b638114ef0f8190f404000f30546c15fa634a885d0bb969e7d5a511c21f6af2f1262d0fe89ce141da7c4031d46727c856aeb0cd812424ce09f318aac7cef836a744676be740e159f417cf50c2384489659c09b35e970c56e791af7502d6ebe8b04ecef90fc9dfd1d2941d9350cb57bfdada45401c34d435b9f13fd90369cd711ec37025fdc9832ce58b251c3b75bc30bd76e1f81354a464d3c56a9f0af879dcceef2bc23941eeb6707db381df86d043a86d3edeb37d0d06ccf9edac421d2b9a455ae18840ae150c83f77972bbdf930ddb0efdb33c77168004b7e0646e32115a70d34cac0eb8ea6dd73a505d92d5d013386ea99150ce068c1e31809c3695e71c9f6ca7f9fb822e65a473ca5a6426b6f86b94dc2877b9087b7cd2b79a08495f2024d2cf56994486d8eb4948c3f2a5488e6337f017535c4c47223df5ed17ab42cd6a0469ea3c28b8d60ae5336b1794d1684cf7561cdbe8311a24e0d92a9f6a603dcc3ea7b7087de849dd2db3e30bea77e2ed1be1e20c5da58ba4b2e9c8f97c9b5a3e9806e7866e1a9b288b5d891dcd5b1c4c0c4b8c025d816846ae46685d47d1a69d4bef1848be2ebb0633319d14e2d84f7a34e085ef9178cc861847dd9c9eb0e0e05947c5592ae663256e38e10ee61a9b5daeef93d09b94a42f1091974438cc31214dfe138fc0e7304215a2f6c3d6ef97fbd8d0e0b551cef50ac6d358e947bed480b4d8e6722e991daf48f151d91deb30afd5420fa8eaa454e052f5016a7531c2b89a461b33d8df3aff8886fc17a4cdf445550d9aca5525248bc66dc217349262a58add8a31b71135c2d498682ad77c94d37b19965c8e8c26f49a5424bce34b1ed3ad6df50e5a08948d8cc01885088be3a7edee4634d88a08ca9aea5a604748eb75a2708745d51ad78cf64efe0c91bc4d508a1ce8adeff7e8a0dab3a5ec49a354770d6b8d0554a42c9a8a2badaeda069a464556e9e4e9cec609864619f58e4efe133f7b0806ac80b89304a23a967d74f944520d60815e3ff30a254c9fdbf9ae2fa247ffb7cff197171f1d45b14a7613c569c2fd87a4becae26763de5eddeaca940d54cdd84a1033b71563553804896c2d7833940f149c6f9f1fc3fb90e9c4007624db0d6196d8f7f18bc8015daa50771fa68201385740ec836e2aacbf3074d2cfabe2c69190c4467d74b864cfcfa76437fd9da1f3366cdfb64dce74c62ea8b2455415b740fecdb17ec4496044930006eaf5eb286a2e2c45ad55e2738147d663c48438e01b4a71b18bc5c7138090e5cdd4973e74211ed7e135c8beb7f345fc8d08a704812e47e243719f9cce2a93cfccf51633791350198be2d3f36d21c74f13b7297b0e0b2a2720f39360fda6c1507fe9d59f2ba468a0ccb4ac0c388806c73bd00bc83baac740ba4da4ece22741bceaf7136a0c463b2ccd073e39d884eea5e5c72c04be560b1a76f94edeef0ff40da2987447693407ea9575d898d311999652b8fc5b537a880b237fedd8f8dc08c617370ab6115041ed5497e3cdbecef0d0a9bbb37eea3e291cdfbb27f88dc118e2e2c421cc27871df1a38792b9e5e809489e9479b595fd08b53af3ab0b11651ba5d7ac50bd2f0f87668a3a02c70e86097d1f044b404e9b7e536694a681c8dbb7c114725eb3583cd94c95e828d25908b44ff2450d820854a2baede782621a6679b08a0100db453861424ea14938911a9de23f7744fb2e8b23ca749d1565c4910ad901624d18c5eb0c7bb9fd0d089162771892ace79e6a476956b0fa9df9e8c48ac04d74c6d9d7d1af9d6914956144e749f9bed28e45d90f2fac18910e92a199e7b35931919831fd3b018c57105448b60070f9a771cbc10a47a2cb37afe813e0ee8e68d9ee1de32881b30c862ecb246ab8f5d94a14bba56a5e2bc2856f505a24fafd9c32d6a22bb7821e63d50289fab91bb88886bcdc16f970f53dd573c1e775c08062583d0ef7245d0a61346d438ae2bf5e86c3f912db9dc62065d9d770aae7acf140c0be7c044ea3c3a837fa45753ea15700b990d7673daf8e3c91629d8515855b5d66359e624fc356bc72fef23ebd8febfb99311afa1f650c82b5886c1815a19117f7190a04a1a9680900386c73042c2e82344d04ca0a172e81c01727a6abbd53a25a4ab3c844842c6fe848fabe7eee3935de92524575c54b72b6e6d6aea39959beb0375743df37e7f41355023ef9c36a7de4bb55114621a2f97d504f60d6107419205b717c4c921b0a0959210b6f3fbfa83aba601574fa6f777406aafa17a8f8510494c74d32d59787f248ce96fd16bdb5d88f2384cadd08fe24bed78dadf8c1d944039cbb2bf8967d6680d35f2442b98f17449a81c567565fcb452723bd0fe405a014a45b93210a3d5ec38dcd5e68f59e1ce28306876aec0a3897b2e0b1175b6e800b153fcb1a4c578e691b1ded96d2744e48965c3ae94b535bb4fa5ef7d0aeaf42b869304506d0884bdfbe0bb034a1435fcc0ef6435dc991bde7b17f6459f61571db4134f2b37ed22f391afd66e110cdcd35408037261c54571da06996237486f5ce01a5a7e26b8173fccd2f921a46d3a432c68431944e342019be4e54543eaa4a2b7345d7bace209d756bc6a816263767f8af5dbe7ea4fb17b128cc11f7f46c6f6a9097387086ee762e68fde0919282aeb5dbf885c672a1c48e9ef460cd1abc32618fbe19de49bc296d643d72c10f816dafef2ab1b20ceefcde25e453c6445752e5d41b0ed674db11f3534857a5f66c54e329e996b3adf5511396d607299e6631889ea5ccd676a4f967000563b4628291432bf26480b6f2bfb1e2738f4e03fe87cb51b8f50b33469a8e9a5b499d790e935a4893d5ec49762a5e26f7e02bb10d73274e62662b41da3acf6634342f5e17bd7e465e46bf30dce84929295203a7c4c5edd38bcecdf006b17eb0dde895b544588c7013a47432cd88f066b007c4e65ad03fc9ea4df79d3965d6376ca73cce0aa4a52cbf58826e09d8e3272220ef1dd7cb472465df318e6019e67f6f7c714bfb4817d4e748bdf145826aba2c438aacce58b3d5f21e5403836f0113f14ad2653bb18dd7eb207e4ca3f5aa441549fa0049e857c61abf4bbad09025d0bff8a53c0857bd5715024b608608186f142809d8a83c6eb74ad2c0ed7383c2d4e24b49156791e3cf9a13f7bd8a7c0e30d166a21a7aa5acd888d5a7f80c677be7f1ff2914311d4e7c76aeb68e24034f9e83da24a75854b2de1fdef2d0ad8543b31347905bda58d748dab6a646188867388d6f5de6dc59ed59c682be3bd21758357919b2a33cd4bf59f2ee6359e917ab1291e8f520bce59e87da2275e4ae3ba64213f3e8262a2a0e7a451525d65172f8b401cf69c50eee1f0e44e9e35dcf1a49e4de34e0913ea0d98cfd5706e7ce9bfecfef8e70abea22d24</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码继续阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题目组</tag>
        <tag>毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5162」WD与积木</title>
    <url>/luogu-p5162-solution/</url>
    <content><![CDATA[<p>9102 年的第一篇 blog。</p>
<p><a href="https://www.luogu.org/problemnew/show/P5162">传送门</a></p>
<a id="more"></a>
<p>大概算是我用 NTT 切的第一道非模板题。</p>
<p>其实本来应该是<a href="http://codeforces.com/contest/438/problem/E">这道</a>。不过调不出来了弃了。</p>
<p>首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令 $F[i]$ 表示 $i$ 块积木所有堆放方案的层数和，$G[i]$ 表示 $i$ 块积木的堆放方案数。</p>
<p>首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个 $n^{2}$ 的方程：</p>
<script type="math/tex; mode=display">
G[n]=\sum\limits_{i=0}^{n}C_{n}^{i}G[n-i]</script><p>但是这样对吗？</p>
<p>代入 $n=0$ 我们发现</p>
<script type="math/tex; mode=display">
G[0]=C_{0}^{0}G[0]=G[0]</script><p><img src="https://i.loli.net/2019/01/02/5c2c7c9a52fe9.jpg" alt=""></p>
<p>注意到，这主要是因为 $C_{n}^{0}=1$ 导致的，因此我们强行将它定义成 $0$ 就好了。</p>
<p>那然后 $G[0]$ 应该等于几？</p>
<script type="math/tex; mode=display">
G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1</script><p>所以说 $G[0]=1$。</p>
<p>如果说您再往下算几项，您就会发现令 $G[0]=1$ 是一个正确的选择。</p>
<p>再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开</p>
<script type="math/tex; mode=display">
G[n]=n!\sum\limits_{i=0}^{n}\cfrac{1}{i!}\times\cfrac{G[n-i]}{(n-i)!}</script><p>定义</p>
<script type="math/tex; mode=display">
H[n]=\begin{cases}
&0&(n=0)\\
&\cfrac{1}{n!}\;\;&(n>1)
\end{cases}</script><script type="math/tex; mode=display">
G[n]=n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{G[n-i]}{(n-i)!}</script><p>注意到我们在运算时先除以了 $n-i$ 的阶乘，累加完之后又乘了一个 $n$ 的逆元。这就启示我们，如果我们定义</p>
<script type="math/tex; mode=display">
G^{\prime}[n]=\cfrac{G[n]}{n!}</script><p>就可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
G^{\prime}[n]&=\sum\limits_{i=0}^{n}H[i]\times G^{\prime}[n-i]\\
G^{\prime}&=G^{\prime}H+1
\end{aligned}</script><p>注意不要忘了 $+1$。因为很明显地 $G^{\prime}H[0]=0$，而 $G^{\prime}[0]=1$。</p>
<p>然后我们就有</p>
<script type="math/tex; mode=display">
G^{\prime}=\cfrac{1}{1-H}</script><p>然后接下来我们并不需要还原出 $G$。直接考虑 $F$，也就是层数和。</p>
<p>首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此</p>
<script type="math/tex; mode=display">
F[n]=G[n]+\sum\limits_{i=0}^{n}C_{n}^{i}F[n-i]</script><p>然后我们拆开组合数，引入上面的 $H$ 数组，并令 $F[0]=0$。至于为什么，留作习题自证（</p>
<script type="math/tex; mode=display">
\begin{aligned}
F[n]&=G[n]+n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{F[n-i]}{(n-i)!}\\
&=n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\
F^{\prime}[n]&=\cfrac{F[n]}{n!}\\
&=\sum\limits_{i=0}^{n}H[i]\times(F^{\prime}[n-i]+G^{\prime}[n-i])\\
F^{\prime}&=H(F^{\prime}+G^{\prime})
\end{aligned}</script><p>不过这次我们就不需要 $+1$ 了。</p>
<p>解上面的方程，我们得到</p>
<script type="math/tex; mode=display">
F^{\prime}=\cfrac{HG^{\prime}}{1-H}=\cfrac{G^{\prime}}{(1-H)^{2}}</script><p>然后我们总结一下</p>
<script type="math/tex; mode=display">
H[n]=\begin{cases}
&0&(n=0)\\
&\cfrac{1}{n!}\;\;&(n>1)
\end{cases}</script><script type="math/tex; mode=display">
G^{\prime}=\cfrac{1}{1-H}</script><script type="math/tex; mode=display">
F^{\prime}=\cfrac{G^{\prime}}{(1-H)^{2}}</script><p>最后的答案，也就是 $n$ 块积木的期望层数，就是 $\cfrac{F[n]}{G[n]}$。然后不难发现 $\cfrac{F^{\prime}[n]}{G^{\prime}[n]}=\cfrac{F[n]}{G[n]}$。</p>
<p>我就是不贴代码（</p>
<p><del>反正会的应该都能写出来了吧（</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「AHOI2017/HNOI2017」礼物</title>
    <url>/luogu-p3723-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3723">传送门</a></p>
<a id="more"></a>
<p>首先我们要有一个简单粗暴的暴力。</p>
<script type="math/tex; mode=display">
\min\limits_{x=0}^{n-1}\min\limits_{c_{1}=0,c_{2}=0}^{m}\sum\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\%n}-c_{2})^{2}</script><p>因为我们关心的只是两个数的差的平方，我们完全可以将 $c_{1}$ 和 $c_{2}$ 这两个非负整数合并成一个整数 $c$。</p>
<script type="math/tex; mode=display">
\min\limits_{x=0}^{n-1}\min\limits_{c=-m}^{m}\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}</script><p>我们仔细观察一下那个 $\Sigma$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}\\
=&\sum\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\%n}+2cA_{i}-2cB_{(i+x)\%n})\\
=&\sum\limits_{i=0}^{n-1}A_{i}^{2}+\sum\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\sum\limits_{i=0}^{n-1}A_{i}-\sum\limits_{i=0}^{n-1}B_{i})-2\sum\limits_{i=0}^{n-1}A_{i}B_{(i+x)\%n}
\end{aligned}</script><p>首先 $\Sigma A_{i}^{2}$ 和 $\Sigma B_{i}^{2}$ 可以看成是常数项。</p>
<p>$nc^{2}+2c(\Sigma A_{i}-\Sigma B_{i})$ 可以看成是一个关于 $c$ 的二次函数，令 $k=(\Sigma A_{i}-\Sigma B_{i})$，我们知道它在 $c=-\cfrac{k}{n}$ 处取得最小值。但是根据题意，$c$ 应当是一个整数，因此我们需要将 $c=\lfloor -\cfrac{k}{n}\rfloor$ 和 $c=\lceil -\cfrac{k}{n}\rceil$ 两者都代入原式，然后取较小值。</p>
<p>然后我们想要求出 $\Sigma A_{i}B_{(i+x)\%n}$ 的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。</p>
<script type="math/tex; mode=display">
\sum\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\sum\limits_{i=0}^{x-1}A_{i-x+n}B_{i}</script><p>然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。</p>
<p>然后一想，我们可以倒过来搞啊。</p>
<p>定义 $F^{R}(x)$ 是将 $F(x)$ 的系数数组翻转过来得到的新多项式。于是我们可以将上式写成</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\sum\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\
=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}
\end{aligned}</script><p>然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当 $x=0$ 的时候就只有 $(AB^{R})_{n-1}$ 一项。</p>
<p>以下是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 131072</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans,k,mx;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],C[maxn+<span class="number">1</span>],D[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">         <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">             res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">         x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">         y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                 re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                 F[j]=(x+y)%mod;</span><br><span class="line">                 F[j+p]=(x-y+mod)%mod;</span><br><span class="line">             &#125;</span><br><span class="line">     re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">         cltstream::read(A[i]);</span><br><span class="line">         ans+=A[i]*A[i];</span><br><span class="line">         k+=A[i];</span><br><span class="line">         C[n<span class="number">-1</span>-i]=A[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">         cltstream::read(B[i]);</span><br><span class="line">         ans+=B[i]*B[i];</span><br><span class="line">         k-=B[i];</span><br><span class="line">         D[n<span class="number">-1</span>-i]=B[i];</span><br><span class="line">     &#125;</span><br><span class="line">     ans+=min(n*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n),n*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n));</span><br><span class="line">     unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">     unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">             unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">     <span class="keyword">for</span>(m=<span class="number">1</span>;m&lt;n;m&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     m&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">         rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(m&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">     NTT(A,m,<span class="number">0</span>);</span><br><span class="line">     NTT(B,m,<span class="number">0</span>);</span><br><span class="line">     NTT(C,m,<span class="number">0</span>);</span><br><span class="line">     NTT(D,m,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">         A[i]=<span class="number">1L</span>L*A[i]*D[i]%mod;</span><br><span class="line">         B[i]=<span class="number">1L</span>L*B[i]*C[i]%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     NTT(A,m,<span class="number">1</span>);</span><br><span class="line">     NTT(B,m,<span class="number">1</span>);</span><br><span class="line">     mx=A[n<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">         mx=max(mx,A[n<span class="number">-1</span>-i]+B[i<span class="number">-1</span>]);</span><br><span class="line">     cltstream::write(ans-=<span class="number">2</span>*mx);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>NTT</tag>
        <tag>AHOI</tag>
        <tag>HNOI</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>「HEOI2012」采花</title>
    <url>/luogu-p4113-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4113">传送门</a></p>
<p><a href="https://dftyem.github.io/2019/01/07/HEOI2012- 采花 /">Taduro 的题解</a></p>
<p>sto <strong>Taduro</strong> orz</p>
<a id="more"></a>
<p>首先，读完题一定有人要跳出来喊「莫队！」。</p>
<p><del>莫队！</del></p>
<p>然后再一看数据范围</p>
<blockquote>
<p>对于 $100\%$ 的数据，$1\leqslant c\leqslant n,m\leqslant 2\times 10^{6}$。</p>
</blockquote>
<p><del>笑容逐渐消失。</del></p>
<p>然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了<del>，树状数组什么时候有这种操作了</del>。</p>
<p>首先这个样例比较菜，我们手造一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 6 2 4 2 3 6 2</span><br></pre></td></tr></table></figure>
<p>首先我们维护一个 <code>nxt</code> 数组，表示当前颜色下一次出现的位置，不存在的话就是 $0$。上面的样例对应的 <code>nxt</code> 差不多长这样：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>nxt[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$8$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<p>然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在 $1$。</p>
<p>然后我们还需要一个数组 <code>ans</code>，对于每一种颜色，我们令<strong>其在指针所在位置及其之后的部分中第二次出现的位置</strong>的 <code>ans</code> 为 $1$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<p>因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。</p>
<p>不难发现，此时 $\sum_{i=1}^{x}ans[i]$ 就是询问 <code>1 x</code> 的答案。</p>
<p>需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的 <code>ans</code> 置为 $0$。同理，第三次就变成了第二次，因此我们需要将其置为 $1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。</p>
<p>这个时候 <code>nxt</code> 数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。</p>
<p>让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$\underline{1}$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$\underline{2}$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$\underline{3}$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">${\color{red}6}$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">${\color{red}6}$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">${\color{red}0}$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$\underline{4}$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">${\color{red}2}$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">${\color{red}2}$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">${\color{red}2}$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">${\color{red}0}$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">${\color{red}1}$</td>
</tr>
</tbody>
</table>
</div>
<p>对于一次询问 <code>l r</code>，我们将指针移动到 <code>l</code> 这个位置之后查询 $\sum_{i=l}^{r}ans[i]$ 即可。</p>
<p>代码就不贴了<del>，其实我还没写（</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>树状数组</tag>
        <tag>分块</tag>
        <tag>HEOI</tag>
        <tag>2012</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>类欧几里得算法学习笔记</title>
    <url>/similar-euclid-algorithm-learning-notes/</url>
    <content><![CDATA[<p>其实我也不知道这个算法的英文名是啥（</p>
<p>我就 yy 出来一个「Similar Euclid Algorithm」（</p>
<a id="more"></a>
<p>给你六个非负整数 $n,a,b,c,k_{1},k_{2}$，你需要求出</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}i^{k_{1}}\lfloor\cfrac{ai+b}{c}\rfloor^{k_{2}}\pmod{1000000007}</script><p>$n,a,b,c\leqslant 10^{9}$，$k_{1}+k_{2}\leqslant 10$。</p>
<p><img src="https://i.loli.net/2019/01/10/5c36dbda14c92.jpg" alt=""></p>
<p>太难了，告辞（</p>
<p>所以我们现在来研究简单一点的。</p>
<p>给你四个非负整数 $n,a,b,c$，你需要求出</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\
g(n,a,b,c)&\equiv\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\
h(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\pmod{998244353}
\end{aligned}</script><p>$n,a,b,c\leqslant 10^{9}$，$10^{5}$ 组询问。</p>
<p><a href="https://www.luogu.org/problemnew/show/P5170">传送门</a></p>
<p>于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。</p>
<p>首先考虑 $f(n,a,b,c)$，假设 $a\geqslant c\vee b\geqslant c$</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)\\
&=\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\\
&=f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor
\end{aligned}</script><p>也就是说，我们只需要重点关注 $a\lt c\wedge b\lt c$ 时的情况即可。我们令 $m=\lfloor\cfrac{an+b}{c}\rfloor$，然后继续往下推</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\sum_{j=1}^{m}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\leqslant ai+b\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\geqslant cj+c-b\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\geqslant\cfrac{cj+c-b}{a}\right]\\
\end{aligned}</script><p>然后我们发现，我们可能需要在 $\cfrac{cj+c-b}{a}$ 周围来一个上取整，然而上取整并没有什么比较好的性质。</p>
<p>考虑转换一下思路。既然 $cj+c\leqslant ai+b$，我们就有 $cj+c\lt ai+b+1$，然后再往下</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n,a,b,c)&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\lt ai+b+1\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\gt cj+c-b-1\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]\\
&=\sum_{j=0}^{m-1}\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\
&=mn-\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\
&=mn-f(m-1,c,c-b-1,a)
\end{aligned}</script><p>然后我们看到，这个函数它递归了！</p>
<p>注意到 $(a,b,c)$ 变成了 $(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归 $\log a$ 次，时间复杂度就是 $O(\log a)$ 了。</p>
<p>然后考虑 $g(n,a,b,c)$。</p>
<p>$a\geqslant c\vee b\geqslant c$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\left(i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i^{2}\lfloor\cfrac{a}{c}\rfloor+i\lfloor\cfrac{b}{c}\rfloor\right)\\
&=\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\\
&=g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor
\end{aligned}</script><p>$a\lt c\wedge b\lt c$，当然 $m$ 还是 $\lfloor\cfrac{an+b}{c}\rfloor$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\sum_{j=1}^{m}i\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}i\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]
\end{aligned}</script><p>我们可以把上面这个式子理解成 $\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor$ 且 $\leqslant n$ 的所有自然数之和，于是差分一下我们得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(n,a,b,c)&=\sum_{j=0}^{m-1}\left(\cfrac{n(n+1)}{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\
&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\
&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)
\end{aligned}</script><p>我们看到这个函数调用了 $h(n,a,b,c)$，我们接下来就来研究一下这个函数。</p>
<p>$a\geqslant c\vee b\geqslant c$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\
&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)^{2}\\
&=\sum_{i=0}^{n}\left(
\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}
+i^{2}\lfloor\cfrac{a}{c}\rfloor^{2}
+\lfloor\cfrac{b}{c}\rfloor^{2}
+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+2\lfloor\cfrac{b}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor
\right)\\
&=
\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}
+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}
+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}\\&
+2\lfloor\cfrac{a}{c}\rfloor\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+2\lfloor\cfrac{b}{c}\rfloor\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor
\\
&=
h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&
+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}
+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}
+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor
\end{aligned}</script><p>您绝对想象不到上面这一坨子东西的 $\TeX$ 源码长什么样（</p>
<p>$a\lt c\wedge b\lt c$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\
&=\sum_{i=0}^{n}\sum_{j=1}^{m^{2}}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor^{2}\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[c^{2}j+c^{2}\lt a^{2}i^{2}+2abi+b^{2}+1\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[i\gt\sqrt{\lfloor\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\rfloor}\right]
\end{aligned}</script><p><img src="https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg" alt=""></p>
<p>然后我们发现推不下去了。</p>
<p>不过办法总是有的。首先我们有一个看起来没啥用的式子</p>
<script type="math/tex; mode=display">
x^{2}=2\sum_{i=1}^{n}i-x</script><p>套进去</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\
&=\sum_{i=0}^{n}\left(2\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\lfloor\cfrac{ai+b}{c}\rfloor\right)\\
&=2\sum_{i=0}^{n}\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\
&=2\sum_{j=1}^{m}j\sum_{i=0}^{n}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]-f(n,a,b,c)\\
&=2\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^{n}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]-f(n,a,b,c)\\
&=2\sum_{j=0}^{m-1}(j+1)\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)-f(n,a,b,c)\\
&=m(m+1)n-2\sum_{j=0}^{m-1}j\lfloor\cfrac{cj+c-b-1}{a}\rfloor-2\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor-f(n,a,b,c)\\
&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\
\end{aligned}</script><p>然后我们看到它奇迹般地递归了！</p>
<p>我们来总结一下。</p>
<script type="math/tex; mode=display">
f(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}
&f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\
&mn-f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)
\end{cases}</script><script type="math/tex; mode=display">
g(n,a,b,c)=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}
&g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\
&\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)
\end{cases}</script><script type="math/tex; mode=display">
h(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}=\begin{cases}
&h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&
+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}
+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}
+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\;\;
&(a\geqslant c\vee b\geqslant c)\\
&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\lt c\wedge b\lt c)
\end{cases}</script><p>但是还有一个细节，如果说 $n=0$ 或 $a=0$，我们需要直接特判，大概像这样：</p>
<script type="math/tex; mode=display">
f(n,a,b,c)=\begin{cases}
&\lfloor\cfrac{b}{c}\rfloor\;\;&(n=0)\\
&(n+1)\lfloor\cfrac{b}{c}\rfloor&(a=0)
\end{cases}</script><script type="math/tex; mode=display">
g(n,a,b,c)=\begin{cases}
&0\;\;&(n=0)\\
&\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor&(a=0)
\end{cases}</script><script type="math/tex; mode=display">
h(n,a,b,c)=\begin{cases}
&\lfloor\cfrac{b}{c}\rfloor^{2}&(n=0)\\
&(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}&(a=0)
\end{cases}</script><p>另外写的时候注意三个函数值要套在结构体里一起算，不然还是会 T。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,a,b,c,n,I2=<span class="number">499122177</span>,I6=<span class="number">166374059</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> f,g,h;</span><br><span class="line"></span><br><span class="line">     Query(re <span class="keyword">int</span> _f,re <span class="keyword">int</span> _g,re <span class="keyword">int</span> _h)&#123;</span><br><span class="line">         f=_f;</span><br><span class="line">         g=_g;</span><br><span class="line">         h=_h;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Query <span class="title">query</span><span class="params">(re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">         b/=c;</span><br><span class="line">         <span class="keyword">return</span> Query(b,<span class="number">0</span>,<span class="number">1L</span>L*b*b%mod);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(!a)&#123;</span><br><span class="line">         b/=c;</span><br><span class="line">         <span class="keyword">return</span> Query(<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod,<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod,<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">         re Query res=query(a%c,b%c,c,n);</span><br><span class="line">         a/=c,</span><br><span class="line">         b/=c;</span><br><span class="line">         <span class="keyword">return</span> Query(</span><br><span class="line">             (res.f+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*a%mod+<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod)%mod,</span><br><span class="line">             (res.g+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod)%mod,</span><br><span class="line">             (res.h+<span class="number">2L</span>L*a*res.g%mod+<span class="number">2L</span>L*b*res.f%mod</span><br><span class="line">                 +<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod*a%mod</span><br><span class="line">                 +<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*a%mod*b%mod)%mod</span><br><span class="line">         );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         re <span class="keyword">int</span> m=(<span class="number">1L</span>L*a*n+b)/c;</span><br><span class="line">         re Query res=query(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>);</span><br><span class="line">         re <span class="keyword">int</span> tmp=((<span class="number">1L</span>L*m*n%mod-res.f)%mod+mod)%mod;</span><br><span class="line">         <span class="keyword">return</span> Query(</span><br><span class="line">             tmp,</span><br><span class="line">             ((<span class="number">1L</span>L*m*n%mod*(n+<span class="number">1</span>)%mod-res.h-res.f)%mod+mod)*I2%mod,</span><br><span class="line">             ((<span class="number">1L</span>L*m*(m+<span class="number">1</span>)%mod*n%mod<span class="number">-2L</span>L*res.g%mod<span class="number">-2L</span>L*res.f%mod-tmp)%mod+mod)%mod</span><br><span class="line">         );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(t);</span><br><span class="line">     <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">         cltstream::read(n);</span><br><span class="line">         cltstream::read(a);</span><br><span class="line">         cltstream::read(b);</span><br><span class="line">         cltstream::read(c);</span><br><span class="line">         Query ans=query(a,b,c,n);</span><br><span class="line">         cltstream::write(ans.f,<span class="number">32</span>);</span><br><span class="line">         cltstream::write(ans.h,<span class="number">32</span>);</span><br><span class="line">         cltstream::write(ans.g,<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，这个东西有什么用啊。</p>
<p><del>没啥用（</del></p>
<p>其他的模板题我就不举了，我们来看一下<a href="https://www.luogu.org/problemnew/show/P4433">这样一道题</a>。</p>
<p>看到推平操作我们可以直接往珂朵莉树上想了。</p>
<p>那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息 <code>l,r,L,R,a,b</code>，表示其对应原序列中的 $[l,r]$ 这段区间，里面一共有 $\sum_{i=L}^{R}ai\operatorname{mod}b$ 颗石头。注意这里的 <code>l,r,L,R</code> 一定不要搞混<del>，我就是因为这样 WA 了整整四遍（</del>。</p>
<p><del>这三个样例一定是故意的。</del></p>
<p>然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：</p>
<script type="math/tex; mode=display">
\sum_{i=L}^{R}ai\operatorname{mod}b=\sum_{i=L}^{R}\left(ai-\lfloor\cfrac{ai}{b}\rfloor b\right)=\cfrac{(R+L)(R-L+1)}{2}-\sum_{i=0}^{R}\lfloor\cfrac{ai}{b}\rfloor b+\sum_{i=0}^{L-1}\lfloor\cfrac{ai}{b}\rfloor b</script><p>直接一波板子套上去。</p>
<p>还有就是，这么算的话中间量会爆 <code>long long</code>，我们可以考虑用 <code>__int128_t</code> 来存。不过这个类型在本地一般是编译不了的，虽然说交到 OJ 上基本没问题。我们可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后把一些没必要用或者是不能用 <code>__int128_t</code> 的改成 <code>signed</code> 即可。</p>
<p>代码还是有必要贴一下的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">signed</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">signed</span> digit[<span class="number">50</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">simEuc</span><span class="params">(re <span class="keyword">int</span> n,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!n)</span><br><span class="line">         <span class="keyword">return</span> b/c;</span><br><span class="line">     <span class="keyword">if</span>(!a)</span><br><span class="line">         <span class="keyword">return</span> (n+<span class="number">1</span>)*(b/c);</span><br><span class="line">     <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">         re <span class="keyword">int</span> res=simEuc(n,a%c,b%c,c);</span><br><span class="line">         <span class="keyword">return</span> res+n*(n+<span class="number">1</span>)*(a/c)/<span class="number">2</span>+(n+<span class="number">1</span>)*(b/c);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         re <span class="keyword">int</span> m=(a*n+b)/c;</span><br><span class="line">         <span class="keyword">return</span> m*n-simEuc(m<span class="number">-1</span>,c,c-b<span class="number">-1</span>,a);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> l,r,L,R,a,b,sum;</span><br><span class="line"></span><br><span class="line">     node(re <span class="keyword">int</span> _l,re <span class="keyword">int</span> _r,re <span class="keyword">int</span> _L,re <span class="keyword">int</span> _R,re <span class="keyword">int</span> _a,re <span class="keyword">int</span> _b)&#123;</span><br><span class="line">         l=_l;</span><br><span class="line">         r=_r;</span><br><span class="line">         L=_L;</span><br><span class="line">         R=_R;</span><br><span class="line">         a=_a;</span><br><span class="line">         b=_b;</span><br><span class="line">         sum=(R+L)*(R-L+<span class="number">1</span>)*a/<span class="number">2</span>-simEuc(R,a,<span class="number">0</span>,b)*b+simEuc(L<span class="number">-1</span>,a,<span class="number">0</span>,b)*b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re node p1,re node p2)&#123;</span><br><span class="line">     <span class="keyword">return</span> p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _it <span class="title">split</span><span class="params">(re <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">     re _it it=s.lower_bound(node(pos,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">     <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">         <span class="keyword">return</span> it;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         --it;</span><br><span class="line">         re <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r,L=it-&gt;L,R=it-&gt;R,a=it-&gt;a,b=it-&gt;b;</span><br><span class="line">         s.erase(it);</span><br><span class="line">         s.insert(node(l,pos<span class="number">-1</span>,L,L+pos-l<span class="number">-1</span>,a,b));</span><br><span class="line">         <span class="keyword">return</span> s.insert(node(pos,r,L+pos-l,R,a,b)).first;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">     re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">     s.erase(itl,itr);</span><br><span class="line">     s.insert(node(l,r,<span class="number">1</span>,r-l+<span class="number">1</span>,a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">     re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(;itl!=itr;res+=itl-&gt;sum,++itl);</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     s.insert(node(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">         re <span class="keyword">int</span> opt,l,r,a,b;</span><br><span class="line">         cltstream::read(opt);</span><br><span class="line">         cltstream::read(l);</span><br><span class="line">         cltstream::read(r);</span><br><span class="line">         <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">             cltstream::read(a);</span><br><span class="line">             cltstream::read(b);</span><br><span class="line">             modifyStone(l,r,a,b);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             cltstream::write(queryStone(l,r),<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>类欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>有上下界的网络流问题与预留推进学习笔记</title>
    <url>/something-about-network-flow-learning-notes/</url>
    <content><![CDATA[<p>感觉最近好颓啊（</p>
<p>这是一篇正在咕咕咕的 blog。<br><a id="more"></a></p>
<h3 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a><a href="https://loj.ac/problem/115">无源汇有上下界可行流</a></h3><p>我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是 $0$。一种简单的想法就是，将每条边的流量上界置为 $\text{upper}(e)-\text{lower}(e)$，下界置为 $0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令</p>
<script type="math/tex; mode=display">
w(u)=\sum_{v\in V,(v,u)\in E}\text{lower}((v,u))-\sum_{v\in V,(u,v)\in E}\text{lower}((u,v))</script><ul>
<li>如果 $w(u)=0$，说明我们不需要对点 $u$ 做出调整。</li>
<li>如果 $w(u)\gt 0$，说明调整上下界后，流入 $u$ 的流量减少地要比流出 $u$ 的流量多，我们就建立一个源点，从其向点 $u$ 连一条流量上界为 $w(u)$ 的边。</li>
<li>如果 $w(u)\lt 0$，说明调整上下界后，流出 $u$ 的流量减少地要比流入 $u$ 的流量多，我们就建立一个汇点，从点 $u$ 向其连一条流量上界为 $-w(u)$ 的边。</li>
</ul>
<p>然后直接跑一边从源点到汇点的最大流即可。</p>
<p>需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。</p>
<p>否则，我们就已经构造出了一组可行解。</p>
<h3 id="有源汇有上下界最大流"><a href="#有源汇有上下界最大流" class="headerlink" title="有源汇有上下界最大流"></a><a href="https://loj.ac/problem/116">有源汇有上下界最大流</a></h3><p>这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。</p>
<p>我们可以从汇点到源点连一条流量上界为 $+\infty$ 的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。</p>
<p>需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。</p>
<p>当然，求解可行流时无解的话，整个问题无解。</p>
<h3 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a><a href="https://loj.ac/problem/117">有源汇有上下界最小流</a></h3><p>还没看懂，先咕着。</p>
<h3 id="最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）"><a href="#最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）" class="headerlink" title="最高标号预流推进（HLPP-Highest Label Preflow Pushing？）"></a><a href="https://loj.ac/problem/127">最高标号预流推进（HLPP-Highest Label Preflow Pushing？）</a></h3><p>还没看懂，先咕着。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>预留推进</tag>
      </tags>
  </entry>
  <entry>
    <title>「HEOI2016/TJOI2016」求和</title>
    <url>/luogu-p4091-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4091">传送门</a></p>
<p>感觉最近意志消沉啥也不想干，于是继续来颓 blog（</p>
<a id="more"></a>
<p>仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（</p>
<p>首先我们知道如果 $n\gt m$，$S(n,m)=0$。于是我们将原式写成</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}\sum_{j=0}^{n}2^{j}j!S(i,j)=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)</script><p>第二类斯特林数有一个通项公式，它长这样</p>
<script type="math/tex; mode=display">
S(n,m)=\cfrac{1}{m!}\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>直观理解一下，$S(n,m)$ 说的是将 $n$ 个有标号的小球放进 $m$ 个无标号的盒子，且不允许空盒的方案数。我们令 $F(n,m,k)$ 表示将 $n$ 个有标号的小球放进 $m$ 个有标号的盒子，且其中至少有 $k$ 个空盒的方案数。不难发现</p>
<script type="math/tex; mode=display">
F(n,m,k)=C(m,k)(m-k)^{n}</script><p>然后我们容斥一下，得到将 $n$ 个有标号的小球放进 $m$ 个有标号的盒子，且不允许空盒的方案数 $G(n,m)$。不难发现</p>
<script type="math/tex; mode=display">
G(n,m)=\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>因为 $S(n,m)$ 的定义中要求盒子无标号，我们再除以盒子的排列方案 $m!$ 即可。</p>
<p>然后我们继续推式子</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\
&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\
&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\
&=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}
\end{aligned}</script><p>我们看到右边就是一个等比数列求和，于是</p>
<script type="math/tex; mode=display">
\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}</script><p>定义</p>
<script type="math/tex; mode=display">
F[i]=\cfrac{(-1)^{i}}{i!}</script><p>右边的等比数列求和比较麻烦，我们需要一些特判。</p>
<script type="math/tex; mode=display">
G[i]=\begin{cases}
&1&(i=0)\\
&n+1&(i=1)\\
&\cfrac{i^{n+1}-1}{i!(i-1)}\;\;&(i>1)
\end{cases}</script><p>然后我们就有</p>
<script type="math/tex; mode=display">
\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\sum_{j=0}^{n}2^{j}j!(F\times G)[j]</script><p>这么一想前几天的我还只会暴力二项式定理展开（</p>
<p><img src="/images/TIM图片20181209192946.jpg" alt=""></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>NTT</tag>
        <tag>HEOI</tag>
        <tag>TJOI</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-01-20：loli的两场模拟赛的题解</title>
    <url>/lolioi-2019-01-20-solutions/</url>
    <content><![CDATA[<p>今天 loli 搞了上午下午连续两场模拟赛，于是来写一篇题解。</p>
<p>上午记为 D1，下午记为 D2。</p>
<a id="more"></a>
<h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><h4 id="T1-简-simple"><a href="#T1-简-simple" class="headerlink" title="T1 简 - simple"></a>T1 简 - simple</h4><p>给你 $2n$ 个数，让你配成 $n$ 对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。</p>
<p>$n\leqslant 100000$。</p>
<p>不予置评。</p>
<h4 id="T2-单-single"><a href="#T2-单-single" class="headerlink" title="T2 单 - single"></a>T2 单 - single</h4><p>给你一棵树，每个点有点权 $a_{i}$，$dist(u,v)$ 表示 $u$ 到 $v$ 的树上路径经过的边数。定义</p>
<script type="math/tex; mode=display">
b_{u}=\sum_{i=1}^{n}dist(u,i)a_{i}</script><p>还会给你一个 $\text{tp}$，$\text{tp}=0$ 时给你 $\{a_{n}\}$ 让你求 $\{b_{n}\}$，$\text{tp}=1$ 时给你 $\{b_{n}\}$ 让你求 $\{a_{n}\}$。多组数据。</p>
<p>$n\leqslant 100000,T\leqslant 5$。</p>
<p>$\text{tp}=0$ 时就是一个简单的树形 DP。</p>
<p>$\text{tp}=1$……高斯消元？不是很会写而且 $O(n^{3})$ 会 T 飞啊（</p>
<p>他给的题解我也没看懂（</p>
<p>我就打了 $\text{tp}=0$ 的 $30$ 分。</p>
<h4 id="T3-题-problem"><a href="#T3-题-problem" class="headerlink" title="T3 题 - problem"></a>T3 题 - problem</h4><p>有一个平面直角坐标系。一开始你在原点，每次移动可以从 $(x,y)$ 移动到 $(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集 $S$，你只能停留在这个点集内的点上，问你恰好 $n$ 步后回到原点的方案数。对 $10^{9}+7$ 取模。</p>
<p>关于 $S$，首先会给你一个 $\text{tp}$，然后 $S$ 如下定义</p>
<script type="math/tex; mode=display">
S=\begin{cases}
&\{(x,y)\mid x,y\in\mathbb{Z}\}\;\;&(\text{tp}=0)\\
&\{(x,y)\mid x\in\mathbb{N},y=0\}&(\text{tp}=1)\\
&\{(x,y)\mid xy=0\}&(\text{tp}=2)\\
&\{(x,y)\mid x,y\in\mathbb{N}\}&(\text{tp}=3)
\end{cases}</script><p>$n\leqslant 100000$，$n\equiv 0\pmod{2}$，$\text{tp}\in\{0,1,2,3\}$。特殊地，当 $\text{tp}=2$ 时 $n\leqslant 1000$。</p>
<p>四合一数论提答（</p>
<p>很明显，无论是 $x$ 坐标上还是 $y$ 坐标上，我们都需要移动偶数次。再加上 $n$ 保证是偶数，我们可以将 $n$ 除以 $2$，然后走 $2n$ 步。</p>
<p>$\text{tp}=0$ 时，我们枚举 $2i$ 步沿 $x$ 轴方向走，$2(n-i)$ 步沿 $y$ 轴方向走。<br>我们可以将这抽象成一个序列，其中有 $i$ 个 $x+1/x-1$，$n-i$ 个 $y+1/y-1$，总排列方案数就是 $\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此</p>
<script type="math/tex; mode=display">
\text{Ans}=(2n)!\sum_{i=0}^{n}\cfrac{1}{i!i!(n-i)!(n-i)!}</script><p>$\text{tp}=1$ 直接卡特兰数。</p>
<p>$\text{tp}=2$ 比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为 $2n$ 的序列是匹配的。</p>
<p>如果说我们有连续一段一共 $i$ 对同种括号，不难发现排列方案数是 $\cfrac{(2i)!}{i!i!}$，于是我们就有了一个 $O(n^{2})$ 的 DP</p>
<script type="math/tex; mode=display">
f[x]=\sum_{i=1}^{x}f[x-i]\cfrac{(2i)!}{i!i!}</script><p>其实如果改一下模数的话这个东西可以用 NTT 优化到 $O(n\log n)$ 的。虽然现在这个样子 MTT 也能搞……但是我不会写（</p>
<p>$\text{tp}=3$ 大概是 $\text{tp}=0$ 与 $\text{tp}=1$ 的结合。枚举沿 $x$ 轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{Ans}&=\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\
&=\sum_{i=0}^{n}\cfrac{(2n)!}{(2i)!(2(n-i))!}\left(\cfrac{(2i)!}{i!i!}-\cfrac{(2i)!}{(i+1)!(i-1)!}\right)\left(\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\right)\\
&=(2n)!\sum_{i=0}^{n}\left(\cfrac{1}{i!i!}-\cfrac{1}{(i+1)!(i-1)!}\right)\left(\cfrac{1}{(n-i)!(n-i)!}-\cfrac{1}{(n-i+1)!(n-i-1)!}\right)
\end{aligned}</script><p>于是愉快地 $230$ 直接 rank1（</p>
<p>话说 wzx 打了 $240$ 分的啊……然而炸成 $210$（</p>
<h3 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h3><h4 id="T1-印章-seal"><a href="#T1-印章-seal" class="headerlink" title="T1 印章 - seal"></a>T1 印章 - seal</h4><p>给你一张 $n\times m$ 的纸，上面有些格子要印墨水。你有一个 $r\times c$ 的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。</p>
<p>$n,m,r,c\leqslant 1000,T\leqslant 10$。</p>
<p>首先我们不难想出一个 $O((n-r)(m-c)rc)$ 也就是差不多 $O(n^{4})$ 的暴力。不过这样只有 $60$ 分。当时我用了一个 <code>bitset</code> 瞎搞了一波把复杂度降到了 $O(n^{3})$，然而……并没有什么用（</p>
<p>拿了 $60$ 就跑（</p>
<h4 id="T2-多边形-polygon"><a href="#T2-多边形-polygon" class="headerlink" title="T2 多边形 - polygon"></a>T2 多边形 - polygon</h4><p>一个 $0-n$ 边形被定义为一个正常的 $n$ 边形。对于一个 $k-n$ 边形，对于它最外层的每一条边，我们向外做 $n$ 边形，得到一个 $(k+1)-n$ 边形。</p>
<p>这是一个 $0-4$ 边形</p>
<p><img src="/images/图片1.png" alt=""></p>
<p>这是一个 $1-4$ 边形</p>
<p><img src="/images/图片2.png" alt=""></p>
<p>这是一个 $2-4$ 边形</p>
<p><img src="/images/图片3.png" alt=""></p>
<p>给你一个 $k-n$ 边形，问你它的生成树数量。对 $998244353$ 取模。</p>
<p>$0\leqslant k\leqslant 10^{6},3\leqslant n\leqslant 10^{9}$。</p>
<p><img src="/images/TIM图片20181023195537.jpg" alt=""></p>
<p>告辞（</p>
<p>彻底放弃治疗（</p>
<h4 id="T3-扔球-ball"><a href="#T3-扔球-ball" class="headerlink" title="T3 扔球 - ball"></a>T3 扔球 - ball</h4><p>给你 $n$ 个球和 $n$ 个瓶子，编号从 $1$ 到 $n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是 $p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。</p>
<p>所有球扔完之后，记 $i$ 号球被扔进了 $a_{i}$ 号瓶子，问你 $\{a_{n}\}$ 的期望逆序对数量。四舍五入保留两位小数。</p>
<p>如果扔球时跳过了 $i$ 号球，那么当做 $a_{i}$ 不存在。</p>
<p>$n\leqslant 500000,0.4\leqslant p\leqslant 0.6$。记 $i$ 号球的指定集合为 $S_{i}$，$\Sigma|S_{i}|\leqslant 500000$。</p>
<p>从后往前扫，扫到 $x$ 时枚举 $a_{x}$ 的可能取值 $y$，将答案累加上 $a_{x}=y$ 的概率与 $a_{x+1}$ 到 $a_{n}$ 中小于 $y$ 的数的数量的期望值的乘积。然后 $a_{x}$ 到 $a_{n}$ 中 $y$ 的出现次数的期望值就是 $a_{x+1}$ 到 $a_{n}$ 中 $y$ 的出现次数的期望值再加上 $a_{x}=y$ 的概率。</p>
<p>套个树状数组就行。</p>
<p>但是等会，$a_{x}=y$ 的概率怎么算啊。</p>
<p>首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim_{n\rightarrow+\infty}\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\
&=\cfrac{p}{1-(1-p)^{|S_{x}|}}
\end{aligned}</script><p>那么第 $2$ 小呢？首先我们第一次扔不能扔进去，所以首先需要乘个 $1-p$，然后就和上面一样了。依次类推，扔进编号第 $i$ 小的瓶子的概率为</p>
<script type="math/tex; mode=display">
\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}</script><p>最后总分只有 $160$，被 $190$ 分的 wzx 吊着打（</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>loli</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>动态树学习笔记</title>
    <url>/link-cut-tree-learning-notes/</url>
    <content><![CDATA[<p>24 号要出去学习，趁现在先自己 xjb 学点啥。</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先我们有一道<a href="https://www.luogu.org/problemnew/show/P3690">模板题</a>。</p>
<p>我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。</p>
<p>这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是 $O(n\log^{2}n)$。</p>
<p>但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面 xjb 捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边 、 删边，同时需要查询某条链上的信息。</p>
<p>很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。</p>
<p>实链剖分一般被称为 LCT，全称<del>Link-Cat Tree</del> <del>Linear Challestend Transformation</del> Link-Cut Tree，也就是动态树。</p>
<p>与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。</p>
<p>为了实现它，我们需要通过更加灵活的 Splay 来维护每一条实链。它具有如下性质：</p>
<ol>
<li>每棵 Splay 维护的是一条原森林中深度严格递增的路径，也就是一条实链。</li>
<li>每个节点属于且仅属于一棵 Splay。</li>
<li>如果一个节点在原森林中有多个儿子，只有一个与它在同一颗 Splay 中，也就是实儿子。其他儿子所在的 Splay 的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。</li>
<li>不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。</li>
</ol>
<p>以下图片来自 <a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。">https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。</a></p>
<p>我们来看这样一棵树</p>
<p><img src="/images/1309909-20180123095924037-1618037447.png" alt=""></p>
<p>其中粗线表示实边，虚线表示虚边。</p>
<p>它所对应的 Splay 森林可能长下面这样，每一个绿框内都是一棵 Splay。</p>
<p><img src="/images/1309909-20180123095955350-1680422636.png" alt=""></p>
<p>当然这并不是唯一的。</p>
<p>为了方便，我先放出我 Splay 的代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">     SplayNode *ftr,*ls,*rs;</span><br><span class="line">     <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">         <span class="comment">// 判断一个节点是否是原森林中的一棵树的树根</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">         rev^=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">             <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                 ls-&gt;reverse();</span><br><span class="line">             <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                 rs-&gt;reverse();</span><br><span class="line">             rev=<span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">         sum=val;</span><br><span class="line">         <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">             sum^=ls-&gt;sum;</span><br><span class="line">         <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">             sum^=rs-&gt;sum;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     re SplayNode* q=p-&gt;ftr;</span><br><span class="line">     q-&gt;pushDown();</span><br><span class="line">     p-&gt;pushDown();</span><br><span class="line">     p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">             p-&gt;ftr-&gt;ls=p;</span><br><span class="line">         <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">             p-&gt;ftr-&gt;rs=p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">         q-&gt;rs=p-&gt;ls;</span><br><span class="line">         <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">             q-&gt;rs-&gt;ftr=q;</span><br><span class="line">         p-&gt;ls=q;</span><br><span class="line">         q-&gt;ftr=p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         q-&gt;ls=p-&gt;rs;</span><br><span class="line">         <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">             q-&gt;ls-&gt;ftr=q;</span><br><span class="line">         p-&gt;rs=q;</span><br><span class="line">         q-&gt;ftr=p;</span><br><span class="line">     &#125;</span><br><span class="line">     q-&gt;pushUp();</span><br><span class="line">     p-&gt;pushUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line"><span class="comment">// 不同于我们以前写的 Splay，现在我们只需要将一个节点旋转到根即可</span></span><br><span class="line">     <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">         <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">             rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><p>首先我们有一个基本操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>首先有一个问题是，这个单词怎么读？</p>
<p><code>/ək&#39;ses/</code>？不不不应该是 <code>/&#39;ækses/</code>。</p>
<p>如果您有兴趣，可以在<a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation">这里</a> 看看自己以前都读错了多少单词（</p>
<p>这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。</p>
<p>我们来看看这个函数的具体过程。还是上面的例子，现在我们调用 <code>access(N)</code>，整棵树会变成这样</p>
<p><img src="/images/1309909-20180123101901740-2118178734.png" alt=""></p>
<p><del>虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（</del></p>
<p>首先我们调用 <code>splay(N)</code>，令 $\text{N}$ 成为它所在的 Splay 的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。</p>
<p><img src="/images/1309909-20180123110136115-1112016464.png" alt=""></p>
<p>向上找到 $\text{N}$ 的父亲 $\text{I}$，调用 <code>splay(I)</code>，回收 $\text{I}$ 的右儿子指针。不过这一次，我们需要再令其指向 $\text{N}$，然后 $\text{N}$ 就成了 $\text{I}$ 的实儿子了。</p>
<p><img src="/images/1309909-20180123110156272-1242463729.png" alt=""></p>
<p>然后继续向上，找到 $\text{I}$ 的父亲 $\text{H}$，调用 <code>splay(H)</code>，并令 $\text{H}$ 的右儿子指针指向 $\text{I}$。</p>
<p><img src="/images/1309909-20180123110209772-2057141058.png" alt=""></p>
<p>最后一步，找到 $\text{H}$ 的父亲 $\text{A}$，调用 <code>splay(A)</code>，并令 $\text{A}$ 的右儿子指针指向 $\text{H}$。</p>
<p><img src="/images/1309909-20180123110213709-49169640.png" alt=""></p>
<p>然后我们看到，$\text{N}$ 和 $\text{A}$ 到了同一颗 Splay 中，完成任务，返回。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     splay(p);</span><br><span class="line">     p-&gt;pushDown();</span><br><span class="line">     p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">     p-&gt;pushUp();</span><br><span class="line">     <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">         splay(q-&gt;ftr);</span><br><span class="line">         q-&gt;ftr-&gt;pushDown();</span><br><span class="line">         q-&gt;ftr-&gt;rs=q;</span><br><span class="line">         q-&gt;ftr-&gt;pushUp();</span><br><span class="line">     &#125;</span><br><span class="line">     splay(p);</span><br><span class="line">     <span class="comment">// 据说闲着没事瞎转转有利于摊开时间复杂度（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="findRoot"><a href="#findRoot" class="headerlink" title="findRoot"></a>findRoot</h3><p>有了 <code>access</code>，我们就可以随心所欲的瞎搞了。比如说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayNode* <span class="title">findRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>返回给定节点所在的树的树根，也就是调用完 <code>access</code> 后它所在的实链上深度最小的节点。</p>
<p>因为 <code>access</code> 的最后自带了一个 <code>splay</code>，这个时候给定节点已经是 Splay 的根节点了，我们直接循环跳左儿子指针即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     access(p);</span><br><span class="line">     <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">     splay(p);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="makeRoot-amp-amp-split"><a href="#makeRoot-amp-amp-split" class="headerlink" title="makeRoot &amp;&amp; split"></a>makeRoot &amp;&amp; split</h3><p>现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵 Splay 中。</p>
<p>不过办法总是有的。比如说我们指定了两个节点 $x$ 和 $y$，我们先调用 <code>access(x)</code>，然后考虑翻转 $x$ 的子树之后会发生什么。</p>
<p><code>access</code> 结束后，$x$ 没有右子树，翻转之后就没有了左子树，也就是说，现在没有比 $x$ 的深度更小的节点了。换句话说就是，$x$ 现在成为了树根。</p>
<p>那么这样一来，$x$ 到 $y$ 的路径就一定满足深度严格递增了，我们只需调用一次 <code>access(y)</code> 就可以把它抽出来。</p>
<p>我们实现下面两个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>令给定节点成为树根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     access(p);</span><br><span class="line">     p-&gt;reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">     makeRoot(p);</span><br><span class="line">     access(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p>我们需要实现函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。</p>
<p>思路很简单。假设我们指定 $x$ 和 $y$ 两个节点，首先调用 <code>makeRoot(x)</code>，然后检查 <code>findRoot(y)</code> 的返回值。如果不是 $x$，说明两个节点不连通，将 $x$ 的父指针指向 $y$；否则，即 <code>findRoot(y)==x</code>，说明两个节点联通，直接返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">     makeRoot(p);</span><br><span class="line">     <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">         p-&gt;ftr=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>我们需要实现函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>切断给定的两个节点之间的边。不存在就什么也不做。</p>
<p>需要注意的是，两个节点 $x$ 和 $y$ 之间直接有边相连，不仅要求 $x$ 与 $y$ 联通，还要求它们在 Splay 中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用 <code>makeRoot(x)</code>，此时 $y$ 应该是 $x$ 的右儿子，并且它不能有左儿子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">     makeRoot(p);</span><br><span class="line">     <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">         q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">         p-&gt;pushUp();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。</p>
<p>完整板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">        _tp z=x;</span><br><span class="line">         x=y;</span><br><span class="line">         y=z;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkCutTree</span>&#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">         SplayNode *ftr,*ls,*rs;</span><br><span class="line">         <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">             rev^=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                     ls-&gt;reverse();</span><br><span class="line">                 <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                     rs-&gt;reverse();</span><br><span class="line">                 rev=<span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">             sum=val;</span><br><span class="line">             <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                 sum^=ls-&gt;sum;</span><br><span class="line">             <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                 sum^=rs-&gt;sum;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">         re SplayNode* q=p-&gt;ftr;</span><br><span class="line">         q-&gt;pushDown();</span><br><span class="line">         p-&gt;pushDown();</span><br><span class="line">         p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">         <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">                 p-&gt;ftr-&gt;ls=p;</span><br><span class="line">             <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">                 p-&gt;ftr-&gt;rs=p;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">             q-&gt;rs=p-&gt;ls;</span><br><span class="line">             <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">                 q-&gt;rs-&gt;ftr=q;</span><br><span class="line">             p-&gt;ls=q;</span><br><span class="line">             q-&gt;ftr=p;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             q-&gt;ls=p-&gt;rs;</span><br><span class="line">             <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">                 q-&gt;ls-&gt;ftr=q;</span><br><span class="line">             p-&gt;rs=q;</span><br><span class="line">             q-&gt;ftr=p;</span><br><span class="line">         &#125;</span><br><span class="line">         q-&gt;pushUp();</span><br><span class="line">         p-&gt;pushUp();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">             <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">                 rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">             re SplayNode* p=mempool+i;</span><br><span class="line">             p-&gt;ftr=p-&gt;ls=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">             cltstream::read(p-&gt;val);</span><br><span class="line">             p-&gt;sum=p-&gt;val;</span><br><span class="line">             p-&gt;rev=<span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">         splay(p);</span><br><span class="line">         p-&gt;pushDown();</span><br><span class="line">         p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">         p-&gt;pushUp();</span><br><span class="line">         <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">             splay(q-&gt;ftr);</span><br><span class="line">             q-&gt;ftr-&gt;pushDown();</span><br><span class="line">             q-&gt;ftr-&gt;rs=q;</span><br><span class="line">             q-&gt;ftr-&gt;pushUp();</span><br><span class="line">         &#125;</span><br><span class="line">         splay(p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">         access(p);</span><br><span class="line">         <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">         splay(p);</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">         access(p);</span><br><span class="line">         p-&gt;reverse();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">         makeRoot(p);</span><br><span class="line">         access(q);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">         makeRoot(p);</span><br><span class="line">         <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">             p-&gt;ftr=q;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">         makeRoot(p);</span><br><span class="line">         <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">             q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">             p-&gt;pushUp();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryPathXorSum</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">         split(mempool+x,mempool+y);</span><br><span class="line">         <span class="keyword">return</span> (mempool+y)-&gt;sum;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">createEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">         link(mempool+x,mempool+y);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destoryEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">         cut(mempool+x,mempool+y);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyVertice</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">         splay(mempool+x);</span><br><span class="line">         (mempool+x)-&gt;val=y;</span><br><span class="line">         (mempool+x)-&gt;pushUp();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">             p-&gt;pushDown();</span><br><span class="line">             printTree(p-&gt;ls);</span><br><span class="line">             <span class="built_in">printf</span>(</span><br><span class="line">                 <span class="string">"%d(%d,%d,%d)\n"</span>,</span><br><span class="line">                 p-mempool,</span><br><span class="line">                 p-&gt;ftr!=<span class="literal">NULL</span>?p-&gt;ftr-mempool:<span class="number">-1</span>,</span><br><span class="line">                 p-&gt;ls!=<span class="literal">NULL</span>?p-&gt;ls-mempool:<span class="number">-1</span>,</span><br><span class="line">                 p-&gt;rs!=<span class="literal">NULL</span>?p-&gt;rs-mempool:<span class="number">-1</span></span><br><span class="line">             );</span><br><span class="line">             printTree(p-&gt;rs);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LinkCutTree QAQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;\</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     QAQ.build(n);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">         <span class="keyword">int</span> opt,x,y;</span><br><span class="line">         cltstream::read(opt);</span><br><span class="line">         cltstream::read(x);</span><br><span class="line">         cltstream::read(y);</span><br><span class="line">         <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                 cltstream::write(QAQ.queryPathXorSum(x,y),<span class="number">10</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                 QAQ.createEdge(x,y);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                 QAQ.destoryEdge(x,y);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                 QAQ.modifyVertice(x,y);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>是不是感觉很好写呢（</del></p>
<h3 id="用-LCT-维护子树信息"><a href="#用-LCT-维护子树信息" class="headerlink" title="用 LCT 维护子树信息"></a>用 LCT 维护子树信息</h3><p>咕咕咕。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Splay</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>「年轻人，你渴望力量吗？」</title>
    <url>/min-25-sieve-learning-notes/</url>
    <content><![CDATA[<p>标题来自某学长安利 min_25 筛的方式（</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，<a href="/number-theory-learning-notes/">杜教筛</a> 可以在 $O(n^{\tfrac{2}{3}})$ 的时间复杂度内计算某些给定的积性函数的前缀和。</p>
<p>但是现在我们希望更快。于是我们有了 min_25 筛（</p>
<p>以下，我们约定 $p$ 是一个质数。$\mathbb{P}_{i}$ 表示第 $i$ 小的质数，$\mathbb{P}_{0}=0$。$\text{minp}(n)$ 表示 $n$ 最小的质因数，$\text{minp}(1)=0$。</p>
<p>现在我们要求一个积性函数 $f$ 的前缀和。我们需要它满足以下两条性质：</p>
<ol>
<li>$f(p)$ 是一个<strong>可以快速求前缀和的完全积性函数</strong>，或者能用多个这样的函数运算得到。</li>
<li>$f(p^{k})$ 可以快速求，大概 $O(k)$ 以内就可以。</li>
</ol>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>我们要对每一个 $x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，求出</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>定义</p>
<script type="math/tex; mode=display">
F(x,y)=\sum_{i=1}^{x}[i\in\mathbb{P}\vee\text{minp}(i)\gt\mathbb{P}_{y}]f^{\prime}(i)</script><p>也就是把所有质数和最小质因数大于 $\mathbb{P}_y$ 的合数全部当成质数代入 $f^{\prime}$ 求值并求和。不难发现</p>
<script type="math/tex; mode=display">
F(x,+\infty)=\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>我们回忆一下埃式筛法的运行过程。</p>
<p>筛完 $k$ 次后，我们除去了最小质因数小于等于 $\mathbb{P}_{k}$ 的合数，剩下了质数和最小质因数大于 $\mathbb{P}_k$ 的合数。</p>
<p>可以看到这和 $F(x,y)$ 的定义十分吻合。$F(x,y)$ 就是埃式筛法筛完 $y$ 次后，没有被筛掉的数的 $f^{\prime}$ 的值的和。</p>
<p>首先，第 $y$ 次筛掉的最小的数很明显是 $\mathbb{P}_{y}^{2}$，如果 $\mathbb{P}_{y}^{2}\gt x$，我们什么也筛不掉，此时 $F(x,y)=F(x,y-1)$。</p>
<p>也因此，筛质数筛到 $\sqrt{n}$ 即可。</p>
<p>否则，即 $\mathbb{P}_{y}^{2}\leqslant x$，我们将所有数除以 $\mathbb{P}_{y}$，之前所有最小质因数等于 $\mathbb{P}_{y}$ 的合数一一对应到了现在所有大于等于 $\mathbb{P}_{y}$ 的数。</p>
<p>又因为 $f^{\prime}$ 是完全积性的，假如我们有一个需要筛掉的数 $z$，我们可以通过 $f^{\prime}(\cfrac{z}{\mathbb{P}_{y}})f^{\prime}(\mathbb{P}_{y})$ 计算 $f^{\prime}(z)$。</p>
<p>那么看起来</p>
<script type="math/tex; mode=display">
F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)</script><p>$F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)$ 包含了三类数的 $f^{\prime}$ 的值：</p>
<ol>
<li>大于等于 $\mathbb{P}_{y}$ 的质数。</li>
<li>最小质因数大于等于 $\mathbb{P}_{y}$（大于 $\mathbb{P}_{y-1}$）的合数。</li>
<li>小于 $\mathbb{P}_{y}$ 的质数。</li>
</ol>
<p>但是很明显第三类数不能被除去，因此实际上</p>
<script type="math/tex; mode=display">
F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)</script><p>综上所述</p>
<script type="math/tex; mode=display">
F(x,y)=\begin{cases}
&F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum\limits_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)\;\;&(\mathbb{P}_{y}^{2}\leqslant x)\\
&F(x,y-1)&(\mathbb{P}_{y}^{2}\gt x)
\end{cases}</script><p>初值为</p>
<script type="math/tex; mode=display">
F(x,0)=\sum_{i=2}^{x}f^{\prime}(i)</script><p>注意到第二维只与 $y-1$ 有关，我们可以滚掉。</p>
<p>还有一个问题。这类题目的 $n$ 会很大，我们无法开一个长度为 $n$ 的数组。</p>
<p>因为 $x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，这样的 $x$ 最多只有 $2\sqrt{n}$ 个，我们可以离散化存储。</p>
<p>具体实现细节我说不清，看代码吧（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cltstream::read(n);</span><br><span class="line">sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sq;++i)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">         g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">         fsum[g[<span class="number">0</span>]]=fsum[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="comment">/**/</span>;</span><br><span class="line">         <span class="comment">// 注释处应填 f`(i)</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=sq;++j)&#123;</span><br><span class="line">         f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">     w[++m]=n/l;</span><br><span class="line">     <span class="comment">// 编号对应的离散化前的值</span></span><br><span class="line">     F[m]=<span class="comment">/**/</span>;</span><br><span class="line">     <span class="comment">// 注释处应填 \sum_&#123;t=2&#125;^&#123;w[m]&#125;f`(t)</span></span><br><span class="line">     <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">         id1[w[m]]=m;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         id2[n/w[m]]=m;</span><br><span class="line">     <span class="comment">// 分段存储值对应的编号，这样数组只需要开到 sqrt&#123;n&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=g[j]*g[j];++i)&#123;</span><br><span class="line">     <span class="comment">//w[i]&gt;=g[j]*g[j]，所以 w[i]/g[j]&gt;=g[j]</span></span><br><span class="line">         re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">         F[i]-=<span class="comment">/**/</span>*(F[id]-fsum[j<span class="number">-1</span>]);</span><br><span class="line">         <span class="comment">// 注释处应填 f`(g[j])</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>这一部分的时间复杂度已被证明是 $O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>然而看上去很奇怪（</del></p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。</p>
<p>定义</p>
<script type="math/tex; mode=display">
S(x,y)=\sum_{i=1}^{x}[\text{minp}(i)\geqslant\mathbb{P}_{y}]f(i)</script><p>也就是所有最小质因数大于等于 $\mathbb{P}_{y}$ 的数的 $f$ 的值的和。我们最终要求的就是 $S(n,1)+f(1)$。</p>
<p>首先我们需要统计所有质数的贡献，也就是 $F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})$。</p>
<p>关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。</p>
<script type="math/tex; mode=display">
\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)</script><p>但是还有一个问题是 $S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)$ 中不包括 $f(1)$，因此 $f(\mathbb{P}_{i}^{j})$ 没有被统计，我们需要手动算进来</p>
<script type="math/tex; mode=display">
\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>于是</p>
<script type="math/tex; mode=display">
S(x,y)=F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})+\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>然后暴力搜，记忆化都不需要，时间复杂度还是 $O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>就很神奇（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">         re <span class="keyword">int</span> res=F[id]-fsum[y<span class="number">-1</span>];</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;g[i]*g[i]&lt;=x;++i)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                 res+=<span class="comment">/*1*/</span>*S(x/p,i+<span class="number">1</span>)+<span class="comment">/*2*/</span>;</span><br><span class="line">                 <span class="comment">//1 处应填 f(p)，2 处应填 f(p*g[i])</span></span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="「Luogu-P4213」「模板」杜教筛（Sum）"><a href="#「Luogu-P4213」「模板」杜教筛（Sum）" class="headerlink" title="「Luogu-P4213」「模板」杜教筛（Sum）"></a><a href="https://www.luogu.org/problemnew/show/P4213">「Luogu-P4213」「模板」杜教筛（Sum）</a></h3><p>首先我们有</p>
<script type="math/tex; mode=display">
\varphi(p)=\text{id}(p)-1</script><script type="math/tex; mode=display">
\mu(p)=-1</script><p>然后 $\text{id}$ 和 $1$ 都是能 $O(1)$ 求前缀和完全积性函数，因此可以用 min_25 筛搞。</p>
<p>说起来比较麻烦，min_25 筛不结合代码大概也很难理解，所以说直接上代码（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,sq,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],w[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],id1[maxn+<span class="number">1</span>],id2[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> prmcnt[maxn+<span class="number">1</span>],prmCnt[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prmsum[maxn+<span class="number">1</span>],prmSum[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getPhi</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">         re <span class="keyword">long</span> <span class="keyword">long</span> res=(prmSum[id]-prmCnt[id])-(prmsum[y<span class="number">-1</span>]-prmcnt[y<span class="number">-1</span>]);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];<span class="number">1L</span>L*p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                 res+=<span class="number">1L</span>L*p/g[i]*(g[i]<span class="number">-1</span>)*getPhi(x/p,i+<span class="number">1</span>)+<span class="number">1L</span>L*p*(g[i]<span class="number">-1</span>);</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">         re <span class="keyword">int</span> res=prmcnt[y<span class="number">-1</span>]-prmCnt[id];</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">             res-=getMu(x/g[i],i+<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">             g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">             prmcnt[g[<span class="number">0</span>]]=prmcnt[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">             prmsum[g[<span class="number">0</span>]]=prmsum[g[<span class="number">0</span>]<span class="number">-1</span>]+i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">             f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     cltstream::read(t);</span><br><span class="line">     <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">         cltstream::read(n);</span><br><span class="line">         sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line">         m=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">             w[++m]=n/l;</span><br><span class="line">             prmCnt[m]=w[m]<span class="number">-1</span>;</span><br><span class="line">             prmSum[m]=<span class="number">1L</span>L*(w[m]<span class="number">-1</span>)*(w[m]+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">                 id1[w[m]]=m;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 id2[n/w[m]]=m;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=<span class="number">1L</span>L*g[j]*g[j];++i)&#123;</span><br><span class="line">                 re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">                 prmCnt[i]-=prmCnt[id]-prmcnt[j<span class="number">-1</span>];</span><br><span class="line">                 prmSum[i]-=<span class="number">1L</span>L*g[j]*(prmSum[id]-prmsum[j<span class="number">-1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">         cltstream::write(getPhi(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">32</span>);</span><br><span class="line">         cltstream::write(getMu(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/TIM截图20190214152934.png" alt=""></p>
<p>上为 min_25 筛，下为杜教筛。</p>
<p>min_25 筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说</p>
<h3 id="「LOJ6053」简单的函数"><a href="#「LOJ6053」简单的函数" class="headerlink" title="「LOJ6053」简单的函数"></a><a href="https://loj.ac/problem/6053">「LOJ6053」简单的函数</a></h3><p>总结一下这个函数：</p>
<script type="math/tex; mode=display">
f(1)=1</script><script type="math/tex; mode=display">
f\left(\prod_{i=1}^{N}p_{i}^{r_{i}}\right)=\prod_{i=1}^{N}(p_{i}\otimes r_{i})</script><p>其中 $\otimes$ 表示按位异或。</p>
<p><img src="/images/TIM图片20190103092627.png" alt=""></p>
<p>按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（</p>
<p>注意到</p>
<script type="math/tex; mode=display">
f(p)=p\otimes 1=\begin{cases}
&p+1\;\;&(p=2)\\
&p-1\;\;&(p\gt 2)
\end{cases}</script><p>我们可以在算前缀和时将 $f(2)$ 当成 $2-1$，然后特判一下加回来。</p>
<p>然后还是要用 min_25 筛的前半部分筛出 $\text{id}$ 和 $1$，其实和上面的 $\varphi$ 没多大区别就是加了点细节（</p>
<p><a href="https://loj.ac/submission/336101">好像这种能随便看代码的 OJ 可以直接扔个提交记录</a>。</p>
<h3 id="「UOJ188」Sanrd"><a href="#「UOJ188」Sanrd" class="headerlink" title="「UOJ188」Sanrd"></a><a href="http://uoj.ac/problem/188">「UOJ188」Sanrd</a></h3><p>次大质因数和。</p>
<p>其实这个题面有点考阅读的。</p>
<p>但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。<del>说好的只能筛积性函数呢（</del></p>
<p>我们来分析一下 min_25 筛的运行过程。</p>
<p>调用到 $S(x,y)$ 时，剩下的最小质因数大于等于 $\mathbb{P}_{y}$ 的数中，只有质数与 $\mathbb{P}_{y-1}$ 相乘之后能够得到次大质因数为 $\mathbb{P}_{y-1}$ 的数。这部分可以直接算。</p>
<p>关于次大质因数大于 $\mathbb{P}_{y-1}$ 的，还是枚举递归暴力搜。然后还是没有算 $f(\mathbb{P}_{i}^{j})$，手动加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">long</span> <span class="keyword">long</span> n,re <span class="keyword">long</span> <span class="keyword">long</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         re <span class="keyword">int</span> k=id[x&lt;=sq?x:n/x+sq];</span><br><span class="line">         re <span class="keyword">long</span> <span class="keyword">long</span> res=(y&gt;<span class="number">1</span>?g[y<span class="number">-1</span>]:<span class="number">0</span>)*(prmCnt[k]-y+<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">long</span> <span class="keyword">long</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                 res+=S(n,x/p,i+<span class="number">1</span>)+g[i];</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://uoj.ac/submission/324057">提交记录</a>。</p>
<p><del>一道比一道神仙，像我这种菜鸡只能抄题解了（</del></p>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><ul>
<li><a href="https://loj.ac/problem/572">「LOJ572」「LibreOJ Round #11」Misaka Network 与求和</a></li>
<li><a href="https://www.spoj.com/problems/DIVCNTK/">「SP34096」DIVCNTK - Counting Divisors (general)</a></li>
<li><a href="https://www.spoj.com/problems/GCDEX2/">「SP19985」GCDEX2 - GCD Extreme (hard)</a></li>
<li><a href="https://www.spoj.com/problems/APS2/">「SP19975」APS2 - Amazing Prime Sequence (hard)</a></li>
</ul>
<h3 id="其它文献"><a href="#其它文献" class="headerlink" title="其它文献"></a>其它文献</h3><ul>
<li><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096">https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096</a></li>
<li><a href="https://www.cnblogs.com/zhoushuyu/p/9187319.html">https://www.cnblogs.com/zhoushuyu/p/9187319.html</a></li>
<li><a href="https://www.cnblogs.com/cjyyb/p/10169190.html">https://www.cnblogs.com/cjyyb/p/10169190.html</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P3613」睡觉困难综合征</title>
    <url>/luogu-p3613-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3613">传送门</a></p>
<a id="more"></a>
<h3 id="xjb-扯"><a href="#xjb-扯" class="headerlink" title="xjb 扯"></a>xjb 扯</h3><p>以前刚学树剖时看到这题感觉好神仙啊没法做啊。</p>
<p>然后现在学了 LCT 过来一看<del>，这不就一水题（</del></p>
<p>xjb 写了棵 LCT 一交。</p>
<p><img src="/images/TIM截图20190215193107.png" alt=""></p>
<p>emmmmmm……</p>
<p>然后改的时候才发现全是细节错误，LCT 的部分动都没动一下（</p>
<p>就比如说，下面是我第一次交的程序的主程序部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">     <span class="keyword">int</span> opt,x,y;</span><br><span class="line">     cltstream::read(opt);</span><br><span class="line">     cltstream::read(x);</span><br><span class="line">     cltstream::read(y);</span><br><span class="line">     <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">int</span> z;</span><br><span class="line">         <span class="comment">// 我都不知道我当时是怎么想的（</span></span><br><span class="line">         cltstream::read(z);</span><br><span class="line">         split(mempool+x,mempool+y);</span><br><span class="line">         re <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans0=(mempool+y)-&gt;ans0,ans1=(mempool+y)-&gt;ans1,ans=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=k<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">             <span class="keyword">if</span>(((ans0&gt;&gt;j)&amp;<span class="number">1</span>)&gt;=((ans1&gt;&gt;j)&amp;<span class="number">1</span>)||z&lt;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">             <span class="comment">// 甚至忘了用 1ULL（</span></span><br><span class="line">                 ans^=ans0&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">             <span class="keyword">else</span>&#123;</span><br><span class="line">                 z-=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                 ans^=ans1&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">             &#125;</span><br><span class="line">         cltstream::write(ans,<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> z;</span><br><span class="line">         cltstream::read(z);</span><br><span class="line">         access(mempool+x);</span><br><span class="line">         (mempool+x)-&gt;tp=y;</span><br><span class="line">         (mempool+x)-&gt;val=z;</span><br><span class="line">         (mempool+y)-&gt;pushUp();</span><br><span class="line">         <span class="comment">//？？？</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我 Splay 节点的内部信息甚至开成了 <code>unsigned</code>，excuse me？？？</p>
<p><del>不这个东西这不是我写的（</del></p>
<h3 id="真正的题解"><a href="#真正的题解" class="headerlink" title="真正的题解"></a>真正的题解</h3><p>首先 LCT。</p>
<p>不过首先的首先您还是要先做了<a href="https://www.luogu.org/problemnew/show/P2114">这道题</a>。</p>
<p>每个 Splay 节点维护两个值，分别是把 $0$ 和 $-1$ 在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。</p>
<p>我们记这两个值为 <code>ans0</code> 和 <code>ans1</code>。</p>
<p>左子树和节点本身的信息很好维护。</p>
<p>而关于右子树，看上去我们没办法迅速求出把到现在为止的 <code>ans0</code> 和 <code>ans1</code> 扔进去跑一遍的结果。</p>
<p>但是注意到这些都是按位运算，位与位之间不互相影响。</p>
<p>我们可以对于 <code>ans0</code> 中是 $1$ 的那些位，提取出 <code>rc-&gt;ans1</code> 的对应位，对于 <code>ans0</code> 中是 $0$ 的那些位，提取出 <code>rc-&gt;ans0</code> 的对应位。</p>
<p>然后 <code>ans1</code> 也类似处理就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">     SplayNode *ftr,*lc,*rc;</span><br><span class="line">     <span class="keyword">int</span> tp,rev;</span><br><span class="line">     <span class="keyword">unsigned</span> val,ans0,ans1;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">apply</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> tp==<span class="number">1</span>?(x&amp;val):tp==<span class="number">2</span>?(x|val):(x^val);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">         ans0=<span class="number">0</span>,ans1=<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span>(lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">             ans0=lc-&gt;ans0;</span><br><span class="line">             ans1=lc-&gt;ans1;</span><br><span class="line">         &#125;</span><br><span class="line">         ans0=apply(ans0),ans1=apply(ans1);</span><br><span class="line">         <span class="keyword">if</span>(rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">             ans0=(ans0&amp;rc-&gt;ans1)|((~ans0)&amp;rc-&gt;ans0);</span><br><span class="line">             ans1=(ans1&amp;rc-&gt;ans1)|((~ans1)&amp;rc-&gt;ans0);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是还有一个问题是，LCT 在连边和提取路径时需要 <code>makeRoot</code>，也就是说需要区间翻转。</p>
<p>但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。</p>
<p>那么提前维护好就行了。提前维护好 <code>sna0</code> 和 <code>sna1</code>，表示把 $0$ 和 $-1$ 反过来跑一遍的结果。</p>
<p>然后就没了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>LCT</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P4705」Van♂游戏</title>
    <url>/luogu-p4705-solution/</url>
    <content><![CDATA[<p>下个月就要省选了我还在颓怕不是要凉</p>
<p>然后再一翻 wzx 的 blog 发现他更新频率快到爆炸</p>
<p>大概这就是神吧</p>
<p>啊啊我好菜啊，不过还是来抄篇题解吧</p>
<p><a href="https://www.luogu.org/problemnew/show/P4705">传送门</a></p>
<a id="more"></a>
<p>令 $\text{Ans}[t]$ 表示 $t$ 次价值：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{Ans}[t]&=\sum_{i=1}^{n}\sum_{j=1}^{m}(a_{i}+b_{j})^{t}\\
&=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=0}^{t}C_{t}^{k}a_{i}^{k}b_{j}^{t-k}\\
&=t!\sum_{k=0}^{t}\cfrac{\sum a_{i}^{k}}{k!}\cfrac{\sum b_{j}^{t-k}}{(t-k)!}
\end{aligned}</script><p>然后我们看到了 $\sum a_{i}^{k}$ 这种东西，要算的话时间复杂度至少要是 $O(nt)$ 的（</p>
<p>从这里往下是抄的题解。</p>
<p>定义</p>
<script type="math/tex; mode=display">
F(x)=\prod_{i=1}^{n}(a_{i}x+1)</script><script type="math/tex; mode=display">
\begin{aligned}
G(x)&=\ln F(x)\\
&=\ln\prod_{i=1}^{n}(a_{i}x+1)\\
&=\sum_{i=1}^{n}\ln(a_{i}x+1)
\end{aligned}</script><p>我们先来考虑如何求出 $F$。定义 $Q_{i}$ 为从 $\{a_{n}\}$ 中选出 $i$ 个数相乘，这样的所有方案结果的总和，且 $Q_{0}=1$。我们有</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^{n}Q_{i}x^{i}</script><p>然后分治。假设我们现在已经求出了 $[l,mid]$ 上的 $Q_{L,0},Q_{L,1},\cdots,Q_{L,mid-l+1}$ 和 $(mid,r]$ 上的 $Q_{R,0},Q_{R,1},\cdots,Q_{R,r-mid}$，不难发现</p>
<script type="math/tex; mode=display">
Q_{i}=\sum_{j=0}^{i}Q_{L,j}Q_{R,i-j}</script><p>这部分的时间复杂度为 $O(n\log^{2}n)$。</p>
<p>然后我们将 $G$ 在 $1$ 这个位置泰勒展开。先回忆一下<a href="/polynomial-learning-notes-pt2/">泰勒展开</a> 的式子</p>
<script type="math/tex; mode=display">
g(x)=\sum\limits_{i=1}^{+\infty}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><script type="math/tex; mode=display">
\ln^{(n)}(x)=(-1)^{n-1}(n-1)!x^{-n}</script><script type="math/tex; mode=display">
\begin{aligned}
G(x)&=\sum_{i=1}^{n}\ln(a_{i}x+1)\\
&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{\ln^{(j)}(1)}{j!}a_{i}^{j}x^{j}\\
&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}(j-1)!1^{-j}}{j!}a_{i}^{j}x^{j}\\
&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}a_{i}^{j}x^{j}\\
&=\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}\left(\sum_{i=1}^{n}a_{i}^{j}\right)x^{j}
\end{aligned}</script><p><img src="/images/TIM图片20190123161752.jpg" alt=""></p>
<p>令人窒息（</p>
<p>然后这道题就做出来了（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">         <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">             res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">         x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">         y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                 re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                 F[j]=(x+y)%mod;</span><br><span class="line">                 F[j+p]=(x-y+mod)%mod;</span><br><span class="line">             &#125;</span><br><span class="line">     re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         G[i]=<span class="number">0</span>;</span><br><span class="line">     G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         NTT(G,j,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">             tmp1[k]=F[k];</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">             tmp1[k]=<span class="number">0</span>;</span><br><span class="line">         NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">             G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">         NTT(G,j,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">             G[k]=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">         G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">         G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">     G[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">         G[i]=<span class="number">0</span>;</span><br><span class="line">     NTT(G,N,<span class="number">0</span>);</span><br><span class="line">     Inv(F,tmp2,n);</span><br><span class="line">     NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">     NTT(G,N,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">         G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">     G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">         G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(re <span class="keyword">int</span>* P,re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">         re <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,N=<span class="number">1</span>;</span><br><span class="line">         calc(P,l,mid);</span><br><span class="line">         calc(P,mid+<span class="number">1</span>,r);</span><br><span class="line">         <span class="keyword">for</span>(;N&lt;r-l+<span class="number">2</span>;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">         F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mid-l+<span class="number">1</span>;++i)</span><br><span class="line">             F[i]=P[l+i<span class="number">-1</span>];</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=mid-l+<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">             F[i]=<span class="number">0</span>;</span><br><span class="line">         NTT(F,N,<span class="number">0</span>);</span><br><span class="line">         G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-mid;++i)</span><br><span class="line">             G[i]=P[mid+i];</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=r-mid+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">             G[i]=<span class="number">0</span>;</span><br><span class="line">         NTT(G,N,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">             F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">         NTT(F,N,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-l+<span class="number">1</span>;++i)</span><br><span class="line">             P[l+i<span class="number">-1</span>]=F[i];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">     unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">             unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">         inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         cltstream::read(A[i]);</span><br><span class="line">     B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">         cltstream::read(B[i]);</span><br><span class="line">     cltstream::read(t);</span><br><span class="line">     calc(A,<span class="number">1</span>,n);</span><br><span class="line">     calc(B,<span class="number">1</span>,m);</span><br><span class="line">     Ln(A,F,t+<span class="number">1</span>);</span><br><span class="line">     Ln(B,G,t+<span class="number">1</span>);</span><br><span class="line">     F[<span class="number">0</span>]=n;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">         F[i]=<span class="number">1L</span>L*F[i]*j%mod;</span><br><span class="line">     G[<span class="number">0</span>]=m;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">         G[i]=<span class="number">1L</span>L*G[i]*j%mod;</span><br><span class="line">     re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;N&lt;(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=t+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">         F[i]=G[i]=<span class="number">0</span>;</span><br><span class="line">     NTT(F,N,<span class="number">0</span>);</span><br><span class="line">     NTT(G,N,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">     NTT(F,N,<span class="number">1</span>);</span><br><span class="line">     N=cltpow(<span class="number">1L</span>L*n*m%mod,mod<span class="number">-2</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=N;i&lt;=t;++i,j=<span class="number">1L</span>L*j*i%mod)</span><br><span class="line">         cltstream::write(<span class="number">1L</span>L*F[i]*j%mod,<span class="number">10</span>);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流学习笔记Part II」总之XJB写点啥（</title>
    <url>/network-flow-learning-notes-pt2/</url>
    <content><![CDATA[<p>Part I 大概是<a href="/something-about-network-flow-learning-notes/">这篇</a>。</p>
<p>去郑州的时候讲的网络流部分。</p>
<p>什么你说游记？咕咕咕。</p>
<a id="more"></a>
<h3 id="一种似乎没有名字的二元组模型"><a href="#一种似乎没有名字的二元组模型" class="headerlink" title="一种似乎没有名字的二元组模型"></a>一种似乎没有名字的二元组模型</h3><h4 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h4><p>你有两台机器和 $n$ 个任务。用第一台机器完成第 $i$ 个任务需要付出 $a_{i}$ 的代价，用第二台完成需要 $b_{i}$ 的代价。你有 $m$ 个三元组<del>（虽然说不是标题说的二元组不过不要在意这些细节）</del>，每一个三元组形如 $(x,y,c)$，意思是如果 $x$ 和 $y$ 两个任务在不同的机器上完成需要额外付出 $c$ 的代价。你需要完成这 $n$ 个任务，并最小化代价和。</p>
<p>我们都知道最小割 = 最大流。因此在一些题目中，如果无法将问题抽象成最大流问题，我们可以试着抽象成最小割问题。</p>
<p>对于任务 $i$，连边 $(S,i,a_{i}),(i,T,b_{i})$。对于一个三元组 $(x,y,c)$，连边 $(x,y,c),(y,x,c)$。</p>
<p>割断 $(S,i,a_{i})$ 意味着任务 $i$ 在第一台机器上完成，割断 $(i,T,b_{i})$ 意味着任务 $i$ 在第二台机器上完成。</p>
<p>首先很明显的是，同时割断 $(S,i,a_{i})$ 和 $(i,T,b_{i})$ 一定不是最优的决策。因此一个任务只会在一台机器上被完成。</p>
<p>对于一个三元组 $(x,y,c)$，如果我们同时割断 $(S,x,a_{x})$ 和 $(S,y,a_{y})$，$S$ 与 $T$ 直接就断开了，这样我们的代价是 $a_{x}+a_{y}$。同时割断 $(x,T,b_{x})$ 和 $(y,T,b_{y})$ 也是类似的。</p>
<p>如果说我们同时割断 $(S,x,a_{x})$ 和 $(y,T,b_{y})$，图上仍存在 $\{(S,y,a_{y}),(y,x,c),(x,T,b_{x})\}$ 这样一条路径，我们还需要割断 $(y,x,c)$，这样我们的代价是 $a_{x}+b_{y}+c$。同时割断 $(x,T,b_{x})$ 和 $(S,y,a_{y})$ 也是类似的。</p>
<h4 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h4><p>你有两台机器和 $n$ 个任务。用第一台机器完成第 $i$ 个任务需要付出 $a_{i}$ 的代价，用第二台完成需要 $b_{i}$ 的代价。你有 $m$ 个六元组，每一个六元组形如 $(x,y,c_{1},c_{2},c_{3},c_{4})$，意思是你需要为 $x$ 和 $y$ 这两个任务付出一些额外代价：</p>
<ul>
<li>如果任务 $x$ 在第一台机器上完成，任务 $y$ 在第一台机器上完成，这个额外代价是 $c_{1}$。</li>
<li>如果任务 $x$ 在第二台机器上完成，任务 $y$ 在第二台机器上完成，这个额外代价是 $c_{2}$。</li>
<li>如果任务 $x$ 在第一台机器上完成，任务 $y$ 在第二台机器上完成，这个额外代价是 $c_{3}$。</li>
<li>如果任务 $x$ 在第二台机器上完成，任务 $y$ 在第一台机器上完成，这个额外代价是 $c_{4}$。</li>
</ul>
<p>你需要完成这 $n$ 个任务，并最小化代价和。</p>
<p>首先仍然是连边 $(S,i,a_{i}),(i,T,b_{i})$。对于每一个六元组，连边 $(S,x,A),(S,y,B),(x,T,C),(y,T,D),(x,y,E),(y,x,F)$。我们发现</p>
<ul>
<li>如果任务 $x$ 在第一台机器上完成，任务 $y$ 在第一台机器上完成，我们需要割断 $(S,x,A),(S,y,B)$，付出 $A+B$ 的代价。</li>
<li>如果任务 $x$ 在第二台机器上完成，任务 $y$ 在第二台机器上完成，我们需要割断 $(x,T,C),(y,T,D)$，付出 $C+D$ 的代价。</li>
<li>如果任务 $x$ 在第一台机器上完成，任务 $y$ 在第二台机器上完成，我们需要割断 $(S,x,A),(y,T,D),(y,x,F)$，付出 $A+D+F$ 的代价。</li>
<li>如果任务 $x$ 在第二台机器上完成，任务 $y$ 在第一台机器上完成，我们需要割断 $(S,y,B),(x,T,C),(x,y,E)$，付出 $B+C+E$ 的代价。</li>
</ul>
<p>因此我们列出如下的方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
&A+B=c_{1}&(1)\\
&C+D=c_{2}&(2)\\
&A+D+F=c_{3}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;&(3)\\
&B+C+E=c_{4}&(4)
\end{cases}</script><p>因为我们要将问题转化成最大流问题，首先想到，我们要有 $A,B,C,D,E,F\geqslant 0$。注意到，$(S,x,A)$ 和 $(x,T,C)$ 中有且仅有一条边会出现在最小割集中，因此我们可以将 $A$ 和 $C$ 同时加上一个数，求出最小割后在答案中减去。$B$ 和 $D$ 也可以类似处理。</p>
<p>需要注意的是，$E$ 和 $F$ 不能被这样处理，因为我们不能确定它们在答案中产生了几次贡献。</p>
<p>$(3)+(4)-(1)-(2)$，我们得到</p>
<script type="math/tex; mode=display">
E+F=c_{3}+c_{4}-c_{1}-c_{2}</script><p>定义 $K=c_{3}+c_{4}-c_{1}-c_{2}$，当 $K\geqslant 0$ 时它有意义，我们直接令 $E=F=\cfrac{K}{2}$ 即可。</p>
<p>剩下的四个量随便给几个值，好算就行。</p>
<p>其实就算 $K\lt 0$ 有时也是可以做的，但是我太菜了不会（</p>
<p>因为太菜了所以没有图（</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="「国家集训队」happiness"><a href="#「国家集训队」happiness" class="headerlink" title="「国家集训队」happiness"></a><a href="https://www.luogu.org/problemnew/show/P1646">「国家集训队」happiness</a></h5><p>题目要求最大化总收益，我们可以先将所有数取相反数，然后最小化总代价。</p>
<p>令位置 $i$ 选文的单独收益是 $a_{i}$，选理的单独收益是 $b_{i}$，连边 $(S,i,-a_{i}),(i,T,-b_{i})$。</p>
<p>考虑一对相邻的位置，他们都选文的额外收益是 $v_{1}$，都选理的额外收益是 $v_{2}$，列出方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
&A+B=-v_{1}\\
&C+D=-v_{2}\\
&A+D+E=0\\
&B+C+E=0
\end{cases}
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
\begin{cases}
&A=-\cfrac{v_{1}}{2}\\
&B=-\cfrac{v_{1}}{2}\\
&C=-\cfrac{v_{2}}{2}\\
&D=-\cfrac{v_{2}}{2}\\
&E=\cfrac{v_{1}+v_{2}}{2}
\end{cases}</script><p>为了避免浮点数，我们把上面所有边的容量乘以 $2$，包括 $(S,i,-a_{i}),(i,T,-b_{i})$，最后再除回来。</p>
<p>然后，为了避免负数，我们将 $A,B,C,D$ 加上 $v_{1}+v_{2}$，把边 $(S,i,-2a_{i}),(i,T,-2b_{i})$ 的容量加上 $2a_{i}+2b_{i}$，最后再减回来。</p>
<p>总结一下就是，对于一个位置 $i$，连边 $(S,i,2b_{i}),(i,T,2a_{i})$。对于一对相邻位置 $x,y$，连边 $(S,x,v_{2}),(S,y,v_{2}),(x,T,v_{1}),(y,T,v_{1}),(x,y,v_{1}+v_{2}),(y,x,v_{1}+v_{2})$。</p>
<script type="math/tex; mode=display">
\text{Ans}=\sum(a_{i}+b_{i})+\sum(v_{1}+v_{2})-\cfrac{\text{MinCut}(S,T)}{2}</script><p>但是我的<a href="https://www.luogu.org/recordnew/show/16563258">代码</a> 不知道为什么写炸了（</p>
<p>反正这个式子应该是没问题的（</p>
<p>那么告辞吧（</p>
<h3 id="闭合子图"><a href="#闭合子图" class="headerlink" title="闭合子图"></a>闭合子图</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于一个有向图 $G$，它的一个闭合子图指的是一个顶点集合 $V$，满足 $V\subset G$，且</p>
<script type="math/tex; mode=display">
\forall u\in V\wedge(u,v)\in G,v\in V</script><p>其中 $|V|$ 最大的 $V$ 被称为 $G$ 的最大闭合子图。</p>
<p>如果 $G$ 中的点有点权，$\sum_{u\in V}w(u)$ 最大的 $V$ 被称为 $G$ 的最大权闭合子图。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首先，我们还是需要将所有点权取相反数，转为求最小权闭合子图。</p>
<p>对于 $G$ 中的一个点 $x$，割断与 $S$ 之间的边表示 $x\notin V$，割断与 $T$ 之间的边表示 $x\in V$。对于 $G$ 中的一条边 $(x,y)$，如果 $x\in V$，那么一定有 $y\in V$。我们可以认为，如果令 $x\in V$，$y\notin V$，需要付出 $+\infty$ 的代价。由此列出方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
&A+B=0\\
&C+D=-w(x)-w(y)\\
&A+D+F=-w(x)\\
&B+C+E=-w(y)+\infty
\end{cases}
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
\begin{cases}
&A=0\\
&B=0\\
&C=-w(x)\\
&D=-w(y)\\
&E=+\infty\\
&F=0
\end{cases}</script><p>于是，去掉所有容量为 $0$ 的边，我们得到 $(x,T,-w(x)),(y,T,-w(y)),(x,y,+\infty)$ 这三条边。如果 $w(x)\geqslant 0$，我们需要把边 $(S,x,0),(x,T,-w(x))$ 的容量都加上 $w(x)$，相当于是把 $(x,T,-w(x))$ 换成了 $(S,x,w(x))$。</p>
<p>总结一下就是，对于原图中的一个正权点 $x$，连边 $(S,x,w(x))$，对于原图中的一个负权点 $x$，连边 $(x,T,-w(x))$。对于原图中的一条边 $(x,y)$，连边 $(x,y,+\infty)$。</p>
<script type="math/tex; mode=display">
\text{Ans}=\sum_{w(x)\geqslant 0}w(x)-\text{MinCut}(S,T)</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数学习笔记</title>
    <url>/generating-function-learning-notes/</url>
    <content><![CDATA[<p>又被 wzx 吊打了 QAQ</p>
<p>来写一篇生成函数吧 QAQ</p>
<p><del>本文全部内容抄袭自<a href="https://www.cnblogs.com/asuldb/p/10533453.html">这篇 blog</a> 和<a href="https://www.cnblogs.com/asuldb/p/10534860.html">这篇 blog</a></del></p>
<a id="more"></a>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个数列 $\{a_{0},a_{1},\cdots,a_{n}\}$ 的生成函数 $f(x)$ 被定义为</p>
<script type="math/tex; mode=display">
f(x)=\sum_{i=0}^{n}a_{i}x^{i}</script><p>就这样（</p>
<h3 id="封闭表达式"><a href="#封闭表达式" class="headerlink" title="封闭表达式"></a>封闭表达式</h3><p>但是这个形式比较玄乎，不便于我们推式子。特别是当我们需要求一个无穷数列的生成函数时。于是我们希望能够进一步化简。</p>
<p>比如说，当 $a_{n}=c^{n}$，即这个数列是 $\{1,c,c^{2},\cdots\}$ 时，它的生成函数是</p>
<script type="math/tex; mode=display">
f(x)=\sum_{i=0}^{n}c^{i}x^{i}=\cfrac{1-(cx)^{n+1}}{1-cx}</script><p>就是一个简单地等比数列求和。很明显，当 $x\in(-1,1)$ 时，如果 $n$ 趋向于正无穷大，则上式等于 $\cfrac{1}{1-cx}$。</p>
<p>我们现在来分析一下斐波那契数列的生成函数。</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\
&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}
\end{aligned}</script><p>为了方便，我们定义当 $n\lt 0$ 时，$F_{n}=0$。</p>
<p>然后我们发现 $F_{1}=F_{0}+F_{-1}=0+0=0$，于是我们再加上一项 $[i=1]$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2}+[i=1])x^{i}\\
&=x+\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}\\
&=x+x\sum_{i=0}^{n}F_{i-1}x^{i-1}+x^{2}\sum_{i=0}^{n}F_{i-2}x^{i-2}\\
&=x+xF(x)+x^{2}F(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">
F(x)=\cfrac{x}{1-x-x^{2}}</script><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><p>那么问题来了，我们闲着没事求这个生成函数有什么用啊。</p>
<p>求通项公式。</p>
<p>我们知道形如 $a_{n}=c^{n}$ 的数列的生成函数等于 $\cfrac{1}{1-cx}$，我们可以试着将 $\cfrac{x}{1-x-x^{2}}$ 分解成两个类似形式的分式的和。</p>
<p>设</p>
<script type="math/tex; mode=display">
1-x-x^{2}=(1-ax)(1-bx)</script><script type="math/tex; mode=display">
\begin{cases}
&a+b=1\\
&ab=-1
\end{cases}
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
\begin{cases}
&a=\cfrac{1+\sqrt{5}}{2}\\
&b=\cfrac{1-\sqrt{5}}{2}
\end{cases}</script><p>再设</p>
<script type="math/tex; mode=display">
\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{x}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><script type="math/tex; mode=display">
\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><p>于是</p>
<script type="math/tex; mode=display">
c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx=x</script><p>等式右边没有常数项，因此 $c+d$ 应当是 $0$。再继续接下去，我们得到</p>
<script type="math/tex; mode=display">
\begin{cases}
&c=\cfrac{1}{\sqrt{5}}\\
&d=-\cfrac{1}{\sqrt{5}}
\end{cases}</script><p>于是</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1+\sqrt{5}}{2}x}-\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1-\sqrt{5}}{2}x}\\
&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}x^{i}-\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}x^{i}\\
&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}\right)x^{i}
\end{aligned}</script><p>结论就是</p>
<script type="math/tex; mode=display">
F_{n}=\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{n}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{n}\right)</script><h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\sum_{i=0}^{n}C_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}+[i=0]\right)x^{i}\\
&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i}\\
&=1+x\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i-1}\\
&=1+xF^{2}(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">
xF^{2}(x)-F(x)+1=0</script><script type="math/tex; mode=display">
F(x)=\cfrac{1\pm\sqrt{1-4x}}{2x}</script><script type="math/tex; mode=display">
2xF(x)=1\pm\sqrt{1-4x}</script><p>当 $x=0$ 时</p>
<script type="math/tex; mode=display">
2\times 0\times 1=1\pm1</script><p>因此根号前应该取负。至此我们得到</p>
<script type="math/tex; mode=display">
F(x)=\cfrac{1-\sqrt{1-4x}}{2x}</script><p>那么通项公式呢？</p>
<p>根据<del>一个我抄过来的</del>广义二项式定理，我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sqrt{1-4x}&=1+\sum_{i=1}^{n}\cfrac{(-1)^{i-1}}{i2^{2i-1}}C_{2i-2}^{i-1}(-4x)^{i}\\
&=1+2\sum_{i=1}^{n}\cfrac{(-1)^{2i-1}}{i}C_{2i-2}^{i-1}x^{i}\\
&=1-2\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\cfrac{1-\sqrt{1-4x}}{2x}\\
&=\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i-1}\\
&=\sum_{i=0}^{n}\cfrac{1}{i+1}C_{2i}^{i}x^{i}
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">
C_{n}=\cfrac{1}{n+1}C_{2n}^{n}</script><h4 id="默慈金数"><a href="#默慈金数" class="headerlink" title="默慈金数"></a>默慈金数</h4><p><del>等会默慈金数是个什么鬼？（</del></p>
<p>默慈金数一般记为 $M_{n}$，被定义为在均匀分布在一个圆上的 $n$ 个有编号的点之间连出彼此不相交的弦的方案数。一根弦也不连也是一种方案。</p>
<script type="math/tex; mode=display">
M_{0}=1</script><script type="math/tex; mode=display">
M_{n}=M_{n-1}+\sum_{i=0}^{n-2}M_{i}M_{n-i-2}</script><script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\sum_{i=0}^{n}M_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}+[i=0]\right)x^{i}\\
&=1+\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}\right)x^{i}\\
&=1+xF(x)+x^{2}F^{2}(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">
x^{2}F^{2}(x)+(x-1)F(x)+1=0</script><script type="math/tex; mode=display">
F(x)=\cfrac{1-x\pm\sqrt{1-2x-3x^{2}}}{2x^{2}}</script><p>总之根号前应该取负（</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\cfrac{1-x-\sqrt{1-2x-3x^{2}}}{2x^{2}}\\
&=\cfrac{2-2x-2\sqrt{1-2x-3x^{2}}}{4x^{2}}\\
&=\cfrac{(1+x)-2\sqrt{(1+x)(1-3x)}+(1-3x)}{4x^{2}}\\
&=\cfrac{(\sqrt{1+x}-\sqrt{1-3x})^{2}}{4x^{2}}
\end{aligned}</script><p>woc 这什么鬼东西溜了溜了。</p>
<p><del>留作课后习题，哪位 dalao 推出来了让我 % 一 %（</del></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「TJOI2015」概率论"><a href="#「TJOI2015」概率论" class="headerlink" title="「TJOI2015」概率论"></a><a href="https://www.luogu.org/problemnew/show/P3978">「TJOI2015」概率论</a></h4><p>首先很明显，互不同构的二叉树一共 $C_{n}$ 棵，其中 $C_{n}$ 是卡特兰数。现在我们希望求出这些二叉树的叶子结点总数，我们记为 $F_{n}$。不难发现</p>
<script type="math/tex; mode=display">
F_{0}=0</script><script type="math/tex; mode=display">
F_{1}=1</script><script type="math/tex; mode=display">
F_{n}=2\sum_{i=0}^{n-1}C_{i}F_{n-i-1}+[i=1]</script><script type="math/tex; mode=display">
\begin{aligned}
F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(2\sum_{j=0}^{i-1}C_{j}F_{i-j-1}+[i=1]\right)x^{i}\\
&=x+2\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}F_{i-j-1}\right)x^{i}\\
&=x+2xCF(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">
F(x)=\cfrac{x}{1-2xC(x)}</script><p>其中 $C(x)$ 是卡特兰数的生成函数，我们知道它的值是 $\cfrac{1-\sqrt{1-4x}}{2x}$，所以说</p>
<script type="math/tex; mode=display">
F(x)=\cfrac{x}{\sqrt{1-4x}}</script><p><del>然后我又不会了（</del></p>
<script type="math/tex; mode=display">
(xC(x))^{\prime}=\cfrac{1}{\sqrt{1-4x}}=\cfrac{F(x)}{x}</script><script type="math/tex; mode=display">
(xC(x))^{\prime}=\sum_{i=0}^{n}(i+1)C_{i}x^{i}</script><script type="math/tex; mode=display">
\cfrac{F(x)}{x}=\sum_{i=0}^{n}F_{i}x^{i-1}=\sum_{i=-1}^{n}F_{i+1}x^{i}</script><p>我们就得到</p>
<script type="math/tex; mode=display">
iC_{i-1}=F_{i}</script><p>于是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{Ans}&=\cfrac{F_{n}}{C_{n}}\\
&=\cfrac{nC_{n-1}}{C_{n}}\\
&=\cfrac{C_{2n-2}^{n-1}}{\cfrac{1}{n+1}C_{2n}^{n}}\\
&=\cfrac{\cfrac{(2n-2)!}{(n-1)!(n-1)!}}{\cfrac{(2n)!}{n!(n+1)!}}\\
&=\cfrac{(2n-2)!n!(n+1)!}{(n-1)!(n-1)!(2n)!}\\
&=\cfrac{n(n+1)}{2(2n-1)}
\end{aligned}</script><h4 id="「国家集训队」整数的-lqp-拆分"><a href="#「国家集训队」整数的-lqp-拆分" class="headerlink" title="「国家集训队」整数的 lqp 拆分"></a><a href="https://www.luogu.org/problemnew/show/P4451">「国家集训队」整数的 lqp 拆分</a></h4><p>其实这道题我几个月前推出来了一个 $O(n^{2})$ 的式子（</p>
<p>如果记答案为 $G_{n}$，我们有</p>
<script type="math/tex; mode=display">
G_{n}=\sum_{i=0}^{n}F_{i}G_{n-i}</script><p>其中 $F_{n}$ 是斐波那契数。为了方便，我们强行定义 $G_{0}=1$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(x)&=\sum_{i=0}^{n}G_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}+[i=0]\right)x^{i}\\
&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}\right)x^{i}\\
&=1+FG(x)
\end{aligned}</script><p>其中 $F(x)$ 是斐波那契数的生成函数。于是</p>
<script type="math/tex; mode=display">
G(x)=\cfrac{1}{1-F(x)}=\cfrac{1-x-x^{2}}{1-2x-x^{2}}=1+\cfrac{x}{1-2x-x^{2}}</script><p>多出来的那个 $1$ 是 $G_{0}$，可以无视掉。</p>
<p>设</p>
<script type="math/tex; mode=display">
(1-ax)(1-bx)=1-2x-x^{2}</script><p>（中间过程略）</p>
<script type="math/tex; mode=display">
\begin{cases}
&a=1+\sqrt{2}\\
&b=1-\sqrt{2}
\end{cases}</script><p>再设</p>
<script type="math/tex; mode=display">
\cfrac{c}{1-(1+\sqrt{2})x}+\cfrac{d}{1-(1-\sqrt{2})x}=\cfrac{x}{1-2x-x^{2}}</script><p>（中间过程略 $\times 2$）</p>
<script type="math/tex; mode=display">
\begin{cases}
&c=\cfrac{1}{2\sqrt{2}}\\
&d=-\cfrac{1}{2\sqrt{2}}
\end{cases}</script><p>于是</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(x)&=1+\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1+\sqrt{2})x}-\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1-\sqrt{2})x}\\
&=1+\sum_{i=0}^{n}\cfrac{1}{2\sqrt{2}}\left((1+\sqrt{2})^{i}-(1-\sqrt{2})^{i}\right)x^{i}
\end{aligned}</script><p>最终结论就是</p>
<script type="math/tex; mode=display">
G_{n}=\cfrac{(1+\sqrt{2})^{n}-(1-\sqrt{2})^{n}}{2\sqrt{2}}</script><p>根据暴力枚举，我们得出 $\sqrt{2}\equiv 59713600\pmod{10^{9}+7}$。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>「Ynoi2014D2T2」人人本着正义之名</title>
    <url>/luogu-p5066-solution-not/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5066">传送门</a></p>
<p><del>一人血书放大常数 Splay 一条生路。</del></p>
<a id="more"></a>
<p>之前 Ynoi2014 唯一一道没公开的题。</p>
<p>写个 $O(nm)$ 的暴力就有 30 了。</p>
<p>我们来分析一下操作 $3,4,5,6$ 都在干些啥。</p>
<p>以操作 $3$ 为例，如果在操作前，有一个位置的数字是 $1$，它左边是一个 $0$，操作完之后那个 $0$ 就会变成 $1$。除此之外不会再有其它改变。</p>
<p>仔细想象一下这个过程，我们发现这实际上是将操作区间内所有极长连续 $1$ 的左端点向左扩展了 $1$ 位，所有极长连续 $0$ 的右端点向左收缩了 $1$ 位。</p>
<p>操作 $4,5,6$ 也是类似的。</p>
<p>那么我们写一棵珂朵莉树就可以获得 50 分了。</p>
<p>但实际上 emmmmm……我的珂朵莉树可能和别人不一样（</p>
<p>别人的珂朵莉树：</p>
<p><img src="/images/TIM截图20190319161404.png" alt=""></p>
<p>我的珂朵莉树：</p>
<p><img src="/images/TIM截图20190319161900.png" alt=""></p>
<p>那么满分做法？</p>
<p>手写平衡树。没了。</p>
<p><del>虽然这么说，但是 lxl 都写了将近 10KB（</del></p>
<p>总体思路就是，手写平衡树维护所有极长连续段的长度，并不需要维护端点因为可以算出来，单独维护还麻烦。每个节点维护子树内极长连续 $0$ 和 $1$ 的数量 、 长度最小值，以及连续段的长度变化量（标记）。修改时判断一下如果最小值变成了 $0$，那么就暴力重构。<del>反正 lxl 说因为有前两个操作的存在这么做时间复杂度是对的。</del></p>
<p>首先有一个问题就是，这样做每个节点维护的必须要是<strong>极长连续段</strong>。想象一下，如果有两个相邻的节点值都是 $1$，我们进行一次操作 $3$ 或 $4$，会发生什么？</p>
<p>两个节点的长度都加了 $1$。然后整个序列莫名其妙多出来 $1$ 个数。再然后您就 WA 了。</p>
<p>然后就是各种各样乱七八糟的细节。虽然这么说但好像没什么可列举的了。</p>
<p>然后您按照上面的思路打完四五百行的代码之后交上去一看：</p>
<p><img src="/images/TIM截图20190319171721.png" alt=""></p>
<p>虽然说暴力重构的时间复杂度<del>应该</del>是对的，但是不难发现它常数大啊。</p>
<p>但是如果不重构，合并相邻的连续段就会变得非常麻烦。</p>
<p>结论就是这题不可写，散了吧散了吧。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>珂朵莉树</tag>
        <tag>毒瘤</tag>
        <tag>Ynoi</tag>
        <tag>2014</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>来扯点多项式？</title>
    <url>/polynomial-triangle-function/</url>
    <content><![CDATA[<p>在 luogu 上看到了多项式三角函数 / 反三角函数的板子。</p>
<p>不过还没加进公共题库，没人交，于是不敢交（</p>
<p>于是来口胡一波吧。</p>
<a id="more"></a>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>总之就是求 $\sin F(x)$，$\cos F(x)$，其他的三角函数都可以用这两个凑出来因此不需要单独讨论。</p>
<p>虽然说我们也有 $\cos x=\sin(x+\cfrac{\pi}{2})$，但是问题来了，模意义下怎么表示 $\pi$（</p>
<p>首先我们有欧拉公式</p>
<script type="math/tex; mode=display">
e^{ix}=\cos x+i\sin x</script><p>于是</p>
<script type="math/tex; mode=display">
e^{iF}=\cos F+i\sin F</script><p>根据定义，$i^{2}\equiv -1\equiv 998244352\pmod{998244353}$。而 $998244352$ 是模 $998244353$ 的二次剩余，说人话就是这样的 $i$ 是存在的。</p>
<p>但是问题来了，我们该怎么分离 $\sin$ 和 $\cos$？</p>
<p>我们还需要有</p>
<script type="math/tex; mode=display">
e^{i(-F)}=\cos F-i\sin F</script><p>很明显地</p>
<script type="math/tex; mode=display">
\sin F=\cfrac{e^{iF}-e^{i(-F)}}{2i}</script><script type="math/tex; mode=display">
\cos F=\cfrac{e^{iF}+e^{i(-F)}}{2}</script><h3 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h3><p>求 $\arcsin F(x)$，$\arccos F(x)$。</p>
<p>我们令答案的多项式为 $G(x)$。</p>
<p>我们都知道</p>
<script type="math/tex; mode=display">
\sin^{2}x+\cos^{2}x=1</script><p>于是知道了 $\sin G$ 或者是 $\cos G$，我们就可以推出另一项，然后再根据</p>
<script type="math/tex; mode=display">
e^{iG}=\cos G+i\sin G</script><script type="math/tex; mode=display">
G=\cfrac{\ln(\cos G+i\sin G)}{i}</script><p>就可以算出 $G$ 了。</p>
<p>那么 $\arctan F(x)$？</p>
<script type="math/tex; mode=display">
\sin^{2}G+\cos^{2}G=1</script><p>因为 $\tan G$ 有意义，所以 $\cos G\neq0$。</p>
<script type="math/tex; mode=display">
\tan^{2}G+1=\sec^{2}G</script><script type="math/tex; mode=display">
\cos G=\cfrac{1}{\sqrt{\tan^{2}G+1}}</script><p>但是看着就麻烦（</p>
<blockquote>
<p>Updated on 2019-03-18</p>
<p>上面这种做法大概不是正解，因为这样需要对一个常数项不是 $1$，最低次非零系数也不是 $1$ 的多项式求平方根，很明显这需要二次剩余<del>，而且我不会</del>。</p>
<p>考虑倍增。</p>
<script type="math/tex; mode=display">
\sin G_{0}-F\equiv 0\pmod{x^{t}}</script><script type="math/tex; mode=display">
\sin G-F\equiv 0\pmod{x^{2t}}</script><script type="math/tex; mode=display">
G\equiv G_{0}-\cfrac{\sin G_{0}-F}{(\sin G_{0}-F)^{\prime}}\equiv G_{0}-\cfrac{\sin G_{0}-F}{\cos G_{0}}\pmod{x^{2t}}</script><p>然后是 $\arccos$。</p>
<script type="math/tex; mode=display">
G\equiv G_{0}-\cfrac{\cos G_{0}-F}{(\cos G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\cos G_{0}-F}{\sin G_{0}}\pmod{x^{2t}}</script><p>然后是 $\arctan$。不过我不怎么会求导 $\tan$（</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\tan x)^{\prime}&=(\cfrac{\sin x}{\cos x})^{\prime}\\
&=\cfrac{(\sin x)^{\prime}}{\cos x}+\sin x(\cfrac{1}{\cos x})^{\prime}\\
&=1+\tan^{2}x
\end{aligned}</script><script type="math/tex; mode=display">
G\equiv G_{0}-\cfrac{\tan G_{0}-F}{(\tan G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\tan G_{0}-F}{1+\tan^{2} G_{0}}\pmod{x^{2t}}</script><p>这大概不能写（</p>
</blockquote>
<h3 id="多项式-GCD-LCM"><a href="#多项式-GCD-LCM" class="headerlink" title="多项式 GCD/LCM"></a>多项式 GCD/LCM</h3><p>既然多项式能够整除和取模，那么 GCD 和 LCM 一定也是可以算的吧！</p>
<p>……应该可以吧（</p>
]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>三角函数</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组自闭笔记</title>
    <url>/suffix-array-learning-notes/</url>
    <content><![CDATA[<p>省选前最后两周。同时也是退役前最后两周。</p>
<p><del>在 wzx 的鼓动下</del>开了字符串。</p>
<p>然后自闭了。</p>
<a id="more"></a>
<p>以下，我们约定，$S_{l,r}$ 表示字符串 $S$ 下标为 $[l,r]$ 的子串，下标从 $1$ 开始。超过串长的部分用小于其他所有字符的空字符填充。</p>
<h3 id="后缀排序"><a href="#后缀排序" class="headerlink" title="后缀排序"></a><a href="https://www.luogu.org/problemnew/show/P3809">后缀排序</a></h3><p><del><code>std::sort</code>（光速逃</del></p>
<p>不过 <code>std::sort</code> 也是可以做的（</p>
<p>我们发现，这种做法的瓶颈在于比较两个后缀的大小。我们可以二分 +Hash 求出它们的最长公共前缀的长度，然后比较这个前缀后一个字符的大小。这么做的时间复杂度是 $O(n\log^{2}n)$ 的。</p>
<p><del>但是没什么用（</del></p>
<p>然后我们就需要用到后缀数组（Suffix Array）了。</p>
<p>SA 一共有四种构建方式，分别是 $O(n\log n)$ 的倍增，$O(n)$ 的 DC3 和 SA-IS，以及 $O(1)$ 的潮爷排序。<del>但是后三种太高端了我都不会（</del></p>
<p>假设对于每一个位置 $i$，我们已经按照 $S_{i,i+k-1}$ 的大小排好了序，并且有了一个排名。我们以 $i$ 的排名为第一关键字，$i+k$ 的排名为第二关键字，排一遍序，整个字符串就被按照 $S_{i,i+2k-1}$ 的大小排好了序。当所有位置的排名都不同时，说明整个过程可以结束了。</p>
<p><del>但是问题来了，排一遍序不是 $O(n\log n)$ 的吗（</del></p>
<p><del>我们有基数排序啊（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[i]：原字符串</span></span><br><span class="line"><span class="comment">// fst[i]：后缀 i 的第一关键字</span></span><br><span class="line"><span class="comment">// snd[i]：第二关键字排名为 i 的后缀</span></span><br><span class="line"><span class="comment">// tak[i]：桶</span></span><br><span class="line"><span class="comment">// sa[i]：排名为 i 的后缀</span></span><br><span class="line"><span class="comment">// 一开始时以首字符为第一关键字，位置为第二关键字排序</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">     ++tak[fst[i]=s[i]];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">122</span>;++i)</span><br><span class="line">     tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">     <span class="comment">// 处理桶内前缀和，用来求出第一关键字为 i 的后缀的最大可能排名</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">     sa[tak[fst[i]]--]=i;</span><br><span class="line">     <span class="comment">// 第一关键字相同时，第二关键字排名越大总排名越大，因此倒序枚举</span></span><br><span class="line">     <span class="comment">// 因为第二关键字是位置，所以 snd[i]=i</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> mx=<span class="number">122</span>,k=<span class="number">1</span>;;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">     re <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         snd[++cnt]=i;</span><br><span class="line">         <span class="comment">// (n-k,n]的这些后缀没有第二关键字，因此排名最靠前</span></span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         <span class="keyword">if</span>(sa[i]&gt;k)</span><br><span class="line">             snd[++cnt]=sa[i]-k;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">         tak[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         ++tak[fst[i]];</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">         tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">         sa[tak[fst[snd[i]]]--]=snd[i];</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         snd[i]=fst[i];</span><br><span class="line">         <span class="comment">// 因为要生成下一轮排序时的第一关键字，把 fst 里的信息先扔到 snd 里</span></span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         fst[sa[i]]=fst[sa[i<span class="number">-1</span>]]+(snd[sa[i]]!=snd[sa[i<span class="number">-1</span>]]||snd[sa[i]+k]!=snd[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">         <span class="comment">// 如果当前后缀与前一个后缀相同则共用排名，否则 +1</span></span><br><span class="line">     <span class="keyword">if</span>(fst[sa[n]]==n)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         mx=fst[sa[n]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去非常的绕（</p>
<p>最后直接输出 <code>sa</code> 数组即可。</p>
<h3 id="rnk-数组"><a href="#rnk-数组" class="headerlink" title="rnk 数组"></a><code>rnk</code> 数组</h3><p><code>rnk[i]</code> 表示排名为 $i$ 的后缀。</p>
<p>不难发现 <code>rnk[sa[i]]=sa[rnk[i]]=i</code>。</p>
<h3 id="het-数组"><a href="#het-数组" class="headerlink" title="het 数组"></a><code>het</code> 数组</h3><p>大概算是 SA 的重点。</p>
<p>令 <code>lcp(x,y)</code> 表示 $x,y$ 两个后缀的最长公共前缀（Longest Common Prefix）的长度。</p>
<p><code>het[i]</code> 就被定义为 <code>lcp(sa[i],sa[i-1])</code>。<code>het[1]=0</code>。</p>
<p>不难发现 <code>lcp(x,z)=min(lcp(x,y),lcp(y,z))(x&lt;y&lt;z)</code>，<code>lcp(x,y)=min{lcp(i,i-1)}=min{het[i]}(rnk[x]&lt;i&lt;=rnk[y])</code>。</p>
<p><del>那么问题来了，怎么求呢（</del></p>
<p>首先我们是肯定不能暴力枚举的。</p>
<p>二分 +Hash？太麻烦而且复杂度不够优秀（</p>
<p>SA 的 <code>het</code> 数组有一个性质，就是 <code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p>
<p>我们只考虑 <code>het[rnk[i-1]]&gt;0</code> 时的情况。</p>
<p>令 <code>k=sa[rnk[i-1]-1]</code>，<code>lcp(i-1,k)=het[rnk[i-1]]</code>，又因为后缀 $i$ 是后缀 $i-1$ 删去首字符得到的，后缀 $k+1$ 是后缀 $k$ 删去首字符得到的，从而 <code>lcp(i,k+1)=het[rnk[i-1]]-1</code>。</p>
<p>后缀 $i-1$ 比后缀 $k$ 大，删去首字符后，后缀 $i$ 肯定也比后缀 $k+1$ 大。根据 <code>lcp</code> 的性质我们有 <code>lcp(i,sa[rnk[i]-1])&gt;=lcp(i,k+1)</code>，也即 <code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p>
<p>利用这个性质，我们就可以在 $O(n)$ 的时间复杂度内求出 <code>het</code> 数组了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">     <span class="keyword">if</span>(rnk[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">         j-=!!j;</span><br><span class="line">         re <span class="keyword">int</span> pos=sa[rnk[i]<span class="number">-1</span>];</span><br><span class="line">         <span class="keyword">for</span>(;i+j&lt;=n&amp;&amp;pos+j&lt;=n&amp;&amp;s[i+j]==s[pos+j];++j);</span><br><span class="line">         het[rnk[i]]=j;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>然后 SA 就彻底建好了。没错就这么点东西（</p>
<h3 id="板子应用"><a href="#板子应用" class="headerlink" title="板子应用"></a><del>板子</del>应用</h3><h4 id="不同子串个数"><a href="#不同子串个数" class="headerlink" title="不同子串个数"></a>不同子串个数</h4><p>给定一个长度为 $n$ 的字符串 $S$，求其本质不同的子串的数量。</p>
<p>首先有一个很显然的结论是，如果一个字符串是 $S$ 的子串，那么它一定是 $S$ 的若干个排名连续的后缀的公共前缀。</p>
<p>对于排名为 $1$ 和排名为 $2$ 的两个后缀来说，它们一共有 <code>het[2]</code> 个公共前缀；排名为 $2$ 和排名为 $3$ 的两个后缀一共有 <code>het[3]</code> 个公共前缀……</p>
<p>因此，$S$ 的不同子串个数就是它的所有子串个数，$\cfrac{n(n+1)}{2}$，减去所有 <code>het</code> 的和。</p>
<h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>给定 $n$ 个字符串 $S_{1},S_{2},\cdots,S_{n}$，求它们的最长公共子串。</p>
<p>我们首先将这 $n$ 个串拼在一起，中间插入特殊字符将相邻的两个串隔开。然后我们将每个串内部的字符染色，第 $1$ 个串染成颜色 $1$，第 $2$ 个串染成颜色 $2$，用尺取法找出 <code>sa[l],sa[l+1],...,sa[r]</code> 覆盖全部 $n$ 种颜色的区间 $[l,r]$，求出其中 <code>min{het[i]}(l&lt;i&lt;=r)</code> 的最大值即可。</p>
<h4 id="模式串出现次数"><a href="#模式串出现次数" class="headerlink" title="模式串出现次数"></a>模式串出现次数</h4><p>给定 $n$ 个文本串和 $m$ 个模式串，询问每个模式串在 $n$ 个文本串中一共出现了多少次。</p>
<p>首先将所有文本串拼在一起。对于每一个模式串，如果我们能够找到这个长串的任意一个后缀 $x$，使得其拥有这个模式串作为前缀，然后找到一个最小的 $l$ 和一个最大的 $r$，使得 <code>min{het[i]}(l&lt;i&lt;=rnk[x])</code> 和 <code>min{het[i]}(rnk[x]&lt;i&lt;=r)</code> 均大于等于该模式串长度，$r-l+1$ 就是答案。不难看出向两边取 $\min$ 这个操作具有单调性，因此我们可以二分。</p>
<p>但是问题来了，我们该怎么找到这个后缀啊。</p>
<p>一想，把模式串也接到文本串后就可以了。</p>
<p>那如果说模式串出现了互相包含的情况呢？</p>
<p>我们可以再开一个数组 <code>col</code>，<code>col[i]</code> 表示 <code>sa[i]</code> 的首字符是否属于一个文本串。因为这个是静态的，直接一遍前缀和就行。</p>
<h4 id="母串数量"><a href="#母串数量" class="headerlink" title="母串数量"></a>母串数量</h4><p>给定 $n$ 个文本串和 $m$ 个模式串，询问每个模式串在多少个文本串中出现过。也就是说，在同一个文本串中出现多次只记一次。</p>
<p>和上面一样，只不过是最后一步 <code>col[i]</code> 表示 <code>sa[i]</code> 的首字符所属的文本串的编号，对于每一个模式串，二分出区间后数一下颜色种类数。</p>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p>自己找去吧（</p>
<p>然后您就会发现字符串的题一道比一道神仙（</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT987」高橋君</title>
    <url>/at987-solution/</url>
    <content><![CDATA[<p><a href="https://tenka1-2014-final.contest.atcoder.jp/tasks/tenka1_2014_final_d">传送门</a></p>
<p><a href="https://www.luogu.org/problemnew/show/AT987">Luogu</a></p>
<p>第一道 AtCoder 的题解。</p>
<p>联动一波<a href="https://www.cnblogs.com/asuldb/p/10623281.html">asuldb</a>。</p>
<a id="more"></a>
<p>「啊这题怎么做啊。看起来好难啊。不会啊。」</p>
<p>「我们来蒙一个做法吧。比如说就莫队了！」</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{m+1}C_{n}^{i}=\sum_{i=0}^{m}C_{n}^{i}+C_{n}^{m+1}</script><script type="math/tex; mode=display">
\sum_{i=0}^{m}C_{n+1}^{i}=\sum_{i=0}^{m}(C_{n}^{i}+C_{n}^{i-1})=\sum_{i=0}^{m}C_{n}^{i}+\sum_{i=0}^{m-1}C_{n}^{i-1}=2\sum_{i=0}^{m}C_{n}^{i}-C_{n}^{m}</script><p>这是左右端点向右移动的情况。向左移动就反过来。</p>
<p>就这样。</p>
<p>但是不知道为什么奇偶性排序会 WA。</p>
<p>好短啊 QAQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(a) (a/sq+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(n,m) (1LL*fac[n]*inv[m]%mod*inv[n-m]%mod)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,sq;</span><br><span class="line"><span class="keyword">int</span> fac[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> t,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">Query q[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re Query p1,re Query p2)&#123;</span><br><span class="line">     <span class="keyword">return</span> id(p1.l)==id(p2.l)?p1.r&lt;p2.r:p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">         inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">         fac[i]=<span class="number">1L</span>L*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">         inv[i]=<span class="number">1L</span>L*inv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     sq=maxn/<span class="built_in">sqrt</span>(n);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         q[i].t=i;</span><br><span class="line">         cltstream::read(q[i].r);</span><br><span class="line">         cltstream::read(q[i].l);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">std</span>::sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">     re <span class="keyword">int</span> L=<span class="number">0</span>,R=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         <span class="keyword">for</span>(;R&lt;q[i].r;res=(<span class="number">2</span>*res-C(R,L)+mod)%mod,++R);</span><br><span class="line">         <span class="keyword">for</span>(;R&gt;q[i].r;--R,res=inv[<span class="number">2</span>]*(res+C(R,L))%mod);</span><br><span class="line">         <span class="keyword">for</span>(;L&lt;q[i].l;++L,res=(res+C(R,L))%mod);</span><br><span class="line">         <span class="keyword">for</span>(;L&gt;q[i].l;res=(res-C(R,L)+mod)%mod,--L);</span><br><span class="line">         ans[q[i].t]=res;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         cltstream::write(ans[i],<span class="number">10</span>);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>莫队</tag>
        <tag>AtCoder</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title>伯努利数失败笔记</title>
    <url>/bernoulli-number-learning-notes/</url>
    <content><![CDATA[<blockquote>
<p>「クールでまばゆいばかりのアルゴリズムを学ばないでください 、 それはうまく検索することが最も重要です。」</p>
<p>——loli</p>
</blockquote>
<p><del>以上，我失败了（</del></p>
<p><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/guan-yu-bo-nu-li-shuo-zhuai-hua-zi-ran-shuo-mi-hu-gong-shi-di-zheng-mi">前半部分的抄袭来源</a>。</p>
<a id="more"></a>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>伯努利数 $B_{n}$ 具有如下性质：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><h3 id="自然数幂和"><a href="#自然数幂和" class="headerlink" title="自然数幂和"></a>自然数幂和</h3><p>我们定义</p>
<script type="math/tex; mode=display">
S(n,k)=\sum_{i=0}^{n-1}i^{k}</script><script type="math/tex; mode=display">
T(n,k)=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><p>我们希望证明 $S(n,k)=T(n,k)$。</p>
<p>在这里，我们采用一种名为「强归纳法」（或者「完全归纳法」）的方法。具体来说，假设我们已经对于任意的 $0\leqslant j\lt k$，证明了 $S(n,j)=T(n,j)$ 成立，利用这个结论推出 $S(n,k)=T(n,k)$ 成立。</p>
<p>当 $k=0$ 时</p>
<script type="math/tex; mode=display">
S(n,k)=n</script><script type="math/tex; mode=display">
T(n,k)=C_{1}^{0}B_{0}n</script><p>因为我们有</p>
<script type="math/tex; mode=display">
C_{1}^{0}B_{0}=[0=0]=1</script><p>从而 $S(n,k)=T(n,k)$ 成立。</p>
<p>当 $k\gt 0$ 时</p>
<script type="math/tex; mode=display">
S(n,k+1)=\sum_{i=0}^{n-1}i^{k+1}</script><script type="math/tex; mode=display">
\begin{aligned}
S(n,k+1)+n^{k+1}&=\sum_{i=0}^{n-1}(i+1)^{k+1}\\
&=\sum_{i=0}^{n-1}\sum_{j=0}^{k+1}C_{k+1}^{j}i^{j}\\
&=\sum_{j=0}^{k+1}C_{k+1}^{j}\sum_{i=0}^{n-1}i^{j}\\
&=\sum_{j=0}^{k+1}C_{k+1}^{j}S(n,j)\\
&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)+C_{k+1}^{k+1}S(n,k+1)
\end{aligned}</script><p>注意到 $C_{k+1}^{k+1}=1$，我们就能得到</p>
<script type="math/tex; mode=display">
n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)</script><p>因为我们已经对于任意的 $0\leqslant j\lt k$，证明了 $S(n,j)=T(n,j)$ 成立，我们就可以将上式进一步变形</p>
<script type="math/tex; mode=display">
\begin{aligned}
n^{k+1}&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)\\
&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)\\
&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)+C_{k+1}^{k}T(n,k)-C_{k+1}^{k}T(n,k)\\
&=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)-C_{k+1}^{k}T(n,k)
\end{aligned}</script><p>接下来，如果我们能够证明</p>
<script type="math/tex; mode=display">
n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)</script><p>自然就能得出 $S(n,k)=T(n,k)$。</p>
<p>愉快地推式子</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i}B_{i}n^{j-i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{j-i}B_{j-i}n^{i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i+1}B_{j-i}n^{i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}\cfrac{j+1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\sum_{i=0}^{j}\cfrac{1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{j}C_{j}^{i}B_{j-i}n^{i+1}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{i}C_{k-i+1}^{j-i}B_{j-i}n^{i+1}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}
\end{aligned}</script><p>上面的第二个等号是将后面的那个 $\sum$ 倒过来（$i\rightarrow j-i$）求和。</p>
<p><del>返回本页面最上端之后，</del>我们回想起伯努利数还有个这么个性质</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><p>于是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}[i=k]\\
&=\cfrac{1}{k+1}C_{k+1}^{k}n^{k+1}\\
&=n^{k+1}
\end{aligned}</script><script type="math/tex; mode=display">
\text{QED}</script><h3 id="诶刚才我干了些什么来着"><a href="#诶刚才我干了些什么来着" class="headerlink" title="诶刚才我干了些什么来着"></a>诶刚才我干了些什么来着</h3><p>哦我好像是证明了这么一个东西</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1}i^{k}=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><h3 id="如何求伯努利数"><a href="#如何求伯努利数" class="headerlink" title="如何求伯努利数"></a>如何求伯努利数</h3><p><del>根据题解，</del>我们知道伯努利数的生成函数是</p>
<script type="math/tex; mode=display">
\cfrac{x}{e^{x}-1}=\cfrac{x}{\sum\limits_{i=1}^{+\infty}\cfrac{x^{i}}{i!}}=\cfrac{1}{\sum\limits_{i=0}^{+\infty}\cfrac{x^{i}}{(i+1)!}}</script><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「Luogu-P3711」仓鼠的数学题"><a href="#「Luogu-P3711」仓鼠的数学题" class="headerlink" title="「Luogu-P3711」仓鼠的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3711">「Luogu-P3711」仓鼠的数学题</a></h4><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x-1}j^{i}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{j}B_{j}x^{i-j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{i-j}B_{i-j}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}\cfrac{(i+1)!}{(i-j)!(j+1)!}B_{i-j}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}i!a_{i}\sum_{j=0}^{i}\cfrac{1}{(j+1)!}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}
\end{aligned}</script><p>定义</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^{n}(n-i)!a_{n-i}x^{i}</script><script type="math/tex; mode=display">
B(x)=\sum_{i=0}^{n}\cfrac{B_{i}}{i!}x^{i}</script><p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{FB[n-j]}{(j+1)!}x^{j+1}
\end{aligned}</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>伯努利数</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2019R1游记」僕らは泥を這いつくばるもの</title>
    <url>/sdoi2019r1-notes/</url>
    <content><![CDATA[<p>被强大无比且随手吊打我的 shzr 催更了，于是诚惶诚恐赶来写这篇游记。</p>
<a id="more"></a>
<h3 id="Day-X"><a href="#Day-X" class="headerlink" title="Day -X"></a>Day -X</h3><p>经过讨论，我们机房研究出了以下两个堪称完美的战术，若能施加实际行动，定能令 SLYZ 省选大获全胜：</p>
<ol>
<li>让潮子分身，在每一位 dalao（如 rqy、ckw 等）身边分别派一个，然后潮他们，他们就炸了。</li>
<li>让潮子在厕所蹲着，每看到有选手上厕所，等他上到一半跑到他背后，潮之曰「你稳了」，他就炸了。</li>
</ol>
<p><del>这都什么鬼东西（</del></p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h3><p>「省选快到了，我想回家休息休息。」</p>
<p>像这样理直气壮地请假回家颓废了。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><h4 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h4><p>12：30 从学校坐车走，等到了济南已经是大概 16：00 了。</p>
<p>到了宾馆 loli 让我们自由组合。然后 mhr 学长主动邀请我住一个房间。</p>
<p>我直接就答应了。</p>
<h4 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h4><p>晚上出去吃饭的时候，潮子一直在潮。</p>
<p>就比如说钦定 wzx 的 SAM 没有了 A，只剩下了一些奇怪的东西一道题都 A 不动了。</p>
<p>可惜绝大部分名言已经失传了。</p>
<p>这可真是糟糕，OI 文学界的一大损失啊。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>就算没有解压密码也是可以看压缩包内部的文件有哪些的。</p>
<p>然后就看到了 T3 有 16 个样例有点方。</p>
<p>解压密码直接一坨乱码。龙虾选手表示解压体验 (?) 极差。</p>
<h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5283">T1</a></h4><p>诶怎么感觉有点像超级钢琴啊。</p>
<p>但是因为我超级钢琴只会 ST 表 + 堆，想了想发现这题不能这么做。</p>
<p>好吧，暴力 60 分先安排上。</p>
<p>出了考场发现人均 A 掉 T1。</p>
<h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5284">T2</a></h4><p>字符串（</p>
<p>不难想到这么一个做法：对于这 $n_{a}+n_{b}$ 个串每一个建一个点，如果 $A$ 类串 $x$ 支配 $B$ 类串 $y$，或者 $B$ 类串 $x$ 是 $A$ 类串 $y$ 的前缀，从 $x$ 向 $y$ 连边。最后整张图有环就是 $-1$，没有 D 个 P 就出来了。</p>
<p>然后暴力建图。莫名其妙能有 60 分。</p>
<h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5285">T3</a></h4><p>写作传统题读作提交答案题。</p>
<p>考场上只想出来了 <code>1_998244353</code> 的 12 分。</p>
<p>然后出考场被各路 dalao 吊打。</p>
<p>关于测试点 8-16，一开始我的想法是给出两个数 $x,y$，有一个长度为 $x$ 的区间从左向右扫过 $[1,y]$ 这个区间。</p>
<p>但实际上是 $[x,y]$ 这个区间内每个数的性质。想到这一点后面的一些数据范围比较小的点就没啥问题了。</p>
<p>但是数据范围比较大的点怎么办？</p>
<p>打一些比较小的表（</p>
<p>标程 70KB 了一下。</p>
<h4 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h4><p>首先是讲评。</p>
<p>没有抢到座位于是只能站着。</p>
<p>因为非常吵什么也听不清。</p>
<p>印象比较深的是讲到 T3 突然一阵掌声。</p>
<p>然后回到宾馆快乐地颓废。</p>
<h4 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h4><p>集体不想出去吃于是点了肯德基，然后……诶诶诶你们什么时候吃完的太快了吧（</p>
<h3 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h3><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5289">T1</a></h4><p>看到题目名我还以为是网络流。</p>
<p>然后我就在想有没有网络流计数这种操作。</p>
<p>大概是没有吧。</p>
<p>打了个爆搜结果还炸了。</p>
<h4 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5290">T2</a></h4><p>看上去好神仙啊。</p>
<p>考场上写了 45 分的状压枚举子集。</p>
<p>结果一出考场听说人均 75，就我不会链的贪心和 $O(n^{2})$ 的做法，自毙了。</p>
<h4 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5291">T3</a></h4><p>想写一写 $L=n$ 或 $k=1$ 的情况。</p>
<p>到最后发现什么也不会，只想到了 $L=n$<strong>且</strong>$k=1$ 的情况。喜提 8 分。</p>
<p>但是最后测出来好像是 12 分来着？没仔细看。</p>
<h4 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h4><p>因为有人要回去所以讲评提前了半小时。</p>
<p>虽然说抢到了一个座位可是今天比昨天还吵真的什么也听不见了。</p>
<p>T3 标程 887 行了解一下（</p>
<p><img src="/images/TIM图片20190409113807.jpg" alt=""></p>
<p>结果接我们回东营的车咕了大概有一个多小时吧，最后得有 20：30 才到家。</p>
<h4 id="晚上-2"><a href="#晚上-2" class="headerlink" title="晚上"></a>晚上</h4><p>当然是回家……啊什么明天就正常上课啦？咕了！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后 60+60+12+0+45+12=189。</p>
<p>随便抓只猴子就比我考的高 /kk</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>FWT抄袭笔记</title>
    <url>/fwt-learning-notes/</url>
    <content><![CDATA[<p>看到坐在我左边的 dalao 在学 FWT。</p>
<p>想着二轮前学一些很酷很炫<del>很失败</del>的算法，于是来<del>背一下</del>学一下吧。</p>
<p><a href="http://www.cnblogs.com/cjyyb/p/9065615.html">抄袭来源</a>。</p>
<a id="more"></a>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们利用 FFT 可以在 $O(n\log n)$ 的时间复杂度内计算</p>
<script type="math/tex; mode=display">
H[k]=(F\times G)[k]=\sum_{i+j=k}F[i]G[j]</script><p>假如说我们把这个式子变一变</p>
<script type="math/tex; mode=display">
H[k]=(F\vee G)[k]=\sum_{i\vee j=k}F[i]G[j]</script><script type="math/tex; mode=display">
H[k]=(F\wedge G)[k]=\sum_{i\wedge j=k}F[i]G[j]</script><script type="math/tex; mode=display">
H[k]=(F\oplus G)[k]=\sum_{i\oplus j=k}F[i]G[j]</script><p>其中 $\vee$ 指按位或，$\wedge$ 指按位与，$\oplus$ 指按位异或。</p>
<p>我们还是希望能够在 $O(n\log n)$ 的时间复杂度内计算出答案。</p>
<p>这种时候我们就需要 FWT（快速沃尔什变换，Fast Walsh–Hadamard Transformation）了。</p>
<p>在 FFT 中，我们先计算出了 $F$ 和 $G$ 的点值多项式，然后将对应位直接相乘得到了 $F\times G$ 的点值多项式，最后还原回了 $F\times G$。</p>
<p>类似地，我们可不可以试着计算出两个多项式 $F^{\prime},G^{\prime}$，使得</p>
<script type="math/tex; mode=display">
(F\times G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p><del>当然可以啊不然还怎么会有 FWT（</del></p>
<h3 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h3><p>对于两个向量 $A$ 和 $B$，我们令</p>
<script type="math/tex; mode=display">
(A,B)=(A[0],A[1],\cdots,B[0],B[1],\cdots)</script><p>设 $F$ 的项数为 $2^{t}$。为了方便，我们将其看做一个 $2^{t}$ 维向量</p>
<script type="math/tex; mode=display">
(F[0],F[1],\cdots,F[2^{t}-1])</script><p>然后我们定义</p>
<script type="math/tex; mode=display">
F_{0}=(F[0],F[1],\cdots,F[2^{t-1}-1])</script><script type="math/tex; mode=display">
F_{1}=(F[2^{t-1}],F[2^{t-1}+1],\cdots,F[2^{t}-1])</script><h3 id="正变换"><a href="#正变换" class="headerlink" title="正变换"></a>正变换</h3><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p>定义</p>
<script type="math/tex; mode=display">
F^{\prime}=\begin{cases}
&(F_{0}^{\prime},F_{1}^{\prime}+F_{0}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\
&F&(t=0)
\end{cases}</script><p>我们发现</p>
<script type="math/tex; mode=display">
F^{\prime}[i]=\sum_{j\vee i=i}F[j]</script><p>$t=0$ 时这十分显然，我们来考虑 $t\gt 0$ 时的情况。</p>
<p>首先很明显的一点是 $j\vee i=i\Leftrightarrow j\subseteq i$，也就是说 $j$ 是 $i$ 的子集。</p>
<p>对于 $F_{1}$ 中的一个下标 $i$，我们在 $F_{1}$ 左边接上 $F_{0}$ 后，这个 $i$ 就多了一个 $2^{t-1}$。</p>
<p>之前 $i$ 的每一个子集 $j$，也同样多了一个 $2^{t-1}$，它们产生的贡献已经被统计在了 $F_{1}^{\prime}[i]$ 内。</p>
<p>那么去掉这个 $2^{t-1}$，我们还有 $j\subseteq i+2^{t-1}$，这部分其实就是 $F_{0}^{\prime}[i]$ 的值。</p>
<p>据此，我们就有</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^{\prime}\cdot G^{\prime}[i]&=\left(\sum_{j\subseteq i}F[j]\right)\left(\sum_{k\subseteq i}G[k]\right)\\
&=\sum_{j\vee k\subseteq i}F[j]G[k]\\
&=\sum_{l\subseteq i}\sum_{j\vee k=l}F[j]G[k]\\
&=\sum_{l\subseteq i}(F\vee G)[l]\\
&=(F\vee G)^{\prime}[i]
\end{aligned}</script><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><p>定义</p>
<script type="math/tex; mode=display">
F^{\prime}=\begin{cases}
&(F_{0}^{\prime}+F_{1}^{\prime},F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\
&F&(t=0)
\end{cases}</script><p>它具有类似的性质</p>
<script type="math/tex; mode=display">
F^{\prime}[i]=\sum_{j\wedge i=i}F[j]</script><script type="math/tex; mode=display">
(F\wedge G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>证明略。</p>
<h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><p>定义</p>
<script type="math/tex; mode=display">
F^{\prime}=\begin{cases}
&(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\
&F&(t=0)
\end{cases}</script><p>然后我们发现按位异或并没有像上面一样的和子集相关的性质。因此我们需要通过一些其他方式来证明它的正确性。</p>
<p>首先</p>
<script type="math/tex; mode=display">
(F+G)^{\prime}=F^{\prime}+G^{\prime}</script><p>如果 $F$ 和 $G$ 都只有一项，这十分显然。</p>
<p>否则</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^{\prime}+G^{\prime}&=(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})+(G_{0}^{\prime}+G_{1}^{\prime},G_{0}^{\prime}-G_{1}^{\prime})\\
&=(F_{0}^{\prime}+G_{0}^{\prime}+F_{1}^{\prime}+G_{1}^{\prime},F_{0}^{\prime}+G_{0}^{\prime}-F_{1}^{\prime}-G_{1}^{\prime})\\
&=((F+G)_{0}^{\prime}+(F+G)_{1}^{\prime},(F+G)_{0}^{\prime}-(F+G)_{1}^{\prime})\\
&=(F+G)^{\prime}
\end{aligned}</script><script type="math/tex; mode=display">
(F\oplus G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>这个不会证，告辞。</p>
<h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>就是把刚刚算出来的 $F^{\prime}$ 变回 $F$。</p>
<script type="math/tex; mode=display">
F=\begin{cases}
&F^{\prime}&(t=0)\\
&\begin{cases}
&(F_{0},F_{1}-F_{0})&(\vee)\\
&(F_{0}-F_{1},F_{1})&(\wedge)\\
&(\cfrac{F_{0}+F_{1}}{2},\cfrac{F_{0}-F_{1}}{2})\;\;\;\;\;\;\;\;&(\oplus)
\end{cases}\;\;\;\;\;\;\;\;&(t\gt 0)
\end{cases}</script><p><del>啥意思啊看不懂啊（</del></p>
<p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P4717">板子题</a> 了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>],G[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FWT(F,tp) &#123;\</span></span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;n;p&lt;&lt;=<span class="number">1</span>)\</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)\</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;\</span><br><span class="line">                 F[j+p][<span class="number">0</span>]=!tp?(F[j+p][<span class="number">0</span>]+F[j][<span class="number">0</span>])%mod:(F[j+p][<span class="number">0</span>]-F[j][<span class="number">0</span>]+mod)%mod;\</span><br><span class="line">                 F[j][<span class="number">1</span>]=!tp?(F[j][<span class="number">1</span>]+F[j+p][<span class="number">1</span>])%mod:(F[j][<span class="number">1</span>]-F[j+p][<span class="number">1</span>]+mod)%mod;\</span><br><span class="line">                 re <span class="keyword">int</span> x=F[j][<span class="number">2</span>],y=F[j+p][<span class="number">2</span>];\</span><br><span class="line">                 F[j][<span class="number">2</span>]=(x+y)%mod;\</span><br><span class="line">                 F[j+p][<span class="number">2</span>]=(x-y+mod)%mod;\</span><br><span class="line">                 <span class="keyword">if</span>(tp)&#123;\</span><br><span class="line">                     F[j][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j][<span class="number">2</span>]%mod;\</span><br><span class="line">                     F[j+p][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j+p][<span class="number">2</span>]%mod;\</span><br><span class="line">                 &#125;\</span><br><span class="line">             &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     n=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">         cltstream::read(F[i][<span class="number">0</span>]);</span><br><span class="line">         F[i][<span class="number">1</span>]=F[i][<span class="number">2</span>]=F[i][<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">         cltstream::read(G[i][<span class="number">0</span>]);</span><br><span class="line">         G[i][<span class="number">1</span>]=G[i][<span class="number">2</span>]=G[i][<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     FWT(F,<span class="number">0</span>);</span><br><span class="line">     FWT(G,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">             F[i][j]=<span class="number">1L</span>L*F[i][j]*G[i][j]%mod;</span><br><span class="line">     FWT(F,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">             cltstream::write(F[i][j],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">10</span>);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h3><p>我们知道 FFT 中的单位元多项式是 $F(x)=1$，类似地，FWT 是否也拥有这样的一个单位元呢？</p>
<p>当然是有的。</p>
<p>对于按位或和按位异或来说，它们的单位元是</p>
<script type="math/tex; mode=display">
(1,0,\cdots,0,0)</script><p>对于按位与来说，它的单位元是</p>
<script type="math/tex; mode=display">
(0,0,\cdots,0,1)</script><h3 id="求逆"><a href="#求逆" class="headerlink" title="求逆"></a>求逆</h3><p>既然有了单位元，我们就不禁会想……这东西能求逆吗？</p>
<p>大概……能吧。</p>
<p>以下所有运算在模 $998244353$ 意义下进行。</p>
<h4 id="按位或-1"><a href="#按位或-1" class="headerlink" title="按位或"></a>按位或</h4><p>给定一个多项式 $F$，让你求出一个多项式 $G$，使得</p>
<script type="math/tex; mode=display">
F\vee G=(1,0,\cdots,0,0)</script><p>首先我们需要知道</p>
<script type="math/tex; mode=display">
F\vee G=(F_{0}\vee G_{0},F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1})</script><p>注意到左半部分和右半部分的下标有一个重要区别就是从右往左第 $t$ 位是否为 $1$。</p>
<p>如果某个下标和右半部分的某个下标进行了按位或，它的第 $t$ 位一定是 $1$，那么它就跑到右半部分去了。</p>
<p>否则，即两个左半部分的下标进行了按位或，这种情况结果还是在左半部分。</p>
<p>然后我们就可以往下推了</p>
<script type="math/tex; mode=display">
\begin{aligned}
F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1}&=0\\
(F_{0}+F_{1})\vee G_{1}&=-F_{1}\vee G_{0}\\
G_{1}&=-F_{1}\vee G_{0}\vee (F_{0}+F_{1})^{-1}
\end{aligned}</script><p>边界条件 $G[0]=F[0]^{-1}$。</p>
<p>大致代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">         G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> tmp1[<span class="number">1</span>&lt;&lt;maxn],tmp2[<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line">         Inv(F,G,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">             tmp1[i]=F[i]+F[(n&gt;&gt;<span class="number">1</span>)+i];</span><br><span class="line">         Inv(tmp1,tmp2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">         FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">         FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">         FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">             tmp2[i]=<span class="number">1L</span>L*F[(n&gt;&gt;<span class="number">1</span>)+i]*G[i]%mod*tmp2[i]%mod;</span><br><span class="line">         FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">         FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">         FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">             G[(n&gt;&gt;<span class="number">1</span>)+i]=(mod-tmp2[i])%mod;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度非常显然是 $O(n^{2}2^{n})$。</p>
<h4 id="按位与-1"><a href="#按位与-1" class="headerlink" title="按位与"></a>按位与</h4><p>给定一个多项式 $F$，让你求出一个多项式 $G$，使得</p>
<script type="math/tex; mode=display">
F\wedge G=(0,0,\cdots,0,1)</script><p>我们可以用类似的过程得到如下结论</p>
<script type="math/tex; mode=display">
F\wedge G=(F_{0}\wedge G_{0}+F_{0}\wedge G_{1}+F_{1}\wedge G_{0},F_{1}\wedge G_{1})</script><script type="math/tex; mode=display">
G_{0}=-F_{0}\wedge G_{1}\wedge (F_{0}+F_{1})^{-1}</script><h4 id="按位异或-1"><a href="#按位异或-1" class="headerlink" title="按位异或"></a>按位异或</h4><p>给定一个多项式 $F$，让你求出一个多项式 $G$，使得</p>
<script type="math/tex; mode=display">
F\oplus G=(1,0,\cdots,0,0)</script><p>首先我们有</p>
<script type="math/tex; mode=display">
F\oplus G=(F_{0}\oplus G_{0}+F_{1}\oplus G_{1},F_{0}\oplus G_{1}+F_{1}\oplus G_{0})</script><p>也就是说</p>
<script type="math/tex; mode=display">
F_{0}\oplus G_{0}+F_{1}\oplus G_{1}=\epsilon</script><script type="math/tex; mode=display">
F_{0}\oplus G_{1}+F_{1}\oplus G_{0}=0</script><p>将上面两个式子相加 、 相减，得到</p>
<script type="math/tex; mode=display">
(F_{0}+F_{1})\oplus(G_{0}+G_{1})=\epsilon</script><script type="math/tex; mode=display">
(F_{0}-F_{1})\oplus(G_{0}-G_{1})=\epsilon</script><p>于是</p>
<script type="math/tex; mode=display">
G_{0}=\cfrac{(F_{0}+F_{1})^{-1}+(F_{0}-F_{1})^{-1}}{2}</script><script type="math/tex; mode=display">
G_{1}=\cfrac{(F_{0}+F_{1})^{-1}-(F_{0}-F_{1})^{-1}}{2}</script><p>时间复杂度 $O(n2^{n})$。</p>
<p>这就没了？并不是。</p>
<p>如果您按照上面的式子写好程序，然后往里面输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>
<p>这样一组数据，您会发现您的程序给出的结果并不正确。</p>
<p>那么原因是什么呢？是我们式子推错了吗？</p>
<p>输出一下中间的运算过程，我们发现，在中间有一步，我们计算 $(2,2)^{-1}$ 时，需要用到 $(0)^{-1}$。</p>
<p>显然它不存在，但是同样显然的是，如果 $(2,2)^{-1}$ 存在，那么这个过程不应该出现这样的问题。</p>
<p>所以说原因就是，$(2,2)^{-1}$，或者更进一步地，$(1,2,3,4)^{-1}$<strong>不存在</strong>。</p>
<h3 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a><a href="https://loj.ac/problem/152">子集卷积</a></h3><p><del>让我来看看有没有点进去看完题面一脸懵逼地关闭标签页的。</del></p>
<p>这道题是让我们求这个东西</p>
<script type="math/tex; mode=display">
h_{R}=\sum_{S\vee T=R,S\wedge T=\varnothing}f_{S}g_{T}</script><p>这比我们之前看到的卷积拥有更加严格的要求，$S\wedge T=\varnothing$，很明显，这是在提示我们抄题解。</p>
<p>我们定义</p>
<script type="math/tex; mode=display">
F_{i,S}=\begin{cases}
&f_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\
&0&(|S|\neq i)
\end{cases}</script><script type="math/tex; mode=display">
G_{i,S}=\begin{cases}
&g_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\
&0&(|S|\neq i)
\end{cases}</script><script type="math/tex; mode=display">
H_{i,S}=\begin{cases}
&h_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\
&0&(|S|\neq i)
\end{cases}</script><p>然后我们从小到大枚举 $i$，计算</p>
<script type="math/tex; mode=display">
H_{i}=\sum_{j=0}^{i}F_{j}\vee G_{i-j}</script><p>为了理解这个式子，我们先将其展开</p>
<script type="math/tex; mode=display">
H_{i,R}=\sum_{j=0}^{i}\sum_{S\vee T=R}F_{j,S}G_{i-j,T}</script><p>根据定义，$F_{i,S}$ 和 $G_{i,S}$ 有值当且仅当 $|S|=i$，因此这就相当于</p>
<script type="math/tex; mode=display">
H_{i,R}=\sum_{S\vee T=R,|S|+|T|=i}F_{|S|,S}G_{|T|,T}</script><p>因为 $S$ 和 $T$ 可能会有交集，从而 $i\gt |R|$ 时 $H_{i,R}$ 也可能有值，这是不符合定义的，因此（如果有必要的话）我们需要手动清空。</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,N;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">1</span>&lt;&lt;maxn],F[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],G[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],H[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;N;p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)</span><br><span class="line">                 F[j+p]=!tp?(F[j+p]+F[j])%mod:(F[j+p]-F[j]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     N=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">         cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         cltstream::read(F[cnt[i]][i]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         cltstream::read(G[cnt[i]][i]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         FWT(F[i],<span class="number">0</span>);</span><br><span class="line">         FWT(G[i],<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">                 H[i][S]=(H[i][S]+<span class="number">1L</span>L*F[j][S]*G[i-j][S]%mod)%mod;</span><br><span class="line">         FWT(H[i],<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">             cnt[S]==i||(H[i][S]=<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">         cltstream::write(H[cnt[i]][i],<span class="number">32</span>);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/images/TIM图片20181011211750.jpg" alt=""></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI2016」循环之美</title>
    <url>/luogu-p1587-solution/</url>
    <content><![CDATA[<p>突然被 wzx 安利的一道题。</p>
<p><a href="https://www.luogu.org/problemnew/show/P1587">传送门</a></p>
<p><a href="https://www.cnblogs.com/asuldb/p/10706088.html">wzx 的题解</a></p>
<a id="more"></a>
<p><del>通过查阅 fuge 的题解，</del>我们发现我们要求的式子是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]</script><p>$[i\perp j]$ 保证了这是一个最简分数从而不会算重，$[j\perp k]$ 保证了这是一个纯循环小数。</p>
<p>首先关于 $[1,n]$ 中与某个常数 $k$ 互质的数的数量，我们有一个结论</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}[i\perp k]=\sum_{i=1}^{n}\sum_{x|i,x|k}\mu(x)=\sum_{x|k}\lfloor\cfrac{n}{x}\rfloor\mu(x)</script><p>然后大力整理</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]&=\sum_{j=1}^{m}[j\perp k]\sum_{i=1}^{n}[i\perp j]\\
&=\sum_{j=1}^{m}[j\perp k]\sum_{x|j}\lfloor\cfrac{n}{x}\rfloor\mu(x)\\
&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{x|j}[j\perp k]\\
&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[jx\perp k]\\
&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[j\perp k]\\
&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{y|k}\lfloor\cfrac{m}{xy}\rfloor\mu(y)
\end{aligned}</script><p>这道题有一个突破口在于，$k$ 的范围很小，只有 $2000$，从而 $d(k)$ 的范围会更小，这就使得我们能够暴力枚举 $k$ 的约数来计算第二个 $\sum$。</p>
<p>观察第一个 $\sum$，我们发现，套上一层整除分块之后，我们需要计算的是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}f(i)</script><p>其中</p>
<script type="math/tex; mode=display">
f(n)=[n\perp k]\mu(n)</script><p>考虑杜教筛，我们再找来一个函数</p>
<script type="math/tex; mode=display">
g(n)=[n\perp k]</script><p>把它们卷积</p>
<script type="math/tex; mode=display">
\begin{aligned}
(f\times g)(n)&=\sum_{d|n}f(d)g(\cfrac{n}{d})\\
&=\sum_{d|n}[d\perp k][\cfrac{n}{d}\perp k]\mu(d)\\
&=[n\perp k]\sum_{d|n}\mu(d)\\
&=\epsilon(n)
\end{aligned}</script><p>然后就差不多了。</p>
<p>不过有一个问题，像这种对 $n$ 和 $m$ 同时整除分块的情况，不能用类似 min_25 的 trick（$N\leqslant\sqrt{n}$ 时存到 <code>ans1[N]</code>，否则存到 <code>ans2[n/N]</code>），只能通过 unordered_map 或者 Hash 来记忆化。</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">50</span>],f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],mu[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">T</span><span class="params">(re <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d[<span class="number">0</span>];++i)</span><br><span class="line">         res+=<span class="number">1L</span>L*(x/d[i])*mu[d[i]];</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(N&lt;=maxn)</span><br><span class="line">         <span class="keyword">return</span> F[N];</span><br><span class="line">     <span class="keyword">if</span>(ans.count(N))</span><br><span class="line">         <span class="keyword">return</span> ans[N];</span><br><span class="line">     re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,lst=T(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=N;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">         r=N/(N/l);</span><br><span class="line">         re <span class="keyword">long</span> <span class="keyword">long</span> tmp=T(r);</span><br><span class="line">         res-=S(N/l)*(tmp-lst);</span><br><span class="line">         lst=tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans[N]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     cltstream::read(k);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">         <span class="keyword">if</span>(k%i==<span class="number">0</span>)</span><br><span class="line">             d[++d[<span class="number">0</span>]]=i;</span><br><span class="line">     mu[<span class="number">1</span>]=F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">             g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">             mu[i]=<span class="number">-1</span>;</span><br><span class="line">             F[i]=-(k%i!=<span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">             f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span>(i%g[j])&#123;</span><br><span class="line">                 mu[i*g[j]]=mu[i]*mu[g[j]];</span><br><span class="line">                 F[i*g[j]]=F[i]*F[g[j]];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">         F[i]+=F[i<span class="number">-1</span>];</span><br><span class="line">     re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>,lst=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n&amp;&amp;l&lt;=m;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">         r=min(n/(n/l),m/(m/l));</span><br><span class="line">         re <span class="keyword">long</span> <span class="keyword">long</span> tmp=S(r);</span><br><span class="line">         res+=(n/l)*T(m/l)*(tmp-lst);</span><br><span class="line">         lst=tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     cltstream::write(res);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「JSOI2015」染色问题</title>
    <url>/bzoj4487-solution/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4487">传送门</a></p>
<p>sto <a href="https://www.cnblogs.com/asuldb/p/10775580.html">asuldb</a> orz</p>
<a id="more"></a>
<p>我们平时遇到的一维容斥大概长这样</p>
<script type="math/tex; mode=display">
F_{i}=\sum_{x=i}^{n}C_{x}^{i}G_{x}\Leftrightarrow G_{i}=\sum_{x=i}^{n}(-1)^{x-i}C_{x}^{i}F_{x}</script><p>如果说遇到高维容斥，我们只需要一维一维地解决掉即可。</p>
<p>但实际上，我们是可以总结出一个 $k$ 维容斥的式子的</p>
<script type="math/tex; mode=display">
F_{i_{1},i_{2},\cdots,i_{k}}=\sum_{x_{1}=i_{1}}^{n_{1}}\sum_{x_{2}=i_{2}}^{n_{2}}\cdots\sum_{x_{k}=i_{k}}^{n_{k}}\left(\prod_{j=1}^{k}C_{x_{j}}^{i_{j}}\right)G_{x_{1},x_{2},\cdots,x_{k}}\Leftrightarrow G_{i_{1},i_{2},\cdots,i_{k}}=\sum_{x_{1}=i_{1}}^{n_{1}}\sum_{x_{2}=i_{2}}^{n_{2}}\cdots\sum_{x_{k}=i_{k}}^{n_{k}}\left(\prod_{j=1}^{k}(-1)^{x_{j}-i_{j}}C_{x_{j}}^{i_{j}}\right)F_{x_{1},x_{2},\cdots,x_{k}}</script><p>没错，这道题就是一个三维容斥的大板子。</p>
<p>我们令至少 $i$ 行 $j$ 列为空，至少 $k$ 种颜色未出现的方案数为 $F_{i,j,k}$，我们有</p>
<script type="math/tex; mode=display">
F_{i,j,k}=C_{n}^{i}C_{m}^{j}C_{c}^{k}(c-k+1)^{(n-i)(m-j)}</script><p><del>话又说回来了这个东西应该是会算重啊（</del></p>
<p>恰有 $i$ 行 $j$ 列为空，恰有 $k$ 种颜色未出现的方案数为 $G_{i,j,k}$，自然</p>
<script type="math/tex; mode=display">
F_{i,j,k}=\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}C_{x}^{i}C_{y}^{j}C_{z}^{k}G_{x,y,z}</script><script type="math/tex; mode=display">
\begin{aligned}
G_{i,j,k}&=\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{x}^{i}C_{y}^{j}C_{z}^{k}F_{x,y,z}\\
&=\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{x}^{i}C_{y}^{j}C_{z}^{k}C_{n}^{x}C_{m}^{y}C_{c}^{z}(c-z+1)^{(n-x)(m-y)}\\
&=C_{n}^{i}C_{m}^{j}C_{c}^{k}\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{n-i}^{x-i}C_{m-j}^{y-j}C_{c-k}^{z-k}(c-z+1)^{(n-x)(m-y)}\\
&=C_{n}^{i}C_{m}^{j}C_{c}^{k}\sum_{x=0}^{n-i}\sum_{y=0}^{m-j}\sum_{z=0}^{c-k}(-1)^{x+y+z}C_{n-i}^{x}C_{m-j}^{y}C_{c-k}^{z}(c-k-z+1)^{(n-i-x)(m-j-y)}\
\end{aligned}</script><p>我们要求的答案就是 $G_{0,0,0}$，简单整理一下就是</p>
<script type="math/tex; mode=display">
\sum_{x=0}^{n}\sum_{y=0}^{m}\sum_{z=0}^{c}(-1)^{x+y+z}C_{n}^{x}C_{m}^{y}C_{c}^{z}(c-z+1)^{(n-x)(m-y)}</script><p>然后你问我为什么要写一篇 blog？<del>闲得没事干（</del></p>
<p>代码瞎写的就不贴了（</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>论一条咸鱼如何瞎搞「WC2015」未来程序</title>
    <url>/luogu-p4920-solving-notes/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4920">传送门</a></p>
<p><del>说不定还会持续更新？（</del></p>
<a id="more"></a>
<h3 id="2019-04-26"><a href="#2019-04-26" class="headerlink" title="2019-04-26"></a>2019-04-26</h3><p>闲得没事翻到这道题了想试一试。</p>
<p>首先看到测试点 1。</p>
<p>很明显的一个 $a\times b\operatorname{mod}c$。</p>
<p>啊什么爆 <code>unsigned long long</code>？Python 了解一下（</p>
<p>然后去看测试点 2。</p>
<p>差不多能总结出这么一个规律来</p>
<script type="math/tex; mode=display">
a_{0}=1\;\;\;\;b_{0}=0\;\;\;\;c_{0}=0</script><script type="math/tex; mode=display">
a_{n}=a_{n-1}+2b_{n-1}+c_{n-1}\;\;\;\;b_{n}=a_{n-1}+b_{n-1}\;\;\;\;c_{n}=a_{n-1}</script><script type="math/tex; mode=display">
\text{Ans}=a_{n}-2b_{n}+c_{n}</script><p>然后手动打表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$</th>
<th style="text-align:center">$a_{n}$</th>
<th style="text-align:center">$b_{n}$</th>
<th style="text-align:center">$c_{n}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$9$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$4$</td>
</tr>
<tr>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$25$</td>
<td style="text-align:center">$15$</td>
<td style="text-align:center">$9$</td>
</tr>
<tr>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$64$</td>
<td style="text-align:center">$40$</td>
<td style="text-align:center">$25$</td>
</tr>
</tbody>
</table>
</div>
<p>然后发现 $a_{n}=F_{n+1}^{2}$，于是推出 $b_{n}=\sum_{i=0}^{n}F_{i}^{2}$，$c_{n}=F_{n}^{2}$。</p>
<p>有一个结论是 $\sum_{i=0}^{n}F_{i}^{2}=F_{n}F_{n+1}$，证明也不难。于是就这样 xjb 写了个矩乘。</p>
<p>然后去看测试点 3。</p>
<p>自然数 $k$ 次方和，恩没难……等等四次方和是啥（</p>
<p><a href="https://www.zybang.com/question/cd5fa7b364c5ac9f3194eac2525ae6aa.html">https://www.zybang.com/question/cd5fa7b364c5ac9f3194eac2525ae6aa.html</a></p>
<p>光速逃（</p>
<p>然后去看测试点 4。</p>
<p>如果把 <code>1</code> 看成黑点，<code>0</code> 看成白点，<code>type=0</code> 就是在遍历所有黑点对，直接一个 $\text{cnt}(\text{cnt}-1)$ 解决。</p>
<p><code>type=1</code> 就是对于每个黑点，求出其到所有白点的曼哈顿距离的最小值，再求和。</p>
<p>不难想到枚举这个最小值，虽然复杂度很假但是数据随机啊（</p>
<p>然后去看测试点 5。</p>
<p>很明显的仅包含黑点的矩形的计数……等等，这不就是半个<a href="https://www.luogu.org/problemnew/show/P5300">与或和</a> 吗（</p>
<p>然后我就突然回想起来了，那道题 WA 成 0 分的记忆。</p>
<p>先把前 4 个点交上去看看吧。然后 10+1+10+6=27。</p>
<p>诶我测试点 4 怎么 6 分啊……一看发现 <code>type=0</code> 写成了 $\cfrac{1}{2}\text{cnt}(\text{cnt}-1)$……</p>
<p>关于测试点 2……先放一放。</p>
<p>然后去看测试点 6。</p>
<p>感觉不怎么会光速弃疗。</p>
<p>然后去看测试点 7。</p>
<p>经过一番分析，我发现这是在求给定数独字典序最小的解，然后第 $i$ 组数据输出前 $i$ 行？（并不是）</p>
<p>打了个爆搜然后跑到死也只跑出来前三组。</p>
<p>哦不我连搜索都不会写了，我失败了 :(</p>
<p>然后去看测试点 8。</p>
<p>大致可以抽象成是给你 7 个点，每个点权值 $w_{i}\in[1,n]\cap\mathbb{N}$，再给你一些边，对于一条边 $(x,y)$，必须要有 $w_{x}\lt w_{y}$，求方案数。</p>
<p>第 1 问给了一条链，很明显方案数就是 $C_{n}^{7}$。</p>
<p>看到后 9 问好像十分麻烦，先跳过吧。</p>
<p>然后去看测试点 9。</p>
<p>一上来一坨字符画一样的东西差点吓到我。</p>
<p>从 VSCode 右边的缩略图里能够很明显看出是一个人。</p>
<p>在仔细阅读了代码之后，我发现这是 10 道解答题。</p>
<p>然后……诶好像差不多该溜了。</p>
<h3 id="2019-04-27"><a href="#2019-04-27" class="headerlink" title="2019-04-27"></a>2019-04-27</h3><p>一大早上被比我不知道强到哪里去了的 asuldb 安利了一道<a href="/luogu-p5176-solution/">看上去很吓人的题</a>。</p>
<p>继续来搞这道提答。</p>
<p>答上了测试点 9 的前两问，然后去看测试点 10……？？！！</p>
<p>这是什么鬼东西怎么这么一大坨子函数……</p>
<p>一开始没看源文件大小，后来一看发现竟然有 1000+KB。</p>
<p>吓得我电脑都卡了。</p>
<p>发现本质上是让求 <code>_()</code> 这个函数的调用次数。于是我就让这个函数返回 1，其他函数返回它调用的所有函数的返回值之和。</p>
<p>然后……算是勉强凑出来前 3 问，5 行左右。</p>
<p>一交……诶我后两个点怎么还 RE 了？</p>
<p>不会是我没交 4 和 5 的 <code>.out</code> 文件吧……然后发现还真是，补上去两个空文件之后评测结果正常了，10+1+10+10+0+0+0+1+2+5=39。</p>
<p>然后发现测试点 7 实际上是将整个数独压成一行复读 $i$ 遍。（好像也不是）</p>
<p>6，8，9，10 四个点挣扎了一会还是弃疗了。</p>
<p>回去看测试点 5……想到反正数据随机，写了一个稍微优化了一点的暴力。</p>
<p>然后改了改测试点 2。一交发现什么变化都没有。</p>
<p><del>luogu 又出锅了？这么想着</del>又交了一遍，然后还是什么变化都没有。</p>
<p>// 以上内容差不多是以回忆的形式写下来的。接下来差不多是边调题边写（</p>
<p>然后发现我测试点 5 的二维前缀和写错了（</p>
<p>仔细一推测试点 2 发现</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{Ans}&=F_{n+1}^{2}-2\sum_{i=0}^{n}F_{i}^{2}+F_{n}^{2}\\
&=F_{n+1}^{2}-2F_{n+1}F_{n}+F_{n}^{2}\\
&=F_{n-1}^{2}
\end{aligned}</script><p>但是就算这样也不应该 WA 啊……写了个暴力发现是因为偷懒矩阵没清空……</p>
<p>然后再一交，10+10+10+10+10+0+0+1+2+5=58。</p>
<p>然后我突然有了一个想法，对于测试点 10，我可以直接用一个 <code>std::map</code> 维护出源文件中的所有函数的值啊。</p>
<p>写了写一交……诶怎么还少了 4 分？</p>
<p>一检查发现只是计算了调用次数，忘了再乘以那个 <code>___</code>。</p>
<p>于是再一交，10+10+10+10+10+0+0+1+2+10=63。</p>
<p>回去看了看测试点 7，感觉没救了，于是想搞一搞测试点 9。</p>
<p>看到第 4 问的答案只有 3 个字符，直接搜于是搜出来一个 <script type="math/tex">_</script>。</p>
<p>再像这样搜了一下第 5 问发现是 <code>we</code>。</p>
<p>考虑到后面都是英文单词了于是把枚举的范围压缩到了 <code>a</code>~<code>z</code>。</p>
<p>然后搜出了第 6 问是 <code>hold</code>，第 7 问是 <code>these</code>。</p>
<p>然后上百度一查发现这句话是 <code>we hold these truths to be self-evident</code>。</p>
<p>那么还剩第 3 问那个人名……这种问题无解吧，尤其是对于我这种咸鱼来说。</p>
<p>于是一交，10+10+10+10+10+0+0+1+9+10=70。</p>
<p>简单推了一下测试点 7，发现指数非常有规律，于是把系数扔到 OEIS 搜了一波。</p>
<p>虽然是<a href="http://oeis.org/A137560">找到了</a>，但是公式也没有生成函数也没有什么也没有。</p>
<p>下面还给我来一行 approved（</p>
<p>弃疗。告辞。</p>
]]></content>
      <categories>
        <category>瞎搞</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>提交答案</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2019R2游记」不会起标题了</title>
    <url>/sdoi2019r2-notes/</url>
    <content><![CDATA[<p>我好菜啊。</p>
<a id="more"></a>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>上午 loli 搞了场模拟赛。</p>
<p>发的第一套题目好像学长们都做过，于是又发了第二套。</p>
<p>然后神仙 hz 随手秒了 T2。</p>
<p>想我这种辣鸡只能在旁边看着。</p>
<p>到最后还是没有人认真写，快乐地颓废了一个上午。</p>
<p>下午当然是回家。</p>
<p>感觉自己最近日渐颓废。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>一觉睡到 11 点，然后去学校坐车。</p>
<p>因为人很少所以可以一个人占两个位，虽然我一轮时也是这么坐的。</p>
<p>一路上一边听音乐一边睡觉不知不觉到了济南。</p>
<p>然后翻山越岭走了 1km 的路去试机。济南的坡多到爆炸。</p>
<p>去抽签发现抽到了最后一个编号 83 号，这一定预示着我要垫底了。</p>
<p>试机的时候什么也没干，就那么看着其他的神仙敲键盘。</p>
<p>……差点忘了一件事，考场的键盘 Ctrl 不在最左下角，最左下角是 Fn，再往右才是 Ctrl，按起来肥肠别扭。</p>
<p>本来 loli 是想让我们出去吃的，结果我们集体跳车，就只剩下 hz、cst、dsq 三个人在那<del>，想想还有点尬</del>。</p>
<p>于是什么也没吃。</p>
<p>晚上玩了玩鬼形兽，不知道是因为资源太少还是啥，糟了好一段时间才通。</p>
<p>睡觉前 loli 日常奶人。</p>
<h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>总之是 7 点下去吃了早饭。然后再次翻山越岭去考场。</p>
<p>开考前可以随便动键盘，然而就算这样也没干啥。</p>
<p>解压密码画风似乎海星的样子。</p>
<p>首先大概扫了一眼三道题。回来看 T1，我们发现这是一道简单题。</p>
<p>然而我却因为这道题调了 1h+。自闭。</p>
<p>T2 不会，什么毒瘤题部分分都不给的。</p>
<p>T3 大概会 20 左右。</p>
<p>除了考场发现人均 120，这样要是一不小心写挂了哪直接就没了啊。</p>
<p>咕掉了下午的讲题。</p>
<p>成绩发下来发现自己 100+0+10=110，海星。</p>
<p>然后同级的其他神仙：</p>
<ul>
<li>cst：100+0+10=110</li>
<li>shzr：50+0+20=70</li>
<li>wyx：50+0+0=50</li>
<li>wzx：0+0+20=20</li>
</ul>
<p><del>然后一看 rqy 甚至也 0+100+0=100，但是他切了 T2 啊 orz。</del></p>
<p>大概看了一下群里发的题解，不过自然是什么也看不懂。</p>
<p>快乐地颓了一个下午。</p>
<p><del>闲着没事开了一把桃源宫 PH，结果打到终符 loli 突然杀了进来。</del></p>
<p>然后莫名其妙被 loli 奶了一口，「zyc 比较稳」<del>，于是伏笔就这么埋下了</del>。</p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>本来对今天也没报多少希望。</p>
<p>拿到压缩包发现今天似乎没有大样例。</p>
<p>解压完之后，还是扫一眼三道题。感觉一道都不会的样子。</p>
<p>去看了看 T2，发现好像是个阶梯 Nim……但是我不会啊。</p>
<p>开始打表。结果好像真的打出规律来了。</p>
<p>于是头铁玩了 5h 的 T2。并且喜提爆零。</p>
<p>看他们好像都会 T1 的样子……自闭。</p>
<p>并没有怎么看成绩。反正都爆零了就这样吧。</p>
<p>听 wzx 说 shzr 从最开始稳到现在，结果最后一天翻车让 wyx 翻进女队。</p>
<p>走到最后来发现自己什么也没有，就这样回去了。</p>
<p>大概这就是菜鸡的命运吧。</p>
<p>回头一看，似乎自从一轮 D2 炸掉之后，我就不应该报太大希望的。</p>
<p>虽然说勉强苟进了二轮，但是这并没有什么用。</p>
<p>告辞。然后一想到后面还有合格考……去世 .jpg</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5178」公约数</title>
    <url>/luogu-p5176-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5176">传送门</a></p>
<a id="more"></a>
<p>首先我们看到要求的这个式子……这什么鬼啊能做吗（</p>
<p>冷静分析一波，我们可以根据括号里的两个加号将原式拆分成三个三重 $\sum$</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(i,j)}{(i,k)\cdot(j,k)}\\
+&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(i,k)}{(i,j)\cdot(j,k)}\\
+&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(j,k)}{(i,j)\cdot(i,k)}
\end{aligned}</script><p>首先我们单独考虑第一个</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(i,j)}{(i,k)\cdot(j,k)}\\
=&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,(i,j)k)\cdot((i,j),k)\cdot\cfrac{(i,j)}{(i,k)\cdot(j,k)}\\
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}(d^{2}xy,dk)\cdot(d,k)\cdot\cfrac{d}{(dx,k)\cdot(dy,k)}\\
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}d^{2}\cdot(d,k)\cdot\cfrac{(dxy,k)}{(dx,k)\cdot(dy,k)}\\
\end{aligned}</script><p>考虑将 $d,x,y,k$ 写成唯一分解形式，然后对于第 $i$ 小的质数 $c_{i}$，它在四个数中的指数分别是 $r_{d,i},r_{x,i},r_{y,i},r_{k,i}$，那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}d^{2}\prod_{i=1}c_{i}^{\min(r_{d,i},r_{k,i})+\min(r_{d,i}+r_{x,i}+r_{y,i},r_{k,i})-\min(r_{d,i}+r_{x,i},r_{k,i})-\min(r_{d,i}+r_{y,i},r_{k,i})}
\end{aligned}</script><p>因为 $x\perp y$，$r_{x,i}$ 和 $r_{y,i}$ 中必定有一个为 $0$，带入整理后我们得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}d^{2}\\
=&p\sum_{i=1}^{n}\sum_{j=1}^{m}(i,j)^{2}
\end{aligned}</script><p>对剩下的两个三重 $\sum$ 也进行类似的化简，最后我们得到答案就是</p>
<script type="math/tex; mode=display">
p\sum_{i=1}^{n}\sum_{j=1}^{m}(i,j)^{2}+m\sum_{i=1}^{n}\sum_{j=1}^{p}(i,j)^{2}+n\sum_{i=1}^{m}\sum_{j=1}^{p}(i,j)^{2}</script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「CF570D」Tree Requests</title>
    <url>/cf570d-solution/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/570/D">传送门</a></p>
<a id="more"></a>
<p>听说是道 dsu on tree 的题。然而我不会 dsu（</p>
<p>我们把题目给的字母 $c$ 转化成 $2^{c-\mathrm{a}}$。这样如果一些节点的权值异或和是 $2^{k}(k\in\mathbb{N}^{+})$ 或 $0$，它们就能够排列成回文串。</p>
<p>我们想到，如果我们能将这些节点重新编号，使得每个询问涉及到的所有节点的新编号都是一个连续的区间，我们就可以直接提取出前缀和。</p>
<p>那么如何编号？BFS 序。</p>
<p>一个显然的性质是，如果我们在构建 DFS 序和 BFS 序时访问每条边的顺序一致，那么对于深度相同且 BFS 序递增的一段区间，它们的 DFS 序一定也是递增的。</p>
<p>于是我们在构建 BFS 序时预处理每个深度的节点的对应区间，然后二分定位到 $v_{i}$ 的子树内的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ec;</span><br><span class="line"><span class="keyword">int</span> des[maxn+<span class="number">1</span>],suc[maxn+<span class="number">1</span>],las[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn+<span class="number">1</span>],dep[maxn+<span class="number">1</span>],size[maxn+<span class="number">1</span>],h[maxn+<span class="number">1</span>],p[maxn+<span class="number">1</span>],bfn[maxn+<span class="number">1</span>],lwr[maxn+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">1</span>],val[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     des[++ec]=y;</span><br><span class="line">     suc[ec]=las[x];</span><br><span class="line">     las[x]=ec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr)</span></span>&#123;</span><br><span class="line">     dfn[cur]=++dfn[<span class="number">0</span>];</span><br><span class="line">     dep[cur]=dep[ftr]+<span class="number">1</span>;</span><br><span class="line">     size[cur]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])&#123;</span><br><span class="line">         dfs(des[i],cur);</span><br><span class="line">         size[cur]+=size[des[i]];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         <span class="keyword">int</span> x;</span><br><span class="line">         cltstream::read(x);</span><br><span class="line">         connect(x,i);</span><br><span class="line">     &#125;</span><br><span class="line">     dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">     h[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;head&lt;tail;)&#123;</span><br><span class="line">         re <span class="keyword">int</span> x=h[++head];</span><br><span class="line">         p[head]=dfn[x];</span><br><span class="line">         bfn[x]=head;</span><br><span class="line">         dep[x]&gt;dep[h[head<span class="number">-1</span>]]&amp;&amp;(lwr[dep[x]]=head);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[x];i;i=suc[i])</span><br><span class="line">             h[++tail]=des[i];</span><br><span class="line">     &#125;</span><br><span class="line">     lwr[dep[h[n]]+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         re <span class="keyword">char</span> c=cltstream::gc();</span><br><span class="line">         <span class="keyword">for</span>(;c&lt;<span class="string">'a'</span>||c&gt;<span class="string">'z'</span>;c=cltstream::gc());</span><br><span class="line">         a[i]=<span class="number">1</span>&lt;&lt;(c-<span class="string">'a'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">         val[i]=val[i<span class="number">-1</span>]^a[h[i]];</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">         <span class="keyword">int</span> x,y;</span><br><span class="line">         cltstream::read(x);</span><br><span class="line">         cltstream::read(y);</span><br><span class="line">         re <span class="keyword">int</span> L=<span class="built_in">std</span>::lower_bound(p+lwr[y],p+lwr[y+<span class="number">1</span>],dfn[x])-p;</span><br><span class="line">         re <span class="keyword">int</span> R=<span class="built_in">std</span>::lower_bound(p+lwr[y],p+lwr[y+<span class="number">1</span>],dfn[x]+size[x])-p<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span>(L&lt;=R)&#123;</span><br><span class="line">             re <span class="keyword">int</span> v=val[R]^val[L<span class="number">-1</span>];</span><br><span class="line">             <span class="keyword">if</span>((v&amp;(v<span class="number">-1</span>))==<span class="number">0</span>)</span><br><span class="line">                 cltstream::pc(<span class="string">'Y'</span>),cltstream::pc(<span class="string">'e'</span>),cltstream::pc(<span class="string">'s'</span>),cltstream::pc(<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 cltstream::pc(<span class="string">'N'</span>),cltstream::pc(<span class="string">'o'</span>),cltstream::pc(<span class="number">10</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             cltstream::pc(<span class="string">'Y'</span>),cltstream::pc(<span class="string">'e'</span>),cltstream::pc(<span class="string">'s'</span>),cltstream::pc(<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS序</tag>
        <tag>BFS序</tag>
      </tags>
  </entry>
  <entry>
    <title>大概算是个斯特林数总结？</title>
    <url>/strling-number-notes/</url>
    <content><![CDATA[<p>看到 wzx 写了个斯特林数总结，于是也想来写一个。</p>
<a id="more"></a>
<h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>将 $n$ 个有标号的元素放入 $m$ 个无标号的集合，且不允许空集的方案数。记为 ${n\brace m}$。</p>
<h4 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h4><script type="math/tex; mode=display">
{n\brace m}={n-1\brace m-1}+m{n-1\brace m}</script><p>考虑第 $n$ 个元素单独构成一个集合还是加入之前的某个集合即可。</p>
<script type="math/tex; mode=display">
{n\brace 0}=1\qquad(n\geqslant 0)</script><script type="math/tex; mode=display">
{n\brace n}=0\qquad(n\gt 0)</script><h4 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h4><script type="math/tex; mode=display">
{n\brace m}=\cfrac{1}{m!}\sum_{i=0}^{m}(-1)^{i}{m\choose i}(m-i)^{n}=\sum_{i=0}^{m}\cfrac{(-1)^{i}}{i!}\cfrac{(m-i)^{n}}{(m-i)!}</script><p>大力容斥即可。</p>
<p>不难发现等式最右边形成了卷积的形式，这使得我们能够在 $O(n\log n)$ 的时间复杂度内计算出 ${n\brace i}$。</p>
<h4 id="自然数的次幂及幂和"><a href="#自然数的次幂及幂和" class="headerlink" title="自然数的次幂及幂和"></a>自然数的次幂及幂和</h4><script type="math/tex; mode=display">
m^{n}=\sum_{i=1}^{m}{m\choose i}i!{n\brace i}</script><p>考虑将 $n$ 个有标号的元素任意地放入 $m$ 个有标号的集合。每个元素都有 $m$ 种选择，因此总方案数为 $m^{n}$。</p>
<p>在这一过程中，可能只有部分集合非空。我们枚举这些非空集合的排列，然后将所有元素放入这些集合，并且这次不允许空集。</p>
<p>显然上述两种方法是等价的。</p>
<p>利用上面这个公式，我们还可以计算自然数的幂和。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^{n-1}i^{m}&=[m=0]+\sum_{i=1}^{n-1}i^{m}\\
&=[m=0]+\sum_{i=1}^{n-1}\sum_{j=1}^{i}{i\choose j}j!{m\brace j}\\
&=[m=0]+\sum_{j=1}^{n-1}j!{m\brace j}\sum_{i=j}^{n-1}{i\choose j}\\
&=[m=0]+\sum_{j=1}^{n-1}j!{m\brace j}{n\choose j+1}\\
&=[m=0]+\sum_{j=1}^{n-1}{m\brace j}\cfrac{n^{\underline{j+1}}}{j+1}
\end{aligned}</script><p>关于 $\sum_{i=j}^{n-1}{i\choose j}={n\choose j+1}$，我们可以认为，等式左边枚举了一个最左侧的位置，然后再在这个位置右侧选择 $j$ 个元素。</p>
<h4 id="次幂转下降幂"><a href="#次幂转下降幂" class="headerlink" title="次幂转下降幂"></a>次幂转下降幂</h4><script type="math/tex; mode=display">
x^{n}=\sum_{i=0}^{n}{n\brace i}x^{\underline{i}}</script><p>考虑数学归纳法。</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^{n+1}&=x\cdot x^{n}\\
&=\sum_{i=0}^{n}{n\brace i}x\cdot x^{\underline{i}}\\
&=\sum_{i=0}^{n}{n\brace i}(x-i+i)x^{\underline{i}}\\
&=\sum_{i=0}^{n}{n\brace i}x^{\underline{i+1}}+\sum_{i=0}^{n}{n\brace i}ix^{\underline{i}}\\
&=\sum_{i=0}^{n+1}{n\brace i-1}x^{\underline{i}}+\sum_{i=0}^{n+1}{n\brace i}ix^{\underline{i}}\\
&=\sum_{i=0}^{n+1}{n+1\brace i}x^{\underline{i}}
\end{aligned}</script><h3 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3><p>这里我们讨论无符号第一类斯特林数。</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>$n$ 个有标号的元素构成 $m$ 个圆排列的方案数。记为 ${n\brack m}$。</p>
<h4 id="递推式-1"><a href="#递推式-1" class="headerlink" title="递推式"></a>递推式</h4><script type="math/tex; mode=display">
{n\brack m}={n-1\brack m-1}+(n-1){n-1\brack m}</script><p>考虑第 $n$ 个元素单独构成一个圆排列还是插入到之前的某个元素之前即可。</p>
<script type="math/tex; mode=display">
{n\brack 0}=1\qquad(n\geqslant 0)</script><script type="math/tex; mode=display">
{n\brack n}=0\qquad(n\gt 0)</script><h4 id="通项公式-1"><a href="#通项公式-1" class="headerlink" title="通项公式"></a>通项公式</h4><p>大概……没有吧。</p>
<h4 id="下降幂转次幂"><a href="#下降幂转次幂" class="headerlink" title="下降幂转次幂"></a>下降幂转次幂</h4><script type="math/tex; mode=display">
x^{\underline{n}}=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}x^{i}</script><p>考虑数学归纳法。</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^{\underline{n+1}}&=(x-n)x^{\underline{n}}\\
&=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}(x-n)x^{i}\\
&=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}x^{i+1}+\sum_{i=0}^{n}(-1)^{n-i+1}{n\brack i}nx^{i}\\
&=\sum_{i=0}^{n+1}(-1)^{n-i+1}{n\brack i-1}x^{i}+\sum_{i=0}^{n+1}(-1)^{n-i+1}{n\brack i}nx^{i}\\
&=\sum_{i=0}^{n+1}(-1)^{n-i+1}{n+1\brack i}x^{i}
\end{aligned}</script><h3 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h3><p>观察下面两个式子</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^{n}&=\sum_{i=0}^{n}{n\brace i}x^{\underline{i}}\\
x^{\underline{n}}&=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}x^{i}
\end{aligned}</script><p>将它们套在一起</p>
<script type="math/tex; mode=display">
x^{\underline{n}}=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}\sum_{j=0}^{i}{i\brace j}x^{\underline{j}}\\=\sum_{j=0}^{n}\sum_{i=j}^{n}(-1)^{n-i}{n\brack i}{i\brace j}x^{\underline{j}}</script><p>于是</p>
<script type="math/tex; mode=display">
\sum_{i=m}^{n}(-1)^{n-i}{n\brack i}{i\brace m}=[m=n]</script>]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>常系数齐次线性递推式第n项的计算</title>
    <url>/linear-ditui-learning-notes/</url>
    <content><![CDATA[<p>没想到我竟然还有再次回到机房的一天。</p>
<p><del>在家颓了两个月了（</del></p>
<p>没想到我竟然还有再次开始写题的一天。</p>
<p><del>luogu 都掉蓝了（</del></p>
<p>没想到我竟然还有再次更新 blog 的一天。</p>
<p><del>上一次还是五月份的时候（</del></p>
<p>我也不知道为什么我要学这么个东西（指标题），而且它好像还没什么用。</p>
<p>反正我就是学了。</p>
<p><del>谁能告诉我递推怎么翻译成英语。扔给 google 它拼命告诉我 recursion（</del></p>
<p>好像扯得有点多的样子。</p>
<p><a href="https://www.luogu.org/problem/P4723">传送门</a></p>
<a id="more"></a>
<p>首先我们分析一下我们需要干什么 (?)。</p>
<p>我们需要计算一个满足以下三个要求的递推数列：</p>
<ol>
<li>「常系数」，指递推过程中用到的系数与下标 $n$ 无关。</li>
<li>「齐次」，指递推式中不存在常数项。</li>
<li>「线性」，指递推式中仅存在一次项（算上系数是二次）。</li>
</ol>
<p><del>不过好像存在常数项也能做的样子。</del></p>
<p>此类递推式一般具有以下形式</p>
<script type="math/tex; mode=display">
a_{n}=\sum_{i=1}^{k}f_{i}a_{n-i}</script><p>其中 $f_{1},f_{2},\cdots,f_{k}$ 为系数数列。</p>
<p>上式仅针对于 $n\geqslant k$ 的情况，$n\lt k$ 时 $a_{n}$ 会被给出。</p>
<p>如下定义初始向量 $S$</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
&a_{0}&\\
&a_{1}\\
&a_{2}\\
&\vdots\\
&a_{k-3}\\
&a_{k-2}\\
&a_{k-1}
\end{bmatrix}</script><p>如下构造矩阵 $A$</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
&0&1&0&\cdots&0&0&0&\\
&0&0&1&\cdots&0&0&0\\
&0&0&0&\cdots&0&0&0\\
&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\
&0&0&0&\cdots&0&1&0\\
&0&0&0&\cdots&0&0&1\\
&f_{k}&f_{k-1}&f_{k-2}&\cdots&f_{3}&f_{2}&f_{1}
\end{bmatrix}</script><p>我们有</p>
<script type="math/tex; mode=display">
a_{n}=(A^{n}S)_{0}</script><p>于是我们计算出 $A^{n}$ 即可。但该过程需要的时间复杂度是 $O(k^{3}\log n)$ 的。</p>
<p>假设，我们有了一个奇妙的序列 $q_{0},q_{1},\cdots,q_{k-1}$，它满足</p>
<script type="math/tex; mode=display">
A^{n}=\sum_{i=0}^{k-1}q_{i}A^{i}</script><p>这样一来，我们就可以在 $O(k^{4})$ 的时间复杂度内……</p>
<p>不，实际上我们并不需要知道整个 $A^{n}$，我们仅需要知道 $A^{n}S$，或者更进一步地，知道 $(A^{n}S)_{0}$ 即可。</p>
<p>我们把上式两边乘以 $S$，然后整理</p>
<script type="math/tex; mode=display">
\begin{aligned}
A^{n}S&=\left(\sum_{i=0}^{k-1}q_{i}A^{i}\right)S\\
A^{n}S&=\sum_{i=0}^{k-1}q_{i}A^{i}S\\
A^{n}S&=\sum_{i=0}^{k-1}q_{i}(A^{i}S)\\
(A^{n}S)_{0}&=\sum_{i=0}^{k-1}q_{i}(A^{i}S)_{0}\\
a_{n}&=\sum_{i=0}^{k-1}q_{i}a_{i}
\end{aligned}</script><p>我们于是得到这样的式子。这使得我们能够在 $O(k)$ 的时间复杂度内计算答案。</p>
<p>然后我们考虑如何构造 $q_{i}$。</p>
<p>注意到 $\sum_{i=0}^{k-1}q_{i}A^{i}$ 的次数比 $A^{n}$ 低，我们令</p>
<script type="math/tex; mode=display">
A^{n}=P(A)G(A)+Q(A)</script><p>其中 $P,G,Q$ 是三个矩阵多项式，并且我们钦定 $G$ 的次数是 $k$，$PG$ 的次数是 $n$。</p>
<p>如果说，这个 $G$ 还满足 $G(A)=0$，我们就有</p>
<script type="math/tex; mode=display">
A^{n}=\sum_{i=0}^{k-1}q_{i}A^{i}=Q(A)</script><p>也就是说，我们要求的 $q_{i}$，就是 $Q$ 的系数，而 $Q$ 是 $A^{n}$ 对 $G$ 取模的结果。</p>
<p>这一过程可以通过快速幂实现，只是取模从整数取模变成了多项式取模。时间复杂度 $O(k\log k\log n)$。</p>
<p>于是我们考虑如何构造 $G$ 的系数 $g_{i}$。</p>
<p>通过查阅题解 (??)，我们得知</p>
<script type="math/tex; mode=display">
g_{i}=\begin{cases}
&-f_{k-i}\;\;\;\;\;\;\;\;&(i\lt k)\\
&1&(i=k)
\end{cases}</script><p><del>证明？不会，告辞。</del></p>
<p>总结一下就是：</p>
<ol>
<li>构造多项式 $G$。</li>
<li>计算多项式 $Q=A^{n}\operatorname{mod} G$。</li>
<li>计算 $a_{n}=\sum_{i=0}^{k-1}q_{i}a_{i}$。</li>
</ol>
<blockquote>
<p>Updated on 2019-08-04</p>
<p><img src="/images/TIM 截图 20190804192526.png" alt=""></p>
<p>告辞 .jpg</p>
</blockquote>
]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>向量</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>不会起标题（理直气壮）</title>
    <url>/polynomial-xxx-notes/</url>
    <content><![CDATA[<p>从 APIO 回来发现 luogu 多了几道 NTT 的板子题，于是来写一下。</p>
<p>关于游记……可能不会发了。</p>
<a id="more"></a>
<h3 id="普通多项式转下降幂多项式"><a href="#普通多项式转下降幂多项式" class="headerlink" title="普通多项式转下降幂多项式"></a><a href="https://www.luogu.org/problemnew/show/P5383">普通多项式转下降幂多项式</a></h3><script type="math/tex; mode=display">
x^{n}=\sum_{i=0}^{n}S(n,i)x^{\underline{i}}</script><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^{n-1}f_{i}x^{i}&=\sum_{i=0}^{n-1}f_{i}\sum_{j=0}^{i}S(i,j)x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{i=0}^{n-1}S(i,j)f_{i}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{i=0}^{n-1}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}f_{i}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{1}{(j-k)!}\sum_{i=0}^{n-1}(j-k)^{i}f_{i}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{F(j-k)}{(j-k)!}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}g_{j}x^{\underline{j}}
\end{aligned}</script><p>所以</p>
<script type="math/tex; mode=display">
g_{i}=\sum_{j=0}^{i}\cfrac{(-1)^{j}}{j!}\cfrac{F(i-j)}{(i-j)!}</script><p>其中求 $F(i-j)$ 需要多点求值。然而我不会。</p>
<p>告辞。</p>
<h3 id="下降幂多项式转普通多项式"><a href="#下降幂多项式转普通多项式" class="headerlink" title="下降幂多项式转普通多项式"></a><a href="https://www.luogu.org/problemnew/show/P5393">下降幂多项式转普通多项式</a></h3><script type="math/tex; mode=display">
x^{\underline{n}}=\sum_{i=0}^{n}(-1)^{n-i}s(n,i)x^{i}</script><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^{n-1}f_{i}x^{\underline{i}}&=\sum_{i=0}^{n-1}f_{i}\sum_{j=0}^{i}(-1)^{i-j}s(i,j)x^{j}\\
&=\sum_{j=0}^{n-1}\sum_{i=0}^{n-1}(-1)^{i-j}s(i,j)f_{i}x^{j}
\end{aligned}</script><p>……告辞。</p>
<h3 id="下降幂多项式乘法"><a href="#下降幂多项式乘法" class="headerlink" title="下降幂多项式乘法"></a><a href="https://www.luogu.org/problemnew/show/P5394">下降幂多项式乘法</a></h3><p>根据提示，一个下降幂多项式可以唯一确定一个次数相同的普通多项式，我们只需要转过去乘起来再转回来就好了！</p>
<p>……大概吧。</p>
<h3 id="第二类斯特林数-·-行"><a href="#第二类斯特林数-·-行" class="headerlink" title="第二类斯特林数 · 行"></a><a href="https://www.luogu.org/problemnew/show/P5395">第二类斯特林数 · 行</a></h3><p>紫题警告。不过的确简单。第二类斯特林数的通项公式推一推就能推成卷积形式。</p>
<h3 id="第二类斯特林数-·-列"><a href="#第二类斯特林数-·-列" class="headerlink" title="第二类斯特林数 · 列"></a><a href="https://www.luogu.org/problemnew/show/P5396">第二类斯特林数 · 列</a></h3><p><del>不会。抄的题解。</del></p>
<p>定义</p>
<script type="math/tex; mode=display">
S_{m}(x)=\sum_{i=0}^{+\infty}S(i,m)x^{i}</script><p>利用第二类斯特林数的递推公式</p>
<script type="math/tex; mode=display">
S(n,m)=S(n-1,m-1)+mS(n-1,m)</script><p>我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
S_{m}(x)&=\sum_{i=0}^{+\infty}S(i,m)x^{i}\\
&=\sum_{i=0}^{+\infty}(S(i-1,m-1)+mS(i-1,m))x^{i}\\
&=S_{m-1}(x)x+mS_{m}(x)x\\
&=\cfrac{S_{m-1}(x)x}{1-mx}\\
&=\cfrac{x^{m}}{\prod_{i=1}^{m}(1-ix)}
\end{aligned}</script><p>关于类似 $\prod(1-ix)$ 这种的怎么计算……我怎么觉得我提过好几遍了呢（</p>
<h3 id="第一类斯特林数-·-行"><a href="#第一类斯特林数-·-行" class="headerlink" title="第一类斯特林数 · 行"></a><a href="https://www.luogu.org/problemnew/show/P5408">第一类斯特林数 · 行</a></h3><p>思路与「第二类斯特林数 · 列」类似。</p>
<script type="math/tex; mode=display">
s(n,m)=s(n-1,m-1)+(n-1)s(n-1,m)</script><script type="math/tex; mode=display">
\begin{aligned}
s_{n}(x)&=\sum_{i=0}^{+\infty}s(n,i)x^{i}\\
&=\sum_{i=0}^{+\infty}(s(n-1,i-1)+(n-1)s(n-1,i))x^{i}\\
&=(n-1+x)s_{n-1}(x)\\
&=\prod_{i=0}^{n-1}(i+x)
\end{aligned}</script><h3 id="第一类斯特林数-·-列"><a href="#第一类斯特林数-·-列" class="headerlink" title="第一类斯特林数 · 列"></a><a href="https://www.luogu.org/problemnew/show/P5409">第一类斯特林数 · 列</a></h3><p>我们发现「第二类斯特林数 · 列」和「第一类斯特林数 · 行」的思路行不通了。</p>
<p><del>题解，打开。</del></p>
<p>我们来观察一下这个式子</p>
<script type="math/tex; mode=display">
(1+x)^{t}</script><p><del>似乎并没有什么用。</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
(1+x)^{t}&=\sum_{i=0}^{t}C(t,i)x^{i}\\
&=\sum_{i=0}^{+\infty}C(t,i)x^{i}\\
&=\sum_{i=0}^{+\infty}\cfrac{t^{\underline{i}}}{i!}x^{i}\\
&=\sum_{i=0}^{+\infty}\cfrac{1}{i!}\sum_{j=0}^{i}(-1)^{i-j}s(i,j)t^{j}x^{i}\\
&=\sum_{j=0}^{+\infty}\sum_{i=j}^{+\infty}\cfrac{1}{i!}(-1)^{i-j}s(i,j)x^{i}t^{j}\\
(1+x)^{t}&=e^{t\ln(1+x)}\\
&=\sum_{i=0}^{+\infty}\cfrac{(1+x)^{i}}{i!}t^{i}\\
&=\sum_{i=0}^{+\infty}\cfrac{1}{i!}\sum_{j=0}^{i}C(i,j)x^{j}t^{i}
\end{aligned}</script><p>根据上面两个不同的整理过程，我们有</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{+\infty}\sum_{j=i}^{+\infty}\cfrac{1}{j!}(-1)^{j-i}s(j,i)x^{j}t^{i}=\sum_{i=0}^{+\infty}\cfrac{1}{i!}\sum_{j=0}^{i}C(i,j)x^{j}t^{i}</script><p>进一步地</p>
<script type="math/tex; mode=display">
\sum_{j=i}^{+\infty}\cfrac{1}{j!}(-1)^{j-i}s(j,i)x^{j}=\cfrac{1}{i!}\sum_{j=0}^{i}C(i,j)x^{j}</script>]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5349」幂</title>
    <url>/luogu-p5349-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5349">传送门</a></p>
<a id="more"></a>
<p><del>其实挺休闲的一道题（</del></p>
<script type="math/tex; mode=display">
\sum_{i=0}f(i)r^{i}=\sum_{i=0}\sum_{j=0}^{m}f_{j}i^{j}r^{i}=\sum_{j=0}^{m}f_{j}\sum_{i=0}i^{j}r^{i}</script><p>于是我们设</p>
<script type="math/tex; mode=display">
g_{n}=\sum_{i=0}i^{n}r^{i}</script><script type="math/tex; mode=display">
\begin{aligned}
g_{n}&=\sum_{i=0}i^{n}r^{i}\\
&=\sum_{i=0}(i-1+1)^{n}r^{i}\\
&=\sum_{i=0}\sum_{j=0}^{n}\binom{n}{j}(i-1)^{j}r^{i}\\
&=\sum_{j=0}^{n}\binom{n}{j}\sum_{i=0}(i-1)^{j}r^{i}\\
&=n!\sum_{j=0}^{n}\cfrac{\sum_{i=0}(i-1)^{j}r^{i-1}}{j!}\cfrac{r}{(n-j)!}\\
\cfrac{g_{n}}{n!}&=\sum_{j=0}^{n}\cfrac{g_{j}}{j!}\cfrac{r}{(n-j)!}\\
\end{aligned}</script><p>我们不难发现卷积的形式。于是此题完。告辞。</p>
<p><del>怎么这么短啊（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn];</span><br><span class="line"><span class="keyword">int</span> n,r;</span><br><span class="line"><span class="keyword">int</span> fac[maxn],fnv[maxn],F[maxn],G[maxn],H[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(;y;x=<span class="number">1L</span>L*x*x%mod,y&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">             res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">             swap(F[i],F[rev[i]]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                 re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                 F[j]=(x+y)%mod;</span><br><span class="line">                 F[j+p]=(x-y+mod)%mod;</span><br><span class="line">             &#125;</span><br><span class="line">     re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">         F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> tmp[maxn];</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;++i)</span><br><span class="line">         G[i]=tmp[i]=<span class="number">0</span>;</span><br><span class="line">     G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">             tmp[k]=F[k];</span><br><span class="line">         NTT(G,j,<span class="number">0</span>);</span><br><span class="line">         NTT(tmp,j,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">             G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">         NTT(G,j,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">             G[k]=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;maxn;++i)</span><br><span class="line">         G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">     unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">         <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">             unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(r);</span><br><span class="line">     fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=fnv[<span class="number">0</span>]=fnv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">         fnv[i]=(mod<span class="number">-1L</span>L*mod/i*fnv[mod%i]%mod)%mod;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         fac[i]=<span class="number">1L</span>L*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">         fnv[i]=<span class="number">1L</span>L*fnv[i<span class="number">-1</span>]*fnv[i]%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         cltstream::read(F[i]);</span><br><span class="line">         H[i]=(mod<span class="number">-1L</span>L*r*fnv[i]%mod)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     ++H[<span class="number">0</span>];</span><br><span class="line">     Inv(H,G,n+<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">         G[i]=<span class="number">1L</span>L*G[i]*fac[i]%mod;</span><br><span class="line">     re <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">         ans=(ans+<span class="number">1L</span>L*F[i]*G[i]%mod)%mod;</span><br><span class="line">     cltstream::write(ans);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「XRound2F」永恒（大概算得上是篇题解）</title>
    <url>/luogu-p5439-solution-probably/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5439">传送门</a></p>
<a id="more"></a>
<p>读完题面，我们很快就想到统计每对点对对答案的贡献，然后累加起来。</p>
<p>于是问题转化成，对于每对点对，求出它们所对应的字符串的 lcp 长度与树上同时经过它们的路径数量之积并求和。</p>
<p>考虑点分治。</p>
<p>对于一个分治中心，我们可以将答案分成两部分，第一部分是分治中心与子树内其它点的贡献，第二部分是分治中心不同子树内的点对的贡献。</p>
<p>对于第一部分，我们直接枚举子树内其它点，然后直接求其与分治中心在 Trie 上对应节点的 lca 的深度，然后乘上其自身的子树大小，与其所在的分治中心的对应子树大小。我们可以通过使用 LCT 维护 Trie 来解决。</p>
<p>对于第二部分，我们在对于一个点计算完它第一部分的贡献之后，查询之前已经完全枚举过的其他子树内的所有点的子树大小与其与该节点在 Trie 上对应节点的 lca 的深度之积并求和。<del>虽然我不是很懂怎么描述，但是反正这个东西 LCT 是可以搞的。</del></p>
<p>计算完以上两部分并累加，我们就得到了答案。不难得出，上述算法的时间复杂度为 $O(n\log^{2}n)$。</p>
<p><a href="https://www.luogu.org/record/22194363">https://www.luogu.org/record/22194363</a></p>
<p><del>然后评测结果就长这样（</del></p>
<p>这时我们点开算法标签，发现里面有个虚树。于是我们来思考用虚树怎么做。</p>
<p>关于上文的第一部分，这个没救，唯一的优化方法就是 $O(1)$ 求 lca。</p>
<p>而关于第二部分，如果我们定义两个点之间的距离为它们的子树大小之积再乘以它们在 Trie 上对应节点的 lca 深度，我们要求的其实就是除去分治中心外所有点对的距离之和，再减去同一子树内所有点对的距离之和。很明显这可以用虚树实现。</p>
<p>经过这样两个优化，我们成功地<del>在想象中</del>将时间复杂度降到了 $O(n\log n)$。</p>
<p>然而我不会虚树 :(</p>
<p>虽然 T 了但还是贴一下代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">     <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">             <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                 it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                 <span class="keyword">if</span>(ih==it)</span><br><span class="line">                     <span class="keyword">return</span> EOF;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> *ih++;</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">             <span class="keyword">return</span> getchar();</span><br><span class="line">         <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">             fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">             oh=cltout;</span><br><span class="line">         &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">char</span> c=gc();</span><br><span class="line">         <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">         <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">             sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">         <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">         x*=sn;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">             pc(<span class="number">45</span>),x=-x;</span><br><span class="line">         <span class="keyword">if</span>(!x)</span><br><span class="line">             pc(<span class="number">48</span>);</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">             <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">             pc(text);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> size,val,sum,add;</span><br><span class="line">     SplayNode *ftr,*lc,*rc;</span><br><span class="line">&#125;;</span><br><span class="line">SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> p-&gt;ftr==<span class="literal">NULL</span>||(p-&gt;ftr-&gt;lc!=p&amp;&amp;p-&gt;ftr-&gt;rc!=p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         p-&gt;lc-&gt;val=(p-&gt;lc-&gt;val+p-&gt;add)%mod;</span><br><span class="line">         p-&gt;lc-&gt;sum=(p-&gt;lc-&gt;sum+<span class="number">1L</span>L*p-&gt;lc-&gt;size*p-&gt;add%mod)%mod;</span><br><span class="line">         p-&gt;lc-&gt;add=(p-&gt;lc-&gt;add+p-&gt;add)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         p-&gt;rc-&gt;val=(p-&gt;rc-&gt;val+p-&gt;add)%mod;</span><br><span class="line">         p-&gt;rc-&gt;sum=(p-&gt;rc-&gt;sum+<span class="number">1L</span>L*p-&gt;rc-&gt;size*p-&gt;add%mod)%mod;</span><br><span class="line">         p-&gt;rc-&gt;add=(p-&gt;rc-&gt;add+p-&gt;add)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     p-&gt;add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     p-&gt;size=<span class="number">1</span>;</span><br><span class="line">     p-&gt;sum=p-&gt;val;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         p-&gt;size+=p-&gt;lc-&gt;size;</span><br><span class="line">         p-&gt;sum=(p-&gt;sum+p-&gt;lc-&gt;sum)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         p-&gt;size+=p-&gt;rc-&gt;size;</span><br><span class="line">         p-&gt;sum=(p-&gt;sum+p-&gt;rc-&gt;sum)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     re SplayNode* q=p-&gt;ftr;</span><br><span class="line">     pushDown(q);</span><br><span class="line">     pushDown(p);</span><br><span class="line">     p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(p-&gt;ftr-&gt;lc==q)</span><br><span class="line">             p-&gt;ftr-&gt;lc=p;</span><br><span class="line">         <span class="keyword">if</span>(p-&gt;ftr-&gt;rc==q)</span><br><span class="line">             p-&gt;ftr-&gt;rc=p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(q-&gt;rc==p)&#123;</span><br><span class="line">         q-&gt;rc=p-&gt;lc;</span><br><span class="line">         <span class="keyword">if</span>(q-&gt;rc!=<span class="literal">NULL</span>)</span><br><span class="line">             q-&gt;rc-&gt;ftr=q;</span><br><span class="line">         p-&gt;lc=q;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         q-&gt;lc=p-&gt;rc;</span><br><span class="line">         <span class="keyword">if</span>(q-&gt;lc!=<span class="literal">NULL</span>)</span><br><span class="line">             q-&gt;lc-&gt;ftr=q;</span><br><span class="line">         p-&gt;rc=q;</span><br><span class="line">     &#125;</span><br><span class="line">     q-&gt;ftr=p;</span><br><span class="line">     pushUp(q);</span><br><span class="line">     pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(;!isRoot(p);rotate(p))</span><br><span class="line">         <span class="keyword">if</span>(!isRoot(p-&gt;ftr))</span><br><span class="line">             rotate((p-&gt;ftr-&gt;ftr-&gt;lc==p-&gt;ftr)==(p-&gt;ftr-&gt;lc==p)?p-&gt;ftr:p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     pushDown(p);</span><br><span class="line">     splay(p);</span><br><span class="line">     p-&gt;rc=<span class="literal">NULL</span>;</span><br><span class="line">     pushUp(p);</span><br><span class="line">     <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;)&#123;</span><br><span class="line">         pushDown(q-&gt;ftr);</span><br><span class="line">         splay(q-&gt;ftr);</span><br><span class="line">         q-&gt;ftr-&gt;rc=q;</span><br><span class="line">         pushUp(q-&gt;ftr);</span><br><span class="line">         q=q-&gt;ftr;</span><br><span class="line">     &#125;</span><br><span class="line">     splay(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">LCA</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">     pushDown(p);</span><br><span class="line">     access(p);</span><br><span class="line">     splay(q);</span><br><span class="line">     q-&gt;rc=<span class="literal">NULL</span>;</span><br><span class="line">     pushUp(q);</span><br><span class="line">     <span class="keyword">for</span>(p=q;p-&gt;ftr!=<span class="literal">NULL</span>;)&#123;</span><br><span class="line">         pushDown(p-&gt;ftr);</span><br><span class="line">         splay(p-&gt;ftr);</span><br><span class="line">         p-&gt;ftr-&gt;rc=p;</span><br><span class="line">         pushUp(p-&gt;ftr);</span><br><span class="line">         p=p-&gt;ftr;</span><br><span class="line">     &#125;</span><br><span class="line">     splay(q);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(re SplayNode* p,re <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     access(p);</span><br><span class="line">     p-&gt;val=(p-&gt;val+x)%mod;</span><br><span class="line">     p-&gt;sum=(p-&gt;sum+<span class="number">1L</span>L*p-&gt;size*x%mod)%mod;</span><br><span class="line">     p-&gt;add=(p-&gt;add+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">     access(p);</span><br><span class="line">     <span class="keyword">return</span> p-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ec,rt,sz,cntsum,ans;</span><br><span class="line"><span class="keyword">int</span> des[<span class="number">2</span>*maxn+<span class="number">1</span>],suc[<span class="number">2</span>*maxn+<span class="number">1</span>],las[maxn+<span class="number">1</span>],id[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> size[maxn+<span class="number">1</span>],mxs[maxn+<span class="number">1</span>],vis[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn+<span class="number">1</span>],stk[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     des[++ec]=y;</span><br><span class="line">     suc[ec]=las[x];</span><br><span class="line">     las[x]=ec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRt</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr)</span></span>&#123;</span><br><span class="line">     size[cur]=<span class="number">1</span>;</span><br><span class="line">     mxs[cur]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])</span><br><span class="line">         <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">             getRt(des[i],cur);</span><br><span class="line">             size[cur]+=size[des[i]];</span><br><span class="line">             mxs[cur]=max(mxs[cur],size[des[i]]);</span><br><span class="line">         &#125;</span><br><span class="line">     mxs[cur]=max(mxs[cur],sz-size[cur]);</span><br><span class="line">     <span class="keyword">if</span>(!rt||mxs[rt]&gt;mxs[cur])</span><br><span class="line">         rt=cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr,re <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">     stk[++stk[<span class="number">0</span>]]=cur;</span><br><span class="line">     re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">     cnt[cur]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])</span><br><span class="line">         <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">             res=(res+calc(des[i],cur,root))%mod;</span><br><span class="line">             cnt[cur]+=cnt[des[i]];</span><br><span class="line">         &#125;</span><br><span class="line">     ans=(ans+<span class="number">1L</span>L*cnt[cur]*(query(mempool+id[cur])-cntsum+mod)%mod+mod)%mod;</span><br><span class="line">     re SplayNode* x=LCA(mempool+id[cur],mempool+id[root]);</span><br><span class="line">     access(x);</span><br><span class="line">     re <span class="keyword">int</span> dx=x-&gt;lc!=<span class="literal">NULL</span>?x-&gt;lc-&gt;size:<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> (res+<span class="number">1L</span>L*cnt[cur]*dx%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr)</span></span>&#123;</span><br><span class="line">     vis[cur]=<span class="number">1</span>;</span><br><span class="line">     cntsum=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur],j=<span class="number">0</span>;i;i=suc[i])</span><br><span class="line">         <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">             re <span class="keyword">int</span> tmp=calc(des[i],cur,cur);</span><br><span class="line">             ans=(ans+<span class="number">1L</span>L*(n-cnt[des[i]])*tmp%mod)%mod;</span><br><span class="line">             <span class="keyword">for</span>(;j&lt;stk[<span class="number">0</span>];++j,update(mempool+id[stk[j]],cnt[stk[j]]),cntsum=(cntsum+cnt[stk[j]])%mod);</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">for</span>(;stk[<span class="number">0</span>];update(mempool+id[stk[stk[<span class="number">0</span>]]],mod-cnt[stk[stk[<span class="number">0</span>]]]),--stk[<span class="number">0</span>]);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])</span><br><span class="line">         <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">             rt=des[i];</span><br><span class="line">             sz=size[des[i]];</span><br><span class="line">             getRt(des[i],cur);</span><br><span class="line">             divide(rt,cur);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     cltstream::read(n);</span><br><span class="line">     cltstream::read(m);</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">         <span class="keyword">int</span> x;</span><br><span class="line">         cltstream::read(x);</span><br><span class="line">         <span class="keyword">if</span>(x)&#123;</span><br><span class="line">             connect(x,i);</span><br><span class="line">             connect(i,x);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">         pushUp(mempool+i);</span><br><span class="line">         <span class="keyword">int</span> x;</span><br><span class="line">         cltstream::read(x);</span><br><span class="line">         <span class="keyword">if</span>(x)</span><br><span class="line">             (mempool+i)-&gt;ftr=mempool+x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">         cltstream::read(id[i]);</span><br><span class="line">     rt=<span class="number">0</span>;</span><br><span class="line">     sz=n;</span><br><span class="line">     getRt(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">     divide(rt,<span class="number">0</span>);</span><br><span class="line">     cltstream::write(ans);</span><br><span class="line">     clop();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>LCT</tag>
        <tag>点分治</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>「CF1114E」Arithmetic Progression</title>
    <url>/cf1114e-solution/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1114/problem/E">传送门</a></p>
<p>大概是写的第一道正常一点的交互题吧（</p>
<a id="more"></a>
<p>因为原序列是打乱的等差数列，任意两项的差一定形如 $kd$，其中 $k\in\mathbb{N}^{+}$。</p>
<p>于是我们想到，如果我们提取出序列中的一些项，比如说前 $m$ 项，差分，然后求出这些数的 gcd，就有可能是原等差数列的公差。</p>
<p>但这并不一定，因为这个 gcd 也有可能是 $kd$ 的形式。</p>
<p>那么把原序列随机打乱就行了。</p>
<p>求出公差之后二分找原序列最大值即可。</p>
<p>实测 $m$ 最大可以取到 $30$。</p>
<p>这样就可以 A 了。</p>
<p><a href="http://codeforces.com/contest/1114/submission/58430411">评测记录</a>。</p>
<p>那么问题来了，这个算法的正确率到底有多大（</p>
<p>我们将这个问题抽象为以下模型：</p>
<blockquote>
<p>给定一长度为 $n$ 的随机排列 $p$ 和一正整数 $m$，$1\leqslant m\lt n$，令</p>
<script type="math/tex; mode=display">
q_{i}=|p_{i+1}-p_{i}|\quad(i\in[1,m])</script><p>试求</p>
<script type="math/tex; mode=display">
P\left(\gcd_{i=1}^{m}q_{i}=1\right)</script></blockquote>
<p>不会。告辞 .jpg</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互</tag>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Challestend的脑内切题清单</title>
    <url>/solving-problems-in-brain/</url>
    <content><![CDATA[<p>如标题所示。</p>
<p>觉得比较简单或者懒得写代码的题。</p>
<p><del>wzx「你怎么还懒得写代码啊。你把这些题都写了就有事干了。」</del></p>
<p>可能有时候会闲着没事写几道。</p>
<a id="more"></a>
<h3 id="「CF915F」Imbalance-Value-of-a-Tree"><a href="#「CF915F」Imbalance-Value-of-a-Tree" class="headerlink" title="「CF915F」Imbalance Value of a Tree"></a><a href="http://codeforces.com/problemset/problem/915/F">「CF915F」Imbalance Value of a Tree</a></h3><p>最大值和最小值分开求。</p>
<p>大力并查集。</p>
<p>以上。</p>
<h3 id="「CF455D」Serega-and-Fun"><a href="#「CF455D」Serega-and-Fun" class="headerlink" title="「CF455D」Serega and Fun"></a><a href="http://codeforces.com/problemset/problem/455/D">「CF455D」Serega and Fun</a></h3><p>大力块链。</p>
<p>记得 loli 以前考过这题。</p>
<p><del>结果那次数据随机放跑了暴力。</del></p>
<h3 id="「CF1182E」Product-Oriented-Recurrence"><a href="#「CF1182E」Product-Oriented-Recurrence" class="headerlink" title="「CF1182E」Product Oriented Recurrence"></a><a href="http://codeforces.com/problemset/problem/1182/E">「CF1182E」Product Oriented Recurrence</a></h3><p>令</p>
<script type="math/tex; mode=display">
g_{i}=\ln f_{i}</script><p>那么</p>
<script type="math/tex; mode=display">
g_{n}=(2n-6)\ln c+g_{n-1}+g_{n-2}+g_{n-3}</script><p>一定存在这样的 $k_{0},k_{1},k_{2},k_{3}$，使得</p>
<script type="math/tex; mode=display">
g_{n}=k_{0}\ln c+k_{1}g_{1}+k_{2}g_{2}+k_{3}g_{3}</script><p>于是</p>
<script type="math/tex; mode=display">
f_{n}=c^{k_{0}}\cdot f_{1}^{k_{1}}\cdot f_{2}^{k_{2}}\cdot f_{3}^{k_{3}}</script><h3 id="「CF1093E」Product-Oriented-Recurrence"><a href="#「CF1093E」Product-Oriented-Recurrence" class="headerlink" title="「CF1093E」Product Oriented Recurrence"></a><a href="http://codeforces.com/problemset/problem/1093/E">「CF1093E」Product Oriented Recurrence</a></h3><p>定义 $f_{i}$ 表示 $a_{i}$ 在 $b$ 中对应的下标，$g_{i}$ 表示 $b_{i}$ 在 $a$ 中对应的下标。</p>
<p>操作一就是在询问</p>
<script type="math/tex; mode=display">
\sum_{i=l_{a}}^{r_{a}}[f_{i}\in[l_{b},r_{b}]]</script><p>操作二就交换一下 $f_{g_{x}}$ 和 $f_{g_{y}}$，$g_{x}$ 和 $g_{y}$。</p>
<p>大力分块。</p>
<h3 id="「CF446C」DZY-Loves-Fibonacci-Numbers"><a href="#「CF446C」DZY-Loves-Fibonacci-Numbers" class="headerlink" title="「CF446C」DZY Loves Fibonacci Numbers"></a><a href="http://codeforces.com/problemset/problem/446/C">「CF446C」DZY Loves Fibonacci Numbers</a></h3><p><del>通过查阅题解，</del>我们知道斐波那契数拥有如下性质</p>
<script type="math/tex; mode=display">
F_{n+m}=F_{n+1}F_{m}+F_{n}F_{m-1}</script><p>考虑使用数学归纳法证明。首先</p>
<script type="math/tex; mode=display">
F_{n+0}=F_{n+1}F_{0}+F_{n}F_{-1}</script><p>……不从 $1$ 开始。</p>
<script type="math/tex; mode=display">
F_{n+1}=F_{n+1}F_{1}+F_{n}F_{0}=F_{n+1}</script><script type="math/tex; mode=display">
F_{n+2}=F_{n+1}F_{2}+F_{n}F_{1}=F_{n+1}+F_{n}=F_{n+2}</script><script type="math/tex; mode=display">
\begin{aligned}
F_{n+m}&=F_{n+m-1}+F_{n+m-2}\\
&=F_{n+1}F_{m-1}+F_{n}F_{m-2}+F_{n+1}F_{m-2}+F_{n}F_{m-3}\\
&=F_{n+1}F_{m}+F_{n}F_{m-1}
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{x}F_{L+i}=F_{L+1}\sum_{i=1}^{x}F_{i}+F_{L}\sum_{i=0}^{x-1}F_{i}</script><p>然后大力线段树（细节略）。</p>
<p><a href="http://codeforces.com/contest/446/submission/58884107">我甚至还写了</a>。</p>
]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>东方催狐谭（とうほうさいこたん） ~ Servants of Harvest Wish</title>
    <url>/touhou-saikotan-servants-of-harvest-wish/</url>
    <content><![CDATA[<blockquote>
<p>この美しい景色も秋の贈り物……</p>
<p>滝のように落ちていく紅葉 、 通りすがる人達に微笑む山……</p>
<p>この絶景を目の前にして 、 言葉が詰まらない方がおかしいと思わない？</p>
</blockquote>
<a id="more"></a>
<p>以上文字选自魔理沙线六面 BOSS 开打前对话。</p>
<p>如果您对东方圈有一定了解，您可能会知道有一款叫做 <code>東方落流星（とうほうらくりゅうせい） ~ The Shattered Sky</code> 的游戏。催狐谭是那个游戏作者的新作。</p>
<p>关于前作落流星，我其实并没有玩过，主要原因就是它的立绘实在是……太抽象了。</p>
<p>然而本作催狐谭的立绘还是可以的。</p>
<p>摘自 THBWiki 的故事背景：</p>
<blockquote>
<p>由于不知名的原因，幻想乡中所有稻谷迅速凋零。</p>
<p>如此下去，人类不久便会陷入饥饿之中。</p>
<p>四位少女决定出发寻找异变的原因并解决异变。</p>
</blockquote>
<p>总体的剧情就是，EX BOSS 为了给自己创造一个新的肉身，从六面 BOSS 那里偷来了如意宝珠。如意宝珠的消失导致了异变。</p>
<p>后来 EX BOSS 让自己的两个手下把宝珠还回去，结果她俩被自机揍了一顿溜回来了。</p>
<p>EX BOSS 感到十分 excited，于是设计把自机引了过来想会会她们。</p>
<p>本作一共有四个自机：灵梦，魔理沙，早苗和龙子（前作落流星五面 BOSS），每个自机都有 AB 两个配置。当然我是只用过魔 A，而且是两三发就通了的那种。</p>
<p>本作的特殊系统比较简单。击破敌人可以获得特殊道具，收集一定数量可以进入一个特殊模式。在这个模式下按 X 可以扔出风神录一样的灵击然后结束该模式，在该模式中收集到的道具越多，灵击圈就越大。虽然可以决死，但是<strong>被弹之后如果不扔决死是会掉残的</strong>。我初通的时候就是因为这个在一面抱 B 撞了（</p>
<p>每一面击破 BOSS 之前收集足够多的特殊道具可以开启 Last Word，不能扔雷，被弹会强制结束符卡而不会掉残。</p>
<p>以及传统艺能，六面 BOSS 的 Last Word 被弹会掉残，以及自机全程处于特殊模式中，普通的雷被换成了原本可以结束该模式的灵击。</p>
<p>我在看过视频剧透的情况下 Lunatic 三发通，而且还是在一面抱 B 撞，四面最后一只大蝴蝶耗俩雷，五道中完全没背板的情况下；Extra 一发通。机体都是魔 A。</p>
<p>所以说这游戏其实也不难，当然我是指 Lunatic 和 Extra 。至于 URA（在 Lunatic 选项处连打 <code>Shift</code> 解锁）和 Lunatic Extra，不好意思我不敢碰。</p>
<p>而且据说，这游戏每一个 BOSS 都有一张异常符卡，是满足一些乱七八糟的条件（比如 EX BOSS 的异常符卡需要在满足一些条件的情况下 NN EX 道中，然后 EX BOSS 的 BGM 甚至还会换曲风，甚至似乎这个才是原曲）之后会额外追加的一张符卡。如果能在实战（单关练习也行，但是 BOSS 练习或符卡练习不行）收掉这张符卡，就会解锁最后的 Overdrive 符卡。</p>
<p>干败吓疯，干败吓疯。</p>
<p>最后是一些链接：</p>
<ul>
<li><a href="https://www.bulletforge.org/u/eredom/p/dong-fang-cui-hu-tan-servants-of-harvest-wish">在 Bullet Forge 上下载该游戏</a></li>
<li><a href="https://thwiki.cc/%E6%9D%B1%E6%96%B9%E5%82%AC%E7%8B%90%E8%AD%9A_%EF%BD%9E_Servants_of_Harvest_Wish.">在 THBWiki 上查阅相关资料</a></li>
<li><a href="https://space.bilibili.com/1418000">观看相关视频</a></li>
</ul>
<p>以及，也许近期会做一个 Lunatic 和 Extra 初通 Replay 的解说。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2020 游记」五月蠅いなお前なんて大嫌いだ</title>
    <url>/sdoi2020-notes/</url>
    <content><![CDATA[<p>闲着没事干写篇游记。</p>
<a id="more"></a>
<blockquote>
<p>鉴于 NOI2020 拟于 8 月份举办以及各省目前的疫情防控情况，NOI 科学委员会经过研究决定：由 CCF 统一命题和评测的 NOI2020 省队选拔安排在 6 月 20 日 - 21 日（周六周日）举行。统一省选安排两试，时间为每天上午 8 点半到 13 点。</p>
</blockquote>
<p>以上文字引用自<a href="http://www.noi.cn/newsview.html?id=1215&amp;hash=618DAD&amp;type=1"> CCF 关于 NOI2020 省选举办时间和方式的通知</a>。</p>
<p><del>标题的「五月蠅いな」和「お前なんて大嫌いだ」是两句话，因为「五月蠅い」后面要直接跟名词不能加「な」qwq</del></p>
<h3 id="Day-∞"><a href="#Day-∞" class="headerlink" title="Day -∞"></a>Day -∞</h3><p>颓废一时爽，一直颓废一直爽<del>，回去做题火葬场</del>。</p>
<h3 id="Day-17（2020-6-2）"><a href="#Day-17（2020-6-2）" class="headerlink" title="Day -17（2020-6-2）"></a>Day -17（2020-6-2）</h3><p>因为合格考没过被迫开始补政治和语文。</p>
<p><del>呐，世界，毁灭吧（无端</del></p>
<p>不知道为什么从中午开始一直头疼，躺了一整个下午总算好点了。</p>
<p>躺在床上的时候突然就想，自己加入信息组已经两年了啊。</p>
<p>曹爷（ID 忘了，Luogu 上叫第一发言者），DEVILK，SuperGoodGame，star_dust，hachimanjy，RiverFun，wavwing，Bj2002，Colorfulmist，SnoWY，Ciyang，ArachnidaKing，Red_dye……</p>
<p>我突然想起来了，以前每天晚上，我们在宿舍里，一边闻着曹爷的大臭脚一边谈笑风生，然后抢曹爷被子时的事情。</p>
<p>我突然想起来了，曾经有过一个晚上，DEVILK 手把手帮我调生日蛋糕时的事情。</p>
<p>我突然想起来了，2018 年的 NOIp，我们在宿舍里，玩算法版谁是卧底时的事情。</p>
<p>我突然想起来了，曾经有过一个晚上，我帮着 hachimanjy 搭建 GitHub 博客时的事情。</p>
<p>当初我去自招的时候见到 RiverFun 是什么心情呢？我已经不知道了。</p>
<p>一开始因为误打误撞进了信息组，wavwing（好像）还惹出了不少事。当时我还只能跟着他后面不做声，结果现在也变成爷字辈了。</p>
<p>我突然想起来了，第一次合格考我回到机房时，Bj2002 大喊一声「您们看看谁来了！」时的事情。</p>
<p>我突然想起来了，当初我为了和 asuldb 深入交流，不畏 Colorfulmist 的潮之力毅然调座位时的事情。结果调过去遇到的第一道题就是一道神仙虚树反演题 <code>Surprise Me!</code>（</p>
<p>我突然想起来了，我以前手把手教 SnoWY 学算法时的事情。结果他现在文化课 OI 两开花随手吊打我。</p>
<p>我突然想起来了，以前闲下来没事干的时候，成天就知道往 Taduro 的座位旁边凑时的事情。</p>
<p>我突然想起来了，以前和 Juan_feng 一起调试 <code>五彩斑斓的世界</code>，<code>未来日记</code> 时的事情。结果后来自己参与了 std 编写的题 <code>文化课</code>（一开始叫 <code>四则运算基础练习题</code>）也被收入 Ynoi<br>了。还是活成了自己讨厌的模样（大雾</p>
<p>我突然想起来了，2019 年一轮省队集训，Day 9，被 nzhtl1477 拍着肩膀说「珂以啊！」时的事情。</p>
<p>我突然想起来了，省队选拔前夕，拿着小本本跑回宿舍记录 Colorfulmist 名人名言时的事情。</p>
<p>我突然想起来了，2019 年一轮省队选拔，Day 1 考完，我和 asuldb 几个人一起在教学楼后面谈笑风生时的事情。</p>
<p>也许真就像那句话所说吧：</p>
<blockquote>
<p>哪有什么突然想起，只是一直藏在心底罢了。</p>
</blockquote>
<p>插播一则旧闻：</p>
<blockquote>
<p>潮子与 asuldb 论 SAM。潮子潮之曰：你的 SAM 没有 A，SM，A 不了。次日，asuldb 遇 SAM 题，得正解。然倍增毙，爆零也。遂叹曰：潮爷奶的准，我的 SAM 就是 A 不了。</p>
</blockquote>
<p>经 典 咏 流 传。</p>
<h3 id="Day-10（2020-6-9）"><a href="#Day-10（2020-6-9）" class="headerlink" title="Day -10（2020-6-9）"></a>Day -10（2020-6-9）</h3><p>我终于通关 Slay the Spire 了！（倒地</p>
<p><del>为什么我这么菜啊 /kk</del></p>
<p>用新角色观者打了一发，感觉不知道为什么就是好像很厉害（大雾</p>
<h3 id="Day-0（2020-6-19）"><a href="#Day-0（2020-6-19）" class="headerlink" title="Day 0（2020-6-19）"></a>Day 0（2020-6-19）</h3><p>中间竟然有连着 9 天没有更新（</p>
<p>而且连 Wiki 也没有（</p>
<p>其实是有一天 GitHub 突然 push 不上去了于是懒得搞了于是咕掉了（</p>
<p>明天就是 Day 1 了 /kk</p>
<p>大概考完这场省选我就要退役了吧 /kk</p>
<p>想着要说点什么，想来想去，还是这句话：</p>
<p>「何も問題は無いようじゃがの ～」</p>
<p><del>最近在看 BUG 之风，看得我拳 ☆ 銃 ☆ 大 ☆ 爆 ☆ 発。</del></p>
<p><del>「そして 、 オレだけが<ruby>再<rt>リ</rt>起<rt>タ</rt>不<rt>イ</rt>能<rt>ヤ</rt></ruby>しない事を許可しろ！」</del></p>
<h3 id="Day-1（2020-6-20）"><a href="#Day-1（2020-6-20）" class="headerlink" title="Day 1（2020-6-20）"></a>Day 1（2020-6-20）</h3><p>前一天晚上定了一个五点整的闹钟，结果<del>因为某种神秘的原因</del>提前十分钟就起来了。</p>
<p>七点几分出的家门，到了机房大概有半多了。进门看到块坐在稳稳的位置上，陶就坐在旁边他自己的位置上。</p>
<p>跟他们说最近在玩 Slay the Spire，陶表示不知道。于是给他看了一下 PKUWC 的同名题目。</p>
<p>以前烜写过这道题的题解，说这是 SB 题。可惜我现在还是不会。直接去问他，他表示早就忘了。</p>
<p>进考场之后也没啥。看他们都在拼命打板子，但是我觉得打了也没用，所以反复确认试题。</p>
<p>一共三道题，<code>icefire</code>，<code>problem</code> 和 <code>shop</code>，从大样例的数量来看全部都是传统题。</p>
<p>解压密码一团乱码。</p>
<p>具体的题意应该迟早会上传到各大 OJ 上，这里就不赘述了。</p>
<p>一开始看了一个小时 T1 毫无进展，于是去看 T2。</p>
<p>稍微推了推就推出来一个矩阵的做法，$O(m^{3}\log n)$，结合暴力可以拿到 60 pts。</p>
<p>然后再回去看 T1 发现这个东西是单峰的，于是写了个三分套树状数组，$O(n\log^{2}n)$，60 pts。但实际上因为是三分所以其中一个 $\log$ 是以 $1.5$ 为底数的，常数会大。可以改成二分，但无论如何都是 60 pts。</p>
<p>做到这里就已经没时间了，T3 直接输出样例走人。</p>
<p>出考场和机房中 dalao 讨论题，发现烜 T1 想出了正解但是没有写出来。据他说是线段树，但是说实话我表示怀疑。</p>
<p>被天下第一的胡块块邀请到了他的家里。现在我写这些东西的时候也是在他家里。</p>
<p>块说自己在家里经常健身，于是我顺便拜见了一下他的健身器械。</p>
<p>被块暴力安利了炉石传说。其实我第一次听说炉石传说还是「你必须攻击该具有嘲讽的随从」的来着。</p>
<p>一个下午就打完了新手教学（</p>
<p>块「你是我见过的新手教学打得最认真的。」</p>
<p>算了吧还是 Slay 好玩（</p>
<h3 id="Day-2（2020-6-21）"><a href="#Day-2（2020-6-21）" class="headerlink" title="Day 2（2020-6-21）"></a>Day 2（2020-6-21）</h3><p>又定了一个五点的闹钟，结果又提前十分钟起来了。</p>
<p>不到七点就走了，到了机房还没开门。</p>
<p>重新抽了座位，然而两天都是二号考场。</p>
<p>瞅一眼压缩包里面，<code>count</code>，<code>transfer</code> 和 <code>tree</code>，传统题。</p>
<p>……？！<code>count</code>！这一定是一道计数题，看我写个 NTT 板子。</p>
<p>结果写了半个小时没写出来 /kk</p>
<p>解压密码和昨天一样是乱码。</p>
<p>打开一看发现 <code>count</code> 是 T3，生成树题。</p>
<p>于是三道题来回看了又看，一直在「想到新思路 -&gt; 开始写代码 -&gt; 写到一半发现假了 -&gt; 自闭」这样循环。</p>
<p>到最后突然发现 T3 可以莫比乌斯反演套矩阵树，然后突然发现自己不会矩阵树。写了半个小时没写出来，弃疗了。</p>
<p>最终成绩：60+60+0+30+10+30=190。我没了 /kk</p>
<p>烜「这套题暴力分贼肥啊你怎么回事啊。」</p>
<p>最后的最后，loli 让我们下午回家，明天开始学文化课。大概这就是我打的最后一场正式的 OI 比赛了吧。</p>
<p>对了差点忘了说了，昨天听说块没看过 JO5 但是被剧透过，于是带着他看了第一话。</p>
<p><del>黄金精神，指偷别人钱抢别人行李给别人发好人卡。</del></p>
<p><del>「めーはもう……めーはもう……めーはもう推しだ！」</del></p>
<p><del>「大丈夫ですかブチャラティ？」</del></p>
<h3 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h3><blockquote>
<p>今番良晤，豪兴不浅，</p>
<p>他日江湖相逢，再当杯酒言欢。</p>
<p>咱们就此别过。</p>
<p>江湖路远，各位请一路珍重。</p>
</blockquote>
<p><del>虽然是从花花的犇犇里抄来的。</del></p>
<p>插播一则新闻：</p>
<blockquote>
<p>真实成绩：60+60+0+0+10+10=140。看来是 D2T1 整个写炸了，D2T3 莫名其妙丢了 20 pts。</p>
</blockquote>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>「2020 省选联考 A 卷 D1T2」组合数问题</title>
    <url>/sdoi2020-d1t2-solution/</url>
    <content><![CDATA[<p>从现在开始我 blog 写题解要附上简要题意（</p>
<a id="more"></a>
<p>给定 $m$ 次多项式 $F(x)=\sum_{i=0}^{m}f_{i}x^{i}$，试求</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{n}{n\choose k}F(k)x^{k}\</script><p>在 $\operatorname{mod}p$ 意义下的值。</p>
<p>其中 $1\leqslant n,x,p\leqslant 10^{9},0\leqslant f_{i}\leqslant 10^{9},1\leqslant m\leqslant\min(n,1000)$。</p>
<p>不过话说回来，D2 早上去机房听烜说这是道衡水的原题，而且还是比原题简单的那种。</p>
<p>首先我们把 $F(k)$ 拆开，得到</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{m}f_{i}\sum_{k=0}^{n}{n\choose k}k^{i}x^{k}</script><p>考虑到 $m$ 比较小，我们可以对于外层 $\sum$ 的每一项单独求值。定义</p>
<script type="math/tex; mode=display">
\begin{aligned}
G_{n,t}(x)&=\sum_{k=0}^{n}{n\choose k}k^{t}x^{k}\\
&=\sum_{k=0}^{n}\left({n-1\choose k}+{n-1\choose k-1}\right)k^{t}x^{k}\\
&=\sum_{k=0}^{n}{n-1\choose k}k^{t}x^{k}+\sum_{k=0}^{n}{n-1\choose k-1}k^{t}x^{k}\\
&=\sum_{k=0}^{n-1}{n-1\choose k}k^{t}x^{k}+\sum_{k=0}^{n-1}{n-1\choose k}(k+1)^{t}x^{k+1}\\
&=\sum_{k=0}^{n-1}{n-1\choose k}k^{t}x^{k}+x\sum_{i=0}^{t}{t\choose i}\sum_{k=0}^{n-1}{n-1\choose k}k^{t}x^{k}\\
&=G_{n-1,t}(x)+x\sum_{i=0}^{t}{t\choose i}G_{n-1,i}(x)
\end{aligned}</script><p>于是我们构造矩阵</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
{0\choose 0}x+1&0&0&\cdots&0&0&1\\
{1\choose 0}x&{1\choose 1}x+1&0&\cdots&0&0&0\\
{2\choose 0}x&{2\choose 1}x&{2\choose 2}x+1&\cdots&0&0&0\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\
{m-1\choose 0}x&{m-1\choose 1}x+1&{m-1\choose 2}x&\cdots&{m-1\choose m-1}x+1&0&0\\
{m\choose 0}x&{m\choose 1}x&{m\choose 2}x&\cdots&{m\choose m-1}x&{m\choose m}x+1&0\\
0&0&0&\cdots&0&0&1
\end{bmatrix}</script><p>和初始向量</p>
<script type="math/tex; mode=display">
S=\begin{bmatrix}
1\\
0\\
0\\
\vdots\\
0\\
0\\
1
\end{bmatrix}</script><p>那么</p>
<script type="math/tex; mode=display">
A^{n}S=\begin{bmatrix}
G_{n,0}(x)\\
G_{n,1}(x)\\
G_{n,2}(x)\\
\vdots\\
G_{n,m-1}(x)\\
G_{n,m}(x)\\
1
\end{bmatrix}</script><p>虽然我在我的另一个 blog 里写过了，不过由于某些原因那个 blog 倒了，于是我在这里再写一遍。</p>
<p>如果直接使用矩阵快速幂来计算 $A^{n}$ 的话，复杂度是 $O(m^{3}\log n)$ 的，但是这还不够。</p>
<p>考虑我们能不能构造出一个奇妙的序列 $c_{0},c_{1},\cdots,c_{m+1}$ 使得 $C(A)=\sum_{i=0}^{m+1}c_{i}A^{i}=A^{n}$。</p>
<p>如果我们构造出来了，令 $S_{k}$ 表示 $S$ 从上往下第 $k$ 维的值，从 $0$ 开始标号。那么</p>
<script type="math/tex; mode=display">
(A^{n}S)_{k}=\left(\sum_{i=0}^{m+1}c_{i}A^{i}S\right)_{k}=\sum_{i=0}^{m+1}c_{i}(A^{i}S)_{k}</script><p>注意到 $(A^{i}S)_{k}$ 就是 $G_{i,k}(x)$，不过如果 $k=m+1$ 就是 $1$。这样我们就可以在 $O(m^{2})$ 的复杂度内计算出答案。</p>
<p>我们设 $A^{n}=P(A)Q(A)+C(A)$，如果我们能够找到一个 $m+2$ 次多项式 $H$ 使得 $Q(A)=0$，就可以有 $C(A)=A^{n}\operatorname{mod}Q(A)$。</p>
<p>一下是一些为了求出 $H$ 所必要的矩阵相关知识。</p>
<p>对于矩阵 $A$，如果等式 $(\lambda I-A)v=0$ 成立，我们称 $\lambda$ 是 $A$ 的一个特征值，$v$ 是 $A$ 的一组特征向量。</p>
<p>有两个<del>连 shadowice dalao 都不会证的</del>结论：</p>
<ol>
<li>满足 $\text{Det}(A)\neq 0$，即满秩的 $n\times n$ 的矩阵 $A$ 拥有 $n$ 组线性无关的特征向量。</li>
<li>当且仅当 $\text{Det}(\lambda I-A)=0$ 时存在这样的 $v$。</li>
</ol>
<p>显然我们刚才构造的矩阵 $A$ 是满秩的。于是根据 Cayley-Hamilton 定理，有 $\prod_{k=0}^{m+1}(\lambda_{k}I-A)=0$，其中 $\lambda_{0},\lambda_{1},\cdots,\lambda_{m+1}$ 表示 $A$ 的 $m+2$ 组特征向量。</p>
<p>于是 $Q(A)=\prod_{k=0}^{m+1}(\lambda_{k}I-A)$。</p>
<p>考虑另外一个多项式 $R(\lambda)=\text{Det}(\lambda I-A)$，<del>根据 shadowice dalao 的 blog，</del>这两个多项式的系数对应相等。</p>
<p>而显然 $\text{Det}(\lambda I-A)=(\lambda-1)(\lambda-x-1)^{m+1}$，使用分治 NTT 可以在 $O(m\log^{2}m)$ 的复杂度内计算出来。</p>
<p>那么总结一下：</p>
<ol>
<li>计算 $R(\lambda)=\text{Det}(\lambda I-A)=(\lambda-1)(\lambda-x-1)^{m+1}$，复杂度 $O(m\log^{2}m)$。</li>
<li>设 $R(\lambda)=\sum_{i=0}^{m+2}q_{i}\lambda^{i}$，有 $Q(A)=\sum_{i=0}^{m+2}q_{i}A^{i}=0$。</li>
<li>计算 $C(A)=A^{n}\operatorname{mod}Q(A)$，时间复杂度 $O(m\log m\log n)$。</li>
<li>设 $C(A)=\sum_{i=0}^{m+1}c_{i}A^{i}$，有 $(A^{n}S)_{k}=\sum_{i=0}^{m+1}c_{i}(A^{i}S)_{k}$，也即 $G_{n,k}(x)=\sum_{i=0}^{m+1}c_{i}G_{i,k}(x)$。</li>
<li>对于所有的 $0\leqslant i\leqslant m+1,0\leqslant k\leqslant m$ 计算 $G_{i,k}(x)$，我们发现 $G$ 的暴力递推式可以转化成 EGF，于是做 $m$ 遍卷积，复杂度 $O(m^{2}\log m)$。</li>
</ol>
<p>那么总体的复杂度相当于 $O(m^{2}\log m)$。</p>
<p>然而我一点都不想写这个玩意（</p>
]]></content>
      <categories>
        <category>口胡</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>NTT</tag>
        <tag>多项式</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>SpellCardsCollectionSecond</title>
    <url>/spell-cards-collection-second/</url>
    <content><![CDATA[<p>Juan_feng 使用了 AK Ynoi 之术！</p>
<p>效果拔群！</p>
<p><strong>内含大量图片！（真的很大）</strong></p>
<a id="more"></a>
<p>最近想突然写一个 OI 模拟人生。</p>
<p>和慎老师交流之后，确定了「设计一个两名玩家见面之后的决斗方式」这样的总体方针。</p>
<p>最后我们确定了「传统的回合制 RPG」「卡牌对决」这样的两种方案。</p>
<p>然后为了设计招式名称，我很快想到从 Nono 443 设计的丰富的符卡库里面找一些灵感。</p>
<p>突然发现 SpellCardsCollectionSecond 还在更新，于是去玩了一下。版本号 <code>0b.39</code>。</p>
<h3 id="b0-39-已实装符卡"><a href="#b0-39-已实装符卡" class="headerlink" title="b0.39 已实装符卡"></a><code>b0.39</code> 已实装符卡</h3><h4 id="寒波「Cold-Stream」（寒流）"><a href="#寒波「Cold-Stream」（寒流）" class="headerlink" title="寒波「Cold Stream」（寒流）"></a>寒波「Cold Stream」（寒流）</h4><p><img src="/img/SCCS/寒波0.png" alt=""></p>
<p>随便扭扭 .jpg</p>
<h4 id="流星「Comet-Shower」（彗星之浴）"><a href="#流星「Comet-Shower」（彗星之浴）" class="headerlink" title="流星「Comet Shower」（彗星之浴）"></a>流星「Comet Shower」（彗星之浴）</h4><p><img src="/img/SCCS/流星0.png" alt=""></p>
<p>随便扭扭 .jpg</p>
<h4 id="月相「Blind-Wall」（盲目之壁）"><a href="#月相「Blind-Wall」（盲目之壁）" class="headerlink" title="月相「Blind Wall」（盲目之壁）"></a>月相「Blind Wall」（盲目之壁）</h4><p><img src="/img/SCCS/月相0.png" alt=""></p>
<p>小玉随机，且只能看到一半；激光奇数。</p>
<p>随便扭扭 .jpg</p>
<h4 id="增幅「Howl-Amplify」（怒吼放大）"><a href="#增幅「Howl-Amplify」（怒吼放大）" class="headerlink" title="增幅「Howl Amplify」（怒吼放大）"></a>增幅「Howl Amplify」（怒吼放大）</h4><p><img src="/img/SCCS/增幅0.png" alt=""></p>
<p>红弹回音式反弹；蓝弹奇数。</p>
<p>随便扭扭 .jpg</p>
<h4 id="把驻「Splash-Anchor」（溅射锚击）"><a href="#把驻「Splash-Anchor」（溅射锚击）" class="headerlink" title="把驻「Splash Anchor」（溅射锚击）"></a>把驻「Splash Anchor」（溅射锚击）</h4><p><img src="/img/SCCS/把驻0.png" alt=""></p>
<p>锚奇数，回来的时候会有水滴弹，way 数会不断增加。</p>
<p>随便扭扭 .jpg</p>
<h4 id="爪痕「染血的狂爪」"><a href="#爪痕「染血的狂爪」" class="headerlink" title="爪痕「染血的狂爪」"></a>爪痕「染血的狂爪」</h4><p><img src="/img/SCCS/爪痕0.png" alt=""></p>
<p>随机 + 有些初见杀的狙。</p>
<p>随便扭扭 .jpg</p>
<h4 id="辻风「弹幕尘旋风」"><a href="#辻风「弹幕尘旋风」" class="headerlink" title="辻风「弹幕尘旋风」"></a>辻风「弹幕尘旋风」</h4><p><img src="/img/SCCS/辻风0.png" alt=""></p>
<p>好像 yuke 和梦旧市都玩过这种弹幕？</p>
<p>随便扭扭 .jpg</p>
<h4 id="北风「Northern-Gust」（北方阵风）"><a href="#北风「Northern-Gust」（北方阵风）" class="headerlink" title="北风「Northern Gust」（北方阵风）"></a>北风「Northern Gust」（北方阵风）</h4><p><img src="/img/SCCS/北风0.png" alt=""></p>
<p>随便扭扭 .jpg</p>
<h4 id="阳光「Solar-Ray-Fall」（太阳射线落）"><a href="#阳光「Solar-Ray-Fall」（太阳射线落）" class="headerlink" title="阳光「Solar Ray Fall」（太阳射线落）"></a>阳光「Solar Ray Fall」（太阳射线落）</h4><p><img src="/img/SCCS/阳光0.png" alt=""></p>
<p>激光打到自机会变成麟弹狙。</p>
<p>诶真好玩 .jpg</p>
<h4 id="月日「Miniature-Eclipse」（微型日食）"><a href="#月日「Miniature-Eclipse」（微型日食）" class="headerlink" title="月日「Miniature Eclipse」（微型日食）"></a>月日「Miniature Eclipse」（微型日食）</h4><p><img src="/img/SCCS/月日0.png" alt=""></p>
<p>露娜本体会把桑尼的激光变成米弹；但是血很少且不会复活所以需要控枪。</p>
<p><del>话说回来那激光也不是完全无缝啊 TAS 大概能躲吧。</del></p>
<h4 id="现像「虚-像-投-影Virtual-Projection」"><a href="#现像「虚-像-投-影Virtual-Projection」" class="headerlink" title="现像「虚 　 像 　 投 　 影Virtual Projection」"></a>现像「<ruby>虚 　 像 　 投 　 影<rt>Virtual Projection</rt></ruby>」</h4><p><img src="/img/SCCS/现像0.png" alt=""></p>
<p>趁着弹幕虚化，一遍向上冲异变躲紫铳弹。</p>
<h4 id="雷庭「天空中的龙之巢」"><a href="#雷庭「天空中的龙之巢」" class="headerlink" title="雷庭「天空中的龙之巢」"></a>雷庭「天空中的龙之巢」</h4><p><img src="/img/SCCS/雷庭0.png" alt=""></p>
<p><img src="/img/SCCS/雷庭1.png" alt=""></p>
<p>随便扭扭 .jpg</p>
<h4 id="结界「多重捕缚阵」"><a href="#结界「多重捕缚阵」" class="headerlink" title="结界「多重捕缚阵」"></a>结界「多重捕缚阵」</h4><p><img src="/img/SCCS/结界0.png" alt=""></p>
<p>随便扭扭 .jpg</p>
<h4 id="祈愿「风祝的祝福」"><a href="#祈愿「风祝的祝福」" class="headerlink" title="祈愿「风祝的祝福」"></a>祈愿「风祝的祝福」</h4><p><img src="/img/SCCS/祈愿0.png" alt=""></p>
<p>有一说一，到后面发弹频率狂暴之后还有点麻烦的。</p>
<h4 id="残响「Reverberate-Echo」（反响回声）"><a href="#残响「Reverberate-Echo」（反响回声）" class="headerlink" title="残响「Reverberate Echo」（反响回声）"></a>残响「Reverberate Echo」（反响回声）</h4><p><img src="/img/SCCS/残响0.png" alt=""></p>
<p>中玉打到板顶版底反弹出发光点弹，发光中玉，光玉三层。</p>
<p>随便扭扭 .jpg</p>
<h4 id="咆哮「Hunting-Howls」（猎杀咆哮）"><a href="#咆哮「Hunting-Howls」（猎杀咆哮）" class="headerlink" title="咆哮「Hunting Howls」（猎杀咆哮）"></a>咆哮「Hunting Howls」（猎杀咆哮）</h4><p><img src="/img/SCCS/咆哮0.png" alt=""></p>
<p><img src="/img/SCCS/咆哮1.png" alt=""></p>
<p>扔出两拨人弹，然后把它们变成自机狙的狗弹。</p>
<p>需要引到角落否则很麻烦。</p>
<h4 id="星条「Old-Glory」（旧日荣耀）"><a href="#星条「Old-Glory」（旧日荣耀）" class="headerlink" title="星条「Old Glory」（旧日荣耀）"></a>星条「Old Glory」（旧日荣耀）</h4><p><img src="/img/SCCS/星条0.png" alt=""></p>
<p><img src="/img/SCCS/星条1.png" alt=""></p>
<p>美国国旗 .jpg</p>
<p>横向的红白激光每个一段时间就会触发一次；被蓝色激光围住的大星弹打到版底会变成小星弹；所有弹幕都在向下移动。</p>
<p>说实话我也不知道怎么躲，随缘吧。</p>
<h4 id="星月「Tiny-Satellites」（极小的卫星）"><a href="#星月「Tiny-Satellites」（极小的卫星）" class="headerlink" title="星月「Tiny Satellites」（极小的卫星）"></a>星月「Tiny Satellites」（极小的卫星）</h4><p><img src="/img/SCCS/星月0.png" alt=""></p>
<p>整个游戏最无聊的符卡。</p>
<h4 id="魔涡「Deep-Mealstrom」（深涡）"><a href="#魔涡「Deep-Mealstrom」（深涡）" class="headerlink" title="魔涡「Deep Mealstrom」（深涡）"></a>魔涡「Deep Mealstrom」（深涡）</h4><p><img src="/img/SCCS/魔涡0.png" alt=""></p>
<p>怎么说呢……随便扭扭吧也没啥好说的。</p>
<h4 id="突风「叶团扇-Downburst（爆发）」"><a href="#突风「叶团扇-Downburst（爆发）」" class="headerlink" title="突风「叶团扇 Downburst（爆发）」"></a>突风「叶团扇 Downburst（爆发）」</h4><p><img src="/img/SCCS/突风0.png" alt=""></p>
<p><img src="/img/SCCS/突风1.png" alt=""></p>
<p>中玉打到版底炸成开花麟弹链，然后麟弹又变成带环小玉自然下落。</p>
<p>旧版本玩过的符卡，用金发孩子的话需要左右大幅度横拉，总之很糟就是了。</p>
<h4 id="离散「调-律-搅-乱Tune-Shaker」"><a href="#离散「调-律-搅-乱Tune-Shaker」" class="headerlink" title="离散「调 　 律 　 搅 　 乱Tune Shaker」"></a>离散「<ruby>调 　 律 　 搅 　 乱<rt>Tune Shaker</rt></ruby>」</h4><p><img src="/img/SCCS/离散0.png" alt=""></p>
<p>一堆狙加上乱七八糟的随机弹。</p>
<p>随便扭扭 .jpg</p>
<h4 id="狱炎「Abyss-Prominence」（深渊流行）"><a href="#狱炎「Abyss-Prominence」（深渊流行）" class="headerlink" title="狱炎「Abyss Prominence」（深渊流行）"></a>狱炎「Abyss Prominence」（深渊流行）</h4><p><img src="/img/SCCS/狱炎0.png" alt=""></p>
<p>其实我也不知道 Abyss Prominence 该咋翻译。</p>
<p>月球可以消去黑红弹和部分大星弹；必须要借着月球的掩护逆穿黑红弹否则会被封死。</p>
<p>比较典型的看上去简单玩起来难的类型。</p>
<h4 id="「原初之光」"><a href="#「原初之光」" class="headerlink" title="「原初之光」"></a>「原初之光」</h4><p><img src="/img/SCCS/原初之光0.png" alt=""></p>
<p>大毒瘤纯狐 /kk</p>
<h4 id="乾坤「如同两位神明大人所说」"><a href="#乾坤「如同两位神明大人所说」" class="headerlink" title="乾坤「如同两位神明大人所说」"></a>乾坤「如同两位神明大人所说」</h4><p><img src="/img/SCCS/乾坤0.png" alt=""></p>
<p><img src="/img/SCCS/乾坤1.png" alt=""></p>
<p>青蛙弱诱导弹，蛇 y 轴狙。</p>
<p>我的解法是奇数波往早苗头上引，偶数波等发弹完大力拉上去。</p>
<h4 id="结晶「Fallen-Fractal」（坠落分型）"><a href="#结晶「Fallen-Fractal」（坠落分型）" class="headerlink" title="结晶「Fallen Fractal」（坠落分型）"></a>结晶「Fallen Fractal」（坠落分型）</h4><p><img src="/img/SCCS/结晶0.png" alt=""></p>
<p>新的 BGM！</p>
<p>……还有新的难度。</p>
<h4 id="日星「Little-Supernova」（小小的超新星）"><a href="#日星「Little-Supernova」（小小的超新星）" class="headerlink" title="日星「Little Supernova」（小小的超新星）"></a>日星「Little Supernova」（小小的超新星）</h4><p><img src="/img/SCCS/日星0.png" alt=""></p>
<p>研究了一段时间的符卡。</p>
<p>最后我找到的解法就是……版底左右晃。</p>
<h4 id="雷鱼「带电游泳弹」"><a href="#雷鱼「带电游泳弹」" class="headerlink" title="雷鱼「带电游泳弹」"></a>雷鱼「带电游泳弹」</h4><p><img src="/img/SCCS/雷鱼0.png" alt=""></p>
<p>激光靠近你会在你身边生成很密的麟弹，就像放电一样很有意思。</p>
<p>大概绕圈吧。</p>
<h4 id="反击「Interception-Charge」（截断蓄力）"><a href="#反击「Interception-Charge」（截断蓄力）" class="headerlink" title="反击「Interception Charge」（截断蓄力）"></a>反击「Interception Charge」（截断蓄力）</h4><p><img src="/img/SCCS/反击0.png" alt=""></p>
<p>本质上是捕获自机子弹变成大玉；然而金发孩子主要用激光所以木大！</p>
<h4 id="怪奇「Jevodan（杰沃丹）的野兽」"><a href="#怪奇「Jevodan（杰沃丹）的野兽」" class="headerlink" title="怪奇「Jevodan（杰沃丹）的野兽」"></a>怪奇「Jevodan（杰沃丹）的野兽」</h4><p><img src="/img/SCCS/怪奇0.png" alt=""></p>
<p>「杰沃丹」这个翻译来自于 <a href="https://zh.moegirl.org.cn/%E6%A2%B5%E8%92%82%E5%86%88%E5%A5%87%E8%BF%B9%E8%B0%83%E6%9F%A5%E5%AE%98#">https://zh.moegirl.org.cn/%E6%A2%B5%E8%92%82%E5%86%88%E5%A5%87%E8%BF%B9%E8%B0%83%E6%9F%A5%E5%AE%98#</a></p>
<p>影狼会不停地横冲直撞，并撕碎沿路上的人弹。反而是圈越小越容易突破出去。</p>
<p>总之就是尽快钻到人弹圈外就好了。</p>
<h4 id="传说「三角海域之魔」"><a href="#传说「三角海域之魔」" class="headerlink" title="传说「三角海域之魔」"></a>传说「三角海域之魔」</h4><p><img src="/img/SCCS/传说0.png" alt=""></p>
<p>船长和两颗鬼火之间的三角形，如果自机进去会生成白色激光，会封死三角形内全部的区域；锚奇数，打到版边的水滴弹大概是随机吧。</p>
<p>大概只能固定走位。</p>
<h4 id="「经年的憎恶」"><a href="#「经年的憎恶」" class="headerlink" title="「经年的憎恶」"></a>「经年的憎恶」</h4><p><img src="/img/SCCS/经年的憎恶0.png" alt=""></p>
<p>随便扭扭 .jpg</p>
<h4 id="秘术「古代传来的神技」"><a href="#秘术「古代传来的神技」" class="headerlink" title="秘术「古代传来的神技」"></a>秘术「古代传来的神技」</h4><p><img src="/img/SCCS/秘术0.png" alt=""></p>
<p><img src="/img/SCCS/秘术1.png" alt=""></p>
<p>固定 + 狙。</p>
<p>随便扭扭 .jpg</p>
<h4 id="神鸟「迦楼罗天翔」"><a href="#神鸟「迦楼罗天翔」" class="headerlink" title="神鸟「迦楼罗天翔」"></a>神鸟「迦楼罗天翔」</h4><p><img src="/img/SCCS/神鸟0.png" alt=""></p>
<p><img src="/img/SCCS/神鸟1.png" alt=""></p>
<p>大概算是整个游戏第三难的符卡。</p>
<p>绿色的麟弹圈速度很快，上穿一定要果断；然后一边处理麟弹圈一边左右移动躲中玉狙或者看准或弹链的缝。</p>
<h4 id="变动「波-纹-偏-移Ripple-Shifter」"><a href="#变动「波-纹-偏-移Ripple-Shifter」" class="headerlink" title="变动「波 　 纹 　 偏 　 移Ripple Shifter」"></a>变动「<ruby>波 　 纹 　 偏 　 移<rt>Ripple Shifter</rt></ruby>」</h4><p><img src="/img/SCCS/变动0.png" alt=""></p>
<p><img src="/img/SCCS/变动1.png" alt=""></p>
<p><img src="/img/SCCS/变动2.png" alt=""></p>
<p><img src="/img/SCCS/变动3.png" alt=""></p>
<p><img src="/img/SCCS/变动4.png" alt=""></p>
<p><img src="/img/SCCS/变动5.png" alt=""></p>
<p><img src="/img/SCCS/变动6.png" alt=""></p>
<p>大概算是整个游戏第二难的符卡。</p>
<p>一共三波，循环；每一波都是红蓝弹绕着版面中心旋转，其中红弹逆时针，蓝弹顺时针；比较特殊的是第三波，红蓝弹重叠会在特定位置形成无缝。</p>
<p>最后一张截图就是差点被封死然后击破了。</p>
<h4 id="電中「超高压-Voltecker（伏特克）」"><a href="#電中「超高压-Voltecker（伏特克）」" class="headerlink" title="電中「超高压 Voltecker（伏特克）」"></a>電中「超高压 Voltecker（伏特克）」</h4><p><img src="/img/SCCS/电中0.png" alt=""></p>
<p><img src="/img/SCCS/电中1.png" alt=""></p>
<p><img src="/img/SCCS/电中2.png" alt=""></p>
<p>所以说 Voltecker 是个啥玩意（</p>
<p>带核弹撞人 + 扔核弹 + 泛狙到纯随机的闪电。</p>
<h4 id="击沉「Abyss-Sinker」（深渊坠沉）"><a href="#击沉「Abyss-Sinker」（深渊坠沉）" class="headerlink" title="击沉「Abyss Sinker」（深渊坠沉）"></a>击沉「Abyss Sinker」（深渊坠沉）</h4><p><img src="/img/SCCS/击沉0.png" alt=""></p>
<p><img src="/img/SCCS/击沉1.png" alt=""></p>
<p><img src="/img/SCCS/击沉2.png" alt=""></p>
<p><img src="/img/SCCS/击沉3.png" alt=""></p>
<p>锚本身是固定的，扔出去后会在轨迹上留下发光小玉，收回来的时候回把小玉打碎成水滴弹；下一波锚彻底砸下来之前上一波的水滴弹不会消失。</p>
<p>三波，循环，但其实后两波有点像的。</p>
<h4 id="转移「次-元-飞-跃Parallel-Switching」"><a href="#转移「次-元-飞-跃Parallel-Switching」" class="headerlink" title="转移「次 　 元 　 飞 　 跃Parallel Switching」"></a>转移「<ruby>次 　 元 　 飞 　 跃<rt>Parallel Switching</rt></ruby>」</h4><p><img src="/img/SCCS/转移0.png" alt=""></p>
<p><img src="/img/SCCS/转移1.png" alt=""></p>
<p><img src="/img/SCCS/转移2.png" alt=""></p>
<p>毫无疑问的整个游戏最难符卡。</p>
<p>弹幕本身是无缝的，分红蓝两色，其中有一种颜色的弹幕没有判定（就是半透明的子弹）；如果穿过没有判定的弹链会导致判定状态切换，即之前没有判定的颜色变得有判定，有判定的颜色变得没有判定。</p>
<p>典型的看上去难玩起来更难的类型。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>如果后面又有更新了的话大概这边也会更新吧。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
        <tag>Nono 443</tag>
      </tags>
  </entry>
  <entry>
    <title>東方鬼葬剣（とうほうきそうけん） ~ Infinite Blade Pavilion</title>
    <url>/touhou-kisouken-infinite-blade-pavilion/</url>
    <content><![CDATA[<blockquote>
<p>「靠为什么刚开学才一个星期我已经感觉过了一辈子了。」</p>
</blockquote>
<p>SLYZ 2018 级 24 班朝代，皇帝及年号更替史：</p>
<ul>
<li>YHN，立「精朝」，称「精太祖」，开元（忘了），后自谥「精虚帝」。</li>
<li>YHN，改「精朝」为「楠朝」，称「楠太宗」，开元「真虚」。</li>
<li>时生物听写，太宗大挫，改元「太虚」。</li>
</ul>
<a id="more"></a>
<p>总而言之就是介绍一个叫做鬼葬剑<del>或者说鬼那啥剑</del>的游戏。</p>
<p>一年前发布的体验版，当时号称东方史上最难同人 STG，并且真的做到了。</p>
<p><del>然后正式版难度大砍。</del></p>
<p><del>不过有一说一体验版的确有一些无理了。</del></p>
<p><del>而且可以续关，虽然是星莲船的续关。我是不会说体验版是连续关都不可以的。</del></p>
<p>似乎ミルカ写的剧本（大概？）都会找一些神话故事作为蓝本。邪星章是旧约新约圣经，导命树是北欧神话，桃源宫是克苏鲁神话，真珠岛是埃及神话。</p>
<p>这次轮到中华神话了。</p>
<p>我是指，六面 Boss 是「<ruby>蚩<rt>し</rt>尤<rt>ゆう</rt></ruby>」，萝莉（确信）。</p>
<p><del>「<ruby>八<rt>や</rt>蘇<rt>そ</rt>神<rt>がみ</rt></ruby> <ruby>秋<rt>しゅう</rt>雨<rt>う</rt></ruby>」（指正</del></p>
<p><del>其实这游戏所有角色都是萝莉（光速逃</del></p>
<p><del>但是我永远喜欢那谁谁まぐら（超光速逃</del></p>
<p><del>去 THBWiki 翻了翻发现是「<ruby>饕<rt>と</rt>喰<rt>ぐ</rt>楽<rt>ら</rt></ruby> まぐら」（奇怪的名字</del></p>
<p>秋雨终符之前其实也有一些台词的。但是因为是图像，在游戏代码里面找不到文字。那么我就回忆一下视频里：</p>
<blockquote>
<center>我が名は蚩尤</center>

<center><font color=##FF0000>鬼</font>として<font color=#FF0000>葬</font>られたものたちの<font color=#FF0000>剣</font>となり！</center>

</blockquote>
<p><strong>结 尾 点 题</strong></p>
<p><strong>文 题 呼 应</strong></p>
<p><strong>升 华 主 题</strong></p>
<p>好吧，其实我现在在游戏里（虽然说是最高难度 Lunatic）连秋雨终符都见不到（</p>
<p>但是不得不说这游戏的弹幕都太野蛮了。比如说，我们有：</p>
<ul>
<li>一面吊打砂哥（？</li>
<li>二面很酷很炫</li>
<li>三面版底出缝</li>
<li>四面劲爆砌墙</li>
<li>五面斩了再说</li>
<li>六面花样爆菊</li>
</ul>
<p><strong>黄 金 精 神</strong>（等等好像哪里不对</p>
<p>好。写完了。睡觉。</p>
<p>链接：</p>
<ul>
<li><a href="https://www.freem.ne.jp/win/game/20533">在 Bullet Forge 上下载该游戏</a></li>
<li><a href="https://thwiki.cc/%E6%9D%B1%E6%96%B9%E9%AC%BC%E8%91%AC%E5%89%A3_%EF%BD%9E_Infinite_Blade_Pavilion.">在 THBWiki 上查阅相关资料</a></li>
<li><a href="https://www.bilibili.com/video/BV1ev411C7aN">观看相关视频</a>（其实这个我也没看，我看的是另外一个 NBNC 的）</li>
</ul>
<p>9-11 补充：</p>
<p>不得不说，这游戏相比起体验版来说真的是削得超级多：</p>
<ul>
<li>梦 A 的面包片的发射频率快了 2 ~ 3 倍左右</li>
<li>道中杂鱼敌人血量大幅度降低，弹幕强度大幅度削弱</li>
<li>Boss 血量大幅度降低</li>
<li>资源变多</li>
</ul>
<p>我初通的时候道中几乎没背板，只是稍微记了一下一些比较麻烦的地方。</p>
<p>结果到最后 7 残见秋雨 5 残通。</p>
<p><del>什么嘛，我打得不是挺好的吗（自许</del></p>
<p>然后试了一下剩下 5 个机体：</p>
<ul>
<li>梦 B 就一个直线机跑得还贼慢</li>
<li>魔 A 说是贯通激光其实还是没法用</li>
<li>魔 B 攻击太鶸</li>
<li>妖 AB 吊毛机体用不来</li>
</ul>
<p>顺便还想补充一下。感觉这游戏 SpellPractice 有问题。很多在 SpellPractice 里面形状固定的弹幕到了 ScenePractice 里面就变成了随机的了。</p>
<p>给人感觉最明显的应该是二面二符・死凶「窮奇のデスサイズ地獄変」。ScenePractice 里可以看到四个分身的初始角度是随机的，结果 SpellPractice 里直接给固定了。</p>
<p>太懒了就不截图什么的了。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
      </tags>
  </entry>
  <entry>
    <title>東方覚醒珠（※二次創作） ~ Fan-made Virtual Autography</title>
    <url>/fan-made-virtual-autography/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1104610/__Fanmade_Virtual_Autography/">Steam 页面</a></p>
<blockquote>
<p><ruby>弾<rt>たま</rt>を<rt> </rt>撃<rt>う</rt>つ<rt> </rt>遊<rt>あそ</rt>びのプレイヤーよ<rt> </rt></ruby>、</p>
<p><ruby>玉<rt>たま</rt>を<rt> </rt>打<rt>う</rt>つ<rt> </rt>遊<rt>あそ</rt>びの<rt> </rt>前<rt>まえ</rt>に<rt> </rt>敗北<rt>はいぼく</rt>せよ<rt> </rt></ruby>！</p>
</blockquote>
<p><del>双关真好玩（</del></p>
<a id="more"></a>
<p>没错，就是这么一款 Steam 上刚出（指两周前）的东方同人……STG？某种意义上算是吧，因为这游戏主要强调的还是 RPG 的部分。</p>
<p>弹幕方面——尤其是 5 Boss，基本不能躲，然后 124 Boss 莫名其妙地糟，其他的其实还好。</p>
<p>尤其是 Ex Boss，说实话除了四符，八符，时符和终符以外并没有什么拿得出手的弹幕。</p>
<p><del>但实际上从混关角度考虑，时符终符两张糟卡放在一起从 RPG 的角度来说十分麻烦，再加上这个时候这边的资源也已经被耗得差不多了。</del></p>
<p>玩法：</p>
<p>如上文所言，这游戏重点在 RPG。</p>
<ol>
<li>本质上是单关练习。自机这边需要带上四个「单位」，按照游戏中的说法是「<ruby>地珠<rt>ちず</rt></ruby>」。单位分红白二色。</li>
<li>通过击破杂鱼敌人和 Boss 的非符或符卡来收集道具。</li>
<li>道具也分红白二色，可以给同色的单位充能。充满一次可以获得一次攻击的机会。</li>
<li>敌方也有单位。自机每 miss 一次也会给对方送过去一些道具，而且这些道具一定会使得对方所有单位获得一次攻击机会。</li>
<li>游戏进行到某些特定节点的时候，会出现 Party Battle 事件，就是敌我双方的单位互相攻击，自机一定先手。</li>
<li>自机方的单位会攻击敌方的单位，一旦某个单位的 HP 降到 0 了，它就不能攻击了。</li>
<li>另一方面，敌方一定会直接攻击自机本体，也就是说自机方的单位不会出现 HP 降到 0 无法攻击的情况。</li>
<li>当然自己本体的 HP 降到 0 了就真的满身疮痍了。</li>
<li>在 6 Boss 的 Final Spell 和 Ex 道中，会出现一些 <strong>特殊的 Party Battle</strong>。</li>
<li>单位有 spell turn 这个属性。大部分单位以 4 或 5 为主，当然也有几个 3 和一个 8。</li>
<li>单位每充满 spell turn 次，就可以扔雷。扔完一个雷就需要重新充满 spell turn 次才可以扔下一个。</li>
<li>虽然一次指扔一个雷，但是扔雷的时候处于能够扔雷的状态的单位越多，雷的威力也会越强。</li>
</ol>
<p>其实，因为我也没有认真读设定文档，还不知道这个游戏到底讲了一个什么故事。</p>
<p>但是还是不可避免地被 5 Boss 这个叫「<ruby>仙覚寺<rt>せんがくじ</rt></ruby>　<ruby>鞠子<rt>まりこ</rt></ruby>」的角色留下了深刻的印象。</p>
<p>首先一登场二话不说切 BGM（而且她的 BGM 的氛围和 5 道中一个天上一个地下），然后直接怼到自机脸上开始自顾自地说自话。</p>
<p>——没错，直接怼到自机脸上。不管这个时候自机往哪跑她都会跟着。</p>
<p>BGM 叫「<ruby>偏執<rt>へんしゅう</rt>の<rt> </rt>朱筆<rt>しゅひつ</rt></ruby>」，好吧的确挺「偏执」的。</p>
<p>而且，设定上她似乎是给「和歌」，或者说「弹幕」做注解的。也许是因为这个原因，弹幕强度高不说，她在 5 关底虽然只有一个单位，但是血非常厚（44444），攻击也很高，基本上两三下就可以直接送自机上路。</p>
<p>——从某种意义上来说她才是这游戏的本体。</p>
<p><del>因为这个 5 Boss 我还自闭了有一阵子。</del></p>
<p>不过话说回来，这游戏竟然还有汉字注音（</p>
<p>以及，以下是一些截图。</p>
<p><img src="/img/20210404190325_1.jpg" alt="本篇难度选择"></p>
<p><img src="/img/20210404190314_1.jpg" alt="本篇关卡选择"></p>
<p><img src="/img/20210404190455_1.jpg" alt="仙覚寺鞠子教你认汉字.jpg"></p>
<p><img src="/img/20210404190640_1.jpg" alt="1 Boss 当 Ex 道中"></p>
<p>那么就这些了。</p>
<big><big><center><ruby>このブログを<rt> </rt>読<rt>よ</rt>んで<rt> </rt>下<rt>くだ</rt>さった<rt> </rt>貴方<rt>あなた</rt>に 、 いや<rt> </rt>重<rt>し</rt>け<rt> </rt>吉事<rt>よごと</rt>！</ruby></center></big></big>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
        <tag>STG</tag>
        <tag>RPG</tag>
      </tags>
  </entry>
  <entry>
    <title>《常世ノ塔》简要测评</title>
    <url>/tokoyo-no-tou/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1393420/TOKOYO_The_Tower_of_Perpetuity/">Steam 页面</a></p>
<blockquote>
<p>$ git status</p>
<p>Nothing to commit, working tree clean</p>
</blockquote>
<a id="more"></a>
<p>闲着没事逛 Steam 翻到的游戏。</p>
<p>每天 23 点刷新一次的塔。刷新完之后可以有两条路线，而且路线中间可以来回切换——流程中有固定的切换点。</p>
<p>本质上当然是更接近平台跳跃，虽然 Steam 上有「Rogue 恶魔城」这样的标签。</p>
<p>稍微玩了 3 个小时左右。</p>
<p>要说第一印象的话，那就是手感不怎么好了。</p>
<p>虽然说跳跃的时候可以通过调节按键时间的长短来调节跳跃的高低，但是实际上可调节的范围并没有多少。轻轻按一下还是跳起来很高。</p>
<p>然后就是重力加速度太大了，或者说角色太重了。空中跳平台的话，滞空时间一长就不知道掉到哪里去了。</p>
<p>然后跑步有惯性？一类的，经常上平台的时候跑过头。</p>
<p>还有为什么没有下蹲啊。</p>
<p>然后关于角色。</p>
<p>默认角色ココア，男孩子——但是因为太可爱了成为了魔界的女仆长——我是说，当然，这是 ao 的<del>，正太控狂喜</del>。</p>
<p>其他角色倒是没怎么了解过，虽然除了ココア之外还有 4 个可选角色。</p>
<p>角色不同大概只有一个不同，那就是用出来的技能不同——顺便一提这游戏没有普攻，蓝条没有满放不出技能的时候就没有攻击手段了——虽然不知道为什么要这么设计。</p>
<p>总感觉玩多了血压上来了。</p>
<p>最远到 5st Region。可能是我太菜了吧。告辞。失礼了。</p>
<p>话说回来这游戏每天更新地图的时候不整点彩蛋啥的吗。</p>
<p>更新完地图不到一个小时就有人通关了，这就是 dalao 吗。</p>
<p><img src="/img/QQ截图20210623003006.png" alt="好多平台啊"></p>
<p><img src="/img/QQ截图20210623003144.png" alt="留下你的遗言吧"></p>
<p><img src="/img/QQ截图20210623005332.png" alt="关于排行榜上只有自己一个人是一种什么体验"></p>
<blockquote>
<p>插播一条新闻：</p>
<p>在独一无二 · 绝对无敌 · 天下无双的伟大的 OI 之神慎老师的启发下，我打算实现一款类似于模拟 OIer 的游戏——在这款游戏中可以像 OIer 一样学习 、 娱乐 、 社交……</p>
<p>但是想实现的要素太多，一时间整理不过来。所以说——有没有谁愿意帮我写一点。</p>
</blockquote>
<p>最近突然喜欢用破折号了也不知道为什么。</p>
<p>6 月 25 日凌晨 3 点左右更新：</p>
<p>我终于通关啦！！！</p>
<p><img src="/img/QQ截图20210625031745.png" alt="排行榜截图（因为退了一次所以没有 Recent You）"></p>
<p>最终 BOSS 见了 3 次过了。</p>
<p>其实本来初见可以过的但是前两个 BOSS 都会开护盾然而最终 BOSS 不开护盾直接可以打，不知道以为还要等护盾结束然后跟她耗了好长时间。</p>
<p>还有就是，全身判定的打击判定是真的大，这个最终 BOSS 再一次用实际行动告诉了我这一点。</p>
<p>以及，冷静下来玩真的会有加成。</p>
<p>顺便一提，那个 W-W 是路线，两个 W 意思是两次都选白线。类似地 B 就是黑线。</p>
<p>个人觉得白线比黑线简单的概率大一些。</p>
<p>最后还有个 To Be continued…?，嘛不过毕竟这游戏才是 EA。</p>
<p>不过说实话，50 层已经够难了，如果继续往上堆层数的话真不一定受得了了。</p>
<p>然后就是，虽然我之前一直在说这游戏手感怎么怎么差，通关一次之后我明白了——本质上只是我不会玩平台跳跃而已。</p>
<p>告辞。失礼了。</p>
<p>6 月 26 日 11 点左右更新：</p>
<p>其实今天凌晨 0 点左右看的时候发现一个人没通关时，我是有些震惊的。</p>
<p>直到我看到了今天的白线最终 BOSS。</p>
<p>しにぞこないナナハ。野蛮。几乎每一招都能杀人。</p>
<p>其中有一招是，她扔出一串手榴弹——或者类似的东西——以抛物线轨道瞄向玩家位置，然后落地炸开一大片。反正我是不会躲。</p>
<p>反观黑线最终 BOSS——暗い星のルゥラ——当然这个名字我是凭记忆打的可能会错，总而言之就是她就很菜了。</p>
<p>虽然技能和昨天在白线时不一样，但还是就那样了。</p>
<p>还有就是，不知道是昨天随机到的道中比较简单，今天的比较难，还是今天我状态不在，道中打得十分去世——进 47 层时，也就是进最终 BOSS 前的补给点时身上只剩下 20+ HP。</p>
<p>最后也是差一下就要在最终 BOSS 9961 了。</p>
<p>顺便一提，9961 是指 BOSS 剩最后一滴血时 Game Over。类比 .jpg</p>
<p><img src="/img/QQ截图20210626105537.png" alt="不知道为什么今天没有不知火游良说不定是 dalao 玩够了跑路了"></p>
<p>顺便一提，上图右半边是因为截这张图的时候是打完最终 BOSS 屏幕闪白的一瞬间，所以什么都看不清。</p>
<p>顺便一提，第二次用ココア通关的时候又确认了一遍剧情，上面总结的应该没啥问题。</p>
<p>6 月 27 日凌晨 3 点左右更新：</p>
<p>又遇到一个新的最终 BOSS，而且似乎和ココア认识？虽然名字忘了。</p>
<p>初见 9961。二见就通了。难度一般。至少比某个死不掉的家伙弱。</p>
<p><img src="/img/TOKOYO_NO_TOU_2021_6_27_2_20_35.png" alt="喜提（虽然只是暂时的）第一"></p>
<p>顺便一提，这次不知道是状态好了还是什么，满血进的 47 层，因此就不需要支付分数回血了。但是我今天的分数反而比昨天低了近 10000 分。神奇 .jpg</p>
<p>还有，手感这种东西，玩多了是真的能适应下来的。</p>
<p>冷静下来想了想，我好想突然明白为什么ナナハ难打了。</p>
<p>到目前为止我一共遇到过三个不同的最终 BOSS，只有她的房间是没有空中平台的——这也就意味着提供给玩家的躲避空间是最少的。</p>
<p>……大概吧。</p>
<p>不知道是什么时候的更新：</p>
<p>玩不下去了。告辞。失礼了。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>2D</tag>
        <tag>像素风</tag>
        <tag>平台跳跃</tag>
      </tags>
  </entry>
  <entry>
    <title>《キミガシネ》最终章前编 B 部分简评</title>
    <url>/kimigashine/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fdbaeeb80bcdb66a0f3144f223923610e44459b34690f26400bd156c4fe42a13">35a38ec48261007c19c17531251046751928eec990ebc90b81468155098643b53434599e5a94bb1f19896fc1de3673c3218151691017f848f720ecb4fba06653a64041ecd1dd76820cb8013c2fffd1d02ae9873e29812a2c805b445f256938485b3566945fe841efea08b9a3b72b308c7475effc86ed39b63a60311f8559badd290a8023ff309239f4e2813648661f2051aac2ada7f2446421b99ac5574d9e7dccc3efd31bce34b9f5268851956d0ae9812e1afb3f8b91d4a541f8e250e3038476d4b992687881e768bced0561d5853e8cf69c76bcfcb385fdfc9ef1c3e6a76956da6fdc74de5e9f7d818e6859599b494b186a400800577c23996f40830845e8de06e326efe927bbe270d6eafc2a3193c02f723f8fdf3c356aea2623f7b21e6a6f0e1674e9dfaec4ee6f5ebadc6189dc83719e49cc170e74ef3ef7fdea39656f5dfa58ebd69e235645081799b65993f24087d757fe714f032a7753e4b5fb70da581f174de40c9ae7727a17cd572a1594495b877d797d2cc7d509a63ba812df3a19a4a2943f670d517e0c8e59f02a0fc0ec45ac916c5c81904591bb8af2414459a5843b8352748f70f181938b6644963ed0ce82c1d09abce27f7c5d04ad9ccc13f68d0558970334629d952c13f141a074db18288aa90605350e7ae64744ef7be2fc72f82fde6eff63ff704ea6508a685f927e6195f3e5f12ed8598e904bd81821415028a39c4c5e168030e38afed7dbc0750a088b3cab04c538574f74cff5fa0ac29d7603d130bdc5974413ce9268015367d8ae9ff4a59f4d28088c3e340a604f56442c0c37ffa24bea36dec365d0637a69c4474774775ba708a4fe2719f0e162a88c24b84863810486c6e64d1ac2468393dc2a08a511db2989d49c3c73c2a6bddacacd862132bbe4df2f0518474c631a39c6771d009ed1f733a2f3d57b04644f898daf1a3ddff60585304d42ceb2b3b8be6ab0f7547ac1b13c521796610f35bd2c32132fff7170d5ea96de7e004c6bc2201436b83f0bb56ac398dacdb2faae3e347a19ad02c0cac854d22d6078d8add795c814a41d35ffd1210ffbfd3294cf7ad77047531f11de79aa85a43a774d5cd22fb7ea1d26f456662f8d97ac446bcb225407579d3acfd9e49c4a48ada40e7c2c3272f70c7580800e2987190a35fbec4cc056badae8681a36a20da3193cfb2735681ad3fa64b3bd0af45d6345904fa398f6a6d67f7077545b29118286666b13cae8dfc68b668b1ebc1f5e84c2b4ded4d29c8257693286cfe59890ed6a016d3b31d5deda428a2333be35e5f6eb40060275eb3bf0bf8bd6adbf164869b06c102c23cab05de3f175bf0a7810daf9608a8c3dbb2a4943277e11d83bb99c18d219297b84ade486dff0ffced078319b9ddb42c7d41ddcafdd55f8a43f94addab90de6c32de67164861a09bdba4cf0104963626464dbbd9c38b23f9e6a01b7ce38b0a1ce1e89cfbb626b178c6ce15e6c8a7946e79e0a78c7cebe6ddd043f03906abfc3981317c1e7bbcc0ca9168fc112b32bbad67424b3f2e1927157d03d0e2183c23d11c6f3f15dbca86e91e5ba94b0a2620415081222b513c1c33c500a940069e7d213bcf5e0c4c6e851a2469282596fa2b4b3ab7bc8bdf5d34ee254a8164075ec697d09f02b86c4d5748b57cc65ccefbbc3f6008b33f4093c058bd581bf8736e376943dbf7d57af30706212f3b5a225b0b03105cb049dac150736b0182bfe046cf8780f3dd95760a886fd05eaccf197b1c07d86731b9dc634c7e422e26bf018b76141e382481205f1c01e9f77b52af847429cafda289b7ad4601fd6dc62ed3e77281a795eba2765335bd5725e636a16bb4b6e986f4d2ed348fe658ee01ac39b41785d49dd22d08e4304620b4f4c6f9a18e687f895ad7fae7fbf175aac7e978030a45185b1a70bd3bc50750c1c8cf1b08edf10df115dcd5145aaec54ca9e5e62a2b573c715c3d186a6d6f95562eedda9f204138f74749f510bcb8308e732b0f7cf49ba76c05451395a69adab983308acc6e79024c7d3d968d84e0e8c6a5b353c8d9f3d39b63ded77a0e3457c329a98d8c5f8651e18745d4b3e4d6d11222434bcd461c278e363ab7585f24906b2282cefcd2a48aa2f576c936b12fd2ad33a117fe53f005c1ab5d037554710e33edb77b597eeb00510c85ae0c19a3d4b227c6f91807e4c5992358c4cb1fe102029d125e2a213d83170d33bfe0386ab088da0967bd896916b4c0dd8b72e3208d8bddeae9f2d63bf2cdb2daef750927a5f37e0aeecb20c671078c1b875818091bd774fd5b4e70b56c5e82905fb479ad60ca44846bb74ba2d4c741ede9dc68bf430d6466d5fd68e3f858edb715298ee7b5d61e854161242db4e150c3f22972fdc8a0620fba04cc60b4aba8f37c88997c33ebfd6eebca56966244a2375c80bd9e61e1c7747472ea073d9286a26a1d1886c2a5d79c643b74bd69e36bbd5f8b2fcf551918993e5434a40c58ccb6699a99e8e5fdf82763891cad85a069e518229a5241338f939171ccf29dd30b11ce0cac2246fc5eec84c4dcbdd463510ed437cf0e4ddbceeff73c09a74984782efe1088a0d4f6b23607e5ca16f41319da3d79df0828512de9717e434a25d88a22d9afe9bbfc4a576e315df1da8c799fc0cae54c13f412a602c732a150647719307f89cda7b420d45162bcb06e5df81273af8062d0c240dfea87cfc60beac75280d0fb2772dc11099dea0163d12b07b6824f91a73d5fea1ea9d6623dcd89f858b4bb1b707b06aa0ec722141dfc6e031aed60987271c0360c429f89c6efa35734c280ea02dc4a756f5a92612ce671099262339cb35be08dd55fc8a3904c8863949681eff8649ecde163cea16f58c12e85ddfbba4af4b1d0519f920582f2716b128468eedccb15dc79ae20562614ae27c00640f5a3e59c3d542081b2a50464cbd626bb33201f20c29dc78e1672d900afa8c1e22f0d5286c4260e11a9025dc3f6bb8e5ee700b8b18aaab74d5c1aefa300b879b5d85c57cb5cb6158fc5174dd7f4ffc1ee6a2ec25716869a406560e371e36db40fe2d1abc9e0d29856ece620d3462de78047c7bae38be51b21ed5e346bdd3ead6bed5cb29642e1f09676466b524c6f42af152c7d355f4666f930eb325076390eb6b7389c584bc8ce74e412263d825ec111963402137028b18139462bf775d49f897a6c11ff6872935471dbf93c1604f53789fb375f21b360e172e1cfa3efb5b70bc1458c5efb97c9a23561ba66aaff979ecd84ce804ce9a9f4bc8bca0ccb0de351db54d1e574685f031ed82d7cd8fc90c9e72d6fc132483f379a103ce9a2770065cb41c50580bdb883b25bae846c9bb93c62b2ecbc88f4abb03b13ccab775314380357453a9f105c7421d812cfcb54a11d69952f3f19c71c90456446118d74dc18fb938a51b43ce8ad9a47dc6885a24c4d9696da117e4bcf6bc3145b49b76f3736fd0fa0306d8da82007a3a410ab83368697b851b43262c9d930006a4602592552ce442561f2b8baf302ac744cd1d064c3a69ab28a2ab519e17290868ab479ea549f0802f90b8ceedff165d1924b976bf4124ea1f0d548dd679b499bcf5721f2af77f4b4b5f3e7ad549d1a0ce7332a79126033819fad50bd5f11f0a7c7034f4b03747d26116b17d6b65c21e0b50dd49873203a1046810d16e49417ab58d1d35c82af8205cfdaf992202e35e9b04ff82fcc8272e1fd817c0104474898928931630fc9e2b05e24fd5384c54afb4ce78d0a78ecff6ac25b539845408777491fbe754be8120f9afedef4e948c9788</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码继续阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>颓废（没那回事）</category>
      </categories>
      <tags>
        <tag>推理</tag>
        <tag>解谜</tag>
      </tags>
  </entry>
  <entry>
    <title>OI Team Meeting：2021-07-17</title>
    <url>/oi-team-meeting-210717/</url>
    <content><![CDATA[<p>2021 年 7 月 17 日，星期六。</p>
<p>SLYZ 2018 级信息竞赛组内部的同学聚会！</p>
<p>计划：到了地方看着办。</p>
<a id="more"></a>
<p>前一天我还因为是几乎第一次一个人出门想要临阵脱逃，这个时候</p>
<blockquote>
<p>阿块「我觉得车到山前必有路吧。」</p>
</blockquote>
<p>第二天 8：00 左右坐上车，差不多 10：00 左右到北门。</p>
<p>想着去找找他们，然后发现了迎面走来的阿稳。</p>
<p>几分钟之后我们又发现了阿块和 R。</p>
<blockquote>
<p>阿稳「我靠阿块变这么壮了。」</p>
</blockquote>
<p>然后我们打算先进门，于是四个人一起在建筑里随机游走。</p>
<p>然后我们看到了一个舞台，一些老年人在上面表演。</p>
<blockquote>
<p>阿稳「老年文工团。」</p>
<p>阿块「我听不清，但我大受震撼 .jpg」</p>
</blockquote>
<p>然后我们遇到了阿陶和阿烜。</p>
<p>zhuoer 似乎要 11：30 才能来。</p>
<p>于是我们继续随机游走到四楼电影院，在那里就坐了。</p>
<p>这个时候阿块向我安利了《元气骑士》。于是我开始和他们打联机。</p>
<blockquote>
<p>我「这场面好混乱啊……欸我怎么死了。」</p>
</blockquote>
<p>过了一会</p>
<blockquote>
<p>我「是谁打死了我……而我又打死了谁……」</p>
<p>我「……！」</p>
<p>我「是……我打死了我！」</p>
</blockquote>
<p>然后等 zhuoer 来了我们打算去吃饭，于是下到三楼。</p>
<p>然而除了我，阿块和 R 以外的四个人两两一组便闲聊便只顾着往前走。</p>
<blockquote>
<p>阿块「打扰一下，你们有在看去哪家吃吗？」</p>
<p>阿陶「没有。」</p>
</blockquote>
<p>然后走着走着我们发现我们绕回起点了。然后我们决定再绕一圈。</p>
<p>第二圈绕到一半，阿稳提议说去吃火锅，然后 zhuoer 说他刚好拿到一张火锅店的票。</p>
<blockquote>
<p>阿稳「有你怎么不早说！」</p>
<p>zhuoer「我说了你不听啊。」</p>
</blockquote>
<p>然后我们去吃火锅。点了一份双人套餐，本来以为他会有两个锅，但实际上是一个锅砍成两半一边一种底料。</p>
<p>于是我们就又点了一份。</p>
<p>在这期间我们聊了很多话题，包括但不限于：</p>
<ol>
<li>上了大学去哪</li>
<li>Steam 18+ 游戏盘点（我「话题变得奇怪了 .jpg」）</li>
<li>高考前在干什么（阿稳「高考前一天晚上我还在看番。」）</li>
</ol>
<p>我还给阿块展示了一下主席自交的后代预测。</p>
<p>吃完饭我们打算去超市逛一圈，然后不知道为什么跑去 B1F 的停车场绕了一大圈。停车场真就热死了。</p>
<p>从超市出来我们发现了两个买彩票的机器，然后阿块身先士卒地上去买了一张。</p>
<p>买的时候他还会问你是否已年满 18 岁。<del>形式主义提问。</del></p>
<p>似乎是刮开之后每三个一样的图案就可以获得那一行的奖金。</p>
<p>第一行</p>
<blockquote>
<p>阿块「哎呀不一样。」</p>
</blockquote>
<p>第二行</p>
<blockquote>
<p>阿块「5 块钱！很好我回本了。」</p>
</blockquote>
<p>剩下几行略。最后</p>
<blockquote>
<p>阿块「很好我赚了 15。」</p>
</blockquote>
<p>然后把票还给机器，上面就会有一个二维码，扫那个拿钱。</p>
<blockquote>
<p>阿稳「欸那如果说我抢在那个买彩票的人之前扫上这个二维码钱是不是就是我的了？」</p>
</blockquote>
<p>然后 zhuoer 又买了一张中了 20，扫码的时候真就自己没扫上给阿稳扫上了。</p>
<blockquote>
<p>阿稳「欸等会他说不定要确认的。」</p>
<p>机器「已将奖金打入您的微信钱包。」</p>
<p>阿稳「********。你快过来我把钱还你。」</p>
</blockquote>
<p>等两个人跟上我们之后</p>
<blockquote>
<p>R「哟！这不是赚了 20 块的阿稳和亏了 5 块的 zhuoer 么！」</p>
</blockquote>
<p>14：00 左右，其他几个人想去玩剧本杀，想带上我。</p>
<blockquote>
<p>我「剧本杀怎么玩啊没玩过。」</p>
<p>阿烜「没事的成爷，到时候你就照着剧本说蛤话就可以了。」</p>
</blockquote>
<p>然后我们就去玩了。</p>
<blockquote>
<p>阿烜「要不我们约定以后每年暑假都来这儿聚一聚吧。」</p>
<p>zhuoer「靠这破地方说不定过两年就给拆了。」</p>
</blockquote>
<p>阿稳说因为我话不多，想给我分一个简单一点的剧本。</p>
<p>（虽然实际上我拿到的并没有多简单</p>
<p>然后开始游戏后我因为不知道说什么于是全程掉线。</p>
<blockquote>
<p>阿稳「成爷怎么挂机啊。」</p>
</blockquote>
<p>过了一会</p>
<blockquote>
<p>zhuoer「不是，现在的问题是我们对成爷的角色一无所知。」</p>
</blockquote>
<p>然后，说实话知道游戏结束我也没能理清楚整个剧情。</p>
<p>啥玩意啊咋回事啊 .jpg</p>
<blockquote>
<p>插播一则旧闻：</p>
<p>慎老师「我们接着做那个机房模拟器吧！」</p>
<p>我「这是 ao 的 qwq」</p>
<p>慎老师「ao 是啥啊。」</p>
<p>我「啊这。ao 就是好的意思（」</p>
<p>慎老师「嗷。」</p>
</blockquote>
<p>还有，这个 Win 10 自带的中文输入法真就太拉了。</p>
<p>2021 年 7 月 21 日更新：</p>
<p>块块给捉了几只虫 qwq</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>同学聚会</tag>
        <tag>颓废</tag>
      </tags>
  </entry>
  <entry>
    <title>弹幕结界：红色禁果</title>
    <url>/red-forbidden-fruit/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1388230/DANMAKAI_Red_Forbidden_Fruit/">Steam 页面</a></p>
<font color=#DD0000><ruby>志<rt>ココロザシ</rt></ruby>ナカバニテ<ruby>死<rt>シ</rt>ス</ruby></font>

<a id="more"></a>
<p><br>闲着没事逛 Steam 发现的 STG。</p>
<p>是原来某个叫做《星天歌：魔界的日常》的游戏的续作。虽然前作我只是云过，是个风格类似东方旧作的类东方 STG。</p>
<p>上 B 站看了一下，然而只能找到<a href="https://www.bilibili.com/video/BV1zr4y1c7g7">一个 20 年的视频</a>。然而我明确地记得我第一次了解到这个游戏是只有我和阿块去了的一轮省队集训，也就是 19 年左右。</p>
<p>不是很懂 .jpg</p>
<p>说一下系统。</p>
<p>击破敌人掉绿宝石，可以 +1 火力，收集很多可以奖残。</p>
<p>每 400 绿宝石奖一残。3200 绿宝石，也就是 8 个奖残之后改为 800 绿宝石奖一残。</p>
<p>一般混关应该可以拿到 4800 的奖残，也就第是 11 个。加上三面道中的一个 Extend 和初始的残机，一共 14 残。<del>别看这么多一会就撞没了。</del></p>
<p>擦弹掉红宝石而且自动吸取，只能 +1 火力。</p>
<p>火力分 1~4 的等级。等级 2 以上时可以按 X 清空火力槽扔雷。</p>
<p>用雷消去的弹幕会变成白宝石，可以增加收集绿宝石时的得分。</p>
<p>没有上线回收。</p>
<p>总体来讲，糟点就是几乎没有什么保命措施。雷一扔出去了很容易被弹幕包围不知所措连续去世。</p>
<p>没错，这游戏就是个猴子游戏，扭不来弹幕死路一条。</p>
<p>还有就是，收集宝石会加 Rank，被弹或扔雷会降 Rank。Rank 越高弹幕越难，虽然我一上手就是 Lunatic 自带锁定 Rank Max。</p>
<p>通了本篇之后解锁 Extra 和 Challenge。</p>
<p>Challenge 就是，把某个角色的所有符卡在 Rank Max 的情况下 NN 击破，就可以解锁一张隐藏符卡。</p>
<p>不知道是要同一难度的所有符卡还是什么，反正我把 Lunatic 的所有符卡击破就解锁了。</p>
<p>还有就是，实战是真的会自带 debuff 的。</p>
<p>单关练习里面什么小缝我不敢钻，一上实战好家伙比谁都怂。</p>
<p><img src="/img/TIM图片20181209192946.jpg" alt=""></p>
<p>以下是一些截图</p>
<p><img src="/img/20210721141838_1.jpg" alt="经典老番之裙底安定"></p>
<p><img src="/img/20210721141223_1.jpg" alt="说不定这位其实是小红帽"></p>
<p><img src="/img/20210721142216_1.jpg" alt="玄学避弹（有一说一我真的搞不懂为什么我没死在这张符卡）"></p>
<p>初通 MISS 情况：三面关底二符，终符；四面关底二非；五面关底二非 ×2，二符 ×2；六面关底一符，三非，四符，终符。</p>
<p>没想到四面 BOSS 竟然给面子只杀了我一次，二符三非三符连起来我竟然没有死。我大受震撼 .jpg</p>
<p>然后五面 BOSS 打崩了死了四次。我再次大受震撼 .jpg</p>
<p>总而言之就是一个超级无敌野蛮的猴子游戏，换句话说就是吃状态。状态不好一面循环。</p>
<p><del>有一说一一面关底一符难的。</del></p>
<p>如果您想要观看我的初通 Replay 并以此嘲讽我有多菜，可以联系我 qwq</p>
<p>最后吐槽一句这游戏中文翻译做的不好。很多地方语句逻辑莫名其妙的。</p>
<p>还有别看第一个角色 POWER 是五颗星，实战就她输出最低。</p>
<p><del>果然金发的女孩子无论在什么世界里都是只有被迫害的份吗（悲</del></p>
<p><del>欸等会隐藏角色也是金发啊（惊觉</del></p>
<p>啊，什么，BGM？不重要，反正都不咋样。<del>其实是还没空听。</del></p>
<p>2021 年 7 月 23 日凌晨更新：</p>
<p>通关之后解锁了一个隐藏角色 Angelica。似乎是 Eldied 捡来的猫？</p>
<p>至少 Eldied 的 Challenge 符卡的符卡说明里这么写。当然我是直接翻的游戏源文件看到的。</p>
<p>高火力诱导，整个游戏输出最高的机体。反正我是怕了。</p>
<p>称号是「かわいい黒猫」，嗯确实可爱。</p>
<p><del>说不定其实项圈也是萌点。</del></p>
<p><del>而且是唯一一个答应 Yami 说还会去找她玩的 qwq</del></p>
<p>ED 里和 Cocoa 好上了，ED 就是两只猫一起喵喵乱叫。</p>
<p><del>以及吐槽一下 Cocoa 的猫弹幕太出戏了。甚至 BGM 里还有猫叫。那种真的猫叫。</del></p>
<p>看评测说低难度版本的弹幕在 Rank 相同的情况下几乎都比高难度版本难出很多。</p>
<p>实际试了一下感觉也就个别情况吧。</p>
<p>但是低难度版本的弹幕 Rank 一高确实变化很大。</p>
<p><del>而且写那个评测的那位还来了句这游戏难度太低。原来如此这就是 dalao 吗。干败吓疯 .jpg</del></p>
<p>而且才发现原来三个机体对应的 EX 道中 BOSS 不一样。</p>
<p>Eldied 对应 Tenka；Diana 对应 Beliel；Angelica 对应 Cocoa。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>STG</tag>
        <tag>猴子</tag>
        <tag>猫</tag>
      </tags>
  </entry>
  <entry>
    <title>简单随笔</title>
    <url>/how-am-i-doing/</url>
    <content><![CDATA[<p>还有不到一个月我就要去大学报道了（悲</p>
<p>快乐无比的暑假生活马上就要迎来结局了。</p>
<p><del>这让我失去了 决心。</del></p>
<p><del>喂，这前面可是地狱啊！</del></p>
<a id="more"></a>
<h2 id="颓废"><a href="#颓废" class="headerlink" title="颓废"></a>颓废</h2><p>回想一下，发现这两个月什么都没干。</p>
<p>想过要写点东西然而写了半个小时就写不下去了。</p>
<p>可能我并不适合创作吧。</p>
<p>脑海中会不时地浮现出一些片段，然而没有办法缝合起来。</p>
<h2 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h2><p>最近换了一台电脑。比之前那台配置好了不少。当然也贵了不少。</p>
<p>试着重新捡起《废墟图书馆》玩了玩，发现不卡了。</p>
<p>从头开始玩发现，认真玩的话前期还是不算太难的。</p>
<p>然后现在卡在殷红迷雾了。有一说一卡莉强到不讲道理了。</p>
<p>比如说某张杀死目标或令目标陷入混乱就再次重新打出的书页。</p>
<p>第一次看我还觉得这个触发条件太严格了，直到有一次我五个司书被这玩意一网打尽。</p>
<p><del>Geburah「这 TM 是啥？」</del></p>
<p>近期可能会写一篇相关的 blog。</p>
<p>但是也可能就鸽了。没人看感觉写的动力不大。</p>
<h2 id="VTB"><a href="#VTB" class="headerlink" title="VTB"></a>VTB</h2><p>然后最近又在 Steam 上找到一个 VTB 模拟器。</p>
<p>想着当成是个 2D 捏人游戏于是买了。</p>
<p>虽然可能的选项非常少，但是捏出来看久了还觉得挺可爱？</p>
<p>游戏性的话就那样吧。不专门安利了。</p>
<p>把捏出来的成果放一下吧：</p>
<p><img src="\img\20210816111128_1.jpg" alt="随便写点啥"></p>
<p>名字叫「<ruby>夢宮<rt>むきゅう</rt></ruby>　 きりこ」，「きりこ」写成汉字的话是「雾子」。</p>
<h2 id="Steam-愿望单"><a href="#Steam-愿望单" class="headerlink" title="Steam 愿望单"></a>Steam 愿望单</h2><p>当然最近也在 Steam 上看到了其他比较想玩的。</p>
<p>比如说大逆终于上 Steam 了。</p>
<p>比如说既然换了个好电脑想玩玩莱莎的炼金工房。</p>
<p>然后现在在等打折。</p>
<h2 id="OI-出题"><a href="#OI-出题" class="headerlink" title="OI 出题"></a>OI 出题</h2><p>就算是现在还是想出一些题的。</p>
<p>翻了翻之前记录下来的题，发现很多都很有意思。</p>
<p>然而我当时一直在想新题就忽视了这些有意思的老题了。</p>
<p>现在新的 idea 有些少了，想着要不要把这些老题翻出来解一解。</p>
<p>但是还是没什么动力。</p>
<p>虽然就现在我是没什么举行正式比赛的可能性了，但是还是不想公开这些题。</p>
<p>不过说起正式比赛，之前 CrOI 第一次正式比赛几乎已经配置好了。然而最后还是弃掉了。</p>
<p>现在就算再扔出来也不会有人做了吧。毕竟我自己都不写 OI 了。</p>
<p>阿块现在毕竟高四肯定没时间。其他人一提起分块就告辞。</p>
<p>说不定这样下去这些题就要发霉了。要不要干脆公开了算了？</p>
<p>这些题里面有一看就不能做的，有看上去能做但我没细想的，也有一看就很简单的。</p>
<p>总之是各种各样乱七八糟的 idea 糅合在一起。甚至还有我做梦梦到的。</p>
<h2 id="补充-I"><a href="#补充-I" class="headerlink" title="补充 I"></a>补充 I</h2><p>阳的主题曲好好听啊。</p>
<blockquote>
<p>Children of the city see only the neon stars</p>
<p>Reflected on the murky gutter sky</p>
<p>Don’t ask me why I desperately wish to be included in the city’s night</p>
<p>致 Challestend：</p>
<p>在北京时间公元 2021 年 9 月 12 日 00：00 之前写完《逆转潮流》的剧本。</p>
</blockquote>
<h2 id="补充-II"><a href="#补充-II" class="headerlink" title="补充 II"></a>补充 II</h2><p>邵好强啊。</p>
<h2 id="补充-III"><a href="#补充-III" class="headerlink" title="补充 III"></a>补充 III</h2><p>打过殷红迷雾了。</p>
<p>但说实话我也很迷，打着打着不知道什么时候给对面打晕了。</p>
<p>这场战斗让我明白了人海战术的重要性。</p>
<p><del>然后把迷雾的书烧到剩最后一本被泪滴抢了（悲</del></p>
<p>第二次用两层把迷雾削成残血然后 Geburah 一张「血舞弥漫」带走了。还解锁一个成就。</p>
<p>然后去打泪滴。<del>这么说好像最后一击好像也是「血舞弥漫」。</del></p>
<p><del>一本书里面塞了十几张战斗书页，不愧是您。</del></p>
<h2 id="补充-IV"><a href="#补充-IV" class="headerlink" title="补充 IV"></a>补充 IV</h2><p>查了一下自己在 Steam 上的总消费金额，发现竟然有 $956.76。</p>
<p>也就是人民币 6196.11 元。</p>
<p>我看懂了，而且我大受震撼 .jpg</p>
<h2 id="补充-V"><a href="#补充-V" class="headerlink" title="补充 V"></a>补充 V</h2><p>邵好强啊。</p>
<h2 id="补充-VI"><a href="#补充-VI" class="headerlink" title="补充 VI"></a>补充 VI</h2><p>干了一下午六协。</p>
<p>突然注意到我语言层和哲学层还没完全解放，没有 E.G.O. 书页，总体强度不比艺术层大多少。</p>
<p>于是去打异想体。</p>
<p>自然层解放战最终阶段什么乱七八糟一堆玩意，直接上去照脸揍不就行了整的什么花里胡哨的。</p>
<p>语言层解放战让我切实明白了「最强之人」是什么意思。</p>
<p>E.G.O. 展现 + 血雾 + 强壮一共 14+ 的骰子点数加成我就问您怕不怕。反正我是怕了。</p>
<h2 id="补充-VII"><a href="#补充-VII" class="headerlink" title="补充 VII"></a>补充 VII</h2><p>打过邵了。</p>
<p><del>我太牛逼了，哈哈！</del></p>
<p>战术的话，首先用哲学层抽烟耗血<del>，虽然整个哲学层就算全灭了邵还剩 600+ 血</del>。</p>
<p>然后换语言层战神组合刚。</p>
<p>但是并没有什么效果。反而是这边被耗到残血了。</p>
<p>还死了一位助理司书。</p>
<p>然后异想体出尸山了。</p>
<p>我当机立断地把剩下三位助理司书喂给 Geburah，照着邵的逆鳞骰子一刀给她砍晕了。</p>
<p>然后下一幕直接砍死了。</p>
<p><del>我太牛逼了，哈哈！</del></p>
<p>杂质的第一战要求 rnfmabj，泪滴和邵的书。</p>
<p><del>然而我都没有。</del></p>
<p>烧三本烧不出东西于是一咬牙把第四本也给烧了。</p>
<p>当一位废墟图书馆玩家试图从书籍中获取知识时 .jpg</p>
<h2 id="补充-VIII"><a href="#补充-VIII" class="headerlink" title="补充 VIII"></a>补充 VIII</h2><p>刚知道怎么打邵。</p>
<p>原来逆鳞骰子不是一直不能打。</p>
<p>威力有效的回合是可以打的，这样她下一回合就算叠强壮也没有用会被无效化掉。</p>
<p><del>原来如此这就是为什么我这么菜吗。</del></p>
<h2 id="补充-IX"><a href="#补充-IX" class="headerlink" title="补充 IX"></a>补充 IX</h2><p>因为昨天晚上熬夜打 Hana 协会，早上起来已经 11 点了。</p>
<p><del>看了一会儿沙雕视频，</del>总之是到了 12 点。</p>
<p>一开电脑发现有一位不认识的 dalao 评论了我的 Blog。</p>
<p>妈耶现在我的 Blog 真的输出到信息组以外了吗。</p>
<p><del>不对其实可能早就输出出去了。</del></p>
<p>dalao 给捉了一只虫。那么好的已经修复 √</p>
<p>话说回来，虽然写的时候因为想着是随便写可能没怎么用心，</p>
<p>被别人看到的话还是会想「我写的足够好了吗」。</p>
<p><del>要知道那篇可是全程口胡一行代码都没有的。</del></p>
<p>突然反应过来，我搁着 QQ 聊天呢一句话分一段。</p>
<h2 id="补充-X"><a href="#补充-X" class="headerlink" title="补充 X"></a>补充 X</h2><p>一早上<del>（指 13 点）</del>起来发现百橙有新活动了。</p>
<p>是一个新的世界 BOSS。</p>
<p>500W 血的精污游泳圈聚合体（</p>
<p>剧情的话就是兔萌萌拉着由希教自己游泳然后魅樱追上去造了一个巨大怪物给她们打。</p>
<p><del>兔萌萌「您就不会点别的了是吗？」</del></p>
<p>其实还有凯在呢。</p>
<p>不像其他 BOSS，这个 BOSS 不会在地图上乱逛。</p>
<p>但是它生成小怪会扣自己血<del>，说不定真就是从自己身上扯下来的</del>。</p>
<h2 id="补充-XI"><a href="#补充-XI" class="headerlink" title="补充 XI"></a>补充 XI</h2><p>试着打了 Codeforces Round #741 (Div. 2)。</p>
<p>本来想在群里拉几个人开黑的，结果没有拉到人。</p>
<p>用了近 50 分钟才切掉三道题，然后弃疗了。</p>
<p>其实也没完全弃疗，最后 15 min 想出了 D 题的解法的雏形。</p>
<p>虽然其实就差了那么一两步。</p>
<p>但是还是没赶上。</p>
<p>最后一个 FST 都没有。于是取得了三题的好成绩。</p>
<p>排名 1919，最后 Rating 掉了 40。</p>
<p>虽然其实我觉得早就该掉了。毕竟我现在这个 Rating 是开黑开出来的。</p>
<p>Steam 愿望单里有游戏发售了。《熔铁少女》。23 点多给我发了封邮件然而没看到。</p>
<p>明天玩玩。</p>
<p><del>虽然还只是看了几张截图但是阿莉比娜 suki（光速逃</del></p>
<p><del>（↑ 无可救药的 lsp）</del></p>
<h2 id="补充-XII"><a href="#补充-XII" class="headerlink" title="补充 XII"></a>补充 XII</h2><p>话说回来，信息组里面好像军训完了的都有。然后我甚至还在暑假模式。阿稳好像也是。</p>
<blockquote>
<p>zhuoer「我现在已经不会走路了。」</p>
<p>阿陶「开学几天你就会再次学会走路的。」</p>
</blockquote>
<p>害怕（大一新生限定）.jpg</p>
<p>原来如此，VS Code 内部的字数统计把空格标点符号甚至换行符都给算进去了。</p>
<h2 id="补充-XIII"><a href="#补充-XIII" class="headerlink" title="补充 XIII"></a>补充 XIII</h2><p>在 B 站找到了写图书馆 mod 用的 dll 的教程。</p>
<p>然后发现我甚至残响乐团还没打。于是去打。</p>
<p>累到半死才打过菲利普和艾琳。</p>
<p>才发现残响乐团也会掉书页。</p>
<p>不过话说回来，我哲学层和宗教层还没解放……应该没啥问题吧……</p>
<p>至少我不想再把这些 BOSS 打一遍了。</p>
<p>话说回来格蕾塔一上来就在面前摆上三大块肉啊该说果然是主厨吗（</p>
<p>开饭 .jpg</p>
<p>话说回来，司书在图书馆内死去的话应该是会变成书而不会留下尸体的。四舍五入一下就是她在吃书（不是</p>
<p>大肉之书 .jpg</p>
<h2 id="Finn"><a href="#Finn" class="headerlink" title="Finn"></a>Finn</h2><p><del>其实标题是个人名。</del></p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hades</title>
    <url>/hades/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1145360/Hades/">Steam 页面</a></p>
<a id="more"></a>
<p>买了有一段时间的游戏了。</p>
<p>最近因为换了新电脑，捡起来又玩了玩。</p>
<p>然后玩累了放了半个多月，然后又捡起来了。</p>
<p>头铁不开作弊模式。然后前天终于通关了。</p>
<p><img src="/img/20210912175705_1.jpg" alt="结算画面（话说清场是指 clear……？"></p>
<p>关于为什么拿了厄里斯形态又拿人体炸弹，这个是因为升级厄里斯形态的时候我还遇到过人体炸弹。但是人体炸弹太好用了。</p>
<p>有一说一应该是这把大炮太好用了。打 3 BOSS 的时候我直接一边绕著而走一边用特殊攻击打，直接把他俩苟死了。打得那叫一个厚颜无耻，那叫一个卑鄙下流，怕不是观众都得跳下来揍主角一顿。这也配自称英雄吗。</p>
<p>整个游戏的话，给人的第一印象大概会是「文本量好大」吧。每次遇到每个 BOSS，每个友好 NPC 都会有不同的对话，粗略估计一百个小时见不着重样的。（虽然我游戏时间也才二十多个小时）</p>
<p>然后就是，按键频率太高了。键盘大概没法玩吧虽然我也没试过。用手柄玩，连着玩上两三把就能把我右手大拇指快累断了。</p>
<p>不过也可能是我太菜了吧。毕竟我一直是闭着眼睛 ABXY 四个键瞎 jb 按。</p>
<p>操作逐渐失去理性 .jpg</p>
<p>还有就是，这游戏的关键资源竟然每一关每种武器只能拿一次，想拿第二次就必须要加难度。这也太去世了。这游戏真换成近战武器怕不是没法玩。毕竟近身打就意味着会挨打。</p>
<p>听说这游戏可以用来当作第一款 Rogue 游戏来玩。表示怀疑。</p>
<p>不过给永久升级还是很好的。不过凭这游戏的难度不给永久升级怕不是逼人开作弊了。</p>
<p>话又说回来了（指强行扯开话题），最近把 Slay 下回来玩了玩又卸了。之前从创意工坊下了下乱七八糟的 mod 解锁了很多乱七八糟的成就，像是一回合打死 BOSS 啥的。看着这些成就莫名其妙觉得难受于是就卸了。</p>
<p>不过我还是很好奇一回合打死 BOSS 这像是人干得出来的事吗。</p>
<p>弱者为何要战斗 .jpg</p>
<p>不过话说回来，我居然发现 Markdown 里被用单对波浪线包括的内容会以下标的形式显示。~就像这样。~然后我就发现上传上去就不行了，也许是 VS Code 的某种神奇的 feature 吧。</p>
<p><img src="/img/20210912175920_1.jpg" alt="刚刚从地底下爬出来的冥界王子第一次看到太阳（Undertale 既视感"></p>
<p><img src="/img/20210912175957_1.jpg" alt="阳间的希腊风景"></p>
<p>话说回来，竟然连阴间也是要送礼的。这个世界怎么了 .jpg</p>
<p>写了这么久才 800+ 字，10 分钟不到就能读完。为什么凑字数这么难啊。</p>
<p>不过话说回来，我 VS Code 内部的字数统计显示已经 1300+ 了。很神奇 .jpg</p>
<p>话说回来，我这是用了多少遍「话说回来」了啊。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>Rogue</tag>
        <tag>希腊神话背景</tag>
        <tag>剧情丰富</tag>
        <tag>肝</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/cf1582contest-outnotes/</url>
    <content><![CDATA[<p>直角，口胡一下刚刚过去的一场 CF 的题。</p>
<p>其实本来想打的然而没仔细看时间以为还是 22：35 开始结果一看 18：05 就开始了于是没赶上。</p>
<p><a href="http://codeforces.com/contest/1582">传送门</a></p>
<a id="more"></a>
<h2 id="A-Luntik-and-Concerts"><a href="#A-Luntik-and-Concerts" class="headerlink" title="A. Luntik and Concerts"></a>A. Luntik and Concerts</h2><p>给出 $a$ 个 $1$，$b$ 个 $2$ 和 $c$ 个 $3$。把这些数字分配到两个集合 $S_1,S_2$ 里，并最小化 $\left|\sum_{x\in S_1}x-\sum_{x\in S_2}x\right|$。</p>
<p>多组数据。$1\leqslant a,b,c\leqslant 10^9$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>观察样例之后大胆猜想最小值一定是 $0$ 或 $1$。</p>
<p>于是 $a+2b+3c$ 为奇数时答案为 $1$，为偶数时答案为 $0$。</p>
<p>虽然只是个猜想不过看上去很靠谱而且如果是在考场上的话已经可以开始写了。</p>
<p>至于证明，肯定分类讨论几波就出来了就不整了（光速逃</p>
<h2 id="B-Luntik-and-Subsequences"><a href="#B-Luntik-and-Subsequences" class="headerlink" title="B. Luntik and Subsequences"></a>B. Luntik and Subsequences</h2><p>给定一个长度为 $n$ 的序列 $a$。令 $S=\sum_{i=1}^{n}a_i$，求 $a$ 有多少个子序列的和等于 $S-1$。</p>
<p>多组数据。$1\leqslant n\leqslant 60$，$0\leqslant a_i\leqslant 10^9$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>注意到一个满足条件的子序列一定是 $a$ 删掉恰好一个 $1$ 和若干个 $0$ 得到的。</p>
<p>设 $a$ 中有 $c_0$ 个 $0$，$c_1$ 个 $1$，则答案为 $c_1\cdot 2^{c_0}$。</p>
<p><del>所以说为啥数据范围这么小。</del></p>
<h2 id="C-Grandma-Capa-Knits-a-Scarf"><a href="#C-Grandma-Capa-Knits-a-Scarf" class="headerlink" title="C. Grandma Capa Knits a Scarf"></a>C. Grandma Capa Knits a Scarf</h2><p>给定一个长度为 $n$ 的字符串。从中删去若干个同种字符（可以一个不删或全部删去）使得原字符串变成回文串。无解输出 $-1$；否则输出至少需要删去多少个字符。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，字符集小写字母。$\sum n\leqslant 2\times 10^5$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>首先，如果给定字符串最左侧和最右侧的字符相同，我们可以将它们删去，即不考虑它们。重复这个动作直到字符串最左侧和最右侧的字符变得不同（或者字符串变为空串，那么答案就是 $0$）。</p>
<p>假设我们选择删去最左侧的字符，将其记为 $c$。重复上述动作，如果最左侧和最右侧的字符相同，就将它们删去；如果不同，这两个字符中有 $c$ 就将其删去然后计数器 $+1$，没有 $c$ 就无解。直到字符串变为空串或者得出无解结论。</p>
<p><del>不过说实话看上去有点假。</del></p>
<h2 id="D-Vupsen-Pupsen-and-0"><a href="#D-Vupsen-Pupsen-and-0" class="headerlink" title="D. Vupsen, Pupsen and 0"></a>D. Vupsen, Pupsen and 0</h2><p>给定一个长度为 $n$ 的序列 $a$，$a_i\neq 0$。试构造一个同样长度为 $n$ 的序列 $b$，$b_i\neq 0$ 且 $\sum_{i=1}^{n}|b_i|\leqslant 10^9$，使得 $\sum_{i=1}^{n}a_ib_i=0$。</p>
<p>多组数据。$2\leqslant n\leqslant 10^5$，$0\lt|a_i|\leqslant 10^4$。$\sum n\leqslant 2\times 10^5$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>注意到对于任意实数 $x,y$，有 $y\cdot x + (-x)\cdot y = 0$。于是对于 $a_{2k-1},a_{2k}$，我们构造 $b_{2k-1}=a_{2k},b_{2k}=-a_{2k-1}$。</p>
<p>但是这样 $a_n$ 可能会单出来，于是我们就将其和 $a_1$ 再配对一次即可。</p>
<p>注意到此时 $\sum_{i=1}^{n}|b_i|\leqslant\sum_{i=1}^{n}|a_i|+|a_1|$……好像超了。</p>
<p>好家伙管他的直接 xjb 一通乱凑得了。</p>
<h2 id="E-Pchelyonok-and-Segments"><a href="#E-Pchelyonok-and-Segments" class="headerlink" title="E. Pchelyonok and Segments"></a>E. Pchelyonok and Segments</h2><p>给定一个长度为 $n$ 的序列 $a$。构造 $k$ 个区间 $[l_1,r_1],[l_2,r_2],\cdots,[l_k,r_k]$ 满足：</p>
<ol>
<li>$r_i-l_i+1=k-i+1$。</li>
<li>若 $i\lt j$ 则 $r_i\lt l_j$。</li>
<li>若 $i\lt j$ 则 $\sum_{x=l_i}^{r_i}a_x\lt\sum_{x=l_j}^{r_j}a_x$。</li>
</ol>
<p>只需输出 $k$ 的最大值。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，$1\leqslant a_i\leqslant 10^9$。$\sum n\leqslant 10^5$。</p>
<p>$\texttt{2s/512MB}$。</p>
<p>令 <code>f[i][j]</code> 表示在原序列的第 $i$ 个后缀构造 $j$ 个区间时最左侧的区间上 $a_i$ 的和的最大值。</p>
<p>显然靠右的区间上 $a_i$ 的和越大，靠左的区间就会有越多的选择。</p>
<p>注意到 $j$ 一定和 $\sqrt{n-i+1}$ 同级，这使得我们可以 $O(n\sqrt{n})$ 暴力搞。</p>
<p>转移的时候就对于每个 $j$ 维护一下所有 <code>f[i][j]</code> 的最大值就好。</p>
<h2 id="F-and-G"><a href="#F-and-G" class="headerlink" title="F and G"></a>F and G</h2><p>不会（理直气壮</p>
<p>自己去看 CF 的题解吧（光速逃</p>
]]></content>
      <categories>
        <category>口胡</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>杂题</tag>
        <tag>瞪眼</tag>
        <tag>构造</tag>
        <tag>暴力 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>退役选手 Challestend 的 CF 杂题题解</title>
    <url>/random-solutions/</url>
    <content><![CDATA[<p>直角。</p>
<p>值得注意的是，本题解使用的记号可能与原题不同。</p>
<p>有些看题解看出来的思维题就不写代码了。</p>
<a id="more"></a>
<h2 id="「CF558E」A-Simple-Task"><a href="#「CF558E」A-Simple-Task" class="headerlink" title="「CF558E」A Simple Task"></a>「CF558E」A Simple Task</h2><p><a href="http://codeforces.com/contest/558/problem/E">传送门</a></p>
<p>给定一个长度为 $n$ 的仅包括小写英文字母的字符串。$m$ 次操作，每次给出一个区间要求升序或降序排序。输出最终得到的字符串。</p>
<p>$1\leqslant n\leqslant 10^5$，$0\leqslant m\leqslant 50000$。</p>
<p>显然我们可以将排好序的区间缩成一个点，然后维护一下每个点内部每个字母的出现次数和它的排序方式。一开始的时候可以认为是 $n$ 个点，每个点只包含一个字母且升序排序。</p>
<p>每次操作就把区间两边的点拆开，然后把整个操作区间并成一个大点。</p>
<p>时间复杂度 $O((n+m)|\Sigma|\log n)$，这题 $|\Sigma|$ 是常数 $26$ 所以实际上就是 $O((n+m)\log n)$。</p>
<p>然而拆点写不动 :(</p>
<p>写了大半天突然发现没考虑操作区间已经被包含在一整个点内部的情况于是果断放弃了。于是就没有代码实现了。</p>
<h2 id="「CF451E」Devu-and-Flowers"><a href="#「CF451E」Devu-and-Flowers" class="headerlink" title="「CF451E」Devu and Flowers"></a>「CF451E」Devu and Flowers</h2><p><a href="http://codeforces.com/contest/451/problem/E">传送门</a></p>
<p>给出 $n$ 个集合，第 $i$ 个集合有 $a_i$ 个元素。相同集合元素不可区分，不同集合元素可区分。从这里面选出 $m$ 个元素，问方案数，模 $998244353$。</p>
<p>$1\leqslant n\leqslant 20$，$0\leqslant m\leqslant 10^{14}$，$0\leqslant a_i\leqslant 10^{12}$。</p>
<p>首先我们发现 $m$ 和 $a_i$ 的范围都非常非常的大，也就是说 NTT 行不通了。</p>
<p>于是考虑容斥。转化为求</p>
<script type="math/tex; mode=display">
\begin{cases}
&\forall 1\leqslant i\leqslant k,0\leqslant x_i\leqslant a_i\\
&\sum_{i=1}^{n}x_i=m
\end{cases}</script><p>的解 $(x_1,x_2,\cdots,x_n)$ 的数量。</p>
<p>令 $F_k$ 表示恰好有 $k$ 个 $x_i\gt a_i$ 的方案数；$G_k$ 表示钦定 $k$ 个 $x_i\gt a_i$ 其他随意的方案数。那么</p>
<script type="math/tex; mode=display">
G_k=\sum_{1\leqslant i_1\lt i_2\lt\cdots\lt i_k\leqslant n}{m-\sum_{j=1}^{k}a_{i_j}+n-1\choose n-1}</script><script type="math/tex; mode=display">
G_k=\sum_{i=k}^{n}{i\choose k}F_i</script><script type="math/tex; mode=display">
F_k=\sum_{i=k}^{n}(-1)^{i-k}{i\choose k}G_i</script><p>求出 $F_0$ 即可。</p>
<p>关于 $G_k$，注意到右边那个组合数因为 $n$ 很小，算一次只需要 $O(n)$。那么 $O(2^n)$ 暴力枚举左边的子序列就好。总时间复杂度 $O(n2^n)$。</p>
<p>我是绝对不会说我算减法忘了 <code>+mod</code> 结果 WA 了一发的（</p>
<p>当然我更不会说我因为每次求组合数 $O(n\log\text{mod})$ 暴力算阶乘逆元结果 TLE 了一发的（</p>
<p><strong>功 力 尽 失</strong></p>
<p>不会吧为什么 $O(n2^n)$ 和 $O(n2^n\log\text{mod})$ 差得这么多啊。</p>
<p><a href="http://codeforces.com/contest/451/submission/137845078">评测记录</a></p>
<h2 id="「CF1188B」Count-Pairs"><a href="#「CF1188B」Count-Pairs" class="headerlink" title="「CF1188B」Count Pairs"></a>「CF1188B」Count Pairs</h2><p><a href="http://codeforces.com/contest/1188/problem/B">传送门</a></p>
<p>给定一个长度为 $n$ 的序列 $a$ 和常数 $p,k$。保证 $a_i$ 两两不同，且 $p$ 是质数。</p>
<p>求数对 $(u,v)$ 的数量，使得 $1\leqslant u\lt v\leqslant n$ 且 $(a_u+a_v)(a_u^2+a_v^2)\equiv k\pmod{p}$。</p>
<p>$2\leqslant n\leqslant 3\times 10^5$，$2\leqslant p\leqslant 10^9$，$0\leqslant k,a_i\lt p$。</p>
<p><del>太菜了没有思路于是被迫看题解。</del></p>
<p>考虑到 $a_i$ 两两不同，我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
(a_u+a_v)(a_u^2+a_v^2)&\equiv k\pmod{p}\\
(a_u+a_v)(a_u-a_v)(a_u^2+a_v^2)&\equiv (a_u-a_v)k\pmod{p}\\
a_u^4-a_v^4&\equiv (a_u-a_v)k\pmod{p}\\
a_u^4-ka_u&\equiv a_v^4-ka_v\pmod{p}\\
\end{aligned}</script><p><img src="/img/TIM图片20181023195537.jpg" alt=""></p>
<p>emmm 话说回来 $u,v$ 放在下标上是不是看不大清啊。</p>
<p>但是我觉得这种情况下 $u,v$ 两个字母算是最合适的了。所以说就这样吧（光速逃</p>
<p>没有代码实现。</p>
<h2 id="「CF383D」Antimatter"><a href="#「CF383D」Antimatter" class="headerlink" title="「CF383D」Antimatter"></a>「CF383D」Antimatter</h2><p><a href="http://codeforces.com/contest/383/problem/D">传送门</a></p>
<p>给定一个长度为 $n$ 的序列 $a$。每次操作可以选定一个区间 $[l,r]$，将区间内每个数染成红色或者黑色（不可以不染色），如果红数黑数分别求和后结果相等，那么这次操作是合法的。求合法操作数量，模 $10^9+7$。两次操作不同当且仅当选定区间不同或者区间内至少一个数颜色不同。</p>
<p>$1\leqslant n,a_i\leqslant 1000$，$\sum a_i\leqslant 10000$。</p>
<p><del>太菜了没有思路于是被迫看题解。</del></p>
<p>令 $w=\sum_{i=1}^{n}a_i$。</p>
<p>首先我们有一个简单粗暴的背包搞法。令 $f(i,j,S)$ 表示在 $[i,j]$ 内选出若干个数加起来等于 $S$ 的方案数，那么这个显然可以 $O(n^2w)$ 搞出来。那么答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\sum_{j=i}^{n}f\left(i,j,\frac{1}{2}\sum_{k=i}^{j}a_k\right)</script><p>但是这不够，我们需要优化。</p>
<p>考虑分治。设当前分治到 $[L,R]$，令 $m=\left\lfloor\frac{L+R}{2}\right\rfloor$，我们需要处理出左端点在 $[L,m]$ 上且右端点在 $(m,R]$ 上的所有区间的贡献。这里一个区间的贡献指的是一次操作选定这个区间后染色的方案数。</p>
<p>考虑任意选取 $x_1\in[L,m],x_2\in(m,R]$，令 $T_1=\sum_{i=x_1}^{m}a_i,T_2=\sum_{i=m+1}^{x_2}a_i$。设有一种操作，$[x_1,m]$ 上黑色数字之和为 $S_1$，$(m,x_2]$ 上黑色数字之和为 $S_2$。那么这次操作合法当且仅当</p>
<script type="math/tex; mode=display">
S_1+S_2=\frac{T_1+T_2}{2}</script><p>即</p>
<script type="math/tex; mode=display">
(2S_1-T_1)+(2S_2-T_2)=0</script><p>则 $[L,R]$ 上跨中点区间的贡献之和为</p>
<script type="math/tex; mode=display">
\sum_{x_1=L}^{m}\sum_{S_1=0}^{w}\sum_{x_2=m+1}^{R}\sum_{S_2=0}^{w}\left[\left(2S_1-\sum_{i=x_1}^{m}a_i\right)+\left(2S_2-\sum_{i=m+1}^{x_2}a_i\right)=0\right]f(x_1,m,S_1)f(m+1,x_2,S_2)</script><p>虽然这个式子像这样写出来很吓人，但实际上只要稍微发挥一下人类智慧我们就可以将其优化到 $O(w(R-L))$。具体方法读者可自行撕烤。</p>
<p>那么总时间复杂度 $O(nw\log n)$。</p>
<p>本来不想写的不过想了想还是写一下吧。</p>
<p><del>下了体育课就去写。</del></p>
<p><a href="http://codeforces.com/contest/383/submission/137870088">评测记录</a></p>
<h2 id="「CF1451E2」Bitwise-Queries-Hard-Version"><a href="#「CF1451E2」Bitwise-Queries-Hard-Version" class="headerlink" title="「CF1451E2」Bitwise Queries (Hard Version)"></a>「CF1451E2」Bitwise Queries (Hard Version)</h2><p><a href="http://codeforces.com/contest/1451/problem/E2">传送门</a></p>
<p>有一个长度为 $n$ 的序列 $a$，但是您不知道它长什么样。每次您可以指定 $1\leqslant u\lt v\leqslant n$，并得到 $a_u$ 和 $a_v$ 按位与 | 或 | 亦或的结果，这叫做一次查询。您最多只能进行 $n+1$ 次查询，然后您需要给出序列 $a$。</p>
<p>$4\leqslant n\leqslant 2^{16}$ 且 $n$ 是 $2$ 的幂，$0\leqslant a_i\lt n$。</p>
<p>以下，$\wedge$ 表示按位与，$\vee$ 表示按位或，$\oplus$ 表示按位异或。</p>
<p>首先我们需要对于 $i\gt 1$ 查询 $a_1\oplus a_i$，然后我们只需要知道 $a_1$ 的值即可还原出整个序列。</p>
<p>以下设 $t_i=a_1\oplus a_i$。显然 $t_1=0$。</p>
<p>若存在 $u\neq v$ 但是 $t_u=t_v$，这说明 $a_u=a_v$。那么我们查询 $a_u\wedge a_v$ 即可得到 $a_u$ 和 $a_v$，也就得到了 $a_1$。</p>
<p>否则，则 $t_i$ 两两不同，即 $a_i$ 两两不同。找到 $u$ 使得 $t_u=1$，查询 $a_1\wedge a_u$ 即可得到 $a_1$ 的二进制表示中除最低位以外的所有其他位。然后再找到 $v$ 使得 $t_v=2$，查询 $a_1\wedge a_v$ 即可得到 $a_1$ 的二进制表示的最低位。</p>
<p>注意到 $t_i\in[0,n)$ 且 $t_i\neq 0$，可以看出上述 $u,v$ 必定存在且唯一。</p>
<p><a href="http://codeforces.com/contest/1451/submission/137894201">评测记录</a></p>
<h2 id="「CF1613E」Team-Building"><a href="#「CF1613E」Team-Building" class="headerlink" title="「CF1613E」Team Building"></a>「CF1613E」Team Building</h2><p><a href="http://codeforces.com/contest/1316/problem/E">传送门</a></p>
<p>有 $n$ 个人，要从中选出恰好 $p$ 个人参加比赛以及恰好 $k$ 个人围观。第 $i$ 个人如果围观会产生 $a_i$ 的价值。参加比赛的话有 $p$ 个位置，第 $i$ 个人在第 $j$ 个位置上产生 $s_{i,j}$ 的价值。要求最大化价值和。</p>
<p>$2\leqslant n\leqslant 10^5$，$1\leqslant p\leqslant 7$，$1\leqslant k,p+k\leqslant n$，$1\leqslant a_i,s_{i,j}\leqslant 10^9$。</p>
<p>考虑到，如果我们已经确定好了要让哪些人参加比赛，那么剩下的人里面要去围观的一定是 $a_i$ 最大的那 $k$ 个人。</p>
<p>于是我们先将所有人按 $a_i$ 降序排序。令 $f_{i,S}$ 表示在前 $i$ 个人中选出一些人参加比赛并填满集合 $S$ 里的位置，然后其他人围观，这样能够得到的最大价值和。</p>
<p>同理，令 $g_{i,S}$ 表示在前 $i$ 个人中选出一些人参加比赛并填满集合 $S$ 里的位置，然后其他人闲着什么也不干，这样能够得到的最大价值和。</p>
<p>显然 $O(p2^pn)$ 可以处理出来。</p>
<p>然后答案就是 $\max_{i=|S|+k}(f_{i,S}+g_{n-i,U-S})$。其中 $U=\{1,2,\cdots,p\}$。</p>
<p>这题是我在学校的 ACM 实验室写出来的。一个下午一共写了两道题都和状压有关。下一题也是。</p>
<p><a href="http://codeforces.com/contest/1316/submission/137951214">评测记录</a></p>
<h2 id="「CF547C」Mike-and-Foam"><a href="#「CF547C」Mike-and-Foam" class="headerlink" title="「CF547C」Mike and Foam"></a>「CF547C」Mike and Foam</h2><p><a href="http://codeforces.com/contest/547/problem/C">传送门</a></p>
<p>给定一个长度为 $n$ 的序列 $a$。您需要维护一个集合 $S$，初始为空。$m$ 次操作，每次给出一个下标 $x$，如果 $x\notin S$ 就将 $x$ 插入 $S$；否则就从 $S$ 中删除 $x$。每次操作后您需要给出下式的值</p>
<script type="math/tex; mode=display">
\sum_{u,v\in S,u\neq v}[a_u\perp a_v]</script><p>$1\leqslant n,m\leqslant 2\times 10^5$，$1\leqslant a_i\leqslant 5\times 10^5$。</p>
<p>以下令 $w=\max_{i=1}^{n}a_i$。</p>
<p>一开始我是这样想的：对于每个位置 $x$ 建立一个标号为 $x$ 的圆点；对于 $\leqslant w$ 的第 $i$ 个质数建立一个标号为 $i$ 的方点。每插入一个位置 $x$，如果第 $i$ 个质数能够整除 $a_x$，就在标号为 $x$ 的圆点和标号为 $i$ 的方点之间连一条边。</p>
<p>这样，$a_u\perp a_v$ 当且仅当标号为 $u$ 的圆点和标号为 $v$ 的圆点不连通。于是使用并查集维护。</p>
<p>但是这样的话不好删除，于是考虑线段树分治转化成只有插入没有删除。总时间复杂度 $O(m\log m\log(n+w))$。</p>
<p>但！是！……显然这种做法是假的。</p>
<p>考虑 $a=\{2,3,6\}$，我们发现按照上述建图方式我们会得到「这三个数两两不互质」这样的结论。但显然这是错的因为 $a_1\perp a_2$。</p>
<p>于是我们考虑容斥。令 $f_{x,v}$ 表示集合 $S$ 中有多少个下标 $y$ 满足 $(a_x,a_y)\geqslant v$。那么插入 $x$ 时产生的贡献就是</p>
<script type="math/tex; mode=display">
\sum_{v|a_x,v\gt 1,|\mu(v)|=1}(-1)^{\gamma(v)-1}f_{x,v}</script><p>其中 $\mu(v)$ 表示莫比乌斯函数，要求 $|\mu(v)|=1$ 是因为我们只需要关注 $(a_x,a_y)$ 中有多少个不同的质因子，而并不需要知道这些质因子的次数分别是多少。</p>
<p>同时 $\gamma(v)$ 表示 $v$ 有多少个不同的质因子，$(-1)^{\gamma(v)-1}$ 就相当于是容斥系数。当然这个东西也可以用 $\mu(v)$ 来表示不过我觉得这样清晰一些。</p>
<p>然后值得注意的是上式计算的是有多少对 $(a_x,a_y)\gt 1$，最终答案实际上是 ${|S|\choose 2}$ 减去上式。</p>
<p>然后我们还需要维护一个 $c_v$ 表示集合 $S$ 中有多少个下标 $y$ 满足 $v|a_y$。</p>
<p>那么显然计算一次上式所需要的时间复杂度是 $O(2^{\gamma(a_x)})$。注意到</p>
<script type="math/tex; mode=display">
2\times 3\times 5\times 7\times 11\times 13\times 17=510510\gt 5\times 10^5</script><p>这意味着 $\gamma(v)\leqslant 7$。因此总时间复杂度 $O(2^7m)$。</p>
<p>虽然最慢的点跑了 $1871\text{ms}$ 不过还好吧。</p>
<p><a href="http://codeforces.com/contest/547/submission/137964567">评测记录</a></p>
<h2 id="「CF1404C」Fixed-Point-Removal"><a href="#「CF1404C」Fixed-Point-Removal" class="headerlink" title="「CF1404C」Fixed Point Removal"></a>「CF1404C」Fixed Point Removal</h2><p><a href="https://codeforces.com/contest/1404/problem/C">传送门</a></p>
<p>给定一个长度为 $n$ 的序列 $a$。每次可以删除一个满足 $a_i=i$ 的元素 $a_i$，且删除会使得元素的下标发生改变。$m$ 次询问，每次给出 $x,y$，将序列的最左侧 $x$ 个数和最右侧 $y$ 个数修改成 $n+1$，然后问最多进行多少次删除。询问相互独立即，上一次询问时被删除或被修改的元素会在下一次询问前复原。</p>
<p>$1\leqslant n,m\leqslant 3\times 10^5$，$1\leqslant a_i\leqslant n$。</p>
<p><del>被最新的多项式黑科技重工业干烂了继续来刷我的小水题。</del></p>
<p>每次询问相当于给出区间 $[l,r]$，然后只能删除这个区间内的元素。</p>
<p>考虑到对于 $a_i$，删除左侧的元素会使得其下标 $-1$，删除右侧的元素不会改变其下标。也就是说如果 $a_i\gt i$，那么其一定无法被删除。</p>
<p>如果 $a_i\leqslant i$，且能够在 $a_i$ 左侧进行至少 $i-a_i$ 次删除，那么 $a_i$ 一定能够被删除。每次贪心地删除最靠右的能够被删除的元素即可。</p>
<p>对于一次询问，显然其左端点越靠左，能够被删除的元素就会越多，且数量至少不会减少。即对于每个位置 $i$，存在一个 $f_i$，使得当询问区间包括 $i$ 时，若询问区间左端点 $\leqslant f_i$，那么 $a_i$ 能够被删除；否则 $a_i$ 不能被删除。</p>
<p>考虑二分求解 $f_i$。注意到当询问区间包括 $i$ 且左端点恰好为 $L$ 时，$a_i$ 能够被删除当且仅当区间 $[L,i)$ 上存在至少 $i-a_i$ 个 $k$ 满足 $f_k\geqslant L$。这部分可以使用主席树维护。总时间复杂度 $O(n\log^2 n)$。</p>
<p><a href="https://codeforces.com/contest/1404/submission/138055322">评测记录</a></p>
<h2 id="「CF888G」Xor-MST"><a href="#「CF888G」Xor-MST" class="headerlink" title="「CF888G」Xor-MST"></a>「CF888G」Xor-MST</h2><p><a href="https://codeforces.com/contest/888/problem/G">传送门</a></p>
<p>给定一个长度为 $n$ 的序列 $a$。构造一张无向完全图，其中点 $u$ 和点 $v$ 之间连一条边权为 $a_u\oplus a_v$ 的边。求最小生成树边权和。</p>
<p>$1\leqslant n\leqslant 2\times 10^5$，$0\leqslant a_i\lt 2^{30}$。</p>
<p>经典 Boruvka 算法练习题。</p>
<p>简单介绍一下这种 B 开头的最小生成树算法：</p>
<p>每次迭代对于每个点 $u$，找出当前与其不连通的所有点 $v$ 中 $(u,v)$ 边权最小的 $v$，然后连边 $(u,v)$。</p>
<p>这里有一个细节是，每次迭代的时候选出来的 $n$ 条边要按照边权从小到大连，否则可能会出现连了大边结果小边连不上了的情况。</p>
<p>不难看出每次迭代每个点所在的连通块大小至少翻倍，于是总时间复杂度 $O(f(n)\log n)$，其中 $f(n)$ 表示单次迭代的时间复杂度。</p>
<p>对于这道题，每次迭代需要对于每个点找出与其不连通的所有点 $v$ 中 $a_u\oplus a_v$ 最小的 $v$。这可以通过动态开点字典树实现，读者可自行撕烤。</p>
<p>于是 $f(n)=n\log a_i$，总时间复杂度 $(n\log n\log a_i)$。</p>
<p>然后调不出来了就这样吧。</p>
<p><a href="https://codeforces.com/contest/888/submission/138078730">评测记录（虽然是 WA 掉的）</a></p>
<h2 id="「CF1528C」Trees-of-Tranquillity"><a href="#「CF1528C」Trees-of-Tranquillity" class="headerlink" title="「CF1528C」Trees of Tranquillity"></a>「CF1528C」Trees of Tranquillity</h2><p><a href="https://codeforces.com/contest/1528/problem/C">传送门</a></p>
<p>给定两棵 $n$ 个节点的树 $S,T$，均以 $1$ 为根。构造一张无向图 $G$，其中 $u,v$ 两个点之间有边当且仅当它们在 $S$ 中是祖先后代关系且在 $T$ 中不是祖先后代关系。求 $G$ 的最大团大小。</p>
<p>$2\leqslant n\leqslant 3\times 10^5$。多组数据，$\sum n\leqslant 3\times 10^5$。</p>
<p>首先我们把这个题意翻译一下，就是让我们找出一些点且这些点中任意一对点在 $S$ 中是祖先后代关系且在 $T$ 中不是祖先后代关系。</p>
<p>显然这些点在 $S$ 中是从一条深度递增的链上抠下来的，因此考虑对 $S$ 中每一条深度递增且从根到叶子的路径计算贡献。</p>
<p>对于点 $u$，设 $[l_u,r_u]$ 为 $T$ 中 $u$ 的子树的 DFS 序区间，问题转化成在一些区间中选出尽可能多的区间互不相交。</p>
<p>考虑设 $f_k$ 表示当前选出的所有区间右端点最大值恰好为 $k$ 时最多能选出多少个区间；同理，$g_k$ 表示当前选出的所有区间左端点最小值恰好为 $k$ 时最多能选出多少个区间。那么显然如果我们一定要选区间 $[l_u,r_u]$，此时的答案为</p>
<script type="math/tex; mode=display">
1+\max_{i=1}^{l_u-1}f_i+\max_{j=r_u+1}^{n}g_j</script><p>使用线段树即可维护。总时间复杂度 $O(n\log n)$。</p>
<p><del>代码实现先等会爬会山先。</del></p>
<p><del>结果一连拖了好几天。</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>树状数组</tag>
        <tag>平衡树</tag>
        <tag>容斥</tag>
        <tag>交互</tag>
        <tag>杂题</tag>
        <tag>CodeForces</tag>
        <tag>思维</tag>
        <tag>DP</tag>
        <tag>状态压缩 DP</tag>
        <tag>二分答案</tag>
        <tag>最小生成树</tag>
        <tag>Boruvka</tag>
        <tag>树形 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>一道日常题的题解</title>
    <url>/a-daily-problem/</url>
    <content><![CDATA[<p>今天校内某比赛的一道题。</p>
<p>感觉挺有意思的于是来写一篇题解。</p>
<p>题面甚至是纯英文，怕不是防 AK 用的。</p>
<p>其实我是可以 AK 的，不过剩下三道题（其中还有一道大模拟懒得写了）。</p>
<p><del>顺便一提，其实我睡过去了一整个上午，打开比赛页面的时候已经是比赛开始五个小时了（</del></p>
<a id="more"></a>
<p>给定一棵 $n$ 个点的树，边有边权。从 $1$ 号节点开始，每次等概率随机选择一个相邻节点走过去，到了叶节点就停下来。这里叶节点定义为度数为 $1$ 的节点。保证根节点不满足这个定义。</p>
<p>走过一条边需要消耗的时间等于这条边的边权。求期望多长时间后能停下来。答案对 $10^9+7$ 取模。</p>
<p>$1\leqslant n\leqslant 10^5$。边权范围不重要（反正不爆 <code>int</code>）。</p>
<p>设 $E(u)$ 表示从 $u$ 号节点出发的期望停止时间。根据期望的线性性，我们可以得到</p>
<script type="math/tex; mode=display">
E(u)=\frac{1}{\operatorname{deg}u}\sum_{(u,v)}(E(v)+w(u,v))</script><p>如果 $u$ 号节点已经是叶节点，那么 $E(u)=0$。</p>
<p>当然，这在形式上完全可以视作一个 $n-r$ 个变量和 $n-r$ 个方程构成的线性方程组，其中 $r$ 表示叶节点的数量。</p>
<p>但是考虑到本题的数据范围，这样做的时间复杂度太大了。我们需要换一个思路。</p>
<p>首先我们梳理一下思路（非形式化地）：</p>
<blockquote>
<p>考虑到，如果节点 $u$ 的所有子节点都是叶节点，那么 $E(u)$ 只会取决于 $E(f(u))$；而且一定是 $E(f(u))$ 的一次函数。</p>
<p>如果节点 $u$ 存在一个不是叶节点的节点 $v$，但是 $v$ 的所有子节点都是叶节点，那么 $E(v)$ 也是 $E(u)$ 的一次函数，我们就可以在 $E(u)$ 的式子中出现的 $E(v)$ 替换成 $E(u)$。这样整个式子中的待求量还是只会剩下 $E(u)$ 和 $E(f(u))$，也就是说 $E(u)$ 可以表示成 $E(f(u))$ 的一次函数。</p>
<p>如此递推到 $1$ 号节点，那么实际上我们需要求解的只有一个关于 $E(1)$ 的一次方程。</p>
</blockquote>
<p>形式化地：</p>
<p>如果一个节点 $u$ 满足</p>
<script type="math/tex; mode=display">
E(u)=\alpha(u)E(f(u))+\beta(u)</script><p>其中 $f(u)$ 表示 $u$ 的父节点，且 $\alpha(u),\beta(u)$ 只与 $u$ 有关而与其他节点无关，那么我们称 $u$ 是可表示的。</p>
<p>显然叶节点都是可表示的。</p>
<p>如果一个节点 $u$ 的所有子节点均是可表示的，那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
&E(u)\\
=&\frac{1}{\operatorname{deg}u}\sum_{(u,v)}(E(v)+w(u,v))\\
=&\frac{E(f(u))+w(u,f(u))}{\operatorname{deg}u}+\frac{1}{\operatorname{deg}u}\sum_{(u,v)\wedge v\neq f(u)}(E(v)+w(u,v))\\
=&\frac{E(f(u))+w(u,f(u))}{\operatorname{deg}u}+\frac{1}{\operatorname{deg}u}\sum_{(u,v)\wedge v\neq f(u)}(\alpha(v)E(u)+\beta(v)+w(u,v))
\end{aligned}</script><p>整理可得</p>
<script type="math/tex; mode=display">
\left(1-\frac{1}{\operatorname{deg}u}\sum_{(u,v)\wedge v\neq f(u)}\alpha(v)\right)E(u)=\frac{E(f(u))+w(u,f(u))}{\operatorname{deg}u}+\frac{1}{\operatorname{deg}u}\sum_{(u,v)\wedge v\neq f(u)}(\beta(v)+w(u,v))</script><p>即 $u$ 是可表示的。</p>
<p>于是我们可以容易地注意到，所有节点均是可表示的，且 $\alpha,\beta$ 均是可求解的。</p>
<p>考虑 $1$ 号节点，有</p>
<script type="math/tex; mode=display">
E(1)=\alpha(1)E(f(1))+\beta(1)</script><p>这里 $f(1)=0$，即 $E(f(1))=0$，我们就可以得到</p>
<script type="math/tex; mode=display">
E(1)=\beta(1)</script><p>而 $E(1)$ 正是本题要求的答案。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>随机游走</tag>
        <tag>图论</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title>退役选手 Challestend 的 CF 杂题题解 II</title>
    <url>/random-solutions-2/</url>
    <content><![CDATA[<p>直角。</p>
<p>因为觉得把所有东西都堆在一篇 Blog 太挤了，于是考虑每十题一篇（</p>
<a id="more"></a>
<h2 id="「CF1408F」Two-Different"><a href="#「CF1408F」Two-Different" class="headerlink" title="「CF1408F」Two Different"></a>「CF1408F」Two Different</h2><p><a href="https://codeforces.com/contest/1408/problem/F">传送门</a></p>
<p>想象有一个长度为 $n$ 的正整数序列 $a$ 和函数 $f:\mathbb{N_+}\times\mathbb{N_+}\rightarrow\mathbb{N_+}$。每次操作指定两个位置 $u,v$，然后将当前的 $a_u$ 和 $a_v$ 同时替换为 $f(a_u,a_v)$。您需要给出方案，使得对于任意的序列 $a$ 和函数 $f$，$q$ 次操作后整个序列最多只剩下两个不同的正整数。</p>
<p>比如说 $n=3$，一种可能的最终序列是</p>
<script type="math/tex; mode=display">
\{f(a_1,a_2),f(a_1,a_2),a_3\}</script><p>$n=4$</p>
<script type="math/tex; mode=display">
\{f(a_1,a_2),f(a_1,a_2),f(a_3,a_4),f(a_3,a_4)\}</script><p>$n=5$</p>
<script type="math/tex; mode=display">
\{A,A,A,A,a_5\}</script><p>其中 $A=f(f(a_1,a_2),f(a_3,a_4))$。</p>
<p>$1\leqslant n\leqslant 15000$，$0\leqslant q\leqslant 5\times 10^5$。</p>
<p>注意到我们可以在 $2^k$ 次操作内将一个长度恰好为 $2^k$ 的子区间处理成一个数字。</p>
<p>然后我就卡在这里了。因为 $n$ 的二进制表示也许会有 $3$ 个或者更多的 $1$。于是我就在想怎么将 $4$ 个相同的数字和另外 $2$ 个相同的数字合并成六个相同的数字。</p>
<p>然后想不出来去看题解发现大可不必。直接取 $k=\lfloor\log n\rfloor$ 然后将序列的前 $2^k$ 和后 $2^k$ 个数字合并即可。显然这样处理之后整个序列最多只剩下两个不同的正整数。</p>
<p>于是代码实现就没有了。</p>
<h2 id="「CF543D」Road-Improvement"><a href="#「CF543D」Road-Improvement" class="headerlink" title="「CF543D」Road Improvement"></a>「CF543D」Road Improvement</h2><p><a href="https://codeforces.com/contest/543/problem/D">传送门</a></p>
<p>给定一棵 $n$ 个节点的无根树。对于每个节点 $u$，您需要求出，至少需要标记树上的多少条边，才能使得对于树上除 $u$ 以外任意节点 $v$，路径 $u\rightarrow v$ 上最多存在一条边未被标记。</p>
<p>$2\leqslant n\leqslant 2\times 10^5$。</p>
<p>我觉得大力树上 DP 就好了。</p>
<p>代码实现下辈子再说。</p>
<h2 id="「CF1139D」Steps-to-One"><a href="#「CF1139D」Steps-to-One" class="headerlink" title="「CF1139D」Steps to One"></a>「CF1139D」Steps to One</h2><p>/* 闲扯开始</p>
<p>本来是想按顺序刷的然而看到这道题于是光速跑过来开搞。</p>
<p>记得高中的时候我刚把位置搬到阿潮旁边的那个晚上大吊阿烜就在写这道题。</p>
<p>……欸不对？哦好像的确是不对。那个晚上阿烜写的是一道虚树题。</p>
<p>算了不管了。</p>
<p>闲扯结束 */</p>
<p><a href="https://codeforces.com/contest/1139/problem/D">传送门</a></p>
<p>有一个序列 $a$，初始为空。每次操作等概率随机选择一个 $[1,m]$ 上的整数并将其插入至 $a$ 的末尾。每次操作后计算 $a$ 中所有元素的 $\gcd$，若为 $1$ 则结束，否则再进行下一次操作。求最终 $a$ 的长度的数学期望值。模 $10^9+7$。</p>
<p>$1\leqslant m\leqslant 10^5$。</p>
<p>考虑令 $f(N,M)$ 表示 $a$ 的长度恰好为 $N$ 时其中所有元素的 $\gcd$ 恰好为 $M$ 的概率。那么显然</p>
<script type="math/tex; mode=display">
\begin{aligned}
&f(N,M)\\
=&\frac{1}{m^N}\sum_{1\leqslant i_1,i_2,\cdots,i_N\leqslant m}[(i_1,i_2,\cdots,i_N)=M]\\
=&\frac{1}{m^N}\sum_{1\leqslant i_1,i_2,\cdots,i_N\leqslant\lfloor\frac{m}{M}\rfloor}[(i_1,i_2,\cdots,i_N)=1]\\
=&\frac{1}{m^N}\sum_{1\leqslant i_1,i_2,\cdots,i_N\leqslant\lfloor\frac{m}{M}\rfloor}\sum_{x|i_k}\mu(x)\\
=&\frac{1}{m^N}\sum_{x=1}^{\lfloor\frac{m}{M}\rfloor}\mu(x)\left\lfloor\frac{m}{Mx}\right\rfloor^N
\end{aligned}</script><p>考虑枚举 $a$ 的长度。设第 $N+1$ 次操作后 $a$ 中所有元素的 $\gcd$ 恰好为 $1$，那么发生这种情况的概率是</p>
<script type="math/tex; mode=display">
\frac{1}{m}\sum_{M=2}^{m}f(N,M)\phi(M)</script><p>其中</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\phi(M)\\
=&\sum_{i=1}^{m}[i\perp M]\\
=&\sum_{i=1}^{m}\sum_{x|i,x|M}\mu(x)\\
=&\sum_{x|M}\mu(x)\left\lfloor\frac{m}{x}\right\rfloor
\end{aligned}</script><p>值得注意的是需要特判一开始就随机到 $1$ 的情况。</p>
<p>然后对 $N$ 求和，我们得到答案为</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\frac{1}{m}+\frac{1}{m}\sum_{N\geqslant 1}(N+1)\sum_{M=2}^{m}f(N,M)\phi(M)\\
=&\frac{1}{m}+\frac{1}{m}\sum_{N\geqslant 1}(N+1)\sum_{M=2}^{m}\phi(M)\sum_{x=1}^{\lfloor\frac{m}{M}\rfloor}\mu(x)\left(\frac{\left\lfloor\frac{m}{Mx}\right\rfloor}{m}\right)^N\\
=&\frac{1}{m}+\frac{1}{m}\sum_{M=2}^{m}\phi(M)\sum_{x=1}^{\lfloor\frac{m}{M}\rfloor}\mu(x)\sum_{N\geqslant 1}(N+1)\left(\frac{\left\lfloor\frac{m}{Mx}\right\rfloor}{m}\right)^N
\end{aligned}</script><p>我们遇到这样一个子问题</p>
<script type="math/tex; mode=display">
\sum_{n\geqslant 1}(n+1)\alpha^n</script><p>当然这里保证 $|\alpha|\lt 1$。</p>
<p>设其为 $S(\alpha)$，则</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\alpha^{-1}S(\alpha)\\
=&\sum_{n\geqslant 0}(n+2)\alpha^n\\
=&\sum_{n\geqslant 0}(n+1)\alpha^n+\sum_{n\geqslant 0}\alpha^n\\
=&1+S(\alpha)+\frac{1}{1-\alpha}
\end{aligned}</script><p>可以解得</p>
<script type="math/tex; mode=display">
S(\alpha)=\sum_{n\geqslant 1}(n+1)\alpha^n=\frac{\alpha(2-\alpha)}{(1-\alpha)^2}</script><p>那么答案就可以记作</p>
<script type="math/tex; mode=display">
\frac{1}{m}+\frac{1}{m}\sum_{M=2}^{m}\phi(M)\sum_{x=1}^{\lfloor\frac{m}{M}\rfloor}\mu(x)S\left(\frac{\left\lfloor\frac{m}{Mx}\right\rfloor}{m}\right)</script><p>第一个 $\sum$ 可以 $O(\sqrt{m})$ 枚举，第二个 $\sum$ 直接 $O(m)$ 暴力算。这样时间复杂度 $O(m\sqrt{m})$ 十分健康可以通过。</p>
<p>其实感觉这个东西可以用 NTT 做到 $O(m\log\text{mod}+m\log m)$，但是反正根号可以过就不用专门动用多项式板子了。</p>
<p><del>好吧其实是因为我已经不会多项式了。</del></p>
<p><a href="https://codeforces.com/contest/1139/submission/139412953">评测记录</a></p>
<h2 id="「CF1167F」Scalar-Queries"><a href="#「CF1167F」Scalar-Queries" class="headerlink" title="「CF1167F」Scalar Queries"></a>「CF1167F」Scalar Queries</h2><p>// 口胡一时爽，实现火葬场（光速逃</p>
<p><a href="https://codeforces.com/contest/1167/problem/F">传送门</a></p>
<p>给定一个长度为 $n$ 的序列 $a$，保证 $a_i$ 两两不同。如下定义 $f(l,r)$：</p>
<p>将 $a_l,a_{l+1},\cdots,a_r$ 取出并从小到大排序。设结果为 $b_1,b_2,\cdots,b_{r-l+1}$。那么</p>
<script type="math/tex; mode=display">
f(l,r)=\sum_{i=1}^{r-l+1}i\cdot b_i</script><p>求</p>
<script type="math/tex; mode=display">
\sum_{1\leqslant l\leqslant r\leqslant n}f(l,r)</script><p>模 $10^9+7$。</p>
<p>$1\leqslant n\leqslant 5\times 10^5$，$1\leqslant a_i\leqslant 10^9$。</p>
<p>考虑将 $a_i$ 从小到大排序，然后分别计算每个 $a_x$ 的贡献。</p>
<p>设对于当前的 $a_x$，设其左侧有 $N$ 个位置的值小于它，从右到左分别为 $l_1,l_2,\cdots,l_N$；类似地，设其右侧有 $M$ 个位置的值小于它，从左到右分别为 $r_1,r_2,\cdots,r_M$。</p>
<p>考虑到，只要选定区间包括 $x$，答案中就会有一个 $a_x$。这部分的贡献为 $x(n-x+1)a_x$。</p>
<p>如果选定区间包括 $l_i$，答案中就会又有一个 $a_x$。注意这里是只考虑 $l_i$ 这一个位置。这部分的贡献为 $l_i(n-x+1)a_x$。</p>
<p>类似地，$r_i$ 对应部分的贡献为 $x(n-r_i+1)a_x$。</p>
<p>求和，我们得到</p>
<script type="math/tex; mode=display">
\left[x(n-x+1)+(n-x+1)\sum_{i=1}^{N}l_i+x\sum_{i=1}^{M}(n-r_i+1)\right]a_x</script><p>使用线段树简单维护即可。总时间复杂度 $(n\log n)$。</p>
<p>代码实现下辈子再说。</p>
<h2 id="「CF1204E」Natasha-Sasha-and-the-Prefix-Sums"><a href="#「CF1204E」Natasha-Sasha-and-the-Prefix-Sums" class="headerlink" title="「CF1204E」Natasha, Sasha and the Prefix Sums"></a>「CF1204E」Natasha, Sasha and the Prefix Sums</h2><p><a href="https://codeforces.com/contest/1204/problem/E">传送门</a></p>
<p>构造一个长度为 $n+m$ 的恰好包含 $n$ 个 $1$ 和 $m$ 个 $-1$ 的序列 $a$，然后定义其价值为其 $n+m+1$ 个前缀和（包括空前缀）中的最大值。对所有可能的序列 $a$，计算价值和。对 $998244853$ 取模。</p>
<p>$0\leqslant n,m\leqslant 2000$。</p>
<p><strong>Warning：$998244{\color{red} 8}53$。</strong></p>
<p><strong>Warning：$998244{\color{red} 8}53$。</strong></p>
<p><strong>Warning：$998244{\color{red} 8}53$。</strong></p>
<p>可以类比一下卡特兰数的求法。</p>
<p>令 $F_k$ 表示最大前缀和 $\leqslant k$ 的方案数。那么考虑一个不符合该条件的序列 $a$，记其前缀和为 $s$。取最小的 $i$ 使得 $s_i\gt k$，那么此时有 $s_i=k+1$，即前 $i$ 个元素中 $1$ 比 $-1$ 多恰好 $k+1$ 个。将 $a_1,a_2,\cdots,a_i$ 取相反数我们就得到了一个恰好包含 $n-k-1$ 个 $1$ 和 $m+k+1$ 个 $-1$ 的新序列 $a^\prime$。</p>
<p>相反地，假设我们现在有一个恰好包含 $n-k-1$ 个 $1$ 和 $m+k+1$ 个 $-1$ 的序列 $a^\prime$，记其前缀和为 $s^\prime$。取最小的 $i$ 使得 $s^\prime_i=-k-1$。将 $a^\prime_1,a^\prime_2,\cdots,a^\prime_i$ 取相反数我们就还原出了 $a$。</p>
<p>也就是说上述的 $a$ 和 $a^\prime$ 之间存在一一映射。注意到 $a^\prime$ 一共有 ${n+m\choose n-k-1}$，我们就得到 $F_k={n+m\choose n}-{n+m\choose n-k-1}$。</p>
<p>特别地，$F_n={n+m\choose n}$。</p>
<p>然后令 $G_k=F_k-F_{k-1}$，计算</p>
<script type="math/tex; mode=display">
\sum_{i=\max(n-m,0)}^{n}i\cdot G_i</script><p>即为答案。</p>
<p>$m=0$ 时需要特判直接输出 $n$。</p>
<p><del>结果我 WA 了三发。</del></p>
<p><del>第一发没特判第二发没注意求和下限第三发忘了删调试信息。</del></p>
<p><a href="https://codeforces.com/contest/1204/submission/139360069">评测记录</a></p>
<p>话说回来，这数据范围还是太小了啊。建议加大力度开到 $10^7$（光速逃</p>
<h2 id="「CF1594E2」Rubik’s-Cube-Coloring-hard-version"><a href="#「CF1594E2」Rubik’s-Cube-Coloring-hard-version" class="headerlink" title="「CF1594E2」Rubik’s Cube Coloring (hard version)"></a>「CF1594E2」Rubik’s Cube Coloring (hard version)</h2><p><a href="https://codeforces.com/contest/1594/problem/E2">传送门</a></p>
<p>给定一棵深度为 $k$，即包含 $2^k-1$ 个节点的完美二叉树。有六种颜色：白，黄，绿，蓝，红，橙。每个节点需要染一种颜色，而且：</p>
<ol>
<li>相邻节点不能同色。</li>
<li>相邻节点不能一白一黄。</li>
<li>相邻节点不能一绿一蓝。</li>
<li>相邻节点不能一红一橙。</li>
</ol>
<p>有 $n$ 个节点已经染好色了。问给剩下的节点染色的方案数。模 $10^9+7$。</p>
<p>$1\leqslant k\leqslant 60$，$1\leqslant n\leqslant 2000$。</p>
<p>首先考虑两个子问题。</p>
<p>子问题一：如果有一个深度为 $d$ 的子树，其根节点已经确定了颜色，除此之外没有已经确定颜色的节点。那么该子树的染色方案有多少种？</p>
<p>显然为 $4^{2^d-2}$。</p>
<p>子问题二：有一条从深度递增的链，两端点的深度分别为 $L,R$。且这条链上其他节点（不包括两端点）及其子树均没有已经确定颜色的节点。那么这条链的染色方案有多少种？不考虑两端点的子树。</p>
<p>显然这可以通过一个 $O(k^2)$ 的 DP 解决。</p>
<p>于是我们对给定的 $n$ 个节点建立虚树，然后在上面跑 DP 即可。</p>
<p>至于建立虚树时需要求 dfs 序，我们可以利用完美二叉树的性质在 $O(k)$ 的时间复杂度内求出任意节点的 dfs 序。具体方法读者可自行撕烤。</p>
<p>注意到上面的 DP 并没有考虑到两端点的子树。考虑到一个节点在虚树上当且仅当它是给定点或它是两个给定点的 LCA，只有第一种情况时，该节点可能存在未被考虑的子树，手动计算然后加上即可。</p>
<p>还有就是虚树中的叶子节点在原树中的子树也需要手动计算。</p>
<p>总时间复杂度 $O(nk+n\log n)$，后面那个 $\log$ 是排序的。</p>
<p>然而不怎么好写于是就不写了（</p>
<p>建议加大力度把 $n$ 开到 $10^6$（光速逃</p>
<h2 id="「CF1619H」Permutation-and-Queries"><a href="#「CF1619H」Permutation-and-Queries" class="headerlink" title="「CF1619H」Permutation and Queries"></a>「CF1619H」Permutation and Queries</h2><p><a href="http://codeforces.com/contest/1619/problem/H">传送门</a></p>
<p>给定一个长度为 $n$ 的排列 $p$。$m$ 次操作，每次要么交换 $p_x$ 和 $p_y$，要么给定给定 $x$ 求执行 $x\leftarrow p_x$ 连续 $k$ 次后 $x$ 的最终结果。</p>
<p>$1\leqslant n,m\leqslant 10^5$，$1\leqslant k\leqslant n$。</p>
<p><del>因为太菜不会做于是被迫去看题解。</del></p>
<p>好吧其实只是一个先猜出复杂度然后再根据复杂度想搞法的题。</p>
<p>一开始一直在想启发式合并启发式分裂，然后线段树分治搞成只有接环或者是只有断环。总而言之就是困在 poly-log 的怪圈里绕不出去了。然后这道题正解是大根号。</p>
<p>令 $B=\sqrt{n}$。处理出 $p$ 的逆排列 $r$，以及另外一个序列 $f$ 表示每个位置沿着 $p$ 指针跳 $B$ 次到达的位置。预处理需要 $O(\sqrt{n})$ 的时间复杂度。</p>
<p>每次修改的时候，假设 $p_x$ 被修改了，那么有且仅有 $x$ 沿着 $r$ 指针跳 $B$ 次以内经过的位置，也就是 $x$ 沿着 $p$ 指针反着跳 $B$ 次以内经过的位置，这些位置的 $f$ 需要修改。也就是说单次修改的时间复杂度这样就是 $O(B)$。</p>
<p>查询的话，显然可以设 $k=l\sqrt{n}+d$，然后跳 $l$ 次 $f$ 再跳 $d$ 次 $p$ 即可。单次查询时间复杂度 $O(\frac{n}{B}+B)$。</p>
<p>综上所述，总时间复杂度 $O(n\sqrt{n}+m\sqrt{n})$。</p>
<p><a href="http://codeforces.com/contest/1619/submission/140273166">评测记录</a></p>
<p>// 什么时候才能变得想杜爷一样强啊 /se</p>
<h2 id="「CF1626D」Martial-Arts-Tournament"><a href="#「CF1626D」Martial-Arts-Tournament" class="headerlink" title="「CF1626D」Martial Arts Tournament"></a>「CF1626D」Martial Arts Tournament</h2><p>// 火星艺术主题旅游（光速逃</p>
<p>// 好吧其实 <code>martial</code> 的意思是「军事的」然后 <code>tournament</code> 的意思是「锦标赛」</p>
<p><a href="http://codeforces.com/contest/1626/problem/D">传送门</a></p>
<p>给定 $n$ 个数 $a_1,a_2,\cdots,a_n$。您需要指定两个数 $x,y$，然后所有小于 $x$ 的数构成集合 $S_1$，所有大于等于 $x$ 且小于 $y$ 的数构成集合 $S_2$，所有大于等于 $y$ 的数构成集合 $S_3$。然后您需要在这三个集合中插入尽可能少的元素，使得三个集合的大小均变为 $2$ 的自然数幂。</p>
<p>您需要找到一组 $x,y$，使得最终需要插入的元素数最少。您只需给出这个插入元素数的最小值。</p>
<p>多组数据。$1\leqslant n\leqslant 2\times 10^5$，$1\leqslant a_i\leqslant n$。$\sum n\leqslant 2\times 10^5$。</p>
<p>记 $c_k$ 表示有多少个数恰好为 $k$。相当于是说把数组 $c$ 分成三个连续段，记这三个连续段的和分别为 $s_1,s_2,s_3$，那么答案就是 $f(s_1)+f(s_2)+f(s_3)$，其中 $f(N)$ 表示大于等于 $N$ 的最小的 $2$ 的自然数幂。</p>
<p>根据题意每个连续段均不能为空，不过因为不需要给出具体方案，所以这个条件可以无视，因为就算最终找到的方案某一段为空，也一定会存在某个三段均不为空的方案，使得这两种方案得出的答案相同。</p>
<p>证明不会。反正是对的。</p>
<p>考虑枚举最右侧连续段的长度，然后枚举最左侧连续段的贡献——也就是说枚举一个 $2$ 的自然数幂 $p$ 然后找到一个尽可能靠右的前缀使得这个前缀的贡献为 $p$，然后要求尽可能靠右是因为这样可以最小化中间连续段的贡献。</p>
<p>两个枚举的时间复杂度分别是 $O(n)$ 和 $O(\log n)$，再加上二分的一个 $\log$，总时间复杂度 $O(n\log^2n)$。</p>
<p>写到这里我突然意识到，如果直接分别枚举两侧连续段的贡献，那么实际上可以做到 $O(\log^4n)$，差不多相当于是线性的。</p>
<p>不过算了。</p>
<p><a href="http://codeforces.com/contest/1626/submission/143167048">评测记录</a></p>
<h2 id="「CF893F」Subtree-Minimum-Query"><a href="#「CF893F」Subtree-Minimum-Query" class="headerlink" title="「CF893F」Subtree Minimum Query"></a>「CF893F」Subtree Minimum Query</h2><p><a href="http://codeforces.com/contest/893/problem/F">传送门</a></p>
<p>给定一棵 $n$ 个节点的树，以 $r$ 为根，点有点权。$m$ 次操作，每次给定 $u,k$，查询在 $u$ 的子树内且到 $u$ 的距离不超过 $k$ 的所有点中点权的最小值。强制在线。</p>
<p>$1\leqslant n\leqslant 10^5$，$1\leqslant a_i\leqslant 10^9$，$1\leqslant m\leqslant 10^6$。</p>
<p>不知道这道题正解是什么，不过我感觉我的做法非常的奇怪。</p>
<p>首先定义 $f_{u,k}$ 表示在 $u$ 的子树内且到 $u$ 的距离严格小于 $2^k$ 的所有点中点权的最小值，然后将这个东西预处理出来——至于怎么预处理就发挥人类智慧吧只能说我的方法感觉已经乱了。</p>
<p>然后将询问给出的 $k$ 分解成若干个 $2$ 的正整数次幂，这里令</p>
<script type="math/tex; mode=display">
k=\sum_{i=1}^{L}2^{x_i}</script><p>其中 $x_i$ 两两不同。那么我们首先对于在 $u$ 的子树内且到 $u$ 的距离恰好为 $1$ 的每一个点 $v$，计算 $f_{v,x_1}$ 的最小值；然后再对于距离恰好为 $1+2^{x_1}$ 的每一个点 $v$，计算 $f_{v,x_2}$ 的最小值；依此类推。然后将上述 $L$ 个值与 $u$ 自身的点权取最小值即为答案。</p>
<p>关于「距离恰好为某个数」这个限制条件，我们可以考虑对原树求一个类似于 BFS 序的东西，就是说，进行一次 BFS，然后对于每个点，定义其 BFS 为其是第几个入队的。</p>
<p>我们刚刚定义的这个 BFS 有一个十分容易注意到的性质：原树中深度相同的节点一定会组成一个连续段。而且能够想象得出来的是，如果我们在进行 BFS 和 DFS 时，对于每个点，访问它的出边的顺序相同，那么对于 BFS 序序列中的一个深度相同的连续段，这些点的 DFS 序一定也是递增的。</p>
<p>这就意味着我们能够通过二分查找来找到，在这样一个连续段上，哪个区间恰好属于某个点的子树。然后套用数据结构在 BFS 序上维护区间最小值即可。</p>
<p>单次查询的时间复杂度是 $O(\log^2n)$。至于总时间复杂度，虽然还会有一个预处理但是考虑到这道题 $m$ 相对于 $n$ 范围较大，因此总时间复杂度可以认为就是 $O(m\log^2n)$。</p>
<p>然而……调不出来了 :(</p>
<p><a href="http://codeforces.com/contest/893/submission/145316368">这条评测记录</a> 是我的最后一次提交，它十分英勇地杀到了 test 42，然后在那里折戟而亡。让我们记住它的故事 (???)。</p>
<h2 id="「CF1691F」K-Set-Tree"><a href="#「CF1691F」K-Set-Tree" class="headerlink" title="「CF1691F」K-Set Tree"></a>「CF1691F」K-Set Tree</h2><p><a href="https://codeforces.com/contest/1691/problem/F">传送门</a></p>
<p>给定一棵 $n$ 个节点的树和正整数 $k$。</p>
<p>定义 $f(r,S)$ 表示以 $r$ 为根时，包含 $S$ 中所有节点的 $T$ 的最小<strong>有根子树</strong>的大小。</p>
<p><strong>有根子树</strong>：若 $u$ 属于该有根子树，则 $u$ 的所有子节点也都属于该有根子树。</p>
<p>试求</p>
<script type="math/tex; mode=display">
\sum_{r\in V}\sum_{S\subseteq V,|S|=k}f(r,S)</script><p>对 $10^9+7$ 取模。</p>
<p>$3\leqslant n\leqslant 2\times 10^5$，$1\leqslant k\leqslant n$。</p>
<p>令 $1$ 号节点为根节点。</p>
<p>首先考虑 $r=1$ 时的情况，此时这个最小有根子树的大小实际上就是 $\mathrm{size}(\mathrm{lca}(S))$。对于每个点 $u$，$\mathrm{size}(\mathrm{lca}(S))=u$ 的方案数为</p>
<script type="math/tex; mode=display">
{\mathrm{size}(u)\choose k}-\sum_{v\in\mathrm{son}(u)}{\mathrm{size}(v)\choose k}</script><p>于是</p>
<script type="math/tex; mode=display">
\sum_{S\subseteq V,|S|=k}f(1,S)=\sum_{u\in V}\left[{\mathrm{size}(u)\choose k}-\sum_{v\in\mathrm{son}(u)}{\mathrm{size}(v)\choose k}\right]\mathrm{size}(u)</script><p>考虑某种类似树上 DP 的换根。现在我们需要将根节点从 $f(r)$ 转移到 $r$，会有如下几种情况：</p>
<ol>
<li>$S$ 完全位于 $r$ 的子树内。</li>
<li>$S$ 完全位于 $r$ 的子树外。</li>
<li>不是上述两种情况。</li>
</ol>
<p>情况 1：转移后，$r$ 的子树大小从原来的 $\mathrm{size}(r)$ 变成了 $n$。另一方面，$\mathrm{lca}(S)=r$ 的方案数为</p>
<script type="math/tex; mode=display">
{\mathrm{size}(r)\choose k}-\sum_{v\in\mathrm{son}(r)}{\mathrm{size}(v)\choose k}</script><p>从而这部分的贡献为</p>
<script type="math/tex; mode=display">
\left[{\mathrm{size}(r)\choose k}-\sum_{v\in\mathrm{son}(r)}{\mathrm{size}(v)\choose k}\right](n-\mathrm{size}(r))</script><p>情况 2：转移后，$f(r)$ 的子树大小从原来的 $n$ 变成了 $n-\mathrm{size}(r)$。另一方面，$\mathrm{lca}(S)=f(r)$ 的方案数为</p>
<script type="math/tex; mode=display">
{n-\mathrm{size}(r)\choose k}-{n-\mathrm{size}(f(r))\choose k}-\sum_{v\in\mathrm{son}(f(r)),v\neq r}{\mathrm{size}(v)\choose k}</script><p>从而这部分的贡献为</p>
<script type="math/tex; mode=display">
\left[{n-\mathrm{size}(r)\choose k}-{n-\mathrm{size}(f(r))\choose k}-\sum_{v\in\mathrm{son}(f(r)),v\neq r}{\mathrm{size}(v)\choose k}\right](-\mathrm{size}(r))</script><p>情况 3：转移前，$\mathrm{lca}(S)=f(r)$，此时 $f(r)$ 的子树大小为 $n$；转移后，$\mathrm{lca}(S)=r$，此时 $r$ 的子树大小同样为 $n$。即这种情况实际上对答案没有贡献。</p>
<p>时间复杂度 $O(n)$。</p>
<p><a href="https://codeforces.com/contest/1691/submission/159252429">评测记录</a></p>
<p>// 好久没写题已经不会调代码力（悲</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>线段树</tag>
        <tag>虚树</tag>
        <tag>杂题</tag>
        <tag>构造</tag>
        <tag>CodeForces</tag>
        <tag>思维</tag>
        <tag>DP</tag>
        <tag>二分答案</tag>
        <tag>树形 DP</tag>
        <tag>莫比乌斯反演</tag>
        <tag>卡特兰数</tag>
        <tag>根号算法</tag>
        <tag>DFS 序</tag>
        <tag>BFS 序</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 1</title>
    <url>/random-solution-pb-1/</url>
    <content><![CDATA[<p>前几天《2022 年安徽省机器人大赛本科组》的 K 题，也就是最后一题。</p>
<p>虽然听说都是原题，不过我懒得去找了。</p>
<a id="more"></a>
<p>给定一张 $n$ 个节点 $2n-3$ 条边的无向图，保证这些边形成了一个正 $n$ 边形的三角剖分。求这张图的一个最小点覆盖。</p>
<p>$n\leqslant 10^5$。</p>
<p><img src="/img/202206151614.png" alt="样例"></p>
<p>对于上面这个样例来说，答案为 $\{1,3,5,7\}$。</p>
<p>考虑多边形内部的某一个三角形，不难发现这三个节点中，至多有一个不在点覆盖内。</p>
<p>如果确定了某一个节点不在点覆盖内，那么与该节点相邻的所有三角形，它们的其它节点则必须在点覆盖内。</p>
<p>考虑对于每个三角形建立一个方点。</p>
<p><img src="/img/202206151615.png" alt="差不多像这样"></p>
<p>如果两个三角形公用一条边，就在两个对应的方点间连一条边。</p>
<p><img src="/img/202206151616.png" alt="差不多像这样"></p>
<p>考虑一下这张新图。如果其中出现环，说明多个三角形共用了一个节点，而且这个节点必须要严格在多边形内部才可以。因此新图不存在环。</p>
<p>同时显而易见地，新图是联通的。因此新图是一棵树。</p>
<p>那么下一步，考虑与某个节点相邻的所有三角形，这些三角形对应的方点一定形成了新图中的一条简单路径。</p>
<p>于是问题转化成，给定一棵树和若干条简单路径，选择尽可能多的路径（对应原图中选择尽可能多的点不在点覆盖内），使得这些被选择的路径互不相交（对应点覆盖的性质）。</p>
<p>这应该是一道树上 DP，但是我调不出来了 :(</p>
<p>读者可自行尝试（光速逃</p>
]]></content>
      <categories>
        <category>口胡</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>ヤマふだ！　にごうめ</title>
    <url>/yamafuda/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1727520?snr=5000_5100___primarylinks">Steam 页面</a></p>
<p>听说最近杀戮尖塔更新了，而且是大更新。</p>
<p>把之前有一个 mod 角色加进来了，忘了名字不过记得是一个如果有一张牌正好在手牌正中央的话，打出去会有加成的角色。有一说一之前玩的时候就觉得这个角色综合质量极高，说成是官方角色都不奇怪。</p>
<p>而且似乎还吸收了 DownFall 的内容，不过没怎么玩过所以不评价。</p>
<p>扯得有点远，总之就是一个轻松愉快的爬山 (?) 游戏。</p>
<p>你这爬山怎么一边爬一边打牌啊（小声</p>
<p>想起来有句话：你这打架怎么掷骰子啊（</p>
<p>刚打完第三关，可能对游戏还理解不深（光速逃</p>
<a id="more"></a>
<p>以下说明以日语描述为准。</p>
<p>这游戏日语文本基本上没几个汉字全是平假名，子供向游戏确认。</p>
<p><img src="/img/20220405214444_1.jpg" alt="为什么没有光敏性癫痫（错乱"></p>
<p><img src="/img/20220405213329_1.jpg" alt="标题画面"></p>
<p><img src="/img/20220405214544_1.jpg" alt="战斗画面（截自第三关）"></p>
<p>「あと ２２ｍ」是说这座山的当前区段还剩 22m。也可以理解成怪的血条还剩 22 点。</p>
<p>怪的左边有一个直角三角形和数字 6，表示当前区段的当前小区段的危险度是 6。可以理解成怪的下一次行动打出 6 点伤害。</p>
<p>画面最下端就是手牌，有些牌上面会带着「のぼる」「まもる」，分别代表这张牌向上攀登的距离和对自身的防护。也可以理解成打出多少伤害和获得多少格挡。</p>
<p>如果带着这两个关键字就说明这张牌是一张攀登牌，一回合只能打出一张攀登牌，且打出之后会直接与怪进行攻击判定，然后结束回合。</p>
<p>攻击判定时，因为怪不会防御，玩家角色侧的伤害是打满的。玩家角色的格挡自然就是减免伤害。</p>
<p>左上角的红心是血条。蓝色石头相当于分数，每打出一点伤害就获得一颗小石头，相当于一点分数。也可以消耗以换取被动道具。</p>
<p>当然游戏中还会有亿些其他的机制，读者可自行探索。</p>
<p><img src="/img/20220405211141_1.jpg" alt="牌库中的一张卡牌"></p>
<p>感觉这游戏有一点就是，保留字太多了。就比如说上面这张截图中就出现了「こうしん」「おちつき」「わくわく」「やまぶみ」「きらきら」「のびのび」「てつなぎ」「おもいだす」「いちごうぶん」这样九个保留字。</p>
<p>哦等等，「てつなぎ」的描述里引用了「もういっぽ」，这样一来就是十个了。</p>
<p>可能本意是为了让卡面上写出来的东西尽可能的少，毕竟这游戏的整体风格也不适合往卡面上塞一大堆文字性的描述。</p>
<p>不过缺点就是记不住这些保留字都是啥效果（</p>
<p>好吧可能玩多了就记住了（</p>
<p>不过还是总结了以下上述十个关键字的意思，不打算自己玩游戏或者想看看的话可以点开看看（</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">こうしん：每打出 1 次，所有同名卡牌获得 +1/+1（指伤害 / 格挡 +1）。使用非同名卡牌时清零。</span><br><span class="line">おちつき X：下一回合格挡加成 +X（X 表示层数）。</span><br><span class="line">わくわく X：整场战斗伤害加成 +X。</span><br><span class="line">やまぶみ：打出伤害时获得分数 ×2.</span><br><span class="line">きらきら X：斩杀（可参考杀戮尖塔的定义）时最大生命 +X。</span><br><span class="line">のびのび X：每 1 个回合不打出，获得 +X/+X，不影响同名卡牌。打出后复原。</span><br><span class="line">てつなぎ X：伤害加成以 X 倍计算。</span><br><span class="line">おもいだす：从弃牌堆中拿取一张牌放回手牌。</span><br><span class="line">いちごうぶん：每场战斗只能打出一次，打出后不会进入弃牌堆。</span><br><span class="line">もういっぽ X：当前回合伤害加成 +X。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>Rogue</tag>
        <tag>卡牌游戏</tag>
        <tag>爬山</tag>
      </tags>
  </entry>
  <entry>
    <title>そう死して尚も咲く人間劇場だ</title>
    <url>/university-second/</url>
    <content><![CDATA[<p><strong>已完结。</strong></p>
<p>新学期开始了（绝望</p>
<p><a href="https://www.bilibili.com/video/BV1K3411i7Gy">日常推歌时间</a></p>
<p><del>不定期推歌（指正</del></p>
<p>由于我之前给块块看上学期的日记的时候……</p>
<blockquote>
<p>阿块「游戏记录是不是有点多。」</p>
</blockquote>
<p>于是笔者再次郑重声明，本文章是我在大学阶段的游戏记录，并且会插入一些大学生活和 ACM 的记录（光速逃</p>
<a id="more"></a>
<h2 id="Day-（寒假期间）"><a href="#Day-（寒假期间）" class="headerlink" title="Day ???（寒假期间）"></a>Day ???（寒假期间）</h2><p>寒假那当然是愉快的颓废时间。</p>
<p>复习是不可能复习的，这辈子都不可能的。</p>
<p>好吧其实还是看了一点。</p>
<p>然后某一天突然发现同宿舍 dalao FYF 打开了脑叶公司（其实 Steam 也只加了他一个好友），于是会动不动跑去凑热闹看他打游戏。</p>
<p>虽然实际上观看体验完全没有因为画质糊的就像每天都是情报部核心抑制一样而且非常的卡。于是到后面就看不下去了。</p>
<p>这位 dalao 因为及时找到了交流群而不是像我一样闷着头玩于是避开了不少坑而且很快集齐了不少强力装备。</p>
<p>以下是一些交流片段。</p>
<blockquote>
<p>我「你觉得安保部部长是男是女。」</p>
<p>FYF「没注意。没怎么看剧情。」</p>
<p>（第二天，趁他刚结束前一天的管理正在看安保部剧情）</p>
<p>我「你觉得安保部部长是男是女。」</p>
<p>FYF「女的吧。」</p>
<p>我「他是男的。」</p>
<p>FYF「啊？？？」</p>
</blockquote>
<p>男美女（确信</p>
<blockquote>
<p>FYF「这些英文名我啥都记不住。」</p>
<p>我「没事多看就能记住了。」</p>
<p>FYF「我突然发现我分不清控制部部长和培训部部长了。」</p>
<p>我「可海星。我一开始玩废墟图书馆的时候也分不清。」</p>
<p>（我是通关了图书馆再去玩脑叶的）</p>
<p>FYF「拿本子的是哪一个？」</p>
<p>我「拿本子的是控制部部长 Malkuth。」</p>
<p>FYF「哦哦，毒贩子。」</p>
<p>我「啊这。毒贩子是培训部部长 Hod。」</p>
</blockquote>
<p>趁着打折买了以撒的结合，虽然只买了本体。</p>
<p>然后打完三次妈心才知道 DLC 也需要买，于是被迫原价（</p>
<p>只能说从重生到忏悔的这个难度差距实在是太大了。</p>
<p>修复了新手玩家也能在困难模式乱杀的 BUG（确信</p>
<p>不得不说这游戏不整个图鉴啥的是真的没法玩（</p>
<h2 id="Day-0「开幕」（2022-2-16）"><a href="#Day-0「开幕」（2022-2-16）" class="headerlink" title="Day 0「开幕」（2022-2-16）"></a>Day 0「开幕」（2022-2-16）</h2><p>今天返校。</p>
<p>反正总而言之就是平静的一天。</p>
<h2 id="Day-1「分裂」"><a href="#Day-1「分裂」" class="headerlink" title="Day 1「分裂」"></a>Day 1「分裂」</h2><p>感受到了窒息胎的难度。</p>
<p>只能说那波紫黑色的穿屏弹幕实在是一点看不懂（</p>
<p>然后第二次打死窒息胎之后受到了精神错乱的盛情邀请。</p>
<p>只能说这种扭来扭曲的开花弹是真的难处理（</p>
<p>而且还动不动变身，变个妈腿直接照着我头上就是一 jo。</p>
<p>好吧其实也可能是大部分血量都已经被窒息胎耗掉了。</p>
<p>下午辅导员来查寝，被告知除了我们寝室以外所有人都在努力复习。</p>
<p>于是为了避免导致挂科的结局我和寝室其他三位 dalao 开始试图复习高数。</p>
<p>虽然没看一会就放下了（光速逃</p>
<p>晚上尝试了以撒的困难难度。</p>
<p>只能说道具拿的好是真的能为所欲为。</p>
<ol>
<li>3 美元纸币（随机眼泪特效）</li>
<li>铅笔（每发射 15 颗眼泪向前抛射大量眼泪）</li>
<li>天使棱镜（环绕角色，使触碰到其的眼泪分裂成四颗）</li>
<li>光明之冠（未受伤时发射钻石眼泪）</li>
<li>圣饼（所有伤害降至半颗心）</li>
<li>柯吉猫的身体（眼泪命中时分裂成四颗较小的）</li>
<li>多维宝宝（模仿角色路径，使触碰到其的眼泪分裂成两颗）</li>
</ol>
<p>打完？？？之后一个虚空传送门恰到好处地生成在了金宝箱的下面。</p>
<p>于是我冲进去把精神错乱揍了一顿（</p>
<p>到最后按住射击我甚至啥也看不清（</p>
<h2 id="Day-2「潜力」"><a href="#Day-2「潜力」" class="headerlink" title="Day 2「潜力」"></a>Day 2「潜力」</h2><p>尝试用拉撒路通关困难模式以解锁伯大尼。</p>
<p>达到妈心的时候身上就带着五颗红心还挂着黑暗诅咒。</p>
<p>然后我突然不知道为什么走位能力大幅度上升只挨了两下就过了。</p>
<p>人在危急关头会爆发出潜力，这句话果然不假（</p>
<p>然后玩了两把伯大尼发现玩不懂。</p>
<p>然后试图使用莉莉丝击败窒息胎（这样就是第三次了）。</p>
<p>结果这次到窒息胎门口身上只堆了两个跟班而且其中一只还是开局自带的淫魔，而且并没有拿到 BFF。</p>
<p>结果我和上一把一样莫名其妙走位能力大幅度上升剩两颗红心过了。</p>
<p>然后下到阴间被乱杀。</p>
<p>似乎打过羔羊会解锁传送门和石头胖子，然而我现在连底片甚至都还没有解锁（</p>
<h2 id="Day-3「起承」"><a href="#Day-3「起承」" class="headerlink" title="Day 3「起承」"></a>Day 3「起承」</h2><p>上午迎来了上一学期拖欠的高数期末考试。</p>
<p>结果一道计算题喜提算的不知道是个什么东西，一道证明题喜提一点不会（</p>
<p>下午是 C 语言的期末考试。</p>
<p>结果喜提坐牢一个小时以上。</p>
<p>不过说实话在纸上写代码确实是有点离谱。</p>
<h2 id="Day-4「转」"><a href="#Day-4「转」" class="headerlink" title="Day 4「转」"></a>Day 4「转」</h2><p>上午是英语期末考试。</p>
<p>笑死，什么都不会。</p>
<p>听力啥也听不懂，阅读 xjb 蒙，词汇一个词不认识，翻译平均每句话 1-2 个词见都没见过，作文写得狗屁不通。</p>
<p>老师，菜菜，捞捞，呜呜 .jpg</p>
<h2 id="Day-5「合」"><a href="#Day-5「合」" class="headerlink" title="Day 5「合」"></a>Day 5「合」</h2><p>上午是计算机的期末考试。</p>
<p>笑死，什么都……好吧其实会一点（</p>
<h2 id="Day-6「萍果与科学素养」（2022-2-22）"><a href="#Day-6「萍果与科学素养」（2022-2-22）" class="headerlink" title="Day 6「萍果与科学素养」（2022-2-22）"></a>Day 6「萍果与科学素养」（2022-2-22）</h2><p>上午喜提新学期第一节高数课。</p>
<p><del>喂，前面可是地狱啊（确信</del></p>
<p>下午喜提第一节离散数学。</p>
<blockquote>
<p>老师「假设你现在要去买一些 ping 果……等会 ping 果怎么写的。」</p>
</blockquote>
<p>然后老师转身在黑板上写下了「萍果」。</p>
<p>奇怪的苹果增加了 .jpg</p>
<blockquote>
<p>老师「（为了讲述符号化的重要性）……假设 A 买了 2 个『萍果』 3 个橘子花了 15 元，然后 B 买了 3 个『萍果』 4 个橘子花了 20 元，那么『萍果』和橘子一个各多少钱……」</p>
</blockquote>
<p>不要钱的苹果增加了 .jpg</p>
<p>说起水果我不禁想起我以前上高中学长给我们讲算法的时候。</p>
<blockquote>
<p>学长「……那么好吧假设我们现在这里有一些玉米树……啊什么你说玉米不长在树上？啊这线段都能长在树上了为啥玉米它就不能了呢？」</p>
</blockquote>
<p>下午三四节物理老师试图通过问我们一些十万个为什么来检测一下我们有没有科学素养。</p>
<blockquote>
<p>「1 皮秒是多少秒？」</p>
<p>「1 太赫兹是多少赫兹？」</p>
<p>「晴天的时候天空为什么是蓝色的？」</p>
</blockquote>
<p>我没有科学素养 .jpg</p>
<h2 id="Day-7「想要乱杀的愿望」"><a href="#Day-7「想要乱杀的愿望」" class="headerlink" title="Day 7「想要乱杀的愿望」"></a>Day 7「想要乱杀的愿望」</h2><p>本来下学期的课都是排满的一整天十节课甚至八节课。</p>
<p>但是周三却神奇地一节课都没有，于是快乐颓废。</p>
<p>解锁了堕化莉莉丝。</p>
<p>第六层的时候本来拿到了一个回形针想扔到 BOSS 房的结果一不小心忘了。</p>
<p>于是在拿便条之前把它扔到了第七层的 BOSS 房。还好变钥匙碎片了（</p>
<p>听说堕化莉莉丝胎拳道乱杀，试了一下发现也就前几层可以（</p>
<p>到最后惨死以撒三阶段（</p>
<p><del>好吧也许是我攻击力没叠够。</del></p>
<h2 id="Day-8「脸接子弹」"><a href="#Day-8「脸接子弹」" class="headerlink" title="Day 8「脸接子弹」"></a>Day 8「脸接子弹」</h2><p>sto 胎拳道天上第一（</p>
<p>感受到了什么叫做乱杀。攻击力叠上去之后冲进人堆打一拳直接死一半，再打一拳死四分之三。</p>
<p>欸为什么不是全死了（</p>
<p>感觉这种东西玩多了我的耐心正在以肉眼可见的速度衰减。现在我已经玩不下去其他的角色了，然后看到怪也懒得走位直接冲上去脸接子弹。</p>
<p>于是疯狂掉血导致开不开天使房拿不到钥匙碎片（</p>
<p>好不容易凑齐一次两个钥匙碎片结果被超级撒旦一阶段（召唤的小怪）乱杀。</p>
<p>第二次凑齐钥匙碎片结果教堂玩具箱连续两层诅咒看不见血条。</p>
<p>不过还好过了。之后一个虚空传送门恰到好处地生成在了金宝箱的下面。</p>
<p>进去一看发现身上带着三颗红心。</p>
<p>然后被精神错乱丝血反杀（</p>
<p>然后我本来想再开一把打精神错乱然后突然转念一想去打回溯先吧。</p>
<p>然后就去打了。</p>
<p>拿到了某个受伤后当前房间内获得圣饼效果的星座道具，说实话要是没这个东西我说不定就要被四名天启骑士乱杀了。</p>
<p>究极瘟疫究极战争至今不会躲（</p>
<p>跟这几位一比祸兽菜的，也就血厚点外加压迫感强点。</p>
<p>（↑ 因为用堕化莉莉丝而移速不够于是被激光糊脸的人）</p>
<p>不过拖屏速度有点快的说实话。</p>
<h2 id="Day-9「？？？」"><a href="#Day-9「？？？」" class="headerlink" title="Day 9「？？？」"></a>Day 9「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-10「？？？」"><a href="#Day-10「？？？」" class="headerlink" title="Day 10「？？？」"></a>Day 10「？？？」</h2><p>平静的一天。</p>
<p><del>其实是忘了写了。</del></p>
<h2 id="Day-11「下落无敌的狐狸」"><a href="#Day-11「下落无敌的狐狸」" class="headerlink" title="Day 11「下落无敌的狐狸」"></a>Day 11「下落无敌的狐狸」</h2><p>平静的一天。</p>
<h2 id="Day-12「颓废」（2022-2-28）"><a href="#Day-12「颓废」（2022-2-28）" class="headerlink" title="Day 12「颓废」（2022-2-28）"></a>Day 12「颓废」（2022-2-28）</h2><p>平静的一天。</p>
<h2 id="Day-13「觉醒-」"><a href="#Day-13「觉醒-」" class="headerlink" title="Day 13「觉醒 (?)」"></a>Day 13「觉醒 (?)」</h2><p>在连续颓废了几天之后，我再次认识到了再这样下去是不行的。</p>
<p>于是从明天（其实还是有点拖延）本日记将会再次变为稍微正常一点的大学生活记录并（尽量）减少游戏记录。</p>
<p>以上。</p>
<p>最近在跟着同寝室 dalao 安利的 Unity 教程试着做 Roguelike 游戏。</p>
<p>然后我现在已经能够生成随机地图了。</p>
<p>当然因为我最近一直在玩以撒，所以说搞出来的这个地图，或者说我正准备做的这款游戏也基本上可以说是和以撒一个模子刻出来的。</p>
<p>没有创意 .jpg</p>
<p>以上。</p>
<h2 id="Day-14「假期」"><a href="#Day-14「假期」" class="headerlink" title="Day 14「假期」"></a>Day 14「假期」</h2><p>从某种意义上也是吧毕竟没课（</p>
<p>啊什么？做游戏？太难了不做了。</p>
<h2 id="Day-15「我靠我游戏闪退了」"><a href="#Day-15「我靠我游戏闪退了」" class="headerlink" title="Day 15「我靠我游戏闪退了」"></a>Day 15「我靠我游戏闪退了」</h2><p>晚上正准备去吃晚饭的时候看到同寝室 dalao FYF 正在玩脑叶于是跑上去凑热闹。</p>
<p>然后拖到 18：40 才去吃完饭。结果就是吃完已经 52 了。</p>
<p>晚上有一节 C 语言然后我们俩现在甚至还不知道教室在哪。</p>
<p>然后我们就问同寝室的另外两位大佬，他们说是在 T02 教室，然后 T02 教室在 T01 教室的里面。</p>
<p>结果我们在外面绕了一大圈却没有找到 T02 教室。</p>
<p>就是说，教室门前的编号非常神奇地从 T01 跳到了 T03。</p>
<p>灵异教室 .jpg</p>
<p>于是我们当机立断地决定不上课了回宿舍打游戏。</p>
<p>那位 dalao 成功地突破了记录部核心抑制战并来到了 Day 46，虽然研发部核心抑制战还没打。</p>
<p>于是我就在旁边指点，帮助他一次就无伤突破了 Day 46。</p>
<p>然后到了 Day 47。</p>
<blockquote>
<p>我「Day 47，简单来讲就是，上层四核心同时抑制。」</p>
<p>FYF「卧槽这么 EX？」</p>
</blockquote>
<p>然后因为那位 dalao 地游戏设备不是很好然后快打完的时候突然来了一波闪退。</p>
<p>心肺停止 .jpg</p>
<p>注 1(?)：到最后那两位成功地找到了教室的 dalao 回来告诉我们说去 T02 需要先进去 T01，然后 T01 最里面有一扇门是 T02 的。</p>
<p>注 2(?)：奇怪的教室分布增加了 .jpg</p>
<p>注 3(?)：不过因为教室不够大人太多坐不下于是我们喜提被 T02 除名然后下节课要去 T01 了。</p>
<p>注 4(?)：心情简单 .jpg</p>
<h2 id="Day-16「？？？」"><a href="#Day-16「？？？」" class="headerlink" title="Day 16「？？？」"></a>Day 16「？？？」</h2><p>管他的（</p>
<h2 id="Day-17「体测重测与睡大觉」"><a href="#Day-17「体测重测与睡大觉」" class="headerlink" title="Day 17「体测重测与睡大觉」"></a>Day 17「体测重测与睡大觉」</h2><p>早上 8：20 有体测的重测和补测。</p>
<p>笑死，再测一遍也过不了 .jpg</p>
<p>晚上是这一学期的第二节 C 语言，虽然对于我和另外某一位 dalao 来说可能是第一节。</p>
<p>然后老师似乎是接着上节课讲单向链表，然后让我们用链表写一个学生成绩管理系统。</p>
<p>那位 dalao 成功地在下课的瞬间写完了 95% 以上的代码。</p>
<p>然后这个时候我写完了于是老师来看我的程序，然后看到了旁边那位 dalao。</p>
<blockquote>
<p>老师「还差多少啊。」</p>
<p>dalao「我就差这一行了。」</p>
<p>老师「你确定你写完这一行之后你的这个程序能跑起来吗？」</p>
<p>dalao「大概吧。」</p>
</blockquote>
<p>然后 dalao 写完一点运行，<code>20+ error(s), 20+ warning(s)</code>。</p>
<p>然后我就提前跑回寝室了。</p>
<p>结果最后是，那位 dalao 回到宿舍之后继续发奋图强并（在我的帮助之下）成功地当天完成了作业。</p>
<blockquote>
<p>dalao「我的作业……完成啦！哈哈哈哈哈！」</p>
</blockquote>
<h2 id="Day-18「古典音乐」"><a href="#Day-18「古典音乐」" class="headerlink" title="Day 18「古典音乐」"></a>Day 18「古典音乐」</h2><p>在同寝室 dalao 的安利之下（其实是看着他玩然后也想玩）开始玩《冰与火之舞》。</p>
<p>然后了解到了我的节奏感到底有多么的差 :(</p>
<p>Plum 是什么 dalao 啊写的曲子真好听（</p>
<p>在创意工坊找到了一个六星的 Terrasphere，再一次了解到了我的节奏感到底有多么的差 :(</p>
<p>搜了一下发现这个俗称大雪花的东西还有一个八星的版本，看了一眼只能说，我看不懂，但我大受震撼。</p>
<p>Turkish March 警告 .jpg</p>
<h2 id="Day-19「游戏玩法变化了！」（2022-3-7）"><a href="#Day-19「游戏玩法变化了！」（2022-3-7）" class="headerlink" title="Day 19「游戏玩法变化了！」（2022-3-7）"></a>Day 19「游戏玩法变化了！」（2022-3-7）</h2><p>最近音乐打太多甚至我以撒都不会玩了（</p>
<p>找到一张谱子《Commando Steve》，然后打完我的感受总结一下就是：</p>
<p>游戏玩法变化了！（指唐突下落式音游）</p>
<p>深夜试图通关《僕たちの旅とエピローグ》，然而并没有成功。</p>
<p>只能说，我现在的想法就是，非常想顺着网线把谱师（们）揪过来问问他（们）这些个阴间变速都是跟谁学的。</p>
<p>感想的话，一句话，「这他妈是啥」。</p>
<h2 id="Day-20「假如给我三天光敏性癫痫」"><a href="#Day-20「假如给我三天光敏性癫痫」" class="headerlink" title="Day 20「假如给我三天光敏性癫痫」"></a>Day 20「假如给我三天光敏性癫痫」</h2><p>——那在这三天里我可能玩不了音游了。</p>
<p>在创意工坊里面翻到了一张又一张奇怪的阴间谱子。</p>
<p>点名批评某《RUSH E》，只能说，就算是像弹钢琴那样十指并用我觉得都不行。</p>
<blockquote>
<p>这他妈是啥？ ——某图书馆语言科学层指定司书</p>
</blockquote>
<h2 id="Day-21「假如给我三天会做物理题」"><a href="#Day-21「假如给我三天会做物理题」" class="headerlink" title="Day 21「假如给我三天会做物理题」"></a>Day 21「假如给我三天会做物理题」</h2><p>——那我也写不来物理作业。</p>
<p>总而言之就是，物理作业好难，算不出来，自闭了。</p>
<p>I closed myself.（小声</p>
<h2 id="Day-22「人是有惰性的」"><a href="#Day-22「人是有惰性的」" class="headerlink" title="Day 22「人是有惰性的」"></a>Day 22「人是有惰性的」</h2><p>今天喜提早八，于是同寝室的某位不方便透露姓名的 dalao 就不想起床了于是让我们拿上他的卡去教室帮他打卡。</p>
<blockquote>
<p>dalao「我电子电路的作业还没写完呢今天下午就要收了我得补作业啊。」</p>
</blockquote>
<p>然后我们当然都是拒绝了（</p>
<p>然后上完一整个上午的课一回到寝室发现那位 dalao 已经点了外卖开始吃午饭了。</p>
<p>一问作业补了吗说没补。</p>
<p>意料之外，情理之中 .jpg</p>
<p>买了一块新的机械键盘，至少声音听起来比我之前那块好听不少。</p>
<p><del>虽然跟我去 CCPC 的时候摸到的大三学长的那块还稍微有点差距不过星吧。</del></p>
<p>总而言之就是现在我可以用机械键盘打音游了然后这样我就不会说按下去一个键还完全感觉不到我有没有按下去了虽然这可能并没有什么大用毕竟凭我乱七八糟的节奏感肯定按着按着拍子就乱了不过总而言之就是好耶！</p>
<p>下午喜提体测，然后要测 1500m。</p>
<p>但是我并跑不下来于是我就去问老师能不能不跑了然后老师让我跑不下来也要走完全程。</p>
<p>然后我走（确信）了 1200m 左右吧老师可能等不及了直接给我一个 7：30 写上去了。</p>
<p>我没有体质 .jpg</p>
<p>下午三四节电子电路当然是一句话都不听。</p>
<p>然而讲的网孔电流法和节点电压法似乎十分重要而且有些难以理解（悲</p>
<p>要挂科力（绝望</p>
<p>晚上老师让我们用 C++ 的 EasyX 库编写游戏（大作业）。</p>
<p>然后我选择的题材是迷宫，坐在旁边的另一位 dalao 选择的是黑白棋（没玩过也没听说过）。</p>
<p>晚上回寝室才发现用新键盘打游戏还非常地不适应（悲</p>
<p><a href="https://www.bilibili.com/video/BV1o44y1H7wh">今天的推歌时间</a></p>
<p>哦我的上帝 Plum 是什么神仙啊纯音乐 vocal 都会写的。</p>
<p>记得之前——至少得是很久以前了是在我还在听术曲的那个时候——奶油糖曾经整过一首所谓的自创语言的术曲。不过虽然实际上那个只是用日语唱出来然后处理一下音频。</p>
<p>可能是为了表现出，歌词一个字都听不懂，只是单纯地被旋律吸引的那种感觉？</p>
<p>但是上面我推的这首是真的我一个字都听不懂。</p>
<p>因为不会韩语（理直气壮</p>
<h2 id="Day-23「黑白棋」"><a href="#Day-23「黑白棋」" class="headerlink" title="Day 23「黑白棋」"></a>Day 23「黑白棋」</h2><p>晚上上完离散数学一回来同寝室 dalao 就开始编写自己的黑白棋游戏。</p>
<p>然后他成功地用 350+ 行代码写出来了一个最基本的逻辑框架。</p>
<p>然后他邀请我们和他玩，然后我因为没有玩过然后被 dalao 吊锤（悲</p>
<h2 id="Day-24「？？？」"><a href="#Day-24「？？？」" class="headerlink" title="Day 24「？？？」"></a>Day 24「？？？」</h2><p>真的真的忘了写了 qaq</p>
<h2 id="Day-25「请你编程，消灭所有的圣斗士」"><a href="#Day-25「请你编程，消灭所有的圣斗士」" class="headerlink" title="Day 25「请你编程，消灭所有的圣斗士」"></a>Day 25「请你编程，消灭所有的圣斗士」</h2><p>上午三四节是两节职业生涯规划。</p>
<p>那当然是光明正大地划水写高数作业一个字都不听（</p>
<p>好吧其实还是听了一点的（</p>
<p>然后前几天似乎有人让我跑去体育馆签个字，8:30 到 10：30 的时候，因为乐跑没过还是啥的。</p>
<p>然后我当然是忘了（</p>
<p>下午在新校区有一场 ACM 比赛。</p>
<p>同寝室有一位 dalao 报了名但是觉得去了也是一道题不会于是就临阵脱逃了。</p>
<p>然后整个寝室只剩下我一个人去了。</p>
<blockquote>
<p>我「我一个人去的话没信心找到路啊」</p>
<p>FYF「群里不是有拼车的吗，你跟他们一起拼不就行了。」</p>
<p>我「都不认识啊。」</p>
</blockquote>
<p>当然最后我还是下定决心自己打车去了新校区。</p>
<p>新校区规模是真的大（梅开二度</p>
<p>然后我自己打车到了南门，然后找不到实验楼南楼，于是向 WWJ 学长求助，然后学长热心地给予了我帮助。</p>
<p>sto WWJ orz</p>
<p>到考场开题。ABEG 没有什么问题，加起来 1h 之内搞定了。</p>
<p>然后剩下 3h 基本都在坐牢。感觉好像有点思路但是就是不会做。</p>
<p>以及就是不得不批评一下题面，题意表述不清（指升序降序都不说），遣词造句随意，定义不严谨（指 C 题说如果矩阵大小不够需要在「周围」补 $0$ 但是「周围」没有严格定义）。</p>
<p>考场上有一位老哥甚至直接骂出声了，「不会出题就不要出题」。</p>
<p>总而言之就是，到最后 C 题打了不需要补 $0$ 的 $60$ 分暴力分，然后总分 $460$。</p>
<p>剩下的 CDFH 每道题甚至不超过四个人切掉（</p>
<p>只能说低估了题目难度了。本来是做着随手 AK 的打算去的结果当头一棒。</p>
<p>还有就是，居然不给发草稿纸。</p>
<p>不过嘛，毕竟都让自带纸质资料了草稿纸应该也可以被解释称一种广义的纸质资料吧也就是说是那种需要自带的。</p>
<p>虽然可能就算有了草稿纸我也拿不了更多的分了。</p>
<p>只能说自己太菜吧，DP 啥都不会的那种。把一个长度为 $n$ 的序列分成恰好 $m$ 段，并最小化每段的平方和。这个应该是一个经典题目了，考场上看出这个模型结果 D 不出来于是寄了。</p>
<h2 id="Day-26「无题」（2022-3-14）"><a href="#Day-26「无题」（2022-3-14）" class="headerlink" title="Day 26「无题」（2022-3-14）"></a>Day 26「无题」（2022-3-14）</h2><p>毕竟只是用来交作业的游戏，我就从以撒 wiki 上整了一只大可爱扔了进去。</p>
<p>然后……然后就没了。</p>
<p>补：今天好像是 $\pi$ 日？</p>
<h2 id="Day-27「天选之子」"><a href="#Day-27「天选之子」" class="headerlink" title="Day 27「天选之子」"></a>Day 27「天选之子」</h2><p>晚上是高数习题课。</p>
<p>于是一周五天就只有周三晚上（当然其实是一整天）没有课了（悲</p>
<p>然后课上助教告诉我们说上个学期高数挂科率达到了整整 $40\%$。</p>
<p>于是这个学期作业提交情况和习题课出勤率要算入平时分（大悲</p>
<p>结果这一天同寝室 FYF dalao 就没有去上习题课。</p>
<p>（↑ 其实他今天一整天都在寝室里打游戏）</p>
<p>然后老师可能是点名点到一半累了，于是名单后半段就随机抽取了几个名字象征性地点了一下。</p>
<p>然后没点到 FYF。</p>
<p>奇怪的运气增加了！</p>
<p>（↑ 虽然他作业还是没交（其实是没写）所以平时分还是要扣的）</p>
<h2 id="Day-28「？？？」"><a href="#Day-28「？？？」" class="headerlink" title="Day 28「？？？」"></a>Day 28「？？？」</h2><p>总而言之就是没有课的一天。</p>
<h2 id="Day-29「职业电竞选手」"><a href="#Day-29「职业电竞选手」" class="headerlink" title="Day 29「职业电竞选手」"></a>Day 29「职业电竞选手」</h2><p>今天下午就要交大雾实验（大雾，大物实验）作业了。</p>
<p>然而我们的 FYF dalao 依然是一个字没写却仍然在高枕无忧地打游戏。</p>
<p>（↑ 他已经三四天没去教室了）</p>
<blockquote>
<p>CTY「我们已经可以为他的职业电竞之路加油鼓劲了。」</p>
</blockquote>
<h2 id="Day-30「US，ES，EG-和-UG」"><a href="#Day-30「US，ES，EG-和-UG」" class="headerlink" title="Day 30「US，ES，EG 和 UG」"></a>Day 30「US，ES，EG 和 UG」</h2><p>今天上午有大雾实验。</p>
<p>然而因为我实验报告并没有写（其实是看着那么多字懒得写了）于是和 FYF 一起缩在寝室睡大觉（</p>
<p>晚上两节离散数学讲数理逻辑及确实是差点没听懂。</p>
<p><del>话说上面那位几天没去上课了啊。</del></p>
<h2 id="Day-31「？？？」"><a href="#Day-31「？？？」" class="headerlink" title="Day 31「？？？」"></a>Day 31「？？？」</h2><p>总而言之就是（几乎）没有课的一天。</p>
<p>突然想起来我英语作文还没写。</p>
<h2 id="Day-32「幸运一抽」"><a href="#Day-32「幸运一抽」" class="headerlink" title="Day 32「幸运一抽」"></a>Day 32「幸运一抽」</h2><p>上午三四节职业生业规划。</p>
<p>老师想抽几个同学回答问题结果上来一抽就抽到了 FYF。</p>
<p><strong>噔 噔 咚</strong>（心肺停止</p>
<p>下午晚上玩以撒的时候觉得是时候打一打挑战了，于是一口气打了十个（</p>
<p>甚至还录屏了（指高血压操作集锦</p>
<h2 id="Day-33「？？？」（2022-3-21）"><a href="#Day-33「？？？」（2022-3-21）" class="headerlink" title="Day 33「？？？」（2022-3-21）"></a>Day 33「？？？」（2022-3-21）</h2><p>平静的一天。</p>
<p>找红隐藏真有意思（</p>
<h2 id="Day-34「你太菜了，把手柄给我」"><a href="#Day-34「你太菜了，把手柄给我」" class="headerlink" title="Day 34「你太菜了，把手柄给我」"></a>Day 34「你太菜了，把手柄给我」</h2><p>/jk</p>
<p>挑战 22 着实折磨，但是幸运饼干给的魂心实在是太多了（</p>
<h2 id="Day-35「？？？」"><a href="#Day-35「？？？」" class="headerlink" title="Day 35「？？？」"></a>Day 35「？？？」</h2><p>本来今天上午是要去做核酸的然而整个寝室集体没起来于是只能明天了（</p>
<p>下午打了 1h+ 的挑战 29，只能说太难了 :(</p>
<p>于是又打了 1h+ 的挑战 31，然后勉强过了。</p>
<p>来让超级撒旦告诉你一个好开局有多么重要吧（</p>
<h2 id="Day-36「拉了」"><a href="#Day-36「拉了」" class="headerlink" title="Day 36「拉了」"></a>Day 36「拉了」</h2><p>拉了。</p>
<h2 id="Day-37「制裁」"><a href="#Day-37「制裁」" class="headerlink" title="Day 37「制裁」"></a>Day 37「制裁」</h2><p>总而言之就是同寝室的那位成天所在寝室不去上课的 dalao 被辅导员叫去谈话了（预计，似乎是下周一下午）。</p>
<p><strong>噔 噔 咚</strong>（绝望</p>
<p>晚上终于过了挑战 37「血腥玛丽」，只能说半颗红心实在是容错太低，稍微多动症一下就没了。</p>
<p>不过其实大部分是运气成分。一层献祭房出了圣餐，然后五层出圣心七层出圣饼。阴间拿了本死灵之书在撒旦面前连拍好几下直接送走。</p>
<p><strong>你不必担心，我已经听到了你那略带惊恐的祈祷（每层一开始拼了命找红心）。</strong></p>
<p><strong>如今，你还没有意识到，痛苦（被血誓吸干红心）这种事物再微小不过了吗？</strong></p>
<p><strong>你需要向我证明你的出人之处。</strong></p>
<p><strong>你应该信任我，将生命（红心）奉献（献祭）给我。然后，我自然会向你展示，什么叫做力量（圣心，圣饼）。</strong></p>
<h2 id="Day-38「咋办啊！」"><a href="#Day-38「咋办啊！」" class="headerlink" title="Day 38「咋办啊！」"></a>Day 38「咋办啊！」</h2><p>下午晚上打以撒，最新更新蓝宝宝加强了，正好我通关标记除了 BR，Hush 和究极贪婪以外还差一个母亲，于是就开始打。结果打了几把总是暴毙，于是果断地进行了一个游戏的退出。</p>
<p>晚上老师要验收 C 语言大作业，要问问题。然后班上有一位 dalao（因为和我写的是一个题目）就想和我一起上去然后让老师只看我的代码问问题都朝着我问。</p>
<p>结果老师问到一般突然点着他让他回答。然后他答不上来……</p>
<p>然后老师又指问了他几个语法问题，就像是，结构体里面定义了两个构造函数（当然名字是一样的，一个有参数一个没有所以可以重名），然后问它们为什么可以重名。然后他答不上来……</p>
<p><strong>噔 噔 咚</strong>（绝望</p>
<p><del>咋办啊！</del></p>
<h2 id="Day-39「咋办啊！！」"><a href="#Day-39「咋办啊！！」" class="headerlink" title="Day 39「咋办啊！！」"></a>Day 39「咋办啊！！」</h2><p>太久没玩隐藏章节已经不会玩力（悲</p>
<p>也许是因为最近玩得太多了腻了吧。</p>
<p>晚上寝室集体赶线代作业，然后发生了如下对话：</p>
<blockquote>
<p>FYF「是不是一个大数在一个小数前面就算做一个逆序数？$4123$ 是 $3$ 个还是 $1$ 个？」</p>
<p>CTY「你自己看书啊。」</p>
<p>FYF「我怎么知道书上哪个地方写了，我这第一次翻开书。」</p>
</blockquote>
<p><strong>噔 噔 咚</strong>（绝望</p>
<h2 id="Day-40「？？？」（2022-3-28）"><a href="#Day-40「？？？」（2022-3-28）" class="headerlink" title="Day 40「？？？」（2022-3-28）"></a>Day 40「？？？」（2022-3-28）</h2><p>平静的一天。</p>
<h2 id="Day-41「通向虚空的大门」"><a href="#Day-41「通向虚空的大门」" class="headerlink" title="Day 41「通向虚空的大门」"></a>Day 41「通向虚空的大门」</h2><p>晚上刷夏娃的通关标记。</p>
<p>一连打了三四局结果一次都没有成功见到虚空传送门（悲</p>
<p>最后一局天使房出了光明之冠于是立刻停下了手中的剃刀片（</p>
<p>本来这个时候还拿了一块钥匙碎片的，结果后面给忘了直接走恶魔房了（</p>
<p><del>不直接凑齐两块碎片是因为炸弹不够。</del></p>
<p>然后喜提硫磺火，然后不知怎么开了蓝子宫的门（可能是第八层打得太快了吧）（指 Boss 房刷的太近了），进去对着窒息胎喷了一通硫磺火（它的连续统还是不会躲）然后成功摸到了虚空的大门。</p>
<p>然后差点被精神错乱乱杀（指一红心 + 一永恒之心）（</p>
<p>前几天的更新似乎在虚空层的时候在画面四周新增了某种黑白噪点，更新前录下来的视频里还是没有的。</p>
<p>教义同款特效（</p>
<h2 id="Day-42「小概率事件」"><a href="#Day-42「小概率事件」" class="headerlink" title="Day 42「小概率事件」"></a>Day 42「小概率事件」</h2><p>晚上继续刷通关标记（这次是参孙）。</p>
<p>习题课，（）都不听。</p>
<p>只能说，概率是真的奇妙。</p>
<p>（↑ 三层天使房开启率被打到 $9\%$ 还能开甚至出了圣饼的人）</p>
<p>（↑ 当场把两个天使都给鲨了）（光头恶霸确信）</p>
<p>最后一局本来向走死母线结果快打死的时候玩血权玩到没血了结果同归于尽了（悲</p>
<p><a href="https://www.bilibili.com/video/BV1Yq4y1n7Gr">推歌？</a></p>
<p>BLASPHEMY AGAINST THE HOLY SPIRIT!!!</p>
<h2 id="Day-43「日记」"><a href="#Day-43「日记」" class="headerlink" title="Day 43「日记」"></a>Day 43「日记」</h2><p>我为什么要来写这么一个破玩意。</p>
<h2 id="Day-44「愚人节」"><a href="#Day-44「愚人节」" class="headerlink" title="Day 44「愚人节」"></a>Day 44「愚人节」</h2><p>今天似乎是愚人节的样子。</p>
<p>一打开 QQ 发现 SDOI 群的名字发生了奇怪的变化，吓得我反复确认这的确是 SDOI 群。</p>
<p>本来想看看今天 Steam 库里的游戏有没有愚人节彩蛋的结果全忘了（</p>
<h2 id="Day-45「日记？」"><a href="#Day-45「日记？」" class="headerlink" title="Day 45「日记？」"></a>Day 45「日记？」</h2><p>（）都不写。</p>
<h2 id="Day-46「无题」"><a href="#Day-46「无题」" class="headerlink" title="Day 46「无题」"></a>Day 46「无题」</h2><p>今天打了一场校赛。</p>
<p>只能说，题目太简单了（</p>
<p>不过有一道 C 还是挺有意思的（</p>
<h2 id="Day-47「摆烂，但是没完全摆烂」（2022-4-4）"><a href="#Day-47「摆烂，但是没完全摆烂」（2022-4-4）" class="headerlink" title="Day 47「摆烂，但是没完全摆烂」（2022-4-4）"></a>Day 47「摆烂，但是没完全摆烂」（2022-4-4）</h2><p>下午本来是昨天比赛的复赛，结果评测系统爆炸了于是取消了。</p>
<p>不过说实话就算系统不爆炸，就这个题目难度也是随手 AK（</p>
<p>刷拉撒路的通关标记。</p>
<p>拉撒路，指复活以后触发贫血，<strong>拉</strong>出来的血<strong>撒</strong>了一<strong>路</strong>（光速逃</p>
<p>第一局，吐根，结果自己摆烂给摆死了。</p>
<p>第二局，史诗胎儿博士 + 硫磺火，结果一不小心就导弹炸自己，最后给炸死了。</p>
<p>第三局，吐根 + 硫磺火（我也想知道为什么每局都有这么多强力道具），结果不知道是因为这两个道具的某种化学反应还是其他道具的效果，每次攻击都会有概率炸自己一下。</p>
<p>第七层发现了这个问题想确认一下结果直接给自己人炸没了。</p>
<h2 id="Day-48「咋办啊」"><a href="#Day-48「咋办啊」" class="headerlink" title="Day 48「咋办啊」"></a>Day 48「咋办啊」</h2><p>上午是昨天下午的比赛。</p>
<p>一上来切掉 AB 然后开始对着 C 犯傻。</p>
<p>交了几发发现过不了于是开 D，然后各种犯低级错误，包括但不限于求网格四联通有障碍最短路写成 DFS。</p>
<p>功力尽失（悲</p>
<p>身败名裂（绝望</p>
<p>到最后 D 勉强过了，E 看出来个大概思路不过没时间写了。</p>
<p>我没有水平 .jpg</p>
<p>出考场试图与 WWJ 学长交流，然后得知他刚刚知道今天上午有比赛。</p>
<blockquote>
<p>学长「睡得可香了。」</p>
</blockquote>
<h2 id="Day-49「请各位光头不要在挑战-45-耍仙术」"><a href="#Day-49「请各位光头不要在挑战-45-耍仙术」" class="headerlink" title="Day 49「请各位光头不要在挑战 45 耍仙术」"></a>Day 49「请各位光头不要在挑战 45 耍仙术」</h2><p>解锁了堕化伊甸，于是成功解锁了传说中的挑战 45。</p>
<p>然后明白了什么叫做真正的仙术。</p>
<p>第一局遇到两个印象比较深刻的主动道具。其中一个好像是吸收掉当前房间内的所有底座道具，每吸收一个道具就生成一只怪物。</p>
<p>然后它生出来的第一只就是回溯线限定的那种堕化狙击苍蝇（好像是这个名字）。</p>
<p>吓得我夺门而逃（</p>
<p>第二个是一个没有充能条的主动道具，使用时在角色位置生成一只大胖。</p>
<p>大胖迫害协会狂喜（错乱</p>
<p>最后通关的那一局是，在第一层的道具房发现了一个没有充能条的主动道具，使用时原地生成一个随机卡牌 / 符文 / 魂石。</p>
<p><strong>混沌宝珠警告（噔噔咚</strong></p>
<p>妈腿？妈心？以撒？小蓝人？一张混沌卡下去全部木大（</p>
<p>还有一些，像是：</p>
<ol>
<li>角色清理完房间时，原地放置一颗大爆弹先生的炸弹。</li>
<li>角色杀死怪物时，几率在当前房间获得一只格罗。</li>
<li>角色拾取卡牌 / 符文 / 魂石时，几率将其重置，然后放屁，并原地生成另一个随机卡牌 / 符文 / 魂石。</li>
<li>角色清理完房间时，承受一颗心的伤害，优先扣除红心。</li>
<li>角色杀死怪物时，在当前层获得一只随机跟班。</li>
<li>角色拾取掉落物时，会听到撒旦的笑声，然后手上会被塞入一颗鲍勃的烂头（可以投掷）。</li>
</ol>
<h2 id="Day-50「科目变化了！」"><a href="#Day-50「科目变化了！」" class="headerlink" title="Day 50「科目变化了！」"></a>Day 50「科目变化了！」</h2><p>早上又要去做核酸（</p>
<p>在门口排了可能有一节课时间的队（</p>
<p>三四节是高数。讲重积分的几何应用和物理应用。不过都是后半段都是计算没啥意思就没听（</p>
<p>在课桌上看到了不知是哪位 dalao 写下的字：</p>
<blockquote>
<p>Be positive. Be patient.</p>
<p>成为阳性。成为病人。</p>
</blockquote>
<p>lmao</p>
<p>下午本来是气排球课，但是老师看体育馆基本上这个学期不能用了于是临时把项目改成了散打。</p>
<p>没错散打。虽然在我看来教别人散打就是教别人鲨人（光速逃</p>
<p>晚上试图打以撒，但是似乎状态不够好于是开摆。</p>
<h2 id="Day-51「你是一个一个一个接龙群啊！」"><a href="#Day-51「你是一个一个一个接龙群啊！」" class="headerlink" title="Day 51「你是一个一个一个接龙群啊！」"></a>Day 51「你是一个一个一个接龙群啊！」</h2><p>查了一下发现表双子解锁的道具是真的一个比一个香，长子权，谷底石，达摩剑，创世纪。于是考虑开始挑战表双子全红。</p>
<p>我严重怀疑以撒这游戏有一个隐藏设定：每当玩家开始认真地玩一个新角色的时候，那一局遇到的道具质量提升。</p>
<p>总之就是半个乱杀局（</p>
<p>晚上一二节离散数学，因为清明假期刚过去老师怕我们前面学的都还给他了于是带着我们进行了一个一节课半的复习。</p>
<p>然后懒得听于是水群。</p>
<p>SD NOIP 群已经沦为复读群力（悲</p>
<h2 id="Day-52「今天我死了」"><a href="#Day-52「今天我死了」" class="headerlink" title="Day 52「今天我死了」"></a>Day 52「今天我死了」</h2><p>把双子的标记刷得差不多了（指还剩下母亲和究极贪婪三个）（隐藏章节双拿天使房双拿带来的战斗力提升原来这么多吗），想开始开表罗的坑了。</p>
<p>结果第一局上来伊甸的祝福送我一个吐根。</p>
<p>因为表罗子弹幽灵眼泪也不用担心子弹撞到石头上或者是板边爆炸，相比于其他角色开局吐根会好打一些。虽然炸隐藏房就有点难。 </p>
<p>直接冲进 Boss Rush 房一通乱杀，吐根两下带走一个 Boss。</p>
<p>然后冲进蓝子宫正面刚死寂（话说回来官中的翻译改成「死寂」了？之前还是「窒息胎」的来着），结果靠太近一发吐根直接给我破盾了。</p>
<p>然后惨死在死寂的连续统攻击之下（</p>
<p>翻了翻之前的视频，发现好像，如果同时持有「硫磺火」「吐根酊」「多维宝宝」，角色发射的血激光在碰到多维宝宝时会爆炸，然后我有一局拉撒路就是这样被炸死的。</p>
<p>可能其他的能够让角色眼泪分裂的跟班，像是天使棱镜也会有类似地效果。不过懒得测试了。</p>
<h2 id="Day-53「咋办啊！！！！」"><a href="#Day-53「咋办啊！！！！」" class="headerlink" title="Day 53「咋办啊！！！！」"></a>Day 53「咋办啊！！！！」</h2><p>下午事校内的比赛。</p>
<p>自信慢慢地去实验室，切掉 ABC 然后开始自闭。</p>
<p>D 看了看感觉不会就跳过了。</p>
<p>E 也感觉不会。然后开 F。</p>
<p>想了 1.5h+ 的暴力递推，写分数类发现 <code>unsigned long long</code> 都存不下，写 <code>long double</code> 发现精度不够。</p>
<p>本来想直接转 Python 的结果发现电脑上没装解释器。</p>
<p>好吧其实就算用 Python 感觉复杂度也要出锅。</p>
<p>比赛开始 2h 过去了才想起来观察性质，结果观察了一下一发过。</p>
<p>G 的大意事给定一个凸包 $A$ 和另一个简单多边形 $B$，问 $B$ 是否严格在 $A$ 内部。</p>
<p>实际上由凸包的性质很快可以得到，如果 $B$ 的所有顶点都严格在 $A$ 内部，那么 $B$ 本身也一定严格在 $A$ 内部。</p>
<p>然后就是 $m$ 次查询某个给定点是否在凸包内。</p>
<p>然后，因为不会写计算几何，我直接把整个凸包拆成两个 $y$ 关于 $x$ 的分段线性函数当作上下界，然后判断每个点的坐标是否在对应 $x$ 坐标的上下界内。</p>
<p>然后返回去看 D 发现暴力背包可行，一写发现写不对。</p>
<p>学术垃圾竟是我自己 .jpg</p>
<p>晚上想起来自己英语作文还没写。</p>
<p>向 WWJ 学长求助，结果……</p>
<blockquote>
<p>学长「上网搜英语作文，我的经历，然后抄一篇。」</p>
<p>我「直接抄网上搜到的真的不会被发现吗（」</p>
<p>学长「不会，老师根本没时间。」</p>
</blockquote>
<p>这就是学长吗（</p>
<p>然后上网搜了一篇，xjb 改了改交上去了。最后修改到 83 pts，海星吧。</p>
<h2 id="Day-54「啊我死了」（2022-4-11）"><a href="#Day-54「啊我死了」（2022-4-11）" class="headerlink" title="Day 54「啊我死了」（2022-4-11）"></a>Day 54「啊我死了」（2022-4-11）</h2><p>尝试刷游魂的母亲通关标记，然而因为隐藏章节没怎么打过疯狂暴毙（</p>
<p>最远的一次在尸宫 I BOSS 房，因为不熟悉那个甩鞭子的 BOSS 的攻击模式，连着两次被鞭子抽到脸上于是寄掉了（</p>
<p>啊我死了（物理</p>
<h2 id="Day-55「啊我死了（梅开二度」"><a href="#Day-55「啊我死了（梅开二度」" class="headerlink" title="Day 55「啊我死了（梅开二度」"></a>Day 55「啊我死了（梅开二度」</h2><p>晚上试图刷游魂的最后一个通关标记，也就是究极贪婪的标记。</p>
<p>然而因为贪婪模式太难了各种暴毙（悲</p>
<p>最远的一次见到究极贪婪结果，因为 BOSS 房旁边有一些上吊的店主，究极贪婪的炸弹硬币把这些炸出蜘蛛了，然后我没看见。</p>
<p>饿啊（指操作下饭</p>
<p>然后就再也没有出过第三章。</p>
<p>此时，一条咸鱼失去了梦想 .jpg</p>
<h2 id="Day-56「别玩了！」"><a href="#Day-56「别玩了！」" class="headerlink" title="Day 56「别玩了！」"></a>Day 56「别玩了！」</h2><p>继续尝试刷游魂的究极贪婪标记。</p>
<p>然后日常暴毙（悲</p>
<p>最后一局成功地拿到了传说中「跳出三界外，不在五行中」的计数二十面骰，然后直接复杂性骨折，柯吉猫的身体，强力安眠药，科技零，剖腹产给整上把究极贪婪按在墙角锤（</p>
<p>强力安眠药 + 剖腹产的组合竟然还是发射拳头（拿了 A+），不过拳头似乎有追踪并且会发射小拳头。</p>
<p>你都生了些什么东西出来啊 kora（</p>
<p>莉莉丝在贪婪模式以外有亿点不好用，于是开始刷店主的标记（</p>
<h2 id="Day-57「？？？」"><a href="#Day-57「？？？」" class="headerlink" title="Day 57「？？？」"></a>Day 57「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-58「发生肾么事了？？！！」"><a href="#Day-58「发生肾么事了？？！！」" class="headerlink" title="Day 58「发生肾么事了？？！！」"></a>Day 58「发生肾么事了？？！！」</h2><p>早上虽然有大物实验不过因为不想写实验报告于是日常翘掉。</p>
<p>结果突然辅导员就推门进来了。</p>
<p>然后那个时候我甚至还没起来。</p>
<p><strong>噔 噔 咚（绝望</strong></p>
<p>晚上继续刷店主的标记，只能说三格血上限可容易暴毙了。</p>
<p>有一局见到母亲结果被二阶段的那个白色蠕虫弹幕爆杀（</p>
<h2 id="Day-59「？？？」"><a href="#Day-59「？？？」" class="headerlink" title="Day 59「？？？」"></a>Day 59「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-60「九条可怜（绝望」"><a href="#Day-60「九条可怜（绝望」" class="headerlink" title="Day 60「九条可怜（绝望」"></a>Day 60「九条可怜（绝望」</h2><p>下午是 CCCC 的热身赛。</p>
<p>虽然上午三四节似乎还有职业生涯规划的样子不过还是半个字不听（</p>
<p>开始比赛前确认到场需要扫一个验证用的二维码，结果 13：30 开始但是老师 12：20+ 才把二维码给出来。</p>
<p>抱歉，搞忘咯 .jpg</p>
<p>进去一看发现巨大多水题。直到我看到最后一题。</p>
<p>题意就是一个序列，每次随机添数，所有数 $\gcd$ 到 $1$ 了就结束，问序列期望长度。</p>
<p>之前写过一篇 CF 上这个题的题解，不过那个时候数据范围只有 $10^5$ 所以我写了个根号的交上去了。不过这次数据范围被超级加倍到了 $10^{11}$。</p>
<p>不会。告辞。</p>
<h2 id="Day-61「？？？」（2022-4-18）"><a href="#Day-61「？？？」（2022-4-18）" class="headerlink" title="Day 61「？？？」（2022-4-18）"></a>Day 61「？？？」（2022-4-18）</h2><p>平静的一天。</p>
<h2 id="Day-62「？？？」"><a href="#Day-62「？？？」" class="headerlink" title="Day 62「？？？」"></a>Day 62「？？？」</h2><p>/kel</p>
<h2 id="Day-63「？？？」"><a href="#Day-63「？？？」" class="headerlink" title="Day 63「？？？」"></a>Day 63「？？？」</h2><p>/kel</p>
<h2 id="Day-64「？？？」"><a href="#Day-64「？？？」" class="headerlink" title="Day 64「？？？」"></a>Day 64「？？？」</h2><p>/kel</p>
<h2 id="Day-65「？？？」"><a href="#Day-65「？？？」" class="headerlink" title="Day 65「？？？」"></a>Day 65「？？？」</h2><p>虽然当初立志要写日记，但是真的不想写（</p>
<h2 id="Day-66「废物竟是我自己」"><a href="#Day-66「废物竟是我自己」" class="headerlink" title="Day 66「废物竟是我自己」"></a>Day 66「废物竟是我自己」</h2><p>之前有一天被 ZJ 私聊问要不要打 CCCC 团体天梯赛，然后那我肯定不好拒绝。</p>
<p>于是就是今天了。虽然我觉得以我的水平也就是去划个水。</p>
<p>要求似乎还挺多，让录一段考场周围环境的视频，甚至还要求这段视频里面周围两米范围内不能有其他人。</p>
<p>然后开题。L1，L2 的题都是巨大多水题，除了 L2 的最后两道。</p>
<p>L2-3 感觉是个树上的经典题目，结果不会。</p>
<p>L2-4 写了个 $O(n^2\log n)$ 的 Dij 结果 T 掉了。</p>
<p>L3-1 是个，算是模拟吧，总而言之是顺利地切掉了。</p>
<p>L3-2 感觉也是个树上的经典题目。大体题意是，给定一棵有根树，求这棵树所有节点按照所有可能的 DFS 序排序后形成的序列的逆序对数量的总和。</p>
<p>记得好像有一种保留重儿子的技巧，可以把时间复杂度从平方优化到一个 $\log$，不过没写出来。</p>
<p>题目给的第二个样例答案是 $516$，然后我的代码跑出来 $258$。感觉就差一点但是不知道错在哪里了。</p>
<p>L3-3，九条可怜，不会，滚。</p>
<p>感觉最近日渐颓废。想着做 CF 题，结果思维不够做不出来。想着做 OI 题，结果每次都是一读完题就开始写，写到一半才发现自己的思路太过暴力或者直接就是假的，正确的思路又需要使用一些数据结构，然后就懒得写了。</p>
<p>如此往复循环，现在是什么题都不会做了。</p>
<p>你他妈的！不可以这样的啊！不可以啊！.jpg</p>
<h2 id="Day-67「？？？」"><a href="#Day-67「？？？」" class="headerlink" title="Day 67「？？？」"></a>Day 67「？？？」</h2><p>/kel</p>
<h2 id="Day-68「？？？」（2022-4-25）"><a href="#Day-68「？？？」（2022-4-25）" class="headerlink" title="Day 68「？？？」（2022-4-25）"></a>Day 68「？？？」（2022-4-25）</h2><p>最近在刷堕化角色的通关标记。</p>
<p>堕化以撒强归强，对选择困难症太不友好了。</p>
<p>玩这个角色得有一半左右的时间在撕烤该拿哪个道具该换哪个道具。</p>
<p>堕化抹大拉好强啊直接横冲直撞都不用担心暴毙反正杀敌掉血然后副主动拍一下两颗红心。</p>
<p>然后开始玩堕化该隐。</p>
<p>有一说一，堕化该隐正常一局我能打 1h+。</p>
<h2 id="Day-69「黑暗中的犹大人（bushi」"><a href="#Day-69「黑暗中的犹大人（bushi」" class="headerlink" title="Day 69「黑暗中的犹大人（bushi」"></a>Day 69「黑暗中的犹大人（bushi」</h2><p>因为堕化该隐非常的没有意思，于是开始玩堕化犹大。</p>
<p>然后第一局就在第一层的宝箱房捡了一个小号。</p>
<p>emmm……无法接受，R 了（</p>
<p>以撒不就是个屎尿屁游戏（暴论</p>
<h2 id="Day-70「食雪汉（指里蓝人」"><a href="#Day-70「食雪汉（指里蓝人」" class="headerlink" title="Day 70「食雪汉（指里蓝人」"></a>Day 70「食雪汉（指里蓝人」</h2><p>堕化犹大非常强于是很快就全红了。</p>
<p>然后开始玩堕化蓝宝宝。</p>
<p>弟啊你这眼泪根本打不出伤害啊。</p>
<p>弟啊你自带这么多大便有什么用吗。</p>
<p>总而言之就是无解弱。埋了吧（无慈悲</p>
<p>于是跑去隔壁打挑战。</p>
<p>首先是成功地靠镰刀眼泪和削皮刀削出来的 3 级肉哥打过了挑战 29。</p>
<p>然后是只开了一层天使房里面还只有一个道具的挑战 40。</p>
<p>第八层 BOSS 战两个妈心直接打起来了甚至连眼睛都没召唤出来。</p>
<p>挑战 41 需要解锁弹珠袋，但是我才发现我还没有解锁。于是直接打开控制台进行了一个安慰剂 + Gulp 的刷。</p>
<p>剩下的挑战还有三个：32，愚人节；34，终极困难；42，烫手山芋。</p>
<p>充血怪 / 肿胀 / 双目硫磺火是什么 diaomao BOSS 啊（暴论</p>
<h2 id="Day-71「FUCK-BLOAT！！！（震声」"><a href="#Day-71「FUCK-BLOAT！！！（震声」" class="headerlink" title="Day 71「FUCK BLOAT！！！（震声」"></a>Day 71「FUCK BLOAT！！！（震声」</h2><p>下次版本更新把这个 diaomao BOSS 删了罢（无慈悲</p>
<p>尤其是绿色变种（</p>
<p>总而言之就是挑战 32 过了。</p>
<p>挑战 42 也在怀表和圣经的帮助下过了。</p>
<p>第六层一进商店就看到圣经是什么神仙运气啊。</p>
<p>然后尝试挑战 34。</p>
<p>因为比较难于是试图刷开局（指在一层图书馆刷出启示录）。</p>
<p>然而因为都是双重 BOSS 所以并不能被替换成天启骑士（悲</p>
<p>第八层，或者说因为是合并诅咒所以实际上是第四层，开了恶魔房，进去一看一个一血交易一个二血交易。</p>
<p>拿了那个二血的一看是亚巴顿。海星吧虽然不是硫磺火。</p>
<p>结果被超级撒旦乱杀（悲</p>
<h2 id="Day-72「参孙感觉很健康！」"><a href="#Day-72「参孙感觉很健康！」" class="headerlink" title="Day 72「参孙感觉很健康！」"></a>Day 72「参孙感觉很健康！」</h2><p>又来打挑战 34（</p>
<p>日常刷开局直到一层图书馆出启示录。</p>
<p>洞穴层开了天使房，一进去发现是个二选一，深思熟虑之后拿了左边的。</p>
<blockquote>
<p><strong>终末天启</strong></p>
<p>唤醒你的信仰</p>
</blockquote>
<p>于是这一局就过了（喜</p>
<p>感觉大傻蛋二阶段平均难度略低于一阶段。就拿这一局挑战 34 来说，我一阶段挨了三下，然后二阶段甚至无伤。</p>
<p>感觉二阶段就像期末考试，大傻蛋（试卷）要是只用（出）你会躲（做）的弹幕（题目）你就能无伤（过），要是只用（出）你不会躲（做）的弹幕（题目）你就会暴毙（挂）（光速逃</p>
<p>从某种意义上来说，挑战 34 稍微挽回了一些超级撒旦作为最终 BOSS 的威严。</p>
<p>然后开始刷里蓝人的通关标记……什么屑角色埋了罢（无慈悲</p>
<h2 id="Day-73「休伤吾儿！」"><a href="#Day-73「休伤吾儿！」" class="headerlink" title="Day 73「休伤吾儿！」"></a>Day 73「休伤吾儿！」</h2><p>堕化蓝宝宝实在是太难玩了（悲</p>
<p>于是开始考虑刷堕化夏娃的通关标记。</p>
<p>感觉堕化夏娃就是血团数量堆上来了就能横着走，但是尤其是打 BOSS 的时候，或者是遇到某些高速贴脸怪，很容易一下子死一大片。</p>
<p>有一局打精神错乱就是如此，然后那局被百变怪残血反杀（悲</p>
<p>有一说一，平衡符号天下第一。</p>
<p>晚上打开了近一个月没有碰过的百橙，顺便进行了一个 DLC 的安排。</p>
<p>两个新角色，希夫和星乃丽华，分别对应之前 NoName 和星破的普通人 (?) 世界线。</p>
<p>然后拿到新角色肯定是先把语音听一篇。听说相比于之前的星破，丽华的性格要温和一些……但是完全听不出来，感觉还是跟个疯子一样（光速逃</p>
<p>属性的话，希夫 8 滴血是什么神仙啊。上一个血这么厚的好像还是斩子，然而斩子不能回血，这个希夫却有着 +0/-2/+0 的面板。<del>这么一看好像也就平均值高了那么一点（</del></p>
<p>机制并没有完全玩懂（</p>
<p>另一边丽华则是 3 滴血，继彼特和奈奈子之后第三个全游戏血量最少的角色出现了，挺容易暴毙的。然后面板是 +2/+0/+0，兄啊说好的性格温和呢你这 +2 攻击真的不是用来鲨人的吗（半脑</p>
<p>被动倒是有一个和星破相反的只能选择星星目标，以及获得星星时数量 +1，然后 Hyper 是接下来三个回合从其他角色手上持续抢夺星星。</p>
<p>深夜突然想去玩一玩传说中的超级食肉男孩，于是就去买了个玩。</p>
<p>有一说一，操作手感真的就那样了（</p>
<p>不知道是不是因为食肉哥只是一块肉，他是真的会粘在墙上和地板上的，尤其是粘在墙上的时候，不按跳跃只按方向键甚至从墙上下不来。</p>
<h2 id="Day-74「山东盛产数学高手是吧」"><a href="#Day-74「山东盛产数学高手是吧」" class="headerlink" title="Day 74「山东盛产数学高手是吧」"></a>Day 74「山东盛产数学高手是吧」</h2><p>下午又有实验室的比赛。一共 4h，又是坐大牢的时间了（悲</p>
<p>上来 A 感觉很简单但是写了很久过不了一只 <code>WA on test 2</code>，于是去写 BC，结果 B 交了两发，C 交了三发才过。功力尽失（悲</p>
<p>读完 D 感觉不大会于是去改 A 的代码，终于在第五次提交的时候过了。</p>
<p>然后去写 E。</p>
<p>题目大意是，有一场 IOI 赛制的比赛，有一道题，有 $N$ 组测试数据，每组测试数据的答案都是 <code>yes</code> 或 <code>no</code>。但是您不会做，于是对于每一组测试数据，您随机回答 <code>yes</code> 或 <code>no</code>。为了防止被判作弊，您至多提交 $K$ 发，求最优策略下的期望成绩。</p>
<p>显然是，如果某一次提交的分数已经足够高了，那么就不要再提交了。</p>
<p>一开始我以为是只要分数严格高于 $\lfloor\frac{N}{2}\rfloor$ 就不要再提交了，然后发现假了。</p>
<p>于是我很快（1h 之后）注意到，每次提交之后，如果剩下的提交次数能够达到的期望分数大于等于这此次提交的分数，那么就要再交一发。形式化地，设 $k$ 次提交的期望分数为 $E_k$，有</p>
<script type="math/tex; mode=display">
E_{k+1}=2^{-n}\sum_{i\gt E_k}{n\choose i}i+2^{-n}\sum_{i\leqslant E_k}{n\choose i}\cdot E_k=p(E_k)\cdot E_k+q(E_k)</script><p>其中 $p(E_k),q(E_k)$ 可以预处理出来。</p>
<p>这是一个变系数线性递推数列。但是注意到数据范围有 $K\leqslant 10^9$，一开始我是想不算到 $E_K$，算到 $E_{3\times 10^7}$ 左右就足够满足精度要求了，结果喜提 <code>WA on test 10</code>。</p>
<p>注意到，当 $\lfloor E_k\rfloor$ 不变的时候，$p(E_k),q(E_k)$ 也是不变的，我们可以用二分求得下一个使得 $\lfloor E_k\rfloor$ 发生变化的 $k$。</p>
<p>$p(E_k),q(E_k)$ 为常数 $p,q$ 时</p>
<script type="math/tex; mode=display">
E_{k+1}=pE_k+q</script><p>设</p>
<script type="math/tex; mode=display">
E_{k+1}+\lambda=p(E_k+\lambda)</script><p>可以解得</p>
<script type="math/tex; mode=display">
\lambda=\frac{q}{p-1}</script><p>然后我们就可以用求等比数列的方法求 $E_{k+m}$ 了，然后就真的可以二分了。</p>
<h2 id="Day-75「？？？」（2022-5-2）"><a href="#Day-75「？？？」（2022-5-2）" class="headerlink" title="Day 75「？？？」（2022-5-2）"></a>Day 75「？？？」（2022-5-2）</h2><p>本来想写点什么的结果忘了。</p>
<p>堕化参孙强是强，只是进了狂暴接下来连着两三个房间一只怪不刷是真的血压 up。</p>
<h2 id="Day-76「？？？」"><a href="#Day-76「？？？」" class="headerlink" title="Day 76「？？？」"></a>Day 76「？？？」</h2><p>堕化 AZ 似乎也很强，只是如果不用标记的话自带的硫磺火蓄力时间有点长（</p>
<p>蓄力到一半以为可以了一松射击发现射不出来（悲</p>
<h2 id="Day-77「？？？」"><a href="#Day-77「？？？」" class="headerlink" title="Day 77「？？？」"></a>Day 77「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-78「？？？」"><a href="#Day-78「？？？」" class="headerlink" title="Day 78「？？？」"></a>Day 78「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-79「？？？」"><a href="#Day-79「？？？」" class="headerlink" title="Day 79「？？？」"></a>Day 79「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-80「？？？」"><a href="#Day-80「？？？」" class="headerlink" title="Day 80「？？？」"></a>Day 80「？？？」</h2><p>今天下午是电路实验。</p>
<p>发现座位表上没有我的名字但是有一个座位是空着的于是我就坐在那里了。</p>
<p>同组的（本来应该是的）FYF 还在寝室里睡大觉于是只能我一个人做了。</p>
<p>做实验好难啊我用了 1.5h+ 才弄明白那些个仪器怎么使用。</p>
<h2 id="Day-81「？？？」"><a href="#Day-81「？？？」" class="headerlink" title="Day 81「？？？」"></a>Day 81「？？？」</h2><p>平静的一天。</p>
<p>晚上成功地举办了信息组第一次大型（指除了阿块以外基本上都来得差不多了）线上集会（</p>
<h2 id="Day-82「周三放假是吧」（2022-5-9）"><a href="#Day-82「周三放假是吧」（2022-5-9）" class="headerlink" title="Day 82「周三放假是吧」（2022-5-9）"></a>Day 82「周三放假是吧」（2022-5-9）</h2><p>下午一二节本来是电路课，但是 XP 群里面不知道为什么突然有一群蛤蟆开始语音聊天。</p>
<p>然后我还没下课不好开麦于是试图使用它那个文字交流功能，结果不知道为什么没有人理我。</p>
<p>然后快下课的时候……</p>
<blockquote>
<p>zhuoer「诶成爷似乎在这里孤独地发着文字。」</p>
</blockquote>
<p>心情简单 .jpg</p>
<h2 id="Day-83「什么超级贪婪」"><a href="#Day-83「什么超级贪婪」" class="headerlink" title="Day 83「什么超级贪婪」"></a>Day 83「什么超级贪婪」</h2><p>本来正在刷堕化伊甸的通关标记，结果刷到自闭了。</p>
<p>堕化伊甸是什么 diaomao 角色啊不会真的有人在除了刷成就以外的时候玩吧。</p>
<p>堕化游魂那当然是跳过。<del>整个游戏暴毙率第一的超级 diaomao 角色（</del></p>
<p>试图刷堕化店长的通关标记，结果是两个血上限其实比起里罗的一碰就死并没有多出来多少容错，尤其是向死寂，精神错乱这种没有小怪补给的最终 BOSS，差不多也就相当于是身上带着一张神圣卡的里罗。</p>
<p>有一局在蓝子宫层的宝箱房找到了吸血鬼之魅，打死寂前半段血量直接巨大多溢出，结果后半段它就不刷小怪了（</p>
<p>喜提暴毙 :(</p>
<h2 id="Day-84「？？？」"><a href="#Day-84「？？？」" class="headerlink" title="Day 84「？？？」"></a>Day 84「？？？」</h2><p>职业生涯规划是什么 diaomao 作业啊（暴论</p>
<h2 id="Day-85「？？？」"><a href="#Day-85「？？？」" class="headerlink" title="Day 85「？？？」"></a>Day 85「？？？」</h2><p>平静（并不是）的一天。</p>
<h2 id="Day-86「？？？」"><a href="#Day-86「？？？」" class="headerlink" title="Day 86「？？？」"></a>Day 86「？？？」</h2><p>电子电路实验报告是什么 diaomao 作业啊（半脑</p>
<h2 id="Day-87「？？？」"><a href="#Day-87「？？？」" class="headerlink" title="Day 87「？？？」"></a>Day 87「？？？」</h2><p>军事理论论文是什么 diaomao 作业啊（全脑</p>
<p>话说回来今天似乎是恋恋之日的来着（</p>
<p>奇怪的节日增加了（光速逃</p>
<p>好吧可能也没那么奇怪（光速跑回来</p>
<h2 id="Day-88「什么人形自走-D4-D8」"><a href="#Day-88「什么人形自走-D4-D8」" class="headerlink" title="Day 88「什么人形自走 D4 + D8」"></a>Day 88「什么人形自走 D4 + D8」</h2><p>堕化伊甸是什么 shadiao 角色啊（震怒</p>
<p>本来想用那个人形自走 D100 的说法的，不过一想好像里伊甸能 roll 的也就只有自己身上的东西了，对应的骰子好像只有一个 D4 一个 D8。</p>
<p>如果真的挨一下就触发一次 D7（重新开始当前房间）那就真的是狗都不玩的角色了（</p>
<p>打百变怪打到残血一不小心挨了一下，直接<strong>全 部 木 大</strong>（绝望</p>
<p>或者当成里罗玩（小声</p>
<h2 id="Day-86「？？？」（2022-5-16）"><a href="#Day-86「？？？」（2022-5-16）" class="headerlink" title="Day 86「？？？」（2022-5-16）"></a>Day 86「？？？」（2022-5-16）</h2><p>堕化该隐，狗都不玩 .jpg</p>
<h2 id="Day-87「？？？」-1"><a href="#Day-87「？？？」-1" class="headerlink" title="Day 87「？？？」"></a>Day 87「？？？」</h2><p>里罗好难（悲</p>
<h2 id="Day-88「？？？」"><a href="#Day-88「？？？」" class="headerlink" title="Day 88「？？？」"></a>Day 88「？？？」</h2><p>晚上把大逆转裁判又捡起来玩了玩。</p>
<h2 id="Day-89「？？？」"><a href="#Day-89「？？？」" class="headerlink" title="Day 89「？？？」"></a>Day 89「？？？」</h2><p>日常打里罗，这次走回溯线结果第一次打到这里太紧张于是暴毙了（绝望</p>
<p>论里罗的一百种死法 .jpg</p>
<p>话说回来，大逆连续两次提示存档的时间间隔好长啊。逆转 123 都是每隔 30min 左右就待续一下，结果大逆直接一口气 2h+。</p>
<h2 id="Day-90「……我那狂野的钢铁脚后跟重重地敲在桌子上的无礼。」"><a href="#Day-90「……我那狂野的钢铁脚后跟重重地敲在桌子上的无礼。」" class="headerlink" title="Day 90「……我那狂野的钢铁脚后跟重重地敲在桌子上的无礼。」"></a>Day 90「……我那狂野的钢铁脚后跟重重地敲在桌子上的无礼。」</h2><p>还请原谅。</p>
<p>lmao.jpg</p>
<h2 id="Day-91「里双子，（）都……还是算了罢」"><a href="#Day-91「里双子，（）都……还是算了罢」" class="headerlink" title="Day 91「里双子，（）都……还是算了罢」"></a>Day 91「里双子，（）都……还是算了罢」</h2><p>距离全红还剩四个角色：</p>
<ol>
<li>堕化该隐，还差究极贪婪。</li>
<li>堕化游魂，比起上面还差精神错乱。</li>
<li>堕化伊甸，比起上面还差母亲和祸兽。</li>
<li>堕化雅各，比起上面还差撒旦，羔羊和超级撒旦。</li>
</ol>
<p>:(</p>
<p>大逆转裁判真好玩（光速逃</p>
<h2 id="Day-92「？？？」"><a href="#Day-92「？？？」" class="headerlink" title="Day 92「？？？」"></a>Day 92「？？？」</h2><p>还没写呢 .jpg</p>
<p>算了不写了 .jpg</p>
<h2 id="Day-93「今天没碰以撒」（2020-5-23）"><a href="#Day-93「今天没碰以撒」（2020-5-23）" class="headerlink" title="Day 93「今天没碰以撒」（2020-5-23）"></a>Day 93「今天没碰以撒」（2020-5-23）</h2><p>直角。</p>
<h2 id="Day-94「今天没碰以撒-×2」"><a href="#Day-94「今天没碰以撒-×2」" class="headerlink" title="Day 94「今天没碰以撒 ×2」"></a>Day 94「今天没碰以撒 ×2」</h2><p>直角。</p>
<p>试图用 Unity 写一个简单的 STG。</p>
<p>造轮子好难（光速放弃</p>
<h2 id="Day-95-98「这个人很懒」"><a href="#Day-95-98「这个人很懒」" class="headerlink" title="Day 95 - 98「这个人很懒」"></a>Day 95 - 98「这个人很懒」</h2><p>什么也没有写。</p>
<h2 id="Day-99「基础生疏-jpg」"><a href="#Day-99「基础生疏-jpg」" class="headerlink" title="Day 99「基础生疏 .jpg」"></a>Day 99「基础生疏 .jpg」</h2><p>今天下午去新校区打排位赛 R2。</p>
<p>首先 A 一眼秒了，结果乘法取模之后加法忘记取模了喜提一发 WA。</p>
<p>然后 B 不会于是去看 C。</p>
<p>C xjb 转化了一波自以为高到不知道哪里去了，结果疯狂 WA。</p>
<p>然后回过头去看 B，对着样例总结了一下规律，然后再稍微一分析，啊这这不是思博题吗。</p>
<p>然后 D 就是一个树上 DP，没有问题。</p>
<p>这个时候已经 2h 了。</p>
<p>然后返回去看 C，才发现是转化出锅了，直接一波暴力然后真就过了。</p>
<p>这个时候已经 3h 了。</p>
<p>E 一看就知道不会。</p>
<p>F 有一个弱化版 F1，切掉算 0.5 分。一开始我是写了个 <code>std::set&lt;std::string&gt;</code>，结果因为时间复杂度实际上大概有 $O(n^3\log n)$ 于是疯狂 TLE。</p>
<p>后来我突然意识到，不是有个东西叫字符串 hash 吗。</p>
<p>于是写了个双模 hash，模数用的 $998244353$ 和 $19^9+9$，然后过了。</p>
<p>虽然都是 4.5 题但是很明显有一位叫做 SHX 的同级 dalao 的罚时不知道比我小到哪里去了。</p>
<p>只可惜那位 dalao R1 比我少切一道题然后排名就比我低了（</p>
<blockquote>
<p>群内 dalao「AB 考察的都是取模。」</p>
<p>还是上面那位「没有很快通过的说明经验生疏了。」</p>
</blockquote>
<h2 id="Day-100「100-天辣！」（2022-5-30）"><a href="#Day-100「100-天辣！」（2022-5-30）" class="headerlink" title="Day 100「100 天辣！」（2022-5-30）"></a>Day 100「100 天辣！」（2022-5-30）</h2><p>去他妈的电路实验（震声</p>
<h2 id="Day-101「人为什么要活着」"><a href="#Day-101「人为什么要活着」" class="headerlink" title="Day 101「人为什么要活着」"></a>Day 101「人为什么要活着」</h2><p>为什么要连着补两节课直接从 7：00 一口气干到 12：00 啊，老师这是觉得 AHU 人均铁人是吗（</p>
<h2 id="Day-102「儿童节」（2022-6-1）"><a href="#Day-102「儿童节」（2022-6-1）" class="headerlink" title="Day 102「儿童节」（2022-6-1）"></a>Day 102「儿童节」（2022-6-1）</h2><p>儿童的眼神 .jpg</p>
<h2 id="Day-103「新宇宙（迫真」"><a href="#Day-103「新宇宙（迫真」" class="headerlink" title="Day 103「新宇宙（迫真」"></a>Day 103「新宇宙（迫真」</h2><p>还挺上头的（这句话指《盗贼遗产 2》）（</p>
<p>简单感受了一下《冰与火之舞》的新 DLC Neo Cosmos，感觉要患上读谱障碍综合征了（</p>
<p>长条好别扭啊而且还是尾巴带判定的长条。<del>不过也可能只是单纯地因为我不会打（</del></p>
<p>这个 DLC 甚至还有剧情（</p>
<p>话说回来，存档读档算作弊吗（</p>
<p>如果算的话，那个存档点都是你给我摆好的为什么我就不能用了（</p>
<p>感觉一开始那个什么监管者的角色设计挺 ao 看的，有新宇宙的感觉。我是说他那一堆手。</p>
<p>亡蝶葬仪（无端迫害</p>
<h2 id="Day-104「盗贼遗产-2」"><a href="#Day-104「盗贼遗产-2」" class="headerlink" title="Day 104「盗贼遗产 2」"></a>Day 104「盗贼遗产 2」</h2><p>成功通过堆命打过了这游戏的一周目的两个最终 BOSS？算是吧。</p>
<p>虽然但是，稍微小小地剧透一下，最终 BOSS 是个缝合怪（</p>
<p>然后会解锁一个累赘系统，类比一下的话就是 Hades 的热度系统，就是会有一些增加难度的选项，然后打开这些选项再从头通关一遍就会有新内容。</p>
<p>一周目忍着没开房规，二周目试着关了碰撞伤害果然世界清静了许多。</p>
<p>感觉如果一个 BOSS 身上安上去太多风格不同的技能的话就会有缝合的感觉。</p>
<p>我觉得这是坏的，是个人都会谔谔的（</p>
<p>全盛拉麦好强（</p>
<p>话说回来，为什么 BOSS 房地形也被加强了啊（</p>
<p>简单找了一下隐藏要素，感觉任务表上给的提示就是那种，找不到的时候看不懂，找到了又觉得好像说的挺有道理的。</p>
<p>以撒说不定已经不会玩力（悲</p>
<h2 id="Day-105「逻辑与推理的实验剧场」"><a href="#Day-105「逻辑与推理的实验剧场」" class="headerlink" title="Day 105「逻辑与推理的实验剧场」"></a>Day 105「逻辑与推理的实验剧场」</h2><p>其实就是看福尔摩斯胡诌（</p>
<p>每天日常部分第一件事就是看福尔摩斯日常犯病（</p>
<h2 id="Day-106「-」"><a href="#Day-106「-」" class="headerlink" title="Day 106「:(」"></a>Day 106「:(」</h2><p>:(</p>
<h2 id="Day-107「-」（2022-6-6）"><a href="#Day-107「-」（2022-6-6）" class="headerlink" title="Day 107「:(:(」（2022-6-6）"></a>Day 107「:(:(」（2022-6-6）</h2><p>明天似乎是高考 Day 1？</p>
<p>希望无敌的阿块能够考个好成**。</p>
<h2 id="Day-108「？？？」"><a href="#Day-108「？？？」" class="headerlink" title="Day 108「？？？」"></a>Day 108「？？？」</h2><p>虽然端午节已经过去很久了不过……</p>
<p>什么是粽子？</p>
<p>要是被包起来的就行。</p>
<p>里面是不是饭也没关系了。</p>
<p>综上所述，结肠造口袋是粽子（暴论</p>
<h2 id="Day-109「？？？」"><a href="#Day-109「？？？」" class="headerlink" title="Day 109「？？？」"></a>Day 109「？？？」</h2><p>全盛拿玛是什么 diaomao 东西啊（半脑</p>
<h2 id="Day-110「？？？」"><a href="#Day-110「？？？」" class="headerlink" title="Day 110「？？？」"></a>Day 110「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-111「？？？」"><a href="#Day-111「？？？」" class="headerlink" title="Day 111「？？？」"></a>Day 111「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-112「？？？」"><a href="#Day-112「？？？」" class="headerlink" title="Day 112「？？？」"></a>Day 112「？？？」</h2><p>平静的一天。</p>
<h2 id="Day-113「进行一个分的骗」"><a href="#Day-113「进行一个分的骗」" class="headerlink" title="Day 113「进行一个分的骗」"></a>Day 113「进行一个分的骗」</h2><p>上午有 diaomao 军事理论考试。</p>
<p>虽然准备了答案但是还是有部分题目找不到（悲</p>
<p>下午去新校区打省赛。</p>
<p>三人一组共用一台电脑。IOI 赛制，因为没有罚时所以十分地不紧张刺激。</p>
<p>贡献了一道 A 和一道 E。本来想写一写 K 的结果到最后调不出来了。</p>
<p>其中 F 存在判断无解并输出 <code>No Solution</code> 的部分。</p>
<blockquote>
<p>同队 dalao「进行一个 <code>&quot;No Solution&quot;</code> 的 <code>puts()</code>。」</p>
</blockquote>
<h2 id="Day-114「推理（确信」（2022-6-13）"><a href="#Day-114「推理（确信」（2022-6-13）" class="headerlink" title="Day 114「推理（确信」（2022-6-13）"></a>Day 114「推理（确信」（2022-6-13）</h2><p>大逆转裁判 2-5，最后的《逻辑与推理的实验剧场》。</p>
<blockquote>
<p>福尔摩斯「船马上就开了，这次就不『玩』了。」</p>
</blockquote>
<p>燃起来力！燃起来力！（狂喜</p>
<p>所以说福尔摩斯以前推理的时候都是，5s 看到真相，然后 55s 撕烤怎么整活（</p>
<ul>
<li>那就是饿昏头的狮子吃了《地毯》！</li>
<li>就是成为这家当铺的店员，用铲子在这里挖地！</li>
<li>被害人的死因就是「吃太多」质量很差的肥皂所引发的中毒身亡！</li>
</ul>
<blockquote>
<p>龙之介写的人物档案「他的推理每次都让人惊掉下巴。」</p>
</blockquote>
<p><strong>Warning：以下折叠部分包含剧透内容。</strong></p>
<p><strong>Warning：以下折叠部分包含剧透内容。</strong></p>
<p><strong>Warning：以下折叠部分包含剧透内容。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大逆二最终章一连放倒两个法官，打破了逆转史上「法官席无真凶」的定律……好像的确「法官就是真凶」这种展开还是天马行空了一点（</span><br><span class="line"></span><br><span class="line">好吧其实如果是《惯例的老爷爷》的话就不会有问题，但是问题是沃尔特克斯和慈狱都是《有名字的》。</span><br><span class="line"></span><br><span class="line">（↑ 这是什么奇妙的书名号用法）</span><br><span class="line"></span><br><span class="line">此玉正是狼（划掉</span><br><span class="line"></span><br><span class="line">烧起来力！烧起来力！（指法官豹变</span><br></pre></td></tr></table></figure>
<h2 id="Dat-115「？？？」"><a href="#Dat-115「？？？」" class="headerlink" title="Dat 115「？？？」"></a>Dat 115「？？？」</h2><p>平静的一天。</p>
<h2 id="Dat-116「？？？」"><a href="#Dat-116「？？？」" class="headerlink" title="Dat 116「？？？」"></a>Dat 116「？？？」</h2><p>平静的一天。</p>
<h2 id="Dat-117「？？？」"><a href="#Dat-117「？？？」" class="headerlink" title="Dat 117「？？？」"></a>Dat 117「？？？」</h2><p>平静的一天。</p>
<h2 id="Dat-118「？？？」"><a href="#Dat-118「？？？」" class="headerlink" title="Dat 118「？？？」"></a>Dat 118「？？？」</h2><p>平静的一天。</p>
<p>看了一遍大逆转裁判的附加内容里面的《成歩堂龍ノ介の罪深き七日間》。</p>
<p>虽然不知道为什么没有翻译。</p>
<p>而且甚至不能暂停。</p>
<p>好吧其实有暂停不过暂停的时候是看不到字的而且暂停之后一小段时间内不知道为什么听不到语音。</p>
<p>很多时候只能读懂一个大概意思。具体细节就分析不过来了（光速逃</p>
<p>有些时候甚至大概意思都不确定看得对不对（再次光速逃</p>
<p>尤其是第一夜和第四夜的判决篇，福尔摩斯那什么「言えない」「気がしない」一套组合拳打下来直接给我干蒙了（</p>
<p>还有，班吉克斯声音 ao 听 /se</p>
<blockquote>
<p>バンジークス「罪深き被告人 、 成歩堂龍ノ介。</p>
<p>貴公の罪は 、『殺人』。」</p>
</blockquote>
<p>这里应该指的是 1-1 吧。后面还说审判就在明天（指游戏正式版发布）。</p>
<h2 id="Day-119「？？？」"><a href="#Day-119「？？？」" class="headerlink" title="Day 119「？？？」"></a>Day 119「？？？」</h2><p>平静（其实也不是啦）的一天。</p>
<h2 id="Day-120「期末考试-Day-1-3」"><a href="#Day-120「期末考试-Day-1-3」" class="headerlink" title="Day 120「期末考试 Day 1/3」"></a>Day 120「期末考试 Day 1/3」</h2><p>期末考试 Day 1，物理 + 英语。</p>
<p>感觉不良好 .jpg</p>
<p>到了物理考场突然发现一个问题就是，没带计算器。</p>
<p><strong>噔 噔 咚</strong>（绝望</p>
<p>下午英语……只能说整整一年没学过英语了，上课全程划水半个字都不带听一下的（光速逃</p>
<p>选词填空平均一道题一个词不认识，选答案全凭感觉。</p>
<ul>
<li>欸这个词看起来好像带点贬义的样子。</li>
<li>欸这个词看起来像是刚学的的样子。</li>
</ul>
<p>能过应该是能过，不过大概也就仅此而已了（小声</p>
<p>下午有亚洲时间场的 CodeForces Div. 2（17：05 开始，2h），本来想在 xp 裙里问一下有没有人打不过还是算了吧，应该是没有的。</p>
<p>好久没打过 CF 了怕不是要下分。</p>
<p>话说回来 xp 裙改名了。</p>
<h2 id="Day-121「期末考试-Day-2-3」（2022-6-20）"><a href="#Day-121「期末考试-Day-2-3」（2022-6-20）" class="headerlink" title="Day 121「期末考试 Day 2/3」（2022-6-20）"></a>Day 121「期末考试 Day 2/3」（2022-6-20）</h2><p>期末考试 Day 2，高数 + 线代。</p>
<p>而且还是一个上午连着考两门。</p>
<p>拿到高数试卷一看，选择第一题要求计算两条直线的夹角。</p>
<p>结果算了半天 $\cos\theta$ 整出来了一个非常奇怪的数字，好像是 $\frac{11}{23}$ 还是多少。</p>
<p>当时我就方了，啊这为什么我选择第一题都算不对了。</p>
<p>然后大题第三题让算一个函数的极值，然后那个函数里面含 $y$ 的部分居然是 $y^3+12y$。</p>
<p>兄啊这不都无界了吗（半脑</p>
<p>当然最后说是题目出错了。</p>
<p>隐函数怎么搞啊不会啊。结果大题第二道 xjb 写了一通，估计一分都捞不着了。90+ 怕不是没希望了。</p>
<p>然后是线代。感觉就计算量来说的话，线代应该是最大的了。草稿纸整整两面被我几乎写完了。</p>
<p>大题倒数第二道要求二次型的标准型，然后就需要用到那个 $QAQ^{-1}$，就需要用到施密特正交化。</p>
<p>$QAQ^{-1}$（并不是颜文字</p>
<p>结果把 $(\alpha_1,\alpha_2,\alpha_3)$ 算出来之后我突然意识到一个问题，我忘了施密特正交化的式子了。</p>
<p><strong>噔 噔 咚</strong>（绝望</p>
<p>就在这个时候我随手算了一下 $\alpha_1\cdot\alpha_2$，发现……</p>
<p>欸这个东西居然等于 $0$！（感叹号，表达惊讶，不表示阶乘）</p>
<p>然后进一步验证之后我发现，$(\alpha_1,\alpha_2,\alpha_3)$ 已经两两正交了。</p>
<p>乐，都可以乐。</p>
<p>证明题感觉 xjb 写了一通也不知道对不对。这边 90+ 应该也希望不大了。</p>
<h2 id="Day-122「中场休息-Day-1-3」"><a href="#Day-122「中场休息-Day-1-3」" class="headerlink" title="Day 122「中场休息 Day 1/3」"></a>Day 122「中场休息 Day 1/3」</h2><p>平静的一天。</p>
<h2 id="Day-123「中场休息-Day-2-3」"><a href="#Day-123「中场休息-Day-2-3」" class="headerlink" title="Day 123「中场休息 Day 2/3」"></a>Day 123「中场休息 Day 2/3」</h2><p>虽然说是中场休息不过下午还有电路实验考试。</p>
<p>抽到了积分运算电路，xjb 连了一通结果老师过来一看「嗯……不是很理想（连的什么 jb 玩意）」，然后给了个 B。</p>
<h2 id="Day-124「中场休息-Day-3-3」"><a href="#Day-124「中场休息-Day-3-3」" class="headerlink" title="Day 124「中场休息 Day 3/3」"></a>Day 124「中场休息 Day 3/3」</h2><p>平静的一天。</p>
<h2 id="Day-125「期末考试-Day-3-3」"><a href="#Day-125「期末考试-Day-3-3」" class="headerlink" title="Day 125「期末考试 Day 3/3」"></a>Day 125「期末考试 Day 3/3」</h2><p>上午离散。</p>
<p>感觉比想象中难了那么一些，怪不得考试前三天老师一只在群里催我们复习。</p>
<p>两道逻辑演算题一道写到一半发现条件写假了，一道只证明出来一般的结论。</p>
<p>下午电路。</p>
<p>觉得电路可能会有一些复杂的计算于是带上了计算器。结果一次都没有用上。全是字母（</p>
<p>感觉题型有那么的一些出乎意料，不过这种程度没有问题的！（大嘘</p>
<p>收卷的时候看了一眼前桌同学的答案突然发现自己第一大题第三小题算平均有功功率的时候直接用的是最大值。</p>
<p><strong>噔 噔 咚</strong>（绝望</p>
<p>老师，菜菜，捞捞，呜呜 .jpg</p>
<p><del>犯什么病啊你又不需要捞（</del></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title>Logic Puzzle Pack</title>
    <url>/logic-puzzle-pack/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/bundle/3331/Logic_Puzzle_Pack/">Steam 页面</a></p>
<p>没错这次是一个系列一共五款游戏。</p>
<p>这篇文章多少会涉及到一些关于一些基本游戏机制的剧透……不过这种程度应该还好吧。</p>
<blockquote>
<p>块「这是扫雷？」</p>
</blockquote>
<a id="more"></a>
<p><img src="/img/20220711101627_1.jpg" alt="Hexcells 1-1"></p>
<p>如图所示，这的确是一款有些类似扫雷的游戏。</p>
<p><img src="/img/20220711101806_1.jpg" alt="Hexcells 3-2"></p>
<p><img src="/img/20220711101815_1.jpg" alt="Hexcells 3-4"></p>
<p>不过不只是扫雷。</p>
<p>如同很多类似的解谜游戏一样，这里面所有的谜题都是能够在不依靠瞎蒙乱猜的前提下完成的……大概罢。</p>
<p>一开始，尤其是第一作 Hexcells 的时候，这个游戏看起来还十分的小清新。但是到了第三作 Hexcells Infinite，事情就开始变得诡异起来了。</p>
<p><img src="/img/20220711101947_1.jpg" alt="Hexcells Infinite 6-3（这么点条件能做？）"></p>
<p><img src="/img/20220711101936_1.jpg" alt="Hexcells Infinite 6-5（地狱绘图）"></p>
<p>觉得必须有一点要指出来的是，这游戏的机制是，每次将一个小格染色的时候，颜色对不对会直接有反馈，并且如果要拿到满星评价的话，整个过程中不能失误一次（手抖也不行）（后期有些关卡会允许至多一次的失误）。</p>
<p>我个人认为这是不好的设计。很多时候一不小心手都一下可能满星评价就没了。然后如果还想拿到满星评价的话，就必须要从头再玩一遍，或者把最终的图案截图下来然后对着这个一个一个点过去。</p>
<p>我觉得可以借鉴一下隔壁 <a href="https://store.steampowered.com/app/642650/Peppers_Puzzles/">Pepper’s Puzzles</a> 的设计：染色的时候无法直接知道这个格子的颜色是否正确。只有把所有格子全部染色之后，才能知道是否所有格子的颜色都是正确的。如果有不正确的格子也不会有提示，需要回过头去修改直到所有格子颜色正确。</p>
<p>这样做虽然可能会出现一个失误导致满盘皆输的情况，不过总体而言肯定要比现在这样过分强调一遍全对的机制要好。</p>
<p>关于后两作 SquareCells 和 CrossCells……那就是完全不同的两个游戏了。读者可自行尝试。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>解谜</tag>
      </tags>
  </entry>
  <entry>
    <title>OI Team Meating：2022-07-24</title>
    <url>/oi-team-meating-220724/</url>
    <content><![CDATA[<p>感觉阿烜一天比一天蛤蟆了。</p>
<a id="more"></a>
<p>预定 11：00 到，结果因为一些预想外的事情耽误了 1.5h+，到的时候已经 11：40 了。</p>
<p>地点是主席家的会议室。</p>
<p>中午一起去吃了华莱士。于是阿潮下午的时候真的喷射出来了。</p>
<p>然后下午打了一个下午的红警，虽然因为我完全不会于是毫无游戏体验。</p>
<p>然后他们似乎开了一局三国杀，然而这个我也是一点都不会。</p>
<p>聚会体验极差（绝望</p>
<p>于是这个时候拥有专车接送的主席就回家了。剩下的我们分两路打车去万达吃晚饭。</p>
<p>然后不知道为什么又回到了去年那个绕了一圈结果去吃火锅的地方。结果真的去吃了火锅。</p>
<p>吃完晚饭离开万达之后，不知道为什么又回到了去年那个玩剧本杀的地方。</p>
<blockquote>
<p>（忘了是谁了）「完了，时间线轮回了。」</p>
</blockquote>
<p>于是这次我们不打算开剧本杀然后选了一款名为《鲜血盟约》的桌游。</p>
<p>结果打开说明书就被超级长的游戏规则震撼到了于是不打算玩了。</p>
<p>于是阿烜拿来一盘大富翁。</p>
<p>一开始我玩得顺风顺水，第一个命运格就抽到了「所有人给我 $600$ 元」这样一张牌。</p>
<p>反观旁边的阿陶，碰到的所有命运格要不就是交钱，要不就是直接进监狱。</p>
<p>然后是对面的阿烜，那个入狱格就像家一样踩了一遍又一遍。</p>
<blockquote>
<p>（忘了是谁了）「进狱系男孩了属于是。」</p>
</blockquote>
<p>游戏进行到中盘，R 和我积攒了大量的资本。这个时候阿陶在他的《天目路》上成功地建造了第二栋房子。</p>
<p>于是我就一不小心踩上去了。于是我就要给阿陶 $3000$ 元。</p>
<p>也就是这个时候我的局势开始急转直下，不知不觉间之前积攒的资本<strong>全 部 木 大</strong>。</p>
<p>然后阿陶甚至在他的《天目路》上建起了第三栋房子，踩一脚 $7500$ 元。</p>
<p>这个时候我的所有土地都已经抵押出去了，然后我手上也没有钱了，然后我现在就站在《天目路》前面一个格子。</p>
<blockquote>
<p>我「来个 $1$ 送我走吧。」</p>
</blockquote>
<p>一扔。出 $1$ 了。</p>
<p><strong>一 代 小 资 本 家 的 陨 落。</strong></p>
<p>后续的话就是，那个《天目路》存在某种引力一样，让其他所有人都情不自禁地往上踩了一脚（同时也几乎送走了其他所有人，除了曾经的大资本家 R 和苟延残喘了很长时间结果踩到一个扣除 $2000$ 元的格子暴毙的 zhuoer），让阿陶几乎一夜翻盘，最终以碾压的优势赢得了胜利。</p>
<p><strong>风 水 轮 流 转。</strong></p>
<p>好吧其实也不是，只不过觉得再这么耗下去肯定是阿陶赢于是就这样了。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>同学聚会</tag>
        <tag>颓废</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 2</title>
    <url>/random-solution-pb-2/</url>
    <content><![CDATA[<p>来源：2022 杭电杯 Day 6 1011 Find different。</p>
<a id="more"></a>
<p>设有一个长度为 $l$ 的序列 $x_0,x_1,\dots,x_{l-1}$，其中 $0\leqslant x_i\lt m$。两种操作：</p>
<ol>
<li>$x_i\leftarrow (x_i+1)\bmod m$</li>
<li>$x_i\leftarrow x_{(i+1)\bmod n}$</li>
</ol>
<p>每次操作时，所有 $x_i$ 同时发生变化。</p>
<p>两个序列 $x_0,x_1,\dots,x_{l-1}$ 和 $y_0,y_1,\dots,y_{l-1}$，如果 $x$ 能够通过若干次操作变为 $y$，那么称 $x$ 和 $y$ <strong>本质相同</strong>；否则称 $x$ 和 $y$ <strong>本质不同</strong>。</p>
<p>$(0,2,2)$ 和 $(0,1,0)$ 是本质相同的，因为：</p>
<ol>
<li>进行操作 $1$：$(0,2,2)\rightarrow(1,0,0)$</li>
<li>进行操作 $2$：$(1,0,0)\rightarrow(0,0,1)$</li>
<li>进行操作 $2$：$(0,0,1)\rightarrow(0,1,0)$</li>
</ol>
<p>对于所有 $1\leqslant l\leqslant n$，求出长度为 $l$ 的所有序列中有多少种本质不同的序列。模 $998244353$。</p>
<p>$n,m\leqslant 10^5$。</p>
<p>令 $f(n)$ 为长度为 $n$ 且满足题目要求的序列的数量。</p>
<p>Burnside 引理：集合 $X$ 在群 $\langle G,\times\rangle$ 作用下的等价类数量等于 $G$ 中所有元素作用在集合 $X$ 上时的不动点数量的算术平均值。</p>
<p>令 $X$ 为全体长度为 $n$ 的序列构成的集合；$G=\{(x,y)\mid 0\leqslant x\lt n,0\leqslant y\lt m\}$，其中 $(x,y)\in G$ 表示进行 $x$ 次操作 $2$ 和 $y$ 次操作 $1$。显然两种操作的相对顺序不影响。</p>
<p>定义 $G$ 上的乘法 $\times$ 为</p>
<script type="math/tex; mode=display">
(x_1,y_1)\times(x_2,y_2)=(x_1+x_2\bmod n,y_1+y_2\bmod m)</script><p>显然 $\langle G,\times\rangle$ 是一个群。</p>
<p>考虑在 $(x,y)$ 作用下 $X$ 中的不动点的数量。此时为了方便，把 $x=0$ 看作 $x=n$，$y=0$ 看作 $y=m$。进行 $x$ 次操作 $1$ 会把原序列划分为 $(n,x)$ 个环（简单回路），每个元素移动到对应环上下一个元素的位置上；进行 $y$ 次操作 $2$ 会把所有元素在模 $m$ 意义下加 $y$。如果进行完所有操作之后序列仍保持不变，必是每个元素移动到的位置上原本的数值恰好比自身大 $y$。按照这样推下去，环上的每个元素会比自身大</p>
<script type="math/tex; mode=display">
k\cdot\frac{n}{(n,x)}y\quad(k\geqslant 1)</script><p>那么这就要求</p>
<script type="math/tex; mode=display">
m\Bigm|\frac{n}{(n,x)}y</script><p>于是我们就可以写出答案的表达式</p>
<script type="math/tex; mode=display">
\begin{aligned}
&f(n)\\
=&\sum_{x=1}^n\sum_{y=1}^m\left[m\Bigm|\frac{n}{(n,x)}y\right]m^{(n,x)}\\
=&\sum_{x=1}^n\sum_{y\mid m}\left[\frac{m}{y}\Bigm|\frac{n}{(n,x)}\right]m^{(n,x)}\\
=&\sum_{x=1}^n\sum_{y\mid m}\left[y\Bigm|\frac{n}{(n,x)}\right]m^{(n,x)}\\
=&\sum_{x=1}^n\left(\frac{n}{(n,x)},m\right)m^{(n,x)}\\
=&\sum_{d=1}^n\sum_{x=1}^n\left[(n,x)=d\right]\left(\frac{n}{d},m\right)m^d\\
=&\sum_{d\mid n}\sum_{x=1}^{n/d}\left[\left(\frac{n}{d},x\right)=1\right]\left(\frac{n}{d},m\right)m^d\\
=&\sum_{d\mid n}\varphi\left(\frac{n}{d}\right)\left(\frac{n}{d},m\right)m^d\\
=&\sum_{ij=n}\varphi(i)(i,m)m^j
\end{aligned}</script><p>时间复杂度 $O(n\log n)$。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>群论</tag>
        <tag>Burnside 引理</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Ct. 1</title>
    <url>/random-solution-ct-1/</url>
    <content><![CDATA[<p>来源：<a href="https://codeforces.com/contest/1715">Codeforces Round #816 (Div. 2)</a></p>
<p>为什么是 Ct 呢因为这是一整场比赛的题解。</p>
<p>为什么 tag 这么多呢因为一道题对应两三个 tag。</p>
<a id="more"></a>
<h2 id="A-Crossmarket"><a href="#A-Crossmarket" class="headerlink" title="A. Crossmarket"></a>A. Crossmarket</h2><p>有一个 $n\times m$ 的网格。Stanley 要从 $(1,1)$ 移动到 $(n,m)$，Megan 要从 $(n,1)$ 移动到 $(1,m)$。两个人可以在 $1$ 个单位时间内移动到自己当前所在格子四联通的格子，而且可以任意决定自己的出发时间。除此之外，Megan 会在经过的每个格子上留下传送门，Stanley 可以在 $1$ 个单位时间内在任意两个传送门之间移动。求两人到达各自终点的合计用时最少是多少。</p>
<p>多组数据。$1\leqslant n,m\leqslant 10^5$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>样例解释已经很明显地告诉了我们答案是 $2(n+m-2)-\max\{n-1,m-1\}$。</p>
<p>时间复杂度 $O(1)$，空间复杂度 $O(1)$。</p>
<h2 id="B-Beautiful-Array"><a href="#B-Beautiful-Array" class="headerlink" title="B. Beautiful Array"></a>B. Beautiful Array</h2><p>构造一组 $a_1,a_2,\dots,a_n$ 使得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\left\lfloor\frac{a_i}{k}\right\rfloor=b</script><script type="math/tex; mode=display">
\sum_{i=1}^na_i=s</script><p>或判断无解。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，$1\leqslant k\leqslant 10^9$，$0\leqslant b\leqslant 10^9$，$0\leqslant s\leqslant 10^{18}$。$\sum n\leqslant 10^5$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>显然有解当且仅当</p>
<script type="math/tex; mode=display">
bk\leqslant s\leqslant bk+n(k-1)</script><p>构造也很简单。</p>
<p>时间复杂度 $O(n)$，空间复杂度 $O(n)$。</p>
<h2 id="C-Monoblock"><a href="#C-Monoblock" class="headerlink" title="C. Monoblock"></a>C. Monoblock</h2><p>给定序列 $a_1,a_2,\dots,a_n$。$m$ 次单点修改，每次修改后求</p>
<script type="math/tex; mode=display">
\sum_{1\leqslant l\leqslant r\leqslant n}g(l,r)</script><p>其中 $g(l,r)$ 表示 $a_l,a_{l+1},\dots,a_r$ 的极长连续段数量。</p>
<p>$1\leqslant n,m\leqslant 10^5$，$1\leqslant a_i\leqslant 10^9$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>可以将一次修改 $(x,v)$ 拆分为：删去包含位置 $x$ 的区间的贡献；将 $a_x$ 修改为 $v$；重新统计包含位置 $x$ 的区间的贡献。</p>
<p>甚至初始状态也可以拆分成 $n$ 次修改，第 $i$ 次为 $(i,a_i)$。</p>
<p>然后就……维护一下每个极长连续段的左右端点再写个线段树啥的数据结构查询一下就可以了。</p>
<p>懒得写了。</p>
<p>时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。</p>
<h2 id="D-2-doors"><a href="#D-2-doors" class="headerlink" title="D. 2+ doors"></a>D. 2+ doors</h2><p>设有一序列 $a_1,a_2,\dots,a_n$。有 $m$ 条限制，第 $i$ 条形如 $a_{u_i}\vee a_{v_i}=x_i$，其中 $\vee$ 表示按位或。</p>
<p>求一组字典序最大的解。输入数据保证至少存在一组解。</p>
<p>$1\leqslant n\leqslant 10^5$，$0\leqslant m\leqslant 2\times 10^5$，$1\leqslant u_i,v_i\leqslant n$，$0\leqslant x_i\lt 2^{30}$。</p>
<p>$\texttt{1.5s/256MB}$。</p>
<p>2-SAT。</p>
<p>时间复杂度 $O(n\log x_i)$，空间复杂度 $O(n+m)$。</p>
<h2 id="E-Long-Way-Home"><a href="#E-Long-Way-Home" class="headerlink" title="E. Long Way Home"></a>E. Long Way Home</h2><p>有一张 $n$ 个点 $m$ 条边的无向图，边有边权。每次可以沿着一条给定边移动，消耗的时间等于这条边的边权；也可以从点 $u$ 直接跳跃到点 $v$，消耗时间 $(u-v)^2$。</p>
<p>对于每个点 $i$，求在至多进行 $k$ 次跳跃的前提下，从点 $1$ 到点 $i$ 的最少用时。</p>
<p>$2\leqslant n\leqslant 10^5$，$1\leqslant m\leqslant 10^5$，$1\leqslant k\leqslant 20$，无重边，可能有自环，$1\leqslant$ 边权 $\leqslant 10^9$。</p>
<p>$\texttt{3s/256MB}$。</p>
<p>令 $f(u,i)$ 表示至多进行 $i$ 次跳跃，到达点 $u$ 的最少用时。那么显然 $f(u,0)$ 可以一遍 Dijkstra 求出。</p>
<p>设当前已经求出了 $f(u,i)$。令 $g(u,i)$ 表示表示至多进行 $i$ 次跳跃，且最有一次移动恰好是一次跳跃，到达点 $u$ 的最少用时。有</p>
<script type="math/tex; mode=display">
g(u,i+1)=\min_{v=1}^n\left\{f(v,i)+(u-v)^2\right\}</script><p>这部分可以一遍斜率优化 DP 求出。</p>
<p>在这之后，建立一个超级源点 $0$，向其他每个点连一条边权为 $0$ 的边。令点 $u$ 此时的 <code>dist</code> 为 $g(u,i+1)$，用 Dijkstra 更新一遍从点 $0$ 出发的最短路，此时点 $u$ 最终求得的最短路长度就是 $f(u,i+1)$ 的值。</p>
<p>时间复杂度 $O(k(m\log n+n))$，空间复杂度 $O(n+m)$。</p>
<h2 id="F-Crop-Squares"><a href="#F-Crop-Squares" class="headerlink" title="F. Crop Squares"></a>F. Crop Squares</h2><p><strong>这是一道交互题。</strong></p>
<p>在平面直角坐标系中有一个矩形，四个顶点分别为 $(0,0)$，$(0,m)$，$(n,0)$ 和 $(n,m)$。其中有一个平行于坐标轴的 $1\times 1$ 的正方形被标记了。这个正方形被矩形完全包含。</p>
<p>每次询问，您可以给出一个面积严格为正的简单多边形，交互库会返回这个多边形与被标记正方形的并的面积。这个多边形不需要被矩形完全包含。</p>
<p>您需要在至多 $5$ 次询问内给出被标记正方形的左下角坐标。</p>
<p>$1\leqslant n,m\leqslant 100$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>神仙题。</p>
<p>只需要两次询问。</p>
<p>第一次询问给出一个下图中的蓝色多边形：</p>
<p><img src="https://espresso.codeforces.com/f8fbbde4a353dfda4f4d7b0dc70b75a7fda9d3ff.png" alt=""></p>
<p>其中红色区域是要求的被标记正方形，绿色区域是二者的并。</p>
<p>若被标记正方形左下角坐标为 $(x,y)$，绿色区域面积为 $S$，有</p>
<script type="math/tex; mode=display">
1-S=\frac{1}{2}\left[\frac{m-y}{m}+\frac{m-y-1}{m}\right]=1-\frac{2y+1}{2m}</script><p>可以解得</p>
<script type="math/tex; mode=display">
y=mS-\frac{1}{2}</script><p>第二次询问给出一个下图中的蓝色多边形：</p>
<p><img src="https://espresso.codeforces.com/8974338f17a7555e4d686e2d53d2732b0ef5d2e7.png" alt=""></p>
<p>令绿色区域面积为 $T$，同理有</p>
<script type="math/tex; mode=display">
x=nT-\frac{1}{2}</script><p>时间复杂度 $O(n+m)$，空间复杂度 $O(1)$。</p>
]]></content>
      <categories>
        <category>口胡</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>Codeforces</tag>
        <tag>杂题</tag>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>观察性质</tag>
        <tag>2-SAT</tag>
        <tag>Dijkstra</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>你解锁了『牺牲者污化以撒』</title>
    <url>/epiphany-tr-isaac/</url>
    <content><![CDATA[<p>英文原文是 “Sacrifice”，为了匹配堕化角色解锁成就的命名格式（比如<strong>堕化以撒</strong>解锁成就 “Broken” 被译为「神伤者」）而译为「牺牲者」。</p>
<p>解锁方式：使用<strong>堕化以撒</strong>击败精神错乱。</p>
<p>初始基础属性和<strong>以撒</strong>完全相同；自带一个炸弹；自带次要主动道具 <strong>Blighted Dice</strong>。</p>
<a id="more"></a>
<h2 id="被动能力"><a href="#被动能力" class="headerlink" title="被动能力"></a>被动能力</h2><p><strong>LESS OPTIONS</strong></p>
<p><strong>MORE CONTROL</strong></p>
<p><strong>污化以撒</strong>与<strong>堕化以撒</strong>类似，只能同时持有 $8$ 个被动道具，且剧情道具和<strong>长子名分</strong>不占据被动道具槽。但与<strong>堕化以撒</strong>不同的是，<strong>污化以撒</strong>没有所有道具二选一的能力。</p>
<p>关于 <strong>MORE CONTROL</strong>，见 <strong>Blighted Dice</strong>。</p>
<h2 id="Blighted-Dice"><a href="#Blighted-Dice" class="headerlink" title="Blighted Dice"></a>Blighted Dice</h2><p><strong>Reroll a part of you</strong></p>
<p>道具品质 $4$。</p>
<p>主动道具，$1$ 充能。</p>
<p>无标签。</p>
<p>存在于以下道具池：宝箱房，隐藏房，贪婪模式商店，贪婪模式隐藏房，腐烂乞丐。</p>
<p>使用时，将被动道具槽内当前被选中的道具摧毁，并生成两个随机底座道具，这两个道具均为来自相同道具池内的相同品质道具，且只能拾取一个。</p>
<p>使用后，该道具变为 <strong>Broken Dice</strong>。</p>
<h2 id="Broken-Dice"><a href="#Broken-Dice" class="headerlink" title="Broken Dice"></a>Broken Dice</h2><p><strong>Ruined destiny</strong></p>
<p>道具品质 $4$。</p>
<p>主动道具，$6$ 充能。</p>
<p>标签：非伊甸</p>
<p>不在任何道具池内且为隐藏道具。</p>
<p>该道具可以在任意充能时使用。使用时，不消耗充能并触发 <strong>Blighted Dice</strong> 的使用效果，但只生成一个底座道具，同时移除角色的一个心之容器或两颗魂心（可能致死）。</p>
<p>满充能时，该道具转化为同样满充能的 <strong>Blighted Dice</strong>。</p>
<p>持有未满充能的该道具时，若触碰底座道具，角色会将其摧毁，然后将该道具充能至满充能。如果角色处于这种状态下，被触碰后会被摧毁的底座道具会变得半透明。触碰由 <strong>Blighted Dice</strong> 的使用效果生成的底座道具或剧情道具不会触发这一条。</p>
<p><strong>游魂</strong>使用该道具会立即死亡。这一条同样适用于<strong>堕化游魂</strong>，虽然在通常的游戏流程中<strong>堕化游魂</strong>无法遇到该道具，因为其没有「攻击性」标签。</p>
<p><strong>堕化雅各之魂</strong>能够正常使用该道具。</p>
<h2 id="长子名分"><a href="#长子名分" class="headerlink" title="长子名分"></a>长子名分</h2><p><strong>Better options</strong></p>
<p><strong>更好的选择</strong></p>
<p>触发 <strong>Blighted Dice</strong> 的使用效果时，生成的底座道具有 $25\%$ 变为被摧毁的道具品质 $+1$ 的道具。</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><ol>
<li>若持有未满充能的 <strong>Broken Dice</strong>，角色总是会摧毁遇到的第一个被动底座道具。<strong>千万不要在这种情况下触碰强力道具。剧情道具可以无视这一条，但必须注意的是长子名分在这种情况下会被摧毁，尽管它在某些方面拥有类似于剧情道具的性质。</strong></li>
<li>若未持有<strong>长子名分</strong>，使用 <strong>Blighted Dice</strong> 摧毁道具只会得到品质相同的道具，这意味着无论摧毁多少个低品质道具都无法使得角色获得较大的提升。</li>
<li>使用 <strong>Blighted Dice</strong> 摧毁道具时，生成的底座道具会从被摧毁的道具出现的所有道具池中抽取，而与角色实际在哪个道具池中遇到该道具无关。以<strong>五芒星</strong>为例，即使角色通过 BOSS 掉落的形式获取该道具，将其摧毁时仍然可能会生成恶魔房道具池甚至是究极隐藏房道具池的道具。</li>
<li>即使一个道具已经因为被角色拾取过而被移除出道具池，它仍然可能被 <strong>Blighted Dice</strong> 生成。</li>
<li>BOSS 房的 $1$ 级道具中有很多提供心之容器的道具，这类道具即使被放下不会收回已经获得的心之容器。使用 <strong>Blighted Dice</strong> 摧毁一个这类道具大概率会得到另外两个提供心之容器的道具。这相当于 $6$ 格充能换取至少一个心之容器的血量，而且如果当前层存在确定不需要的其他道具则还可以牺牲它们来换取充能。重复这样做，角色可以获得大量的心之容器用于获取恶魔交易等用途。</li>
<li>若未持有<strong>长子名分</strong>，使用 <strong>Blighted Dice</strong> 无法得到高品质的道具，这使得<strong>污化以撒</strong>在获取高品质道具方面不如<strong>堕化以撒</strong>。因为虽然前者能够通过 <strong>Blighted Dice</strong> 产生多次而不仅仅是一次二选一，这些二选一的品质始终是确定的；而后者则有可能在虽然仅有一次的二选一中获得高品质道具。</li>
<li><strong>逆位审判</strong>可以在当前房间生成补货机，可以将 <strong>Blighted Dice</strong> 生成的道具重置为当前房间道具池的道具。可以在天使房 / 恶魔房 / 隐藏房使用这一策略，因为这些房间道具池的道具平均质量较高。隐藏房有时会出现天然生成的补货机，也可以加以利用。</li>
<li>剩余部分基本上和<strong>堕化以撒</strong>类似，如<strong>糖果心</strong>，<strong>灵魂吊坠</strong>，<strong>店长的胯袋</strong>，<strong>谷底石</strong>等道具能够给角色带来极大的属性提升；<strong>虚空</strong>，<strong>无底坑</strong>等道具能够回收利用角色不得不放下的道具等。</li>
</ol>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>以撒的结合</tag>
        <tag>MOD</tag>
        <tag>Epiphany</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Ct. 2</title>
    <url>/random-solution-ct-2/</url>
    <content><![CDATA[<p>来源：<a href="https://codeforces.com/contest/1725">COMPFEST 14 - Preliminary Online Mirror (Unrated, ICPC Rules, Teams Preferred)</a></p>
<p>21：35 开始 5h，02：35 结束。</p>
<blockquote>
<p>群友「多打打，运气好直接少走 $70$ 年弯路。」</p>
</blockquote>
<p>当然我是 1：00 就去睡觉了，剩下一个 C 交给 chr 写了。</p>
<p>当然之前 20：00 的 ARC 我是不可能一不小心下了一波小分的。没有这种事。</p>
<a id="more"></a>
<h2 id="A-Accumulation-of-Dominoes"><a href="#A-Accumulation-of-Dominoes" class="headerlink" title="A. Accumulation of Dominoes"></a>A. Accumulation of Dominoes</h2><p>有一个 $N\times M$ 的网格写有数字，第一行从左到右依次是 $1,2,\dots,M$，第二行是 $M+1,M+2,\dots,2M$，以此类推。试求有多少对格子四联通且数字相差恰好 $1$。</p>
<p>$1\leqslant N,M\leqslant 10^9$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>签到题一号。</p>
<p>显然 $M\gt 1$ 时答案为 $N\times(M-1)$；$M=1$ 时答案为 $N-1$。</p>
<h2 id="B-Basketball-Together"><a href="#B-Basketball-Together" class="headerlink" title="B. Basketball Together"></a>B. Basketball Together</h2><p>有 $N$ 个人，第 $i$ 个人的力量是 $P_i$。可以把若干个人组成队伍，这样同一个队伍里的所有人的力量都会变为队伍中力量最大的人的力量。一个队伍是合法的当且仅当其中所有人的力量之和严格大于 $D$。试求至多能组成多少个合法的队伍。</p>
<p>$1\leqslant N\leqslant 10^5$，$1\leqslant D,P_i\leqslant 10^9$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>签到题二号。</p>
<p>显然最优策略是选定一个剩下的人里面力量最大的。设这个人的力量为 $A$，那么在从剩下的人里面抽出来力量最小的 $\left\lceil\frac{D+1}{A}\right\rceil-1$ 个人凑成一个队伍即可。</p>
<h2 id="G-Garage"><a href="#G-Garage" class="headerlink" title="G. Garage"></a>G. Garage</h2><p>如果一个正整数 $x$ 能够被表示成 $b^2-a^2$ 的形式，其中 $1\lt a\lt b$，那么称 $x$ 是好的。试求第 $N$ 小的好的正整数。</p>
<p>$1\leqslant N\leqslant 10^9$。</p>
<p>$\texttt{1s/128MB}$。</p>
<p>当然，OEIS 上是能够找到这个数列的。它是 <a href="http://oeis.org/A024352">A024352</a>。</p>
<p>我们可以看到，有 $a_n=4+\left\lfloor\frac{4n-3}{3}\right\rfloor\;(n\gt 1)$。特殊地，$a_1=3$。</p>
<h2 id="M-Moving-Both-Hands"><a href="#M-Moving-Both-Hands" class="headerlink" title="M. Moving Both Hands"></a>M. Moving Both Hands</h2><p>有一张 $N$ 个点 $M$ 条边的有向图，无重边，无自环，边有边权。现在 Challestend 想要玩一个游戏：首先将他的两只手分别放在两个不同的点上。每次他可以将其中一只手沿着一条边移动到一个相邻的点。这一过程需要花费的时间等于边的边权。如果某个时刻 Challestend 的两只手停留在了同一个点上，那么结束游戏。</p>
<p>试求，对于所有 $2\leqslant p\leqslant N$，如果 Challestend 的左手放在 $1$ 号点上，右手放在 $p$ 号点上，那么他是否能够在有限时间内结束游戏，以及如果答案为是，结束游戏的最短用时是多少。</p>
<p>$2\leqslant N\leqslant 10^5$，$0\leqslant M\leqslant 2\times 10^5$，边权 $1\leqslant W_i\leqslant 10^9$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>日常花式求最短路。相当于求 $1$ 到 $p$ 的最短路，但是要求路径的前半段正常走，后半段要按照边的反方向走。</p>
<p>总之就是正着求一遍最短路然后倒着再求一遍就可以了。</p>
<h2 id="H-Hot-Black-Hot-White"><a href="#H-Hot-Black-Hot-White" class="headerlink" title="H. Hot Black Hot White"></a>H. Hot Black Hot White</h2><p>令 $\operatorname{concat}(x,y)$ 表示将 $x$ 和 $y$ 在 $10$ 进制下拼接起来得到的数，如 $\operatorname{concat}(10,24)=1024$。</p>
<p>给定 $N$ 个数 $A_1,A_2,\dots,A_N$，保证 $N$ 是偶数。将这 $N$ 个数分成两类，每类 $\frac{N}{2}$ 个。如果存在一个数 $Z\in[0,3)$，使得对于任意一对被分到不同类的 $A_i$ 和 $A_j$，都有</p>
<script type="math/tex; mode=display">
\operatorname{concat}(A_i,A_j)\times\operatorname{concat}(A_j,A_i)+A_i\times A_j\not\equiv Z\pmod 3</script><p>那么这种分类方案是好的。试给出一种好的分类方案并给出对应的 $Z$。</p>
<p>$2\leqslant N\leqslant 10^5$，$1\leqslant A_i\leqslant 10^9$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>众所周知，一个数模 $3$ 等于它的 $10$ 进制数位和模 $3$。根据这一条性质，我们能够很容易地得出</p>
<script type="math/tex; mode=display">
\operatorname{concat}(x,y)\equiv x+y\pmod 3</script><p>于是限制条件可以整理为</p>
<script type="math/tex; mode=display">
A_i^2+A_j^2\not\equiv Z\pmod 3</script><p>$0,1,2$ 平方之后分别变为 $0,1,1$。那么相当于将 $N$ 个 $0$ 或 $1$ 分成两类，并且找到一个数使得它不能通过从两类中分别选出一个数相加得到。不难发现，$0$ 比较多时可以取 $2$，$1$ 比较多时可以取 $0$。</p>
<h2 id="C-Circular-Mirror"><a href="#C-Circular-Mirror" class="headerlink" title="C. Circular Mirror"></a>C. Circular Mirror</h2><p>一个圆上排列着 $N$ 个标记点，顺时针标记为 $1,2,\dots,N$。对于 $1\leqslant i\lt N$，$i$ 号点到 $i+1$ 号点之间的弧长为 $D_i$；$N$ 号点到 $1$ 号点之间的弧长为 $D_N$。</p>
<p>现在需要用 $1\sim M$ 的 $M$ 种颜色给每个标记点上色，且不能出现构成直角三角形的三个标记点颜色均相同的情况。求方案数，对 $998244353$ 取模。</p>
<p>$1\leqslant N\leqslant 3\times 10^5$，$2\leqslant M\leqslant 3\times 10^5$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>以下仅考虑 $N\gt 2$。</p>
<p>考虑直径穿过的一对标记点，如果这两个标记点颜色相同，那么用于这两个标记点的颜色就不能用于其他标记点；如果这两个标记点颜色不同，那么并没有什么其他限制。</p>
<p>设一共有 $K$ 对标记点被直径穿过。考虑枚举有 $i$ 对标记点颜色相同，可以很容易地得到答案为</p>
<script type="math/tex; mode=display">
\sum_{i=0}^K{K\choose i}{M\choose i}i!(M-i)^{K-i}(M-i-1)^{K-i}(M-i)^{N-2K}</script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>杂题</tag>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>Dijkstra</tag>
        <tag>简单题</tag>
        <tag>贪心</tag>
        <tag>OEIS</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 3</title>
    <url>/random-solution-pb-3/</url>
    <content><![CDATA[<p>来源：<a href="https://atcoder.jp/contests/abc268/tasks/abc268_f">ABC268 F Best Concatenation</a></p>
<a id="more"></a>
<p>给定 $N$ 个只包含 $\texttt 1$ 到 $\texttt 9$ 的数字和字符 $\texttt X$ 的非空字符串 $S_1,S_2,\dots,S_N$。您需要将这 $N$ 个字符串拼接成一个大串 $T$，即确定一个长度为 $N$ 的排列 $P$ 然后令</p>
<script type="math/tex; mode=display">
T=S_{P_1}+S_{P_2}+\cdots+S_{P_N}</script><p>在这之后，对于每一个满足 $1\leqslant i\lt j\leqslant|T|$ 的 $(i,j)$，如果 $T_i=\texttt X$ 且 $T_j$ 是数字，那么您获得与 $T_j$ 的数值相等的分数。试求您能够获得的最终分数的最大值。</p>
<p>$2\leqslant N\leqslant 2\times 10^5$，$\sum|S_i|\leqslant 2\times 10^5$。</p>
<p>$\texttt{2s/1024MB}$。</p>
<p>也不知道我这个题意说的清不清楚。</p>
<p>总之就是如果前面有一个 ‘X’ 后面有一个数字那么就获得那个数字那么多的分数。然后求最大分数。</p>
<p>对于每个 $S_i$，令 $A_i$ 表示其中 $\texttt X$ 的数量，$B_i$ 表示其中数字的值的总和。</p>
<p>考虑已经确定了排列 $P$。此时若交换 $P_i$ 和 $P_{i+1}$，不难发现分数变化量为</p>
<script type="math/tex; mode=display">
A_{P_{i+1}}B_{P_i}-A_{P_i}B_{P_{i+1}}</script><p>如果 $P$ 是最优解，上面这个变化量需要 $\leqslant 0$。整理一下得到</p>
<script type="math/tex; mode=display">
\frac{A_{P_i}}{B_{P_i}}\geqslant\frac{A_{P_{i+1}}}{B_{P_{i+1}}}</script><p>即 $\frac{A_{P_i}}{B_{P_i}}$ 单调不增。</p>
<p>那么把所有 $\frac{A_i}{B_i}$ 算出来排个序即可。注意特殊处理一下 $B_i=0$ 的情况。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC 2022 网络赛 Round 2 部分题解</title>
    <url>/icpc-2022-net-contest-round-2/</url>
    <content><![CDATA[<p>还没有题面。等拿到题面了再补。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>ICPC</tag>
        <tag>2022</tag>
        <tag>网络赛</tag>
        <tag>施工中</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Ct. 4</title>
    <url>/random-solution-ct-4/</url>
    <content><![CDATA[<p>第一次试图在实验室过夜并打 Codeforces Global Round。</p>
<blockquote>
<p>d*m「听上去很容易下分的样子。」</p>
</blockquote>
<p>85 min 写出来四题我觉得已经可以开香槟了。这波上大分。</p>
<p>于是从考场偷偷溜出来写一写题解（</p>
<p>用户名 CLT，如果想要 AC 代码请去 CF 翻提交记录。（考场代码，不保证可读性）</p>
<a id="more"></a>
<h2 id="A-Glory-Addicts"><a href="#A-Glory-Addicts" class="headerlink" title="A. Glory Addicts"></a>A. Glory Addicts</h2><p>您有 $n$ 个技能。第 $i$ 个技能的类型为 $a_i$（只能为 $0$ 或 $1$，$0$ 表示火属性技能，$1$ 表示冰属性技能），威力为 $b_i$。</p>
<p>您需要将这 $n$ 个技能每个释放恰好一遍。</p>
<p>如果释放一个技能时，之前刚刚释放过一个不同类型的技能，那么当前这个技能威力翻倍。</p>
<p>试求所有技能实际威力之和的最大值。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，$a_i\in\{0,1\}$，$1\leqslant b_i\leqslant 10^9$。$\sum n\leqslant 10^5$。</p>
<p>$\texttt{2s/512MB}$。</p>
<p>假设火属性技能的数量严格大于冰属性技能的数量，那么有一种思路是：</p>
<ol>
<li>释放威力最低的火属性技能</li>
<li>释放威力最高的冰属性技能</li>
<li>释放威力最高的火属性技能</li>
<li>释放威力第二高的冰属性技能</li>
<li>释放威力第二高的火属性技能</li>
<li>……（如此重复直到所有的冰属性技能均被释放过）</li>
<li>释放剩余的火属性技能</li>
</ol>
<p>这样一来，所有的冰属性技能和等数量的威力最高的火属性技能被以双倍威力释放。</p>
<p>反过来，如果释放的第一个技能是威力最低的冰属性技能，模拟一遍会发现，除了这个威力最低的冰属性技能的威力从双倍变成了单倍，其他方面没有任何变化。因此，火属性技能较多时，释放的第一个技能应当是火属性技能。</p>
<p>同理，冰属性技能较多时，释放的第一个技能应当是冰属性技能。</p>
<p>但是如果两种技能恰好数量相同，那么就不得不牺牲一个威力最低的技能了（它只能以单倍威力释放）。</p>
<h2 id="B-Prefix-Sum-Addicts"><a href="#B-Prefix-Sum-Addicts" class="headerlink" title="B. Prefix Sum Addicts"></a>B. Prefix Sum Addicts</h2><p>假设有一个长度为 $n$ 的单调不下降序列 $a$。定义其前缀和序列 $s$ 为</p>
<script type="math/tex; mode=display">
s_i=\sum_{j=1}^ka_j</script><p>现在给定 $s_{n-k+1},s_{n-k+2},\dots,s_n$，试求是否存在一个符合条件的 $a$。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，$1\leqslant k\leqslant n$，$|s_i|\leqslant 10^9$。$\sum n\leqslant 10^5$。</p>
<p>$\texttt{2s/512MB}$。</p>
<p>如果 $k=1$ 那么必定有解。以下考虑 $k\gt 1$。</p>
<p>首先肯定是检查一下它给的这部分 $s$ 是否满足差分单调不下降。</p>
<p>然后如果 $k=n$ 还需要有 $s_1\leqslant s_2-s_1$。</p>
<p>然后令 $x=s_{n-k+2}-s_{n-k+1}$，那么对于所有的 $1\leqslant i\leqslant n-k+1$，需要有 $a_i\leqslant x$。</p>
<p>那么显然只要 $(n-k+1)x\geqslant s_{n-k+1}$ 就必定会有解。至于这个解具体长什么样，这不重要。</p>
<h2 id="C-Even-Number-Addicts"><a href="#C-Even-Number-Addicts" class="headerlink" title="C. Even Number Addicts"></a>C. Even Number Addicts</h2><p>Alice 和 Bob 在一起玩游戏。</p>
<p>现在他们面前有 $n$ 个数 $a_1,a_2,\dots,a_n$。每次一个人可以选择其中的一个数，将其加入自己的得分，然后将其删去。Alice 先手。</p>
<p>等到所有数都被删去之后，如果 Alice 的得分是偶数，那么 Alice 获胜；否则，即若 Alice 的得分是奇数，那么 Bob 获胜。</p>
<p>Alice 和 Bob 都足够聪明。试判断谁会获胜。</p>
<p>多组数据。$1\leqslant n\leqslant 100$，$|a_i|\leqslant 10^9$。$1\leqslant T\leqslant 100$，这里 $T$ 表示数据组数。</p>
<p>$\texttt{2s/512MB}$。</p>
<p>令 $O(x,y)$ 表示当前剩余 $x$ 个奇数和 $y$ 个偶数，且 Alice 先手时，Alice 能否让自己的最终得分为奇数。</p>
<p>$E(x,y)$ 类似，不过是能否让自己的最终得分为偶数。</p>
<p>首先考虑边界条件。手玩一下可以发现</p>
<script type="math/tex; mode=display">
O(4k+1,0)=\texttt{T}\quad O(4k+2,0)=\texttt{T}\quad(k\geqslant 0)</script><script type="math/tex; mode=display">
O(4k+3,0)=\texttt{F}\quad O(4k+4,0)=\texttt{F}\quad(k\geqslant 0)</script><script type="math/tex; mode=display">
O(0,k)=\texttt{F}\quad(k\gt 0)</script><script type="math/tex; mode=display">
E(4k+1,0)=\texttt{F}\quad E(4k+2,0)=\texttt{F}\quad(k\geqslant 0)</script><script type="math/tex; mode=display">
E(4k+3,0)=\texttt{T}\quad E(4k+4,0)=\texttt{T}\quad(k\geqslant 0)</script><script type="math/tex; mode=display">
E(0,k)=\texttt{T}\quad(k\gt 0)</script><p>其中 $\texttt{T}$ 表示 <code>true</code>，$\texttt{F}$ 表示 <code>false</code>。</p>
<p>考虑 $x\geqslant 1$ 且 $y\geqslant 1$ 时。此时 Alice 有两种选择：删去一个奇数，或者删去一个偶数。</p>
<p>如果 Alice 希望她的得分是奇数，且她选择删去一个奇数，那么当前局面变为 $x-1$ 个奇数和 $y$ 个偶数，且 Alice 之后的得分需要是偶数。</p>
<p>此时 Bob 同样有两种选择：（$x\geqslant 2$ 时才可以）删去一个奇数，或者（任何情况都可以）删去一个偶数。</p>
<p>这两种情况分别对应了 $(x=1\vee E(x-2,y))$ 和 $E(x-1,y-1)$。显然只有这两种情况的结果均为 $\texttt{T}$ 时 Alice 才能获胜。</p>
<p>以此类推，还有如下三种情况：</p>
<ol>
<li>Alice 希望她的得分是奇数，且她选择删去一个偶数</li>
<li>Alice 希望她的得分是偶数，且她选择删去一个奇数</li>
<li>Alice 希望她的得分是偶数，且她选择删去一个偶数</li>
</ol>
<p>总而言之我们有</p>
<script type="math/tex; mode=display">
O(x,y)=OO(x,y)\vee OE(x,y)</script><script type="math/tex; mode=display">
E(x,y)=EO(x,y)\vee EE(x,y)</script><p>其中</p>
<script type="math/tex; mode=display">
OO(x,y)=(x=1\vee E(x-2,y))\wedge E(x-1,y-1)</script><script type="math/tex; mode=display">
OE(x,y)=(y=1\vee O(x,y-2))\wedge O(x-1,y-1)</script><script type="math/tex; mode=display">
EO(x,y)=(x=1\vee O(x-2,y))\wedge O(x-1,y-1)</script><script type="math/tex; mode=display">
EE(x,y)=(y=1\vee E(x,y-2))\wedge E(x-1,y-1)</script><p><del>读者可自行验证正确性。</del></p>
<h2 id="D-Permutation-Addicts"><a href="#D-Permutation-Addicts" class="headerlink" title="D. Permutation Addicts"></a>D. Permutation Addicts</h2><p>给定一个长度为 $n$ 的排列 $a_1,a_2,\dots,a_n$ 和 $0\leqslant k\leqslant n$。</p>
<p>现构造序列 $b$。对于每个 $1\leqslant i\leqslant n$：</p>
<ol>
<li>如果 $a_i\leqslant k$，令 $b_{a_i}$ 的值为所有满足 $1\leqslant j\lt i$ 且 $a_j\gt k$ 的 $j$ 中最大的 $j$ 对应的 $a_j$。如果不存在这样的 $j$，令 $b_{a_i}$ 的值为 $n+1$。</li>
<li>如果 $a_i\gt k$，令 $b_{a_i}$ 的值为所有满足 $1\leqslant j\lt i$ 且 $a_j\leqslant k$ 的 $j$ 中最大的 $j$ 对应的 $a_j$。如果不存在这样的 $j$，令 $b_{a_i}$ 的值为 $0$。</li>
</ol>
<p>现给定构造好的 $b$，要求还原出 $k$ 的值和整个的 $a$。多解则任意输出。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，$0\leqslant b_i\leqslant n+1$。$\sum n\leqslant 10^5$。输入数据保证有解。</p>
<p>$\texttt{2s/512MB}$。</p>
<p>为了方便，以下称 $\leqslant k$ 的数为小数，$\gt k$ 的数为大数。</p>
<p>如果 $b_y=x$，一种简单的思路就是直接把 $y$ 摆在 $x$ 右侧一个位置。$x=0$ 和 $x=n+1$ 的情况则是摆在排列最左侧。</p>
<p>如果有多个两两不同的 $y_1,y_2,\dots,y_s$ 满足 $b_{y_i}=x$，那么这些 $y_i$ 都摆在 $x$ 右侧最靠近的位置即可，且它们之间的相对顺序无影响。</p>
<p>但是可能会存在一些 $z_1,z_2,\dots,z_t$ 满足 $b_{z_j}=y_{i_0}$，这样的话 $y_{i_0}$ 必须要在其他 $y_i$ 的右侧，然后再往右侧直接接 $z_j$。</p>
<p>考虑到，无论如何，$y_i$ 和 $z_j$ 不可能同时是小数或大数，必定是以下两种情况恰好之一：</p>
<ol>
<li>$y_i$ 都是小数，$z_j$ 都是大数。</li>
<li>$y_i$ 都是大数，$z_j$ 都是小数。</li>
</ol>
<p>如果存在超过两个 $y_{i_0}$，那么无论如何排列这些 $y_i$，都会出现要么有一些 $z_j$ 无法紧跟在对应的 $y_{i_0}$ 的右侧，要么两个相邻的 $y_j$ 之间插入了一些 $z_j$（这样 $b_{y_j}$ 的值会不对）。这不符合题目的「保证有解」的限制条件，即每次这样的 $y_{i_0}$ 至多存在一个。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>杂题</tag>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>简单题</tag>
        <tag>博弈论</tag>
        <tag>公平组合游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Ct. 3</title>
    <url>/random-solution-ct-3/</url>
    <content><![CDATA[<p>今天 ACM 实验室的一场原题大赛。</p>
<p>把其中一些觉得稍微有点意思的题跳了出来写一写题解。</p>
<p>今日题源 :</p>
<ul>
<li>A: 1426A (*800)</li>
<li>B1: 1560F1 (*1900)</li>
<li>B2: 1560F2 (*2100)</li>
<li>C: 1509B (*1100)</li>
<li>D: 1295E (*2200)</li>
<li>E: 1608B (*1200)</li>
<li>F: 1612D (*1600)</li>
<li>G: 1624D (*1400)</li>
<li>H: 1495C (*2300)</li>
<li>I: 771A (*1500)</li>
<li>J: 583A (*1000)</li>
</ul>
<p>差点就 AK 了。以及被三队暴打。</p>
<a id="more"></a>
<h2 id="C-TMT-Document"><a href="#C-TMT-Document" class="headerlink" title="C. TMT Document"></a>C. TMT Document</h2><p>给定一个长度为 $n$ 且只包含 $\texttt{T}$ 和 $\texttt{M}$ 两种字符的字符串 $S$。保证 $3\mid n$。现在需要把 $S$ 分割成若干个互不相交的子序列，且每个子序列都是 $\texttt{TMT}$（$\texttt{Towa Maji Tenshi}$）。试判断是否可能。</p>
<p>多组数据。$3\leqslant n\lt 10^5$。$\sum n\leqslant 10^5$。</p>
<p>$\texttt{1s/256MB}$。</p>
<p>其实……只要把前 $\frac{n}{3}$ 个 $\texttt{T}$ 和后 $\frac{n}{3}$ 个 $\texttt{T}$ 匹配，然后每对 $\texttt{T}$ 中间再塞一个 $\texttt{M}$ 就可以了。</p>
<p>但是考场被牛客还是哪里的一道 $\texttt{red}$ 题带偏了，写了好几发没过于是暂时搁置了。</p>
<p>最后回头重新看这道题的时候感觉当时的自己就是个**。</p>
<h2 id="D-Permutation-Separation"><a href="#D-Permutation-Separation" class="headerlink" title="D. Permutation Separation"></a>D. Permutation Separation</h2><p>给定一个长度为 $n$ 的 $1\sim n$ 的排列 $p$ 和另外一个长度为 $n$ 的序列 $a$。</p>
<p>首先选定 $1\leqslant k\lt n$，将 $p$ 分割成 $S_L=\{p_1,p_2,\dots,p_k\}$ 和 $S_R=\{p_{k+1},p_{k+2},\dots,p_n\}$ 两个集合。然后执行如下操作若干次（可以是 $0$ 次）：</p>
<p>选定 $1\leqslant i\leqslant n$，支付 $a_i$ 的代价将 $p_i$ 其移动到另外一个集合——即，如果 $p_i\in S_L$，将 $p_i$ 从 $S_L$ 中删去并加入 $S_R$；反之亦然。</p>
<p>目标是不存在 $x\in S_L$ 和 $y\in S_R$ 使得 $x\gt y$。试求达成目标需要支付的最小代价。</p>
<p>值得注意的是，如果操作后 $S_L=\varnothing$ 或 $S_R=\varnothing$，算作目标被达成。</p>
<p>$2\leqslant n\leqslant 2\times 10^5$，$1\leqslant p_i\leqslant n$，$1\leqslant a_i\leqslant 10^9$。</p>
<p>$\texttt{2s/256MB}$。</p>
<p>虽然这是不符合题目要求的，但是让我们首先考虑一下 $k=0$ 时的情况。</p>
<p>定义 $f(i)$ 表示，在当前的 $k$ 的取值下，通过若干次操作将 $S_L$ 变为 $\{1,2,\dots,i\}$ 的最小代价。特殊地，$f(0)$ 表示将 $S_L$ 变为 $\varnothing$ 的最小代价。</p>
<p>不难得出</p>
<script type="math/tex; mode=display">
f(0)=0</script><script type="math/tex; mode=display">
f(i)=\sum_{j=1}^ia_{q_i}</script><p>其中 $q$ 表示 $p$ 的逆排列。</p>
<p>如果现在将 $k$ 的值增加 $1$，考虑 $f(i)$ 会如何变化。</p>
<p>（以下的 $k$ 的值都是增加后的）</p>
<p>$f(p_k),f(p_k+1),\dots,f(n)$ 会减少 $a_k$，因为现在 $p_k$ 已经在 $S_L$ 中了。</p>
<p>相对地，$f(0),f(1),\dots,f(p_k-1)$ 会增加 $a_k$，因为现在 $p_k$ 已经不在 $S_R$ 中了。</p>
<p>那么对于当前 $k$ 的取值，答案显然是</p>
<script type="math/tex; mode=display">
\min_{i=0}^nf(i)</script><p>最终答案就是 $k$ 的所有取值对应答案的 $\min$。这可以很容易地通过线段树维护区间加 + 区间 $\min$ 求解。</p>
<h2 id="F-X-Magic-Pair"><a href="#F-X-Magic-Pair" class="headerlink" title="F. X-Magic Pair"></a>F. X-Magic Pair</h2><p>给定 $(a,b)$ 和 $x$。执行如下两种操作之一若干次（可以是 $0$ 次）：</p>
<ol>
<li>将 $a$ 变为 $|a-b|$。</li>
<li>将 $b$ 变为 $|a-b|$。</li>
</ol>
<p>试求能否把 $a$ 或者 $b$ 变为 $x$。</p>
<p>多组数据。$1\leqslant a,b,x\leqslant 10^{18}$。</p>
<p>$\texttt{2s/512MB}$。</p>
<p>不失一般性，令 $a\leqslant b$。</p>
<p>令当前状态为 $(a_0,b_0)$。那么可以到达的状态有</p>
<ol>
<li>$(a_0,b_0)$</li>
<li>$(b_0-a_0,b_0)$</li>
<li>$(a_0,b_0-a_0)$</li>
<li>$(b_0-2a_0,b_0-a_0)$</li>
<li>$(a_0,b_0-2a_0)$</li>
<li>$(b_0-3a_0,b_0-2a_0)$</li>
</ol>
<p>脑补一下可以得出：如果令 $b_0=p\cdot a_0+q$，其中 $0\leqslant q\lt a_0$，那么 $a_0$ 和所有的 $p^\prime\cdot a_0+q$ 都会出现，其中 $0\leqslant p^\prime\leqslant p$。</p>
<p>但是如果持续操作到 $b\lt a$，那么事情会发生变化。</p>
<p>但是根据类欧几里得算法的相关结论，这个变化次数一定不会超过 $O(\log b)$。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>杂题</tag>
        <tag>构造</tag>
        <tag>原题</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 4</title>
    <url>/random-solution-pb-4/</url>
    <content><![CDATA[<p>2022 年 10 月 1 日 20：00 ~ 21：40，AHU 2021 届不知名 ACM 选手<strong>関原みや</strong>（化名）报名参加 <a href="https://atcoder.jp/contests/abc271">AtCoder Beginner Contest 271</a>。期间因大脑短路，A/D/E 题各 WA 1 发，C 题 WA 4 发，G 题本应做出却未能做出（F 题就算了，真不会），最终以 1075th 的坏成绩遗憾<del>离世</del>离场，Rating 倒扣 17 分。距今已过 34 分 24 秒，警钟长鸣。</p>
<p>来源：<a href="https://atcoder.jp/contests/abc271/tasks/abc271_g">ABC271 G Access Counter</a></p>
<a id="more"></a>
<p>高桥君建立了一个网站，然后在上面放置了一个访问计数器。在这之后，高桥君和他的一个朋友青木君会频繁地访问这个网站。</p>
<p>给定一个长度为 $24$ 的字符串 $c_0c_1\cdots c_{23}$，且 $c_i\in\{\mathtt{T},\mathtt{A}\}$。在访问计数器被设置后的第 $n$ 个小时中（$n$ 从零开始计数），如果 $c_{n\bmod 24}=\mathtt{T}$，那么高桥君有 $X/100$ 的概率访问网站；如果 $c_{n\bmod 24}=\mathtt{A}$，那么青木君有 $Y/100$ 的概率访问网站。</p>
<p>如果访问计数器统计到的第 $N$ 次访问恰好是高桥君，高桥君会爆炸。因此试求第 $N$ 次访问恰好是青木君的概率。对 $998244353$ 取模。</p>
<p>$1\leqslant N\leqslant 10^{18}$，$1\leqslant X,Y\leqslant 99$，且 $X$ 和 $Y$ 都是整数。</p>
<p>$\mathtt{2s/1024MB}$。</p>
<p>这么一看相当直来直去的概率题。</p>
<p>令 $P(i,j)$ 表示第 $i$ 次访问的下一次是第 $j$ 次访问的概率。这里不考虑这次访问是谁。显然我们有</p>
<script type="math/tex; mode=display">
P(i,j)=\sum_{n\geqslant 0}\prod_{k=i+1}^{j-1}(1-p_k)\cdot p_j\cdot\left(\prod_{k=1}^n(1-p_k)\right)^n=\frac{\prod_{k=i+1}^{j-1}(1-p_k)\cdot p_j}{1-\prod_{k=1}^n(1-p_k)}</script><p>$Q_t(i)$ 表示第 $t$ 访问对应 $c_i$ 的概率。显然我们有</p>
<script type="math/tex; mode=display">
Q_1(i)=\prod_{k=1}^{i-1}(1-p_k)\cdot p_i</script><script type="math/tex; mode=display">
Q_t(i)=\sum_{j=0}^{23}Q_{t-1}(j)P(j,i)</script><p>注意到，如果我们能够把 $P(i,j)$ 和 $Q_t(i)$ 写成如下的矩阵形式的话</p>
<script type="math/tex; mode=display">
A_t=\begin{bmatrix}
Q_t(0)\\
Q_t(1)\\
\vdots\\
Q_t(23)\\
\end{bmatrix}
\quad F=\begin{bmatrix}
P(0,0)&P(1,0)&\cdots&P(23,0)\\
P(0,1)&P(1,1)&\cdots&P(23,1)\\
\vdots&\vdots&\ddots&\vdots\\
P(0,23)&P(1,23)&\cdots&P(23,23)\\
\end{bmatrix}</script><p>上面那个关系式就可以简写成</p>
<script type="math/tex; mode=display">
A_t=A_{t-1}F=A_1F^{t-1}</script><p>即</p>
<script type="math/tex; mode=display">
A_N=A_1F^{N-1}</script><p>那么我们就可以在 $O(\log N)$ 的时间复杂度内计算出所有的 $Q_N(i)$。虽然严格上来讲这部分还会有一个高达 $24^3$ 的常数。</p>
<p>那么最终的答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{23}[c_i=\mathtt{A}]Q_N(i)</script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>概率论</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 5</title>
    <url>/random-solution-pb-5/</url>
    <content><![CDATA[<p>2022 年 10 月 17 日 22：35 ~ 次日 00：35，AHU 2021 届不知名 ACM 选手<strong>関原みや</strong>（化名）报名参加 <a href="https://codeforces.com/contest/1743">Educational Codeforces Round 137 (Rated for Div. 2)</a>。期间因急了，C 题 WA 1 发，（某数据随机复杂度虚伪的）D 题 WA 4 发；但最后关头潜力爆发，做出 F 题并成功上分，跻身 Candidate Master 之列。距今已过……不知道多久，佳话永流传。</p>
<p>来源：<a href="https://codeforces.com/contest/1743/problem/F">CF1743 F Intersection and Union</a></p>
<a id="more"></a>
<p>给定 $n$ 个集合 $S_1,S_2,\dots,S_n$，其中 $S_i=[l_i,r_i]\cap\mathbb{Z}$。</p>
<p>现构造操作序列 $p_1,p_2,\dots,p_{n-1}$，其中 $p_i\in\{\cup,\cap,\oplus\}$，$\cup$ 表示集合的并，$\cap$ 表示集合的交，$\oplus$ 表示集合的对称差。</p>
<p>显然整个操作序列 $p$ 一共有 $3^{n-1}$ 中方案。试对于每种 $p$，计算</p>
<script type="math/tex; mode=display">
\left|(((S_1\;p_1\;S_2)\;p_2\;S_3)\;p_3\;S_4)\;\cdots\;p_{n-1}\;S_n\right|</script><p>的和。对 $998244353$ 取模。</p>
<p>$2\leqslant n\leqslant 3\times 10^5$，$0\leqslant l_i\leqslant r_i\leqslant 3\times 10^5$。</p>
<p>$\mathtt{5s/512MB}$。</p>
<p>令 $T_k$ 表示下式的计算结果</p>
<script type="math/tex; mode=display">
(((S_1\;p_1\;S_2)\;p_2\;S_3)\;p_3\;S_4)\;\cdots\;p_{k-1}\;S_k</script><p>可以大致看成是 $S_k$ 的前缀和。</p>
<p>考虑对于每个 $x$，计算有多少种方案使得 $x\in T_n$。</p>
<p>设当前考察到 $T_{k-1}$。并且有 $x\not\in S_k$，那么：</p>
<ol>
<li>如果 $x\not\in T_{k-1}$，无论 $p_k$ 如何取值，总有 $x\not\in T_k$。</li>
<li>如果 $x\in T_{k-1}$，$p_k=\cap$，那么 $x\not\in T_k$。</li>
<li>如果 $x\in T_{k-1}$，$p_k=\cup$ 或 $p_k=\oplus$，那么 $x\in T_k$。</li>
</ol>
<p>同理，如果 $x\in S_k$，那么：</p>
<ol>
<li>如果 $x\not\in T_{k-1}$，$p_k=\cap$，那么 $x\not\in T_k$。</li>
<li>如果 $x\not\in T_{k-1}$，$p_k=\cup$ 或 $p_k=\oplus$，那么 $x\in T_k$。</li>
<li>如果 $x\in T_{k-1}$，$p_k=\oplus$，那么 $x\not\in T_k$。</li>
<li>如果 $x\in T_{k-1}$，$p_k=\cup$ 或 $p_k=\cap$，那么 $x\in T_k$。</li>
</ol>
<p>设 $f(k,0/1,0/1)$：其中 $f(k,0,0)$ 表示在 $x\not\in T_{k-1}$ 的情况下，$x\not\in T_k$ 的方案数；剩余状态的含义可以以此类推。我们可以整理出：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
f(k,0,0)&f(k,0,1)\\
f(k,1,0)&f(k,1,1)
\end{bmatrix}
=\begin{bmatrix}
f(k-1,0,0)&f(k-1,0,1)\\
f(k-1,1,0)&f(k-1,1,1)
\end{bmatrix}
\begin{bmatrix}
3&0\\
1&2
\end{bmatrix}\quad(x\not\in S_k)</script><script type="math/tex; mode=display">
\begin{bmatrix}
f(k,0,0)&f(k,0,1)\\
f(k,1,0)&f(k,1,1)
\end{bmatrix}
=\begin{bmatrix}
f(k-1,0,0)&f(k-1,0,1)\\
f(k-1,1,0)&f(k-1,1,1)
\end{bmatrix}
\begin{bmatrix}
1&2\\
1&2
\end{bmatrix}\quad(x\in S_k)</script><p>这样我们只需从小到大扫一遍 $x$，用扫描线处理出每个 $S_k$ 是否包含当前 $x$，然后再用线段树维护单点修改和区间矩阵乘积即可。</p>
<p>当然还有一些细节，比如说 $S_1$ 这个位置有些特殊，所以实际上求解矩阵乘积的时候求解的是 $[2,n]$ 上的乘积，然后再根据是否有 $x\in S_1$ 单独计算 $S_1$ 产生的贡献。</p>
<p>还有就是，如果 $x\not\in\bigcup S_i$，那么这个 $x$ 不应该参与计算。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>矩阵</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC 2022 Regional 合肥站游记</title>
    <url>/icpc-2022-regional-hefei-notes/</url>
    <content><![CDATA[<p>今天本来会有一场大物的考试。还好我因为打 ICPC 申请了免考不然就要在大物考场上丢人了。</p>
<p>前 3h 写出来 6 题。最后 2h 我在写一道数学题，SHX 在写一道数据结构题，结果都没有写出来。</p>
<p>本来以为写出来 7-8 题可以混一块金牌的。结果赛后一查排行榜，8 题 42 队，7 题 67 队，结果金牌只有 35 块。</p>
<p>也就是说无论如何都没有大金牌了 /kk</p>
<p>最后 rank 72 拿了一块银牌。</p>
<p>这么说来上周的 CCPC 其实是最有希望拿金牌的。如果我能够少浪费一时间的话。</p>
<p>害群之马竟是我自己 /kk</p>
<a id="more"></a>
<h1 id="我写出来的题"><a href="#我写出来的题" class="headerlink" title="我写出来的题"></a>我写出来的题</h1><h2 id="A-Welcome-to-USTC"><a href="#A-Welcome-to-USTC" class="headerlink" title="A. Welcome to USTC"></a>A. Welcome to USTC</h2><p>给定一个字符串 $S$。保证 $S$ 中恰好包含 $\mathtt{U},\mathtt{S},\mathtt{T},\mathtt{C}$ 四个大写英文字母各一个，其他字符均为小写英文字母，且 $\mathtt{USTC}$ 在 $S$ 中作为<strong>子序列</strong>出现。</p>
<p>每次操作可以交换 $S$ 中的两个相邻字符。现要让 $\mathtt{USTC}$ 在 $S$ 中作为<strong>子串</strong>出现，试求最小操作次数。</p>
<p>$4\leqslant |S|\leqslant 10^4$。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>设 $\mathtt{U},\mathtt{S},\mathtt{T},\mathtt{C}$ 的下标依次为 $a,b,c,d$，答案显然为</p>
<script type="math/tex; mode=display">
(b-a-1)+2(c-b-1)+(d-c-1)</script><p>时间复杂度 $O(|S|)$，空间复杂度 $O(|S|)$。</p>
<h2 id="G-Game-Plan"><a href="#G-Game-Plan" class="headerlink" title="G. Game Plan"></a>G. Game Plan</h2><p>您有一个集合 $S$。初始时 $S=\{0\}$。现在您可以进行 $t$ 次操作。在第 $i$ 次操作中，您可以在如下两项中任选其一：</p>
<ol>
<li>$S\leftarrow S\cap\{a_i\}$</li>
<li>$S\leftarrow S\cap\{b_i\}$</li>
</ol>
<p>（原题中还有一个值域上界，不过现在看来这个不重要）</p>
<p>试求 $t$ 次操作后 $\operatorname{mex}(S)$ 的最大值。</p>
<p>$1\leqslant n\leqslant 10^9$，$1\leqslant t\leqslant 10^6$，$1\leqslant a_i,b_i\leqslant n$。其中 $n$ 为值域上界。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>考虑建图。$n+1$ 个，依次标号为 $1,2,\dots,n+1$。对于每一个 $i$，我们连一条边 $(a_i,b_i)$。</p>
<p>现在问题转化为，在这张图上，对于每条边标记其中一个端，问未被标记过的标号最小的的标号最大是多少。</p>
<p>考虑到，如果一个连通块是一棵树，那么我们不得不放弃其中的一个不标记。那么显然放弃标号最大的是最优策略。</p>
<p>但是在树的基础上，再随便增加一条边，我们都能够做到标记这个连通块中的所有。</p>
<p>以上。时间复杂度 $O(t\log t)$，空间复杂度 $O(t)$。</p>
<h2 id="H-Jackpot"><a href="#H-Jackpot" class="headerlink" title="H. Jackpot"></a>H. Jackpot</h2><p>黑板上写有 $n$ 个正整数 $k+1$。每次操作您可以选择一个大于 $1$ 的整数，令其为 $x$，然后它有 $\frac{1}{x-1}$ 的概率变为 $x-1$，$\frac{1}{x-1}$ 的概率变为 $x-2$……$\frac{1}{x-1}$ 的概率变为 $1$。</p>
<p>您的目的是让所有数都变为 $1$。试求期望操作次数。对 $10^9+7$ 取模。</p>
<p>多组数据。$1\leqslant n\leqslant 10^9$，$2\leqslant k\leqslant 10^3$。$T\leqslant 10^3$。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>容易发现这些数都是两两独立的。令 $E(i)$ 表示将一个数从 $i$ 变到 $1$ 的期望操作次数，可以直接得出答案等于 $n\cdot E(k+1)$。</p>
<p>$E(i)$ 也很容易计算。我们可以进行如下的预处理</p>
<script type="math/tex; mode=display">
E(i)=1+\frac{1}{i-1}\sum_{1\leqslant j\lt i}E(j)</script><p>时间复杂度 $O(k^2+T)$，空间复杂度 $O(k)$。</p>
<h1 id="SHX-写出来的题"><a href="#SHX-写出来的题" class="headerlink" title="SHX 写出来的题"></a>SHX 写出来的题</h1><h2 id="B-Genshin-Impact"><a href="#B-Genshin-Impact" class="headerlink" title="B. Genshin Impact"></a>B. Genshin Impact</h2><p>您可以释放一种火魔法。这种火魔法每 $y$ 秒可以释放一次，每次释放有 $\frac{1}{p}$ 的成功率，如果成功，会使得敌人在接下来的 $x$ 秒内进入燃烧状态。如果敌人已经处于燃烧状态，状态的剩余时间会被重置为 $x$ 秒。</p>
<p>现在您会一直不停地对着同一个血量无限的敌人释放这种火魔法。试求当经过的时间趋向于正无穷大时，</p>
<script type="math/tex; mode=display">
\frac{\text{ 敌人处于燃烧状态的时间 }}{\text{ 总时间 }}</script><p>的值（……大概收敛吧）。</p>
<p>多组数据。$1\leqslant x,y,p\leqslant 10^3$。$T\leqslant 10^3$。</p>
<p>Special Judge：相对误差不超过 $10^{-6}$。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>一看到题面很快啊，我就有了如下的一个看上去很真（大嘘）的想法</p>
<script type="math/tex; mode=display">
\frac{1}{p}\frac{\min(x,y)}{y}</script><p>这个东西显然是不对的。因为如果 $x\gt y$，上一次成功了这一次没有成功那么燃烧状态会持续。</p>
<p>不过算了，反正 SHX 写出来了。</p>
<blockquote>
<p>无穷会把我们在有限的世界里积累起来的直觉打得粉碎。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　——関原みや</p>
</blockquote>
<h2 id="J-Produce-the-Problems"><a href="#J-Produce-the-Problems" class="headerlink" title="J. Produce the Problems"></a>J. Produce the Problems</h2><p>给定 $n,a,b$ 和两个长度为 $n$ 的序列 $d,c$。您需要构造 $n$ 个字符串 $S_1,S_2,\dots,S_n$，其中 $S_i$ 需要恰好包含 $d_i$ 个 $\mathtt{D}$ 和 $c_i$ 个 $\mathtt{C}$。并且，如果令 $S=S_1S_2\cdots S_n$，$S$ 中不能出现超过 $a$ 个连续的 $\mathtt{D}$ 或超过 $b$ 个连续的 $\mathtt{C}$。问是否能够做到。</p>
<p>$1\leqslant n\leqslant 10^6$，$0\leqslant a,b,d_i,c_i\leqslant 10^6$。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>构造题，一生之敌。</p>
<p>不过算了，反正 SHX 写出来了。</p>
<blockquote>
<p>构造题是人类思维进步的阶梯。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　——関原みや</p>
</blockquote>
<h2 id="M-Mahjong"><a href="#M-Mahjong" class="headerlink" title="M. Mahjong"></a>M. Mahjong</h2><p>得。这题我连题意都不知道。只听说是个大模拟。</p>
<p>不过算了，反正 SHX 写出来了。</p>
<blockquote>
<p>大模拟题就是 【ACM 粗口 】 题。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　——関原みや</p>
</blockquote>
<h1 id="没过的题"><a href="#没过的题" class="headerlink" title="没过的题"></a>没过的题</h1><h2 id="E-My-friends’-friends-are-my-friends"><a href="#E-My-friends’-friends-are-my-friends" class="headerlink" title="E. My friends’ friends are my friends"></a>E. My friends’ friends are my friends</h2><p><strong>Warning：以下所用记号与原始题面存在出入。</strong></p>
<p><strong>Warning：以下文字已经经过了一定程度的转化，与原始题面想要表达的含义存在出入。</strong></p>
<p>给定一张 $n$ 个和 $m$ 条边的无向图和一个特殊节点 $r$。点有点权 $a,b$，边有边权 $w$。</p>
<p>现在每个点上都站着一个人。对于一个点 $i$，如果您能够支付给这个点上的人 $a_i\cdot\operatorname{dist}(r,i)$ 元，那么 TA 就会对您产生 $b_i$ 点贡献。其中 $\operatorname{dist}$ 表示两点间的最短路。</p>
<p>现在您需要集齐 $S$ 点贡献，但是您的预算只有 $T$ 元。问是否能够做到。</p>
<p>$1\leqslant n\leqslant 10^4$，$1\leqslant m\leqslant 10^6$，$0\leqslant S\leqslant 10^4$，$0\leqslant T\leqslant 10^{12}$。</p>
<p>$0\leqslant a_i,b_i\leqslant 10^4$，$1\leqslant w_i\leqslant 10^4$。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>令 $f(i)$ 表示恰好获得 $i$ 点贡献至少需要多少钱。不过 $f(S)$ 比较特殊，它表示至少获得 $S$ 点贡献（即包括了 $S+1$ 点和更多的情况）至少需要多少钱。</p>
<p>那么我们可以写一个 $O(nS)$ 的背包 DP。</p>
<p>结果 T 了（悲</p>
<h2 id="I-Counting-Lines"><a href="#I-Counting-Lines" class="headerlink" title="I. Counting Lines"></a>I. Counting Lines</h2><p>给定 $n$。称平面直角坐标系内横纵坐标均为 $[0,n)$ 上的整数的这 $n^2$ 个点为标记点。一条直线是好的，当且仅当它满足如下两个条件：</p>
<ol>
<li>经过至少两个标记点</li>
<li>与 $x$ 轴的夹角的绝对值小于等于 $\frac{\pi}{4}$</li>
</ol>
<p>试求好的直线的数量。</p>
<p>多组数据。$2\leqslant n\leqslant 10^6$。$T\leqslant 10^3$。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>推了半天结果发现不对（悲</p>
<p>以下是考场思路：</p>
<p>我们把夹角在 $[-\frac{\pi}{4},0)$ 的部分逆时针旋转 $\frac{\pi}{2}$ 到 $[\frac{\pi}{4},\frac{\pi}{2})$，然后再减去夹角为 $0$ 和 $\frac{\pi}{4}$ 的部分（加起来一共是 $3n-3$），发现剩下的部分实际上是</p>
<script type="math/tex; mode=display">
\sum_{\Delta x=1}^{n-1}\sum_{\Delta y=1}^{n-1}[\Delta x\perp\Delta y]f(\Delta x,\Delta y)</script><p>其中 $f(\Delta x,\Delta y)$ 表示斜率为 $\frac{\Delta y}{\Delta x}$ 的好的直线的数量。</p>
<p>套路莫比乌斯反演</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{\Delta x=1}^{n-1}\sum_{\Delta y=1}^{n-1}[\Delta x\perp\Delta y]f(\Delta x,\Delta y)\\
=&\sum_{t=1}^{n-1}\mu(t)\sum_{u=1}^{\lfloor(n-1)/t\rfloor}\sum_{v=1}^{\lfloor(n-1)/t\rfloor}f(tu,tv)\\
\end{aligned}</script><p>然后就是这里。仔细思考我们会发现，$f(\Delta x,\Delta y)$ 与 $(\Delta x,\Delta y)$ 有关，因此不能直接套二者互质时的式子。</p>
<p>然后……然后就不会了（悲</p>
<h2 id="K-Quarantine"><a href="#K-Quarantine" class="headerlink" title="K. Quarantine"></a>K. Quarantine</h2><p>现在有排成一条直线的 $n$ 个居民区，依次标号为 $1,2,\dots,n$。</p>
<p>有 $m$ 个时间，每次事件有如下 $4$ 中类型：</p>
<ol>
<li>给出 $l,r$。区间 $[\max(l-A,1),\min(r+A,n)]$ 内的所有居民区进入「被感染」状态。</li>
<li>给出 $l,r,k$。如果区间 $[\max(l-A,1),\min(r+A,n)]$ 内处于「被感染」状态的最长连续段长度至少为 $k$，那么区间内的所有居民区进入「隔离」状态；否则，什么也不发生。</li>
<li>给出 $l,r$。区间 $[\max(l-A,1),\min(r+A,n)]$ 内的所有居民区解除「被感染」状态和「隔离」状态。</li>
<li>给出 $l,r$。查询区间 $[\max(l-A,1),\min(r+A,n)]$ 内有多少个居民区处于「隔离」状态。</li>
</ol>
<p>其中 $A$ 表示上一次事件 $4$，即查询的答案，初始为 $0$。</p>
<p>$1\leqslant n\leqslant 10^9$，$1\leqslant m\leqslant 10^5$。</p>
<p>$\mathtt{1s/256MB}$。</p>
<p>抽象一下的话就是：</p>
<ol>
<li>区间覆盖</li>
<li>查询区间最长连续段长度</li>
<li>查询区间和</li>
</ol>
<p>第一反应是珂朵莉树，但是细想发现需要手写平衡树维护，因为 <code>std::set</code> 在这道题中已经不够用了。</p>
<p>但是想了想觉得太麻烦了于是放弃了。</p>
<p>SHX 的写法是动态开点线段树，但是没写出来。</p>
<h1 id="剩下的题"><a href="#剩下的题" class="headerlink" title="剩下的题"></a>剩下的题</h1><p>C 超级大模拟题（样例解释一页半）</p>
<p>D 看不懂</p>
<p>F 神仙计算几何题</p>
<p>L 神仙数学题</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>杂题</tag>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>数学期望</tag>
        <tag>莫比乌斯反演</tag>
        <tag>ICPC</tag>
        <tag>2022</tag>
        <tag>概率论</tag>
        <tag>Regional</tag>
        <tag>合肥</tag>
        <tag>难题</tag>
        <tag>模拟</tag>
        <tag>最短路</tag>
        <tag>背包</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈基于转置原理的多项式多点求值算法</title>
    <url>/polynomial-multipoint/</url>
    <content><![CDATA[<p>考虑一个经典的问题。给定 $n$ 次多项式</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^nf_ix^i</script><p>和 $n+1$ 个点值 $a_0,a_1,\dots,a_n$。您需要对于每个 $k$，求出 $b_k=F(a_k)$，对 $998244353$ 取模。</p>
<p>据说以前这种问题都是采用多项式取模的方法。但是现在我们有新科技了。</p>
<p>本篇文章将会以我个人认为十分通俗易懂的方式来详细地讲解这种新科技。</p>
<p>参考文献略。</p>
<a id="more"></a>
<h2 id="线性算法"><a href="#线性算法" class="headerlink" title="线性算法"></a>线性算法</h2><p>若一个算法可以被看作是方阵 $A$，输入向量 $\mathbf v$，输出向量 $A\mathbf v$，则称该算法为线性算法。</p>
<p>比如说，FFT 就是一个线性算法，其对应的方阵为</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&1&1&\cdots&1\\
1&\omega_n^1&\omega_n^2&\cdots&\omega_n^n\\
1&\omega_n^2&\omega_n^4&\cdots&\omega_n^{2n}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
1&\omega_n^n&\omega_n^{2n}&\cdots&\omega_n^{n^2}\\
\end{bmatrix}</script><h2 id="转置原理"><a href="#转置原理" class="headerlink" title="转置原理"></a>转置原理</h2><p>对于一个线性算法，设其对应的方阵 $A$ 满足</p>
<script type="math/tex; mode=display">
A=E_1E_2\cdots E_n</script><p>其中 $E_i$ 均为初等矩阵。则有</p>
<script type="math/tex; mode=display">
A^{\mathrm T}=E_n^{\mathrm T}\cdots E_2^{\mathrm T}E_1^{\mathrm T}</script><p>这里稍微复习一下，初等矩阵指的是只进行一次初等变换的矩阵。这里的初等变换包括</p>
<ol>
<li>$v_i\leftarrow v_i\cdot k$</li>
<li>$v_i\leftarrow v_i+v_j\cdot k$</li>
</ol>
<p>如果 $E_i$ 对应第一种初等变换，它的转置就是自身；如果是第二种，转置后 $i$ 和 $j$ 互换，即对应的初等变换变为 $v_j\leftarrow v_j+v_i\cdot k$。</p>
<p>这里的关键点在于，如果 $A\mathbf v$ 比较好求，而 $A^{\mathrm T}\mathbf v$ 相对难求，我们可以将求 $A\mathbf v$ 的过程分析出来，把每一步转置然后倒序执行，就可以求出 $A^{\mathrm T}\mathbf v$ 了。</p>
<h2 id="多项式乘积的转置"><a href="#多项式乘积的转置" class="headerlink" title="多项式乘积的转置"></a>多项式乘积的转置</h2><p>考虑两个多项式</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^nf_ix^i</script><p>和</p>
<script type="math/tex; mode=display">
G(x)=\sum_{i=0}^mg_ix^i</script><p>令它们的乘积为</p>
<script type="math/tex; mode=display">
H(x)=\sum_{i=0}^{n+m}h_ix^i</script><p>考虑计算这一乘积的算法。为了便于理解，我们将 $G(x)$ 视作常量，$F(x)$ 和 $H(x)$ 视作变量，考虑一个作用在如下 $(n+1)+(n+m+1)=2n+m+2$ 维列向量上的线性算法</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
f_0\\
f_1\\
f_2\\
\vdots\\
f_n\\
h_0\\
h_1\\
\vdots\\
h_{n+m}
\end{bmatrix}</script><p>初始时 $f_i$ 已经有值，而 $h_i$ 为 $0$。算法流程如下：</p>
<ol>
<li>循环变量 $i\leftarrow 0\dots n+m$</li>
<li>循环变量 $j\leftarrow \max(0,i-m)\dots\min(n,i)$</li>
<li>执行 $h_i\leftarrow h_i+f_j\times g_{i-j}$</li>
</ol>
<p>考虑这一过程的转置，其流程如下：</p>
<ol>
<li>循环变量 $i\leftarrow n+m\dots 0$</li>
<li>循环变量 $j\leftarrow \min(n,i)\dots\max(0,i-m)$</li>
<li>执行 $f_j\leftarrow f_j+h_i\times g_{i-j}$</li>
</ol>
<p>相当于在已知 $H(x)$ 和 $G(x)$ 的情况下求解 $F(x)$。其中</p>
<script type="math/tex; mode=display">
f_k=\sum_{i-j=k}h_ig_j=\sum_{i+(m-j)=m+k}h_ig^{\mathrm R}_{m-j}=\sum_{i+j=m+k}h_ig^{\mathrm R}_j</script><p>其中 $g^{\mathrm R}_i=g_{m-i}$，即 $G$ 的所有系数翻转过来。</p>
<p>于是我们可以如下定义多项式乘积的转置</p>
<script type="math/tex; mode=display">
[x^k](H\times^{\mathrm T}G)=[x^{m+k}](H\times G^{\mathrm R})</script><p>不难发现，如果 $F(x)$ 是 $n$ 次多项式，$G(x)$ 是 $m$ 次多项式，那么 $(F\times^{\mathrm T}G)(x)$ 会是 $n-m$ 次多项式。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>令</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
1&a_0^1&a_0^2&\cdots&a_0^n\\
1&a_1^1&a_1^2&\cdots&a_1^n\\
1&a_2^1&a_2^2&\cdots&a_2^n\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
1&a_n^1&a_n^2&\cdots&a_n^n\\
\end{bmatrix}
\qquad\varphi=\begin{bmatrix}
f_0\\
f_1\\
f_2\\
\vdots\\
f_n
\end{bmatrix}
\qquad\beta=\begin{bmatrix}
b_0\\
b_1\\
b_2\\
\vdots\\
b_n
\end{bmatrix}</script><p>我们有</p>
<script type="math/tex; mode=display">
A\varphi=\beta</script><p>考虑</p>
<script type="math/tex; mode=display">
\gamma=A^{\mathrm T}\varphi=\begin{bmatrix}
1&1&1&\cdots&1\\
a_0^1&a_1^1&a_2^1&\cdots&a_n^1\\
a_0^2&a_1^2&a_2^2&\cdots&a_n^2\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
a_0^n&a_1^n&a_2^n&\cdots&a_n^n\\
\end{bmatrix}
\begin{bmatrix}
f_0\\
f_1\\
f_2\\
\vdots\\
f_n
\end{bmatrix}
=\begin{bmatrix}
c_0\\
c_1\\
c_2\\
\vdots\\
c_n
\end{bmatrix}</script><p>不难发现</p>
<script type="math/tex; mode=display">
c_k=\sum_{i=0}^nf_ia_i^k</script><p>定义生成函数</p>
<script type="math/tex; mode=display">
C(x)=\sum_{i=0}^n\frac{f_i}{1-a_ix}</script><p>则</p>
<script type="math/tex; mode=display">
c_k=[x^k]C(x)</script><p>这里 $C(x)$ 可以通过经典的分治 NTT 求解。令</p>
<script type="math/tex; mode=display">
C_{l,r}(x)=\frac{P_{l,r}(x)}{Q_{l,r}(x)}</script><p>对于叶子节点 $[i,i]$，执行</p>
<script type="math/tex; mode=display">
P_{i,i}(x)=f_i</script><script type="math/tex; mode=display">
Q_{i,i}(x)=1-a_ix</script><p>对于内部节点 $[l,r]$，执行</p>
<script type="math/tex; mode=display">
P_{l,r}(x)=P_{l,m}(x)Q_{m+1,r}(x)+P_{m+1,r}(x)Q_{l,m}(x)</script><script type="math/tex; mode=display">
Q_{l,r}(x)=Q_{l,m}(x)Q_{m+1,r}(x)</script><p>注意到，$Q_{l,r}(x)$ 实际上和 $f_i$ 没有任何关系，我们可以把它们视作常量。然后把剩下的 $(n+1)^2$ 个 $P_{l,r}(x)$ 全部塞进一个向量里，那么上述分治过程就可以视作是一个针对该向量的线性算法。</p>
<p>我们可以写得再清晰一些，比如说像下面这样</p>
<script type="math/tex; mode=display">
P_{l,r}(x)\leftarrow P_{l,r}(x)+P_{l,m}(x)\times Q_{m+1,r}(x)</script><script type="math/tex; mode=display">
P_{l,r}(x)\leftarrow P_{l,r}(x)+P_{m+1,r}(x)\times Q_{l,m}(x)</script><p>以及最后一步的</p>
<script type="math/tex; mode=display">
C(x)\leftarrow C(x)+P_{0,n}(x)\times Q_{0,n}^{-1}(x)</script><p>那么转置之后，第一步自然就是</p>
<script type="math/tex; mode=display">
B_{0,n}(x)\leftarrow B_{0,n}(x)+F(x)\times^{\mathrm T}Q_{0,n}^{-1}(x)</script><p>想不明白为什么吗？我也想不明白。</p>
<p>在这之后，从上向下分治，对于内部节点 $[l,r]$，执行</p>
<script type="math/tex; mode=display">
B_{l,m}(x)\leftarrow B_{l,m}(x)+B_{l,r}(x)\times^{\mathrm T}Q_{m+1,r}(x)</script><script type="math/tex; mode=display">
B_{m+1,r}(x)\leftarrow B_{m+1,r}(x)+B_{l,r}(x)\times^{\mathrm T}Q_{l,m}(x)</script><p>最终对于叶子节点 $[i,i]$，$B_{i,i}(x)$ 必定会是一个 $0$ 次多项式，其仅有的一个常数项系数就是我们要求的 $b_i$ 了。</p>
<p>当然，如果多项式次数和点值数量不对等也很容易处理，用 $0$ 补齐即可。</p>
<p><a href="https://www.luogu.com.cn/problem/P5050">请问您要来点板子题吗 qwq？</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个算法好在哪里：</p>
<ol>
<li>常数小：<code>std::vector</code> 也不必太过担心被卡常。</li>
<li>代码实现难度小：只要能够完全理解整个算法流程，便能够十分迅速且正确地写出代码。</li>
</ol>
]]></content>
      <categories>
        <category>学术</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>多项式</tag>
        <tag>矩阵</tag>
        <tag>多点求值</tag>
        <tag>线性代数</tag>
        <tag>转置原理</tag>
      </tags>
  </entry>
  <entry>
    <title>当一名半东方玩家试图分析觉醒珠的 Masterpieces 符卡会发生什么</title>
    <url>/thfmva-masterpieces/</url>
    <content><![CDATA[<p><a href="/fan-made-virtual-autography">之前的文章</a></p>
<p><strong>内含大量图片！</strong></p>
<a id="more"></a>
<p>昨天（2022-1-17）觉醒珠突然更新了 Masterpieces，类比一下相当于是永夜抄的 Last Words。</p>
<p>虽然好像除了 2/3/5 BOSS 以外其他 BOSS 的 Masterpiece 符卡名都和之前版本拆包拆出来的不一样了……</p>
<p>懒得接说了，看图吧（bushi</p>
<h2 id="博丽灵梦"><a href="#博丽灵梦" class="headerlink" title="博丽灵梦"></a>博丽灵梦</h2><p>「夢想櫺子」/「梦想棂子」</p>
<p><a href="https://hanyu.baidu.com/zici/s?from=aladdin&amp;query=%E6%A3%82&amp;srcid=51368&amp;wd=%E6%A3%82">https://hanyu.baidu.com/zici/s?from=aladdin&amp;query=%E6%A3%82&amp;srcid=51368&amp;wd=%E6%A3%82</a></p>
<p>梦想窗户格子（bushi</p>
<p>之前版本的游戏内符卡名叫做「夢想朱印」/「梦想朱印」。</p>
<p><img src="/img/THFmVA/A1.jpg" alt=""></p>
<p><img src="/img/THFmVA/A2.jpg" alt=""></p>
<p><img src="/img/THFmVA/A3.jpg" alt=""></p>
<p><img src="/img/THFmVA/A4.jpg" alt=""></p>
<p><img src="/img/THFmVA/A5.jpg" alt=""></p>
<h2 id="雾雨魔理沙"><a href="#雾雨魔理沙" class="headerlink" title="雾雨魔理沙"></a>雾雨魔理沙</h2><p>「ブレイジングツアー・幻想郷」/「Blazing Tour（炫目之旅）・幻想乡」</p>
<p>之前版本的游戏内符卡名叫做「移り気なマスタースパーク」/「性情不定的 Master Spark（极限火花）」。</p>
<p><img src="/img/THFmVA/B1.jpg" alt=""></p>
<p><img src="/img/THFmVA/B2.jpg" alt=""></p>
<p><img src="/img/THFmVA/B3.jpg" alt=""></p>
<h2 id="宇佐见堇子"><a href="#宇佐见堇子" class="headerlink" title="宇佐见堇子"></a>宇佐见堇子</h2><p>「ドローンに引かれて善光寺参り」/「被无人机引到善光寺参拜」</p>
<p>好像官方专辑里面有一首歌叫做《被牛引到善光寺参拜》的来着。</p>
<p>之前版本的游戏内符卡名叫做「ギガ級ポケット Wi-Fi」/「GiB 级口袋 Wi-Fi」。</p>
<p><img src="/img/THFmVA/C1.jpg" alt=""></p>
<p><img src="/img/THFmVA/C2.jpg" alt=""></p>
<p><img src="/img/THFmVA/C3.jpg" alt=""></p>
<h2 id="藏人未见"><a href="#藏人未见" class="headerlink" title="藏人未见"></a>藏人未见</h2><p>「スペルカードアタック」/「Spellcard Attack」（符卡攻击）</p>
<p>这符卡名……确定就叫这个吗……</p>
<p>之前版本的游戏内符卡名叫做「ファイナルラブレター」/「Final Love Letter」（最后的情书）。</p>
<p><img src="/img/THFmVA/11.jpg" alt=""></p>
<p><img src="/img/THFmVA/12.jpg" alt=""></p>
<h2 id="平贺生然"><a href="#平贺生然" class="headerlink" title="平贺生然"></a>平贺生然</h2><p>「丑の日参り」/「丑日参拜」</p>
<p>之前版本的游戏内符卡名也是这个。</p>
<p><img src="/img/THFmVA/21.jpg" alt=""></p>
<p><img src="/img/THFmVA/22.jpg" alt=""></p>
<p><img src="/img/THFmVA/23.jpg" alt=""></p>
<p><img src="/img/THFmVA/24.jpg" alt=""></p>
<p><img src="/img/THFmVA/25.jpg" alt=""></p>
<p><img src="/img/THFmVA/26.jpg" alt=""></p>
<p><img src="/img/THFmVA/27.jpg" alt=""></p>
<h2 id="八云紫"><a href="#八云紫" class="headerlink" title="八云紫"></a>八云紫</h2><p>「ルドゥスとパイディアの決別」/「Ludus 和 Paidia 的诀别」</p>
<p>关于 Ludus 和 Paidia 这两个词，我在<a href="https://www.mighty-boards.com/blog/game-studies-101/ludus-and-paidia">这篇文章</a> 中找到了一些解释。这篇文章是英文的，因此我会在下面提取一些关键信息：</p>
<blockquote>
<p>Back in the 1950s, <strong>the French sociologist Roger Caillois</strong> already had the same thought. He tried to make sense of play by breaking it$^\dagger$ down into <strong>a whole taxonomy of different concepts</strong> – <strong>different kinds</strong> of play, if you will. We don’t need to get into all the details of this taxonomy here, but let’s take a look at his idea that all forms of play exist between two opposing poles: <strong>paidia and ludus</strong>.</p>
<p>$^\dagger$ 指前文中的 play，即「玩」这一词汇。</p>
</blockquote>
<p>大意：法国社会学家 Roger Caillois 试图将「玩」这一词汇分割成更多更加精细的词汇——用来具体形容怎么玩的词汇。他的理论提到，「玩」可以被分为两类——Paidia 和 Ludus。</p>
<p>顺便一提，ludus 的源语言是拉丁语，包含 “play, game, sport, training” 等含义；paidia 的源语言是希腊语 παιδιά，包含 “childish play, amusement” 等含义。</p>
<blockquote>
<p>When children first begin to play, Caillois says, there is <strong>no structure to what they’re doing</strong>. Their play is a kind of joyful excess of energy – running around with <strong>no apparent purpose</strong>, throwing things, taking on, dropping and reshaping roles in games of make-believe. <strong>This is paidia.</strong> With enough repetition, though, this free, anarchic kind of play starts to take on structure and form. <strong>Rules are established</strong> to regulate it. It becomes a focused attempt at facing up to a challenge by strictly regulated means. <strong>This is ludus.</strong> </p>
</blockquote>
<p>大意：Paidia 表示毫无目的地瞎 jb 闹；Ludus 表示在遵循某种特定的，被公认的规则的前提下进行的游戏。</p>
<p>或许可以翻译成「守序和混乱的诀别」？（小声</p>
<p>盘古开天地（bushi</p>
<p>之前版本的游戏内符卡名也是这个。</p>
<p><img src="/img/THFmVA/31.jpg" alt=""></p>
<p><img src="/img/THFmVA/32.jpg" alt=""></p>
<p><img src="/img/THFmVA/33.jpg" alt=""></p>
<p><img src="/img/THFmVA/34.jpg" alt=""></p>
<p><img src="/img/THFmVA/35.jpg" alt=""></p>
<p><img src="/img/THFmVA/36.jpg" alt=""></p>
<p><img src="/img/THFmVA/37.jpg" alt=""></p>
<h2 id="刺田严姬"><a href="#刺田严姬" class="headerlink" title="刺田严姬"></a>刺田严姬</h2><p>「光鴉二重結界」/「光鸦二重结界」</p>
<p>之前版本的游戏内符卡名叫做「光烏陣」/「光乌阵」。</p>
<p><img src="/img/THFmVA/41.jpg" alt=""></p>
<p><img src="/img/THFmVA/42.jpg" alt=""></p>
<p><img src="/img/THFmVA/43.jpg" alt=""></p>
<p><img src="/img/THFmVA/44.jpg" alt=""></p>
<h2 id="仙觉寺鞠子"><a href="#仙觉寺鞠子" class="headerlink" title="仙觉寺鞠子"></a>仙觉寺鞠子</h2><p>「<ruby>閄<rt>ものかげからきゅうにとびだしてひとをおどろかせるときにはっするこえ</rt></ruby>」/「<ruby>閄<rt>人躲在暗处突然发出的使人惊骇的声音</rt></ruby>」</p>
<p>关于「閄」这个字，根据给出的解释，对应的汉语读音应该是 huò。</p>
<p>查到日语似乎可以读作「こく」或者是「わく」，但是输入法似乎打不出来。</p>
<p>年度最佳 diaomao 符卡名确信。虽然今年才不到二十天。</p>
<p>之前版本的游戏内符卡名也是这个。</p>
<p><img src="/img/THFmVA/51.jpg" alt=""></p>
<p><img src="/img/THFmVA/52.jpg" alt=""></p>
<p><img src="/img/THFmVA/53.jpg" alt=""></p>
<p><img src="/img/THFmVA/54.jpg" alt=""></p>
<p><img src="/img/THFmVA/55.jpg" alt=""></p>
<p><img src="/img/THFmVA/56.jpg" alt=""></p>
<h2 id="大伴家珠叶"><a href="#大伴家珠叶" class="headerlink" title="大伴家珠叶"></a>大伴家珠叶</h2><p>「アルスポエティカの祝砲」/「Ars Poetica（《诗艺》）的礼炮」</p>
<p>在 Wikipedia 上找到<a href="https://en.wikipedia.org/wiki/Ars_Poetica">这样一个词条</a>。</p>
<p>虽然没看，但是好像很厉害的样子。</p>
<p>之前版本的游戏内符卡名叫做「鎮守府に水漬く屍」/「镇守府的沉水尸骸」。</p>
<p><img src="/img/THFmVA/61.jpg" alt=""></p>
<p><img src="/img/THFmVA/62.jpg" alt=""></p>
<p><img src="/img/THFmVA/63.jpg" alt=""></p>
<p><img src="/img/THFmVA/64.jpg" alt=""></p>
<h2 id="轩端目目"><a href="#轩端目目" class="headerlink" title="轩端目目"></a>轩端目目</h2><p>「サイトマエステラ」/「Site Maestra」</p>
<p>查了一下，首先 Site Maestra 整个的格式 neta 自东方幻想乡的四面道中 BGM，那首歌的名字叫做 Alice Maestra。</p>
<p>这里的 maestra 是意大利语词汇 maestro 的阴性形式，似乎是可以笼统地翻译为 master。</p>
<p>那么 Site Maestra 是不是就是 Site Master，即「网站大师」呢？</p>
<p>润色能力有限，就这样吧。</p>
<p>之前版本的游戏内符卡名叫做「京都グランドオーダー」/「京都 Grand Order」。</p>
<p>搜 Grand Order 基本上只能搜到 FGO……</p>
<p><img src="/img/THFmVA/71.jpg" alt=""></p>
<p><img src="/img/THFmVA/72.jpg" alt=""></p>
<p><img src="/img/THFmVA/73.jpg" alt=""></p>
<p><img src="/img/THFmVA/74.jpg" alt=""></p>
<p><img src="/img/THFmVA/75.jpg" alt=""></p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
        <tag>STG</tag>
        <tag>RPG</tag>
      </tags>
  </entry>
  <entry>
    <title>Crypt of the Necrodancer：命悬一线，诅咒与血的死之舞会</title>
    <url>/crypt-of-the-necrodancer/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/247080/Crypt_of_the_NecroDancer/">Steam 页面</a></p>
<center><font color=##DD0000>MY PULSE IS BEATING LIKE A DRUM,</font></center>

<center><font color=##DD0000>我的脉管搏动，如同擂鼓，</font></center>

<center><font color=##DD0000>BUT MY BLOOD IS RUNNING COLD.</font></center>

<center><font color=##DD0000>但我的血液冰冷，毫无生气。</font></center>

<a id="more"></a>
<p><br>前几天在知乎上刷到一个问题「Steam 上最难达成全成就的游戏是哪一款？」然后看到了这个游戏。</p>
<p>顺便一提，那个问题下面还有人回答 Rabi-Ribi（</p>
<p>于是打算买来玩一玩，然后发现……</p>
<p><img src="/img/TIM图片20181221165111.jpg" alt=""></p>
<p>一进游戏就会有一段剧情，描述的大概是一名叫做凯登丝（Cadence$^\dagger$）的女性不顾家人反对去挑战一座地牢，失足掉了下去，但是没死，被什么人上了一个诅咒，然后挂着这个诅咒在地牢里探索<del>，并逐渐发现背后隐藏的真相</del>。</p>
<p>Cadence$^\dagger$：n.（说话时语调的）抑扬顿挫，起落；（乐段或乐句的）收束，静止。</p>
<p>整体玩法大概是肉鸽打怪，但是加上了一个条件：所有行动，包括但不限于移动，攻击（虽然大部分情况下往敌人身上创过去就是攻击），使用道具，都需要<strong>卡着音乐的节拍</strong>，<strong>且每一拍只能行动一步</strong>；玩家角色行动一步之后，所有敌人也都会同时行动一步。</p>
<p>（凯登丝的话）可以空拍，虽然根据套路不空拍会有更多收益。</p>
<p>整个游戏一共四大关，每一大关又细分为三个小关和一个 BOSS。</p>
<p>游戏中敌人死亡会掉落钱币，可以用来在商店购买道具。<del>甚至商店老板也能给杀了。</del></p>
<p>地图上可能会生成一些钻石，可以用来购买永久升级。</p>
<p>游戏中还有一个「全区域模式」，需要把四个大关连在一起打完，而且初始血上限固定三格。</p>
<p>然而截至今天（2023-2-7），「用凯登丝通关全区域模式」这个成就的获取率也仅仅只有 4.0%。</p>
<p>然后就是这样一个仅仅只是通关就已经十分困难的角色还要不断地更新各种新奇的阴间角色。</p>
<p>比如说虽然自带一瓶复活药，但是血量锁死半颗心受伤即死空拍即死并且只能使用初始自带的攻击范围一格伤害一颗心的小匕首的 Aria；拥有无穷多颗炸弹但是只能用炸弹输出的 Eli；虽然可以免费获取商店里的商品但是不能拾取钱币否则暴毙的 Monk；一次移动往前跳出去两格，想要只移动一格必须要消耗掉半颗心的血量的 Dorian；简单粗暴地把游戏调到两倍速的 Bolt；以及究极缝合怪 Coda = Aria + Monk + Bolt……</p>
<p>1-1 的 BPM 是 120，二倍速就是 240——这个数值已经超过了死亡金属的 175，其中后者是正常速率下 BPM 最高的 BOSS 战。这个速度相当于每秒需要按键 3.33 次。</p>
<p>至于二倍速下的死亡金属，BPM 已经达到了 350。这个速度相当于每秒按键 5.83 次。</p>
<p>我看懂了，且我大受震撼 .jpg</p>
<p>建议都去玩一下，再进一步拉低成就获取率（</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>肉鸽</tag>
        <tag>（广义）音游</tag>
      </tags>
  </entry>
  <entry>
    <title>ホリゾントに辿り着かなかった者</title>
    <url>/ec-final-2023-notes/</url>
    <content><![CDATA[<p>有幸参加 2023 年的 ICPC EC Final。</p>
<p>标题取自《东方眠世界 ~ Wonderful Waking World》的 Stage 6 标题。</p>
<p>文章内图片由同行 dalao SHX 提供。</p>
<a id="more"></a>
<h2 id="Day-1（2023-3-24）"><a href="#Day-1（2023-3-24）" class="headerlink" title="Day 1（2023-3-24）"></a>Day 1（2023-3-24）</h2><p>早上就像早八一样快 8：00 起来，然后和 CHR 打车到合肥南站，坐高铁去上海。</p>
<p>到了酒店放下东西正准备乘坐电梯下楼的时候，电梯一打开发现里面有一个半人高的机器人呆在里面。然后那个机器人让我们让开。</p>
<blockquote>
<p>「你看这个机器人它都没有手，它是怎么按到电梯按钮的呢？」</p>
<p>「它前面好像有一个盖子。它说不定就是从那个盖子里面伸出来一条触手去按按钮。」</p>
</blockquote>
<p>去 SHU 的路上看到了一个邮筒。正在我们感叹都什么年代了还有邮筒的时候，走近一看发现邮筒上贴着一个二维码。</p>
<p><img src="/img/QQ图片20230329165055.jpg" alt="可可爱爱二维码邮筒（只可远观不可近玩）"></p>
<p>下午 15：00 有热身赛，我们成功地在 15：30 之前赶到了考场。</p>
<p><img src="/img/QQ图片20230329165049.jpg" alt="SHU"></p>
<p><img src="/img/QQ图片20230329165050.jpg" alt="当时甚至正在下着雨"></p>
<p><img src="/img/QQ图片20230329165045.jpg" alt="热身赛赛场"></p>
<p><img src="/img/QQ图片20230329165052.jpg" alt="「三条可怜」的英文队名（虽然说原计划是 Karen Sanjou 的来着）"></p>
<p>看了一下。A 题不难，C 题经典猜数二分（虽然因为题意修改和交互题最后忘记输出换行 WA 了几发）。B 题看了看，不会。跑路了。</p>
<p>晚上和实验室老学长 HLS 共进晚餐。听到学长们在谈论一些求职相关地话题，感觉完全不懂，插不上话。</p>
<p>晚上在酒店和 SHX 回忆高中生活。向他展示了我高中时期写的《楠书》。</p>
<blockquote>
<p>「下次团建可以推广一下 100% 鲜橙汁。」</p>
</blockquote>
<p>晚上和 SHX 一起点了汉堡外卖。过了一会 SHX 接到电话说外卖已经送到门口了。然后我一打开门发现那个机器人就站在门口。它的显示屏提示我按下按钮打开。然后我一按，那个机器人瞬间就开膛破肚，里面放着我们俩的外卖。</p>
<p><img src="/img/QQ图片20230329165057.jpg" alt="可可爱爱送外卖机器人（拍摄时间本日下午）"></p>
<p><img src="/img/mmexport1680080464189.jpg" alt="和学长们的外滩合影（像素凑合一下吧）（似乎站得有些靠边上了）"></p>
<h2 id="Day-2（2023-3-25）"><a href="#Day-2（2023-3-25）" class="headerlink" title="Day 2（2023-3-25）"></a>Day 2（2023-3-25）</h2><p>虽然人在上海，但是还是需要 8：00 起床。</p>
<blockquote>
<p>「就像早八一样。」</p>
</blockquote>
<p>10：00 开始比赛。扫了一眼题目，M 好像可做但是队友已经在写了。看了看 B 和 J 感觉可以写。</p>
<p>队友用了半个小时写完了 M，然后我写 J。结果写到一半发现思路不完备，墨迹了一整个小时修正思路才 A 掉。</p>
<p>然后队友开始开 C 和 F 两题。结果直到比赛结束都没有搞出来。</p>
<p>到最后喜提两题，铁牌，Honourable。</p>
<p>吃完晚饭后和实验室群友一起去看《铃芽之旅》。在那之前顺便感受了一下 LC 带过来的没有玩过的桌游《爆炸猫咪》。玩了两个小时喜提一次胜利。</p>
<p>某些人不管看什么东西都能联想到卷绩点上，我不说是谁。</p>
<p>晚饭 SHX 吃了一碗盖饭和一碗拉面，然后看完电影回到酒店还跟我说想要吃夜宵。这食量不愧是肥鸭哥（</p>
<h2 id="Day-3（2023-3-26）"><a href="#Day-3（2023-3-26）" class="headerlink" title="Day 3（2023-3-26）"></a>Day 3（2023-3-26）</h2><p>SHX 去参加华为挑战赛了。自己一个人在酒店打游戏。</p>
<p>下午没去颁奖典礼。听群友说主持人在台上暴论「三条可怜真可怜啊」。</p>
<p>好家伙，我们队哪怕有一个人在现场，多少不得冲上去邦邦给 TA 两拳。</p>
<p>晚上去参加华为晚宴。因为一些原因只能在教练席通过投屏感受现场的氛围。</p>
<p>抽奖环节喜提一个三等奖。奖品是智能牙刷，蓝牙音箱和台灯三选一。觉得都没啥用于是选了一个蓝牙音箱。</p>
<p><img src="/img/IMG20230329170016.jpg" alt="可可爱爱蓝牙音箱（拍摄于 AHU 龙河实验室）"></p>
<p>从 SHU 回来乘坐的是公交车。但是司机师傅不知道为什么把我们带到了完全反方向的一个校门。然后我们必须要横穿整个 SHU 才能到达地铁站。</p>
<blockquote>
<p>低情商：把你们放在这里了。我走了。</p>
<p>高情商：给我们最后一次参观 SHU 校园的机会。</p>
</blockquote>
<p>因为不熟悉 SHU 校内构造，我们不得不求助导航。LC 负责看导航并告诉我们该往哪里走。</p>
<blockquote>
<p><em>（过了一会）</em></p>
<p>LXR「稍等一下，我们有人在看导航吗？我们现在是走在正确的道路上的吗？」</p>
<p>LC「让我看看……<em>（掏出导航）</em>哦不好意思走过了。<em>（带着我们折返）</em>」</p>
<p><em>（过了一会）</em></p>
<p>CHR「是不是又没有人在看导航了？」</p>
<p>LC「确实，让我看看……<em>（掏出导航）</em>哦我们又走错了。<em>（带着我们折返）</em>」</p>
<p><em>（过了一会）</em></p>
<p>SHX「这条路看着不对劲啊。我们是不是走错了。」</p>
<p>LC「让我看看……<em>（掏出导航）</em>哦确实走错了。<em>（带着我们折返）</em>」</p>
<p>CHR「你这交互系统做得不够好啊。你还得用户询问才能知道走错路了。」</p>
</blockquote>
<p>回来的路上最后一次路过了那个带着二维码的可爱小邮筒。</p>
<blockquote>
<p>CHR「拍张照片吧。明天就见不到了。」</p>
</blockquote>
<p>回来之后在酒店房间里没事干，听到隔壁 313（我们是 311，313 是 LC 和 LXR）。敲门进去一看发现在玩《爆炸猫咪》，于是加入了他们。</p>
<p>基础描述可以自行查询搜索引擎。</p>
<p>以下是精彩片段回放：</p>
<blockquote>
<p><em>（游戏开局）</em></p>
<p>我「我有点怂，让我打一张『<ruby>幻觉<rt>See the Future</rt></ruby>』看看情况……好的没问题。」</p>
<p>MS「这玩的也太怂了。开局肯定是要尽可能多的抽牌啊。怎么会有人开局就抽到『<ruby>爆炸猫<rt>Exploding Kitten</rt></ruby>』呢？你看……<em>（抽到『<ruby>爆炸猫<rt>Exploding Kitten</rt></ruby>』）</em>」</p>
<p>CHR「好看。」</p>
<p>MS「『<ruby>调情<rt>Favor</rt></ruby>』！<em>（对着我）</em>给我一张牌。」</p>
<p>我「我……我……我扔了<em>（打出『<ruby>鬼扯<rt>Nope</rt></ruby>』）</em>也不给你！」</p>
<p>LC「太棒了！就该这样！宁愿粉身碎骨也不要被剥削！」</p>
<p><em>（游戏终局：四人存活，抽牌堆里只剩下三张『<ruby>爆炸猫<rt>Exploding Kitten</rt></ruby>』）</em></p>
<p>CHR「现在再洗牌什么的其实已经没有意义了。你看吧，我就直接明牌了，这里面剩下三张全是炸弹。」</p>
<p>LC「选择一张你喜欢的炸弹，然后被它炸死吧。」</p>
<p><em>（巅峰对决：两人存活，抽牌堆里只剩下一张『<ruby>爆炸猫<rt>Exploding Kitten</rt></ruby>』）</em></p>
<p>我「我……我是不是已经死了。<em>（察觉）</em>欸你们看，这个『<ruby>捣乱<rt>Shuffle</rt></ruby>』的描述，它不是要求我至少要切洗一次抽牌堆吗？如果抽牌堆里只剩下一张牌了，我没有办法切洗我是不是就卡住永远停不下来了。」</p>
<p>MS「卡 bug 是吧。」</p>
<p><em>（游戏后期：抽牌堆从上面开始两张牌都是『<ruby>爆炸猫<rt>Exploding Kitten</rt></ruby>』）</em></p>
<p>CHR「『<ruby>高潮<rt>Attack</rt></ruby>』！」</p>
<p>我「完了我死了……我需不需要死两次？」</p>
<p>CHR「一次就够了。」</p>
<p>我「<em>（准备抽牌）（把手放到抽牌堆顶部）</em>至少……我没有把炸弹放在这个位置。<em>（抽到『<ruby>爆炸猫<rt>Exploding Kitten</rt></ruby>』）</em>」</p>
<p>LC「<em>（自己放进抽牌堆的『<ruby>爆炸猫<rt>Exploding Kitten</rt></ruby>』被狙击目标抽到了）</em>但是……我也没有害死你啊。我只是让你掉了一点血而已。你上一把可是直接把我斩杀了。」</p>
<p>我「不是……但是我就只有一滴血啊。<em>（进行我的回合）</em>哦不对，我应该是两滴血，初始自带的『<ruby>泻火<rt>Defuse</rt></ruby>』算是一滴血。」</p>
<p>LC「有没有人来『<ruby>调情<rt>Favor</rt></ruby>』我啊……有没有人来让我『<ruby>泻火<rt>Defuse</rt></ruby>』啊。」</p>
<p>CHR「？」</p>
</blockquote>
<p><img src="/img/IMG20230329165957.jpg" alt="以此谨记我的上海之旅（拍摄于 AHU 龙河实验室）"></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>难题</tag>
        <tag>EC Final</tag>
        <tag>2023</tag>
        <tag>上海</tag>
        <tag>SHU</tag>
        <tag>失败</tag>
      </tags>
  </entry>
  <entry>
    <title>「AHU 2023 校赛 J」沉默乐团</title>
    <url>/ahu2310-solution/</url>
    <content><![CDATA[<p>防 AK 题。只可惜多项式技巧不够炉火纯青，差一点就把柿子推出来了。</p>
<p>所以说爱妈题面呢搞快点 /se</p>
<p><a href="https://hydro.ac/d/ahuacm/p/AHU2310">传送门</a></p>
<a id="more"></a>
<p>或者说这里还有一份形式化题面：</p>
<p>给定 $n, m, k$ 和 $a, b \in (\mathbb Z_p / \{0\})^n$。令</p>
<script type="math/tex; mode=display">
t_i = ([1, a_i] \cap \mathbb Z)^{b_i}</script><script type="math/tex; mode=display">
T = \prod_{i = 1}^n t_i</script><script type="math/tex; mode=display">
f(x) = \sum_{s \in T} \left[\sum_{v \in s} [v \geqslant k] = x\right]</script><p>试求 $f(0), f(1), \dots, f(m)$ 的值。对 $998244353$ 取模。</p>
<p>应该没有写错吧……</p>
<p>首先忽略所有 $a_i \lt k$ 的演奏家。这部分的贡献是很容易计算的。</p>
<p>以下只考虑 $a_i \geqslant k$ 的情况。</p>
<p>我们可以容易地写出第 $i$ 位演奏家的一次演奏的生成函数</p>
<script type="math/tex; mode=display">
(a_i - k + 1)x + (k - 1)</script><p>那么第 $i$ 位演奏家的生成函数就是</p>
<script type="math/tex; mode=display">
((a_i - k + 1)x + (k - 1))^{b_i}</script><p>总体的生成函数就是</p>
<script type="math/tex; mode=display">
\prod_{i = 1}^n ((a_i - k + 1)x + (k - 1))^{b_i}</script><p>于是开始推柿子</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \prod_{i = 1}^n ((a_i - k + 1) x + (k - 1))^{b_i} \\
= & \prod_{i = 1}^n (k - 1)^{b_i} \prod_{i = 1}^n \left(1 + \frac{a_i - k + 1}{k - 1} x\right)^{b_i} \\
= & \prod_{i = 1}^n (k - 1)^{b_i} \exp \sum_{i = 1}^n b_i \ln \left(1 + \frac{a_i - k + 1}{k - 1} x\right) \\
= & \prod_{i = 1}^n (k - 1)^{b_i} \exp \sum_{i = 1}^n b_i \sum_{j \geqslant 1} \frac{(-1)^{j - 1} \left(\frac{a_i - k + 1}{k - 1}\right)^j x^j}{j} \\
= & \prod_{i = 1}^n (k - 1)^{b_i} \exp \sum_{j \geqslant 1} \frac{(-1)^{j - 1} x^j}{j} \sum_{i = 1}^n b_i \left(\frac{a_i - k + 1}{k - 1}\right)^j
\end{aligned}</script><p>注意到里面有一个 $\sum x^j \sum b_i d_i^j$ 的形式。这个该怎么处理呢？</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \sum_{j \geqslant 0} x^j \sum_{i = 1}^n b_i d_i^j \\
= & \sum_{i = 1}^n b_i \sum_{j \geqslant 0} (d_i x)^j \\
= & \sum_{i = 1}^n \frac{b_i}{1 - d_i x} \\
= & \frac{\sum_{i = 1}^n b_i \prod_{j \neq i}(1 - d_i x)}{\prod_{i = 1}^n (1 - d_i x)}
\end{aligned}</script><p>总结：菜就多刷题。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 6</title>
    <url>/random-solution-pb-6/</url>
    <content><![CDATA[<p>我对我暑假期间的摸鱼行为表示沉痛反省。</p>
<p>虽然但是，下次还敢。</p>
<p>有些套路的一道题。但是可以拿来锻炼代码能力。</p>
<p>来源懒得找了。</p>
<a id="more"></a>
<p>给出一个长度为 $n$ 的序列 $a_1, a_2, \dots, a_n$。对于所有 $k = 1, 2, \dots, n$，计算以下问题的答案：</p>
<ul>
<li>将序列 $a$ 划分为尽可能少的子区间，使得在每一个子区间内都至多出现 $k$ 个不同的数字。</li>
</ul>
<p>比如 $a = [1, 5, 7, 8, 1, 7, 6, 1]$，$k = 1, 2, \dots, 8$ 时的答案依次为 $[8, 4, 3, 2, 1, 1, 1, 1]$。具体方案如下：</p>
<ul>
<li>$k = 1$：$[[1], [5], [7], [8], [1], [7], [6], [1]]$</li>
<li>$k = 2$：$[[1, 5], [7, 8], [1, 7], [6, 1]]$</li>
<li>$k = 3$：$[[1, 5, 7], [8, 1, 7], [6, 1]]$</li>
<li>$k = 4$：$[[1, 5, 7, 8], [1, 7, 6, 1]]$</li>
<li>$k \geqslant 5$：$[[1, 5, 7, 8, 1, 7, 6, 1]]$</li>
</ul>
<p>$1 \leqslant n \leqslant 10^5$。$1 \leqslant a_i \leqslant n$。</p>
<p>$\texttt{2s/256MiB}$。</p>
<p>假设我们确定了一个 $k$ 的值，考虑这样一个简单直接的思路：每次贪心地删去最长的颜色数不超过 $k$ 的前缀。</p>
<p>注意到，对于序列的一个任意的长度为 $k$ 的子区间，它里面的颜色数必定不超过 $k$。即每次删去的前缀长度至少为 $k$。设每次确定前缀长度需要的时间复杂度为 $f(n)$，我们有</p>
<script type="math/tex; mode=display">
\sum_{k = 1}^n \left\lceil \frac{n}{k} \right\rceil f(n) = n \log n \cdot f(n)</script><p>于是考虑如何确定前缀长度。做法显然：对于每个位置 $i$，令 $p_i$ 表示 $a_i$ 下一次出现的位置，没有则为 $n + 1$。那么「区间 $[l, r]$ 内的颜色数」就可以转化为「区间 $[l, r]$ 内 $p_i \gt r$ 的 $i$ 的数量」。后者是一个二维数点问题，可以使用主席树求解。</p>
<p>二分一个 $\log$，主席树一个 $\log$，再加上最外层的部分就是 $\Theta(n \log^3 n)$。</p>
<p>很遗憾，这样是无法通过本题的。</p>
<p>平时我们在写线段树的时候，经常会用到线段树上二分的技巧来省去一个 $\log$。但是很遗憾，这种技巧在本题时不适用的。笔者表达能力有限，这部分就留给读者作为习题了。</p>
<p>考虑回顾整道题。现在我们已经将问题转化为了二维数点问题。但是仔细分析发现，我们的标记点只有 $\Theta(n)$ 个，但是询问次数却可以达到 $\Theta(n \log^2 n)$ 次。考虑想办法平衡时间复杂度。</p>
<p>考虑根号算法。将原序列每 $\sqrt n$ 个元素分成一个块。首先维护 <code>cnt1[i][j]</code> 表示前 $i$ 个块里面有多少个数字 $\leqslant j$。</p>
<p>然后考虑散块。注意到块内颜色数必定不会超过 $\sqrt n$，于是考虑块内离散化。即维护 <code>rank[i][j]</code> 表示第 $i$ 个块内 $j$ 的排名（$\lt j$ 的数字的数量 $+1$），<code>cnt2[i][j]</code> 表示 $i$ 这个位置所在的块内，$i$ 本身以及 $i$ 前面的位置里面，有多少个数字块内排名 $\leqslant j$。</p>
<p>上面三个数组的大小均为 $n^{1.5}$。预处理所需要的时间复杂度自然也是 $\Theta(n^{1.5})$。于是总时间复杂度 $\Theta(n^{1.5} + n \log^2 n)$。</p>
<p>还有一点，在本题的数据范围下，一个 $n^{1.5}$ 大小的 <code>int</code> 类型数组需要占用约 $\texttt{120MiB}$ 的内存，所以说三个这样的数组其实是开不下的。但是注意到 <code>rank</code> 和 <code>cnt2</code> 两个数组的值都很小，不会超过 $\sqrt n$。而在本题的数据范围下，后者的极限值约为 $320$。因此可以将这两个数组开成 <code>short</code> 类型。这样就可以通过了。</p>
<p><a href="https://codeforces.com/group/VWnF2uaMLi/contest/468262/submission/219065742">评测记录</a></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 7</title>
    <url>/random-solution-pb-7/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1900/problem/F">Codeforces Round 911 (Div. 2) F. Local Deletions</a></p>
<p>什么？我连 Div. 2 F 都写出来了？</p>
<a id="more"></a>
<p><strong>以下是前置知识。</strong></p>
<p>对于一个序列 $a_1, a_2, \dots, a_n$，定义 $a_i$ 是一个局部最小值当且仅当</p>
<script type="math/tex; mode=display">
(i = 1 \vee a_i \lt a_{i - 1}) \wedge (i = n \vee a_i \lt a_{i + 1})</script><p>定义 $a_i$ 是一个局部最大值当且仅当</p>
<script type="math/tex; mode=display">
(i = 1 \vee a_i \gt a_{i - 1}) \wedge (i = n \vee a_i \gt a_{i + 1})</script><p>设 $x$ 是一个序列，其中的数字互不相同。定义 <strong>操作</strong> $f_1(x)$ 表示保留 $x$ 中的所有局部最小值，并将这些数字按照原顺序拼接起来；$f_2(x)$ 类似，只不过是保留局部最大值。<strong>操作不给出返回值，而是会直接修改 $x$。</strong></p>
<p>定义 <strong>函数</strong> $f(x)$ 表示在 $x$ 上按照 $f_1, f_2, f_1, f_2, \dots$ 的顺序应用上述两种操作，直到 $x$ 中只剩下一个数字。那个数字就是 $f(x)$ 的值。</p>
<p>比如说，考虑 $[1, 3, 2]$。应用 $f_1$ 得到 $[1, 2]$，再应用 $f_2$ 得到 $[2]$。于是 $f([1, 3, 2]) = 2$。</p>
<p><strong>以下是正文。</strong></p>
<p>给出一个长度为 $n$ 的排列 $a_1, a_2, \dots, a_n$。$m$ 次询问，每次给出一个区间 $[l, r]$，试求 $f([a_l, a_{l + 1}, \dots, a_r])$。</p>
<p>$1 \leqslant n, m \leqslant 10^5$。</p>
<p>$\mathtt{3s/256MiB}$。</p>
<p>首先我们可以（或感性或理性地）注意到以下几点：</p>
<ol>
<li>大部分 $[l, r]$ 区间上的局部最值同时也是整个序列的局部最值</li>
<li>只有 $[l, r]$ 最靠两侧的两个数字可能不满足上一条</li>
<li>每次应用 $f_1$ 或 $f_2$，都会使得序列的长度至少减半</li>
</ol>
<p>我们可以预处理出整个序列应用 $k$ 次操作之后会变成什么样，记为 $A_k$。</p>
<p>对于依次针对 $[l, r]$ 的询问，应用 $k$ 次操作之后得到的序列，它的核心部分一定是 $A_k$ 的一个子区间。考虑到最靠两侧的两个数字可能会出问题，我们可以直接把它们拆成散点，然后对于所有拆出来的散点暴力求解。</p>
<p>这样，最多 $\log n$ 次模拟之后，核心区间就会完全消失，剩下最多 $2 \log n$ 个散点同样暴力求解。</p>
<p>时间复杂度的一个很松的上界是 $O(n \log n + m \log^2 n)$。但是基本跑不满，在实际数据上的表现非常优秀。</p>
<p>看了一眼官方题解，看到还提到了一个性质：左右两边的散点数量各自不会超过一个。</p>
<p>这十分明显：每次核心区间分裂出散点之后，这个新的散点和之前旧的散点必定只能保留一个。</p>
<p>这样一看的话时间复杂度应该在 $\Theta((n + m) \log n)$ 左右。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>アイリスの咲く季節が巡り、四十八月の雨が降る</title>
    <url>/karen-captain-contest-notes-2023/</url>
    <content><![CDATA[<p>就是可怜队长 CLT 的 2023 下半年的比赛游记了。</p>
<p>大一那年在集训队里的地位还没有构建起来，大二那年还有疫情影响，导致大三才体验到到处跑打比赛是什么感受。</p>
<a id="more"></a>
<h2 id="CCSP-Day-2（2023-10-22）"><a href="#CCSP-Day-2（2023-10-22）" class="headerlink" title="CCSP Day -2（2023-10-22）"></a>CCSP Day -2（2023-10-22）</h2><p>听说冬权老师率领的三队在 ICPC 西安站势如破竹勇夺一块银牌。</p>
<p>鱼的那一队似乎也银了。现在压力来到一队这边。</p>
<h2 id="CCSP-Day-1（2023-10-23）"><a href="#CCSP-Day-1（2023-10-23）" class="headerlink" title="CCSP Day -1（2023-10-23）"></a>CCSP Day -1（2023-10-23）</h2><p>试着补了一下昨天的 CF。Div. 1 + 2 + 3 还真是第一次见。</p>
<p>看了一下 Div. 1 的 A 和 B，感觉不一定能写出来。</p>
<p>写了一下 C，但是因为低级错误交了五发才过。</p>
<p>我是罚时国王（绝望</p>
<h2 id="CCSP-Day-0（2023-10-24）"><a href="#CCSP-Day-0（2023-10-24）" class="headerlink" title="CCSP Day 0（2023-10-24）"></a>CCSP Day 0（2023-10-24）</h2><p>早上试着单人 VP 了一下 <a href="https://atcoder.jp/contests/ttpc2023">東京工業大学プログラミングコンテスト 2023</a>。</p>
<p>写了 A。</p>
<p>B 是一个有点技巧的优化建图题，感觉有点麻烦就没写。</p>
<p>C 是一个不知道怎么回事的数学题，看了一眼题解感觉挺麻烦的就放弃了。</p>
<p>E 一看感觉很高深，看了题解发现需要用到高斯整数，感觉超出了自己的知识储备就放弃了。</p>
<p>F 是一个复杂度分析理论 + 大模拟，看了题解发现细节非常多就懒得写了。</p>
<p>H 是一个以前嘴巴过的字符串题，基本上是套个板子就差不多了的题于是就没写。</p>
<p>剩下又看了几道题感觉都不会，于是就润了。</p>
<p>感觉心态莫名其妙地浮躁，平静不下来。这个样子去打比赛怕不是要打铁了。</p>
<p>马上就要坐飞机赶去沈阳准备打 CCSP 了。话说回来我上一次坐飞机是几岁来着了。</p>
<p>打车 11：00 左右到了机场，但是因为没有做过飞机不会办理手续于是只能等鸭佬过来。</p>
<p>午饭品鉴了排骨面，虽然但是一整碗面只有一块排骨而且没有多少肉。感觉被坑了。</p>
<p>吃完午饭去办理值机的时候发现座位已经没有了。于是被临时调了一个商务舱的座位。于是白嫖了商务舱的服务。</p>
<p>品鉴了飞机上提供的辣子鸡，还不错。不过橙汁是真的酸。</p>
<p>下飞机之后又坐了一个小时的地铁到酒店。</p>
<p>这个时候突然被告知 CCF 之前发过一封邮件，里面有这次 CCSP 的赛程。</p>
<p>一看发现我超，从 9：00 考到 21：00，整整 12h 的极致坐牢体验。</p>
<p>然后就去学校报道了。</p>
<p><img src="/img/游记/CSP 六人组（笔者在左二；没有鱼）.jpg" alt="CSP 六人组（笔者在左二；没有鱼）"></p>
<p><img src="/img/游记/CSP 高分墙.jpg" alt="CSP 高分墙"></p>
<p>晚餐和群友一起品鉴了铁锅炖。非常的美味。</p>
<p>这个时候鱼佬姗姗来迟，跟我们分享了他们队伍在 ICPC 西安站勇夺「顽强拼搏奖」的故事（指比赛结束前 2s 交题并过题）。</p>
<p><img src="/img/游记/夜间的沈阳街头 1.jpg" alt="夜间的沈阳街头"></p>
<p><img src="/img/游记/夜间的沈阳街头 2.jpg" alt="夜间的沈阳街头"></p>
<p><img src="/img/游记/夜间的沈阳街头 3.jpg" alt="夜间的沈阳街头"></p>
<p><img src="/img/游记/夜间的沈阳街头 4.jpg" alt="夜间的沈阳街头"></p>
<p><img src="/img/游记/铁锅炖.jpg" alt="铁锅炖"></p>
<p>晚餐之后群友又去品鉴了沈阳街头小吃。</p>
<p><img src="/img/游记/安大妈丸子.jpg" alt="安大妈丸子"></p>
<p>回到酒店之后就葛优躺了。</p>
<h2 id="CCSP-Day-1（2023-10-25）"><a href="#CCSP-Day-1（2023-10-25）" class="headerlink" title="CCSP Day 1（2023-10-25）"></a>CCSP Day 1（2023-10-25）</h2><p>一整个晚上感觉没太睡好。</p>
<p>8：30 左右赶到考场。和 XCPC 不一样，这边是给提供电脑的。</p>
<p>几位群友执意要合影留念。我感觉有点公开处刑就润了。</p>
<p><img src="/img/游记/白天的沈阳街头.jpg" alt="白天的沈阳街头"></p>
<p><img src="/img/游记/沈阳师范大学 1.jpg" alt="沈阳师范大学"></p>
<p><img src="/img/游记/沈阳师范大学 2.jpg" alt="沈阳师范大学"></p>
<p><img src="/img/游记/CSP 六人组（没有笔者）.jpg" alt="CSP 六人组（没有笔者）"></p>
<p>但是只能用电脑自带的薄膜键盘。最左下角甚至不是 Ctrl 键是 Fn 键导致非常的难用。</p>
<p>试机一共两道题。一道是 A + B，另外一道是非常简单的树上 DP。</p>
<p>正赛一共五道题。然而前三道题的题面加起来一共 7 页。然后 D 题 11 页，E 题 19 页。</p>
<p>我看不懂，但我大受震撼。</p>
<p>花了 40min 写出来了 A 题的 60 分。然后又花了 40min 写出来了 B 题的 50 分。</p>
<p>冷静了一下之后用 20min 切掉了 B 题。然后又用了 20min 把 A 题改到了 95 分。</p>
<p>接下来的 C 题整整花了我 2.5h（不包括吃午饭的用时），而且还只写出来了一个 80 分的做法。</p>
<p>这个时候已经 14：00 了。对着剩下两道题看了看感觉实在不是自己能够写得了的题目。于是品鉴玩晚饭 18：00 左右就离场了。</p>
<p>在外面等了 1h 左右（因为房卡在鸭佬那里），然后鸭佬也出来了。</p>
<p>和鸭佬一起买了蜜雪冰城，品鉴了麻辣烫。</p>
<p>本来想去吃麦当劳的，结果进店看了看感觉有点贵，消费力跟不上就放弃了。</p>
<p><img src="/img/游记/麻辣烫.jpg" alt="麻辣烫"></p>
<p><img src="/img/游记/夜间的沈阳街头 5.jpg" alt="夜间的沈阳街头"></p>
<p><img src="/img/游记/夜间的沈阳街头 6.jpg" alt="夜间的沈阳街头"></p>
<p><img src="/img/游记/夜间的沈阳街头 7.jpg" alt="夜间的沈阳街头"></p>
<p>回到酒店，被阿烜怒斥说这种提前跑路的行为没有奥林匹克精神。</p>
<p>然后收到了鱼佬刑满释放的消息。</p>
<blockquote>
<p>我「这不给鱼佬颁个『耐力奖』（」</p>
<p>LXR「『顽强拼搏奖』（」</p>
</blockquote>
<h2 id="CCPC-桂林-Day-1（2023-10-26）"><a href="#CCPC-桂林-Day-1（2023-10-26）" class="headerlink" title="CCPC 桂林 Day -1（2023-10-26）"></a>CCPC 桂林 Day -1（2023-10-26）</h2><p>早上六点就醒了然后睡不着了。</p>
<p>为什么这个酒店一到这个点窗外就会有鸽子啊，在外面又是咕咕叫又是拍翅膀的吵死了（全脑</p>
<p>这该不会是什么奇妙的叫醒服务吧。</p>
<p><img src="/img/游记/鸽子.jpg" alt="鸽子"></p>
<p>中午的时候鸭佬说想去沈阳市区逛一逛，于是换了一家酒店住。</p>
<p>下午有点困于是一觉睡到五点。然后鸭佬出去逛街了。</p>
<p>似乎 zhuoer 也在沈阳，本来想去找他的结果拖到 20：00 就没去了。</p>
<p>以及听说铜首了。这就是 CCSP 的含金量吗 275 铜牌。</p>
<p>这个酒店房间的隔音似乎很差，甚至能听到隔壁的说话声。</p>
<p>晚上点了麦当劳，然后又看到了可可爱爱送外卖机器人。</p>
<p>之前去 EC Final 的时候就想过，机器人是怎么按电梯按钮的，看来是内部系统是连在一起的。</p>
<p><img src="/img/游记/送外卖机器人.jpg" alt="送外卖机器人"></p>
<h2 id="CCPC-桂林-Day-0（2023-10-27）"><a href="#CCPC-桂林-Day-0（2023-10-27）" class="headerlink" title="CCPC 桂林 Day 0（2023-10-27）"></a>CCPC 桂林 Day 0（2023-10-27）</h2><p>下午坐飞机去桂林打 CCPC。</p>
<p><img src="/img/游记/桂林站酒店.jpg" alt="桂林站酒店"></p>
<p>到九点的时候已经 23：00 了，于是和鸭佬一起品鉴了塔斯汀汉堡。</p>
<p>本来想点麦门的不过确实是有点贵。</p>
<h2 id="CCPC-桂林-Day-1（2023-10-28）"><a href="#CCPC-桂林-Day-1（2023-10-28）" class="headerlink" title="CCPC 桂林 Day 1（2023-10-28）"></a>CCPC 桂林 Day 1（2023-10-28）</h2><p>一觉睡到 10：00 没赶上酒店的早餐，于是直接跳过早餐到午餐了。</p>
<p>和鸭佬一起品鉴了外卖猪脚饭。</p>
<p>下午正准备去考场的时候遇到了高中同学 SWY。</p>
<p>振奋 .jpg</p>
<p>到了考场发现居然开幕式还有表演。</p>
<p><img src="/img/游记/表演.jpg" alt="表演"></p>
<p><img src="/img/游记/桂林站考场.jpg" alt="桂林站考场"></p>
<p><img src="/img/游记/学校墙.jpg" alt="学校墙"></p>
<p><img src="/img/游记/三条可怜.jpg" alt="三条可怜"></p>
<p><img src="/img/游记/奇妙的提交与罚时.jpg" alt="奇妙的提交与罚时"></p>
<p><img src="/img/游记/奇妙的问答.jpg" alt="奇妙的问答"></p>
<p><img src="/img/游记/我去，柚子厨！.jpg" alt="我去，柚子厨！"></p>
<p>开幕式进行到一半的时候发现可以看题了，于是看了看 A。</p>
<p>队友提供了一个思路，写完正准备交发现比赛推迟了。</p>
<p>过了一会又回去看的时候发现突然可以交了。喜提 6min 罚时。</p>
<p>然后队友去看 B。似乎是一个 LIS，不过鸭佬直接开始写线段树了。</p>
<p>这个时候我去看了看 D。花了几分钟验证了一下一个关于欧拉函数的柿子，虽然实际上并没有用到。</p>
<p>想了想感觉出来了一个关于 D 的性质。写了一发结果 T 了。</p>
<p>又仔细想了想发现那个性质是不对的。于是就放弃了。</p>
<p>旁边队友讨论了很久，写了 1h+ 才磕磕绊绊开出 B。</p>
<p>然后就只剩下大概 30min 开 C 了。队友写了个凸包发现不对，于是就下机了。</p>
<p>快结束的时候去和 SWY 交流了一下想法，获取到了 C 的正解。</p>
<p>赛后看了看 dalao 在知乎上发的题解，感觉好像也不是很难（bushi</p>
<p><img src="/img/游记/热身赛的三条可怜.jpg" alt="热身赛的三条可怜"></p>
<p>这个时候我的手机已经没电了，去找了个小卖部租了一个充电宝充到了 6%。虽然很少不过还好撑到回到酒店了。</p>
<p>晚上跟着 HMD dalao 去电玩城打街机。</p>
<p>看到 dalao 在旁边像八爪鱼一样敲着音游机台感觉十分震撼。</p>
<p>在旁边找到了一个 STG 的台子，于是打开了《怒首领蜂》。</p>
<p>经过十把左右的尝试，成功地见到了 4 BOSS。</p>
<p>然后被打死了。</p>
<p>最后续了一个币进了五面，结果被道中打成筛子，大败落荒而逃。</p>
<p><img src="/img/游记/街机厅 1.jpg" alt="街机厅"></p>
<p><img src="/img/游记/街机厅 2.jpg" alt="街机厅"></p>
<p><img src="/img/游记/投篮游戏.jpg" alt="投篮游戏"></p>
<p><img src="/img/游记/（似乎是）格斗游戏.jpg" alt="（似乎是）格斗游戏"></p>
<p><img src="/img/游记/舞萌 DX 1.jpg" alt="舞萌 DX"></p>
<p><img src="/img/游记/舞萌 DX 2.jpg" alt="舞萌 DX"></p>
<p><img src="/img/游记/飞机.jpg" alt="飞机"></p>
<p><img src="/img/游记/大战怒蜂 1 道中 BOSS（鸭佬拍摄）.jpg" alt="大战怒蜂 1 道中 BOSS（鸭佬拍摄）"></p>
<h2 id="CCPC-桂林-Day-2（2023-10-29）"><a href="#CCPC-桂林-Day-2（2023-10-29）" class="headerlink" title="CCPC 桂林 Day 2（2023-10-29）"></a>CCPC 桂林 Day 2（2023-10-29）</h2><p>早上 7：30 痛苦地爬起来去打比赛。</p>
<p>听群友说学校有打印店。于是 7：40 到学校之后极限让鸭佬跑去把板子打印出来了。</p>
<p>首先把签到 M 写出来了。</p>
<p>然后鸭佬开 G 我开 I。</p>
<p>鸭佬写了 1h 的 G 结果 WA 了，让我去看看。</p>
<p>我看了一眼题面 2min 给出了一个做法，写了写交上去过了。</p>
<p>然后我感觉 I 有一些想法，结果写了 2h+ 没有写出来。</p>
<p>中间主办方给发了午餐，一袋（包装上写着「手抓饼」的）鸡块和一个汉堡，还有一小瓶可口可乐。</p>
<p>这个时候 HMD 发现 K 的数据范围非常巧妙，只需要小小地分类讨论一下就可以暴力过。于是写了 1h 过了。</p>
<p>这个时候我发现我 I 维护的其中一部分信息可能是冗余的，我把这部分去掉之后就过了。</p>
<p>然后队友去看 B，给我了一个思路然后我磕磕绊绊地在比赛最后 2min 的时候写了出来交上去过了。</p>
<p>最后 5 题将近 1000 罚时，喜提铜首。</p>
<blockquote>
<p>冬权老师「成功拿铁，庆功宴改开批斗大会。」</p>
</blockquote>
<p><img src="/img/游记/正式赛的三条可怜.jpg" alt="正式赛的三条可怜"></p>
<p><img src="/img/游记/诸神之战（确信）.jpg" alt="诸神之战（确信）"></p>
<p>晚上又和 HMD 去街机厅打游戏。</p>
<p>续币两次突破了 5 BOSS，结果我超你这游戏怎么还有 6 面的。</p>
<p>尝试了舞萌 DX，感觉良好。</p>
<p>安大附近似乎也有机台，以前都没了解过。改天可以找鸭佬再去打（bushi</p>
<p><img src="/img/游记/蓝屏.jpg" alt="蓝屏"></p>
<p><img src="/img/游记/舞萌 DX 2.jpg" alt="舞萌 DX"></p>
<h2 id="归途-·-其一（2023-10-30）"><a href="#归途-·-其一（2023-10-30）" class="headerlink" title="归途 · 其一（2023-10-30）"></a>归途 · 其一（2023-10-30）</h2><p>一觉睡到 10：00 才起来。</p>
<p>中午和两名队友一起品鉴了肯德基。</p>
<p>晚上坐着鸭佬家长公司的员工的车回到了龙河。在那之前一起去品鉴了椰子火锅，可惜忘记拍照了。</p>
<h2 id="CCPC-深圳-Day-1（2023-11-9）"><a href="#CCPC-深圳-Day-1（2023-11-9）" class="headerlink" title="CCPC 深圳 Day -1（2023-11-9）"></a>CCPC 深圳 Day -1（2023-11-9）</h2><p>鸭佬订的是 22：00 的飞机，于是 19：30 打车去机场。</p>
<p>花了 50，略贵。</p>
<p>然后飞机还延误了整整 1h，第二天 1：20 左右才到的深圳。</p>
<p>然后又做了 1.5h 的公交车和 0.5h 的出租车才辗转到了酒店。</p>
<h2 id="CCPC-深圳-Day-0（2023-11-10）"><a href="#CCPC-深圳-Day-0（2023-11-10）" class="headerlink" title="CCPC 深圳 Day 0（2023-11-10）"></a>CCPC 深圳 Day 0（2023-11-10）</h2><p>这次订的酒店房间是一张大床，于是要和鸭佬同床共枕了。</p>
<p>太不像话了，这简直就是楠桐 .jpg</p>
<p>虽然已经凌晨 4：00 了但是有点饿于是点了华莱士外卖。</p>
<p>吃完外卖之后完了一会游戏，6：00 左右试图睡觉然而睡不着。</p>
<p>中午和鸭佬一起品鉴了猪脚饭。非常的好吃。</p>
<p>然后我就昏迷过去了，一直到 20：00 才醒来。</p>
<p>这期间鸭佬和 HMD 去逛街了。</p>
<h2 id="CCPC-深圳-Day-1（2023-11-11）"><a href="#CCPC-深圳-Day-1（2023-11-11）" class="headerlink" title="CCPC 深圳 Day 1（2023-11-11）"></a>CCPC 深圳 Day 1（2023-11-11）</h2><p>因为前一天起的很晚所以晚上完全睡不着。</p>
<p>1：00 睡着，醒了两次 3：00 去上了个厕所睡不着了。</p>
<p>鸭佬下楼品鉴了麦当劳早餐，顺便给我带了一份。</p>
<p>11：30 左右和队友们去深圳科技大学报到。</p>
<p>报道完之后品鉴了食堂，感觉还行。</p>
<p>去听了开幕式，感觉就是一堆领导上去放屁。</p>
<blockquote>
<p>主持人「开幕式到此结束。请参赛选手前往羽毛球场进行热身。」</p>
</blockquote>
<p>热身（指打羽毛球（bushi</p>
<p>等着进考场的时候有人过来问我说「你们这个三条可怜是什么意思啊。」</p>
<p>「我只知道九条可怜。」</p>
<p>于是我就回答说「因为我们是三个人所以叫三条可怜。」</p>
<p>考场还蛮大的，可以清楚的看到旁边和对面的各一个队伍。</p>
<p><img src="/img/游记/深圳站考场 1.jpg" alt="深圳站考场"></p>
<p><img src="/img/游记/深圳站考场 2.jpg" alt="深圳站考场"></p>
<p>热身赛一共三题。A 是神仙构造；B 是思博暴力；C 是 lxl。</p>
<p>看了看 A 感觉不会于是交给队友了。</p>
<p>想了 1.5h 的 C 想出来一个解法，可以归纳成单点插入和区间求和。</p>
<p>可惜忘记拿板子了敲不出来平衡树。</p>
<p>感觉平衡树的熟练度还是需要提升一下的，至少提升到像线段树一样随手可以写出来吧。</p>
<p>赛后和同校队伍交流了 A 题，发现居然要用到异或。干败吓疯 .jpg</p>
<p>逛了逛考场，用鸭佬的手机拍了几张逆天队名。</p>
<p><img src="/img/游记/难铜首银摄金.jpg" alt="难铜首银摄金"></p>
<p><img src="/img/游记/真的是菜狗，吗？.jpg" alt="真的是菜狗，吗？"></p>
<p>这里甚至还配备有 AED。</p>
<p><img src="/img/游记/AED.jpg" alt="AED"></p>
<p>想象一下，参赛选手因为开不出题而突发心脏病，志愿者对其进行紧急救助（bushi</p>
<p>晚宴懒得去了，和鸭佬回到了酒店。</p>
<p>19：00 的时候不知道为什么突然非常困于是睡过去了。</p>
<p>一觉睡到第二天 3：00</p>
<h2 id="CCPC-深圳-Day-2（2023-11-12）"><a href="#CCPC-深圳-Day-2（2023-11-12）" class="headerlink" title="CCPC 深圳 Day 2（2023-11-12）"></a>CCPC 深圳 Day 2（2023-11-12）</h2><p>早上起来之后直接退房了。</p>
<p>然后坐另一位可能是参赛选手的车到了考场。</p>
<p>这个考场查得似乎很严啊还要过金属探测器。</p>
<p>进场之后发现板子么没带于是极限跑过去拿，成功在比赛开始前 1min 赶回去了。</p>
<p>开题之后，一看 A 就感觉有思路，于是开始写。</p>
<p>写了 1h 发现过不了，于是交给队友写 I。</p>
<p>然后队友写了 1h 的 I 发现过不了，于是我们开始一起看 A。</p>
<p>然而想了很久的 A 都没有想出来。</p>
<p>这个时候我看了看 F 感觉可以，于是交了一发过了。</p>
<p>这个时候已经比赛过去 3h+ 了。</p>
<p>剩下两个小时我们一直在想 A，然而还是没过。</p>
<p>中间我推了推 B 的柿子。推出来一个多项式 $\exp$ 一写发现不对。</p>
<p>又算了算发现上面那个柿子是假的。然后就放弃了。</p>
<p>最后 1 题，喜提铜牌。连去颁奖典礼的脸都没了。</p>
<p>三条可怜，大败而归（绝望</p>
<p>晚上找了一个网吧试图过夜。</p>
<p>听说在网吧电脑登 Steam 账号会很危险，于是试图登小号。</p>
<p>但是小号上全都是黄油。网吧电脑上也没有什么会玩的游戏。</p>
<p>于是玩了一个晚上的手机。到半夜还没电了。</p>
<p>体验很差，下次不去网吧了。</p>
<p><img src="/img/游记/恶臭机号.jpg" alt="恶臭机号"></p>
<p><img src="/img/游记/卷.jpg" alt="卷"></p>
<h2 id="归途-·-其二（2023-11-13）"><a href="#归途-·-其二（2023-11-13）" class="headerlink" title="归途 · 其二（2023-11-13）"></a>归途 · 其二（2023-11-13）</h2><p>虽然只睡了 2h+ 但是我感觉精神状态非常良好。</p>
<p>早上和队友们一起品鉴了深圳街头叉烧包。非常的好吃。</p>
<p>7：20 坐飞机飞往南京。等我们赶到登机口的时候广播已经开始催了。</p>
<p>最极限的一集。</p>
<p>到了南京之后马上就被巨大的温差冻得浑身发抖。</p>
<p>然后就坐火车回合肥，再然后就分头回学校了。</p>
<h2 id="ICPC-合肥-Day-1（2023-11-25）"><a href="#ICPC-合肥-Day-1（2023-11-25）" class="headerlink" title="ICPC 合肥 Day 1（2023-11-25）"></a>ICPC 合肥 Day 1（2023-11-25）</h2><p>一觉睡到 12：00 才醒来。</p>
<p>因为龙河直接就在科大旁边，所以可以直接走路过去。</p>
<p>品鉴了科大的食堂。感觉非常地成功。</p>
<p>看到考场门口还有一些小游戏，甚至还有奖品。</p>
<p>可惜我到的时候已经结束了。</p>
<p><img src="/img/游记/合肥站校徽墙.jpg" alt="合肥站校徽墙"></p>
<p><img src="/img/游记/击倒 BUG 规则.jpg" alt="击倒 BUG 规则"></p>
<p><img src="/img/游记/击倒 BUG.jpg" alt="击倒 BUG"></p>
<p><img src="/img/游记/弹走 BUG 规则.jpg" alt="弹走 BUG 规则"></p>
<p><img src="/img/游记/弹走 BUG.jpg" alt="弹走 BUG"></p>
<p>到了考场之后发现 BJ 也在。看到了位置但是有点可惜没有上去打招呼。</p>
<p>当然块也在。</p>
<p><img src="/img/游记/三条可怜（夏季限定）.jpg" alt="三条可怜（夏季限定）"></p>
<p><img src="/img/游记/合肥站三条可怜 1.jpg" alt="合肥站三条可怜"></p>
<p><img src="/img/游记/合肥站三条可怜 2.jpg" alt="合肥站三条可怜"></p>
<p>热身赛开始前 10min 左右试题册就发下来了。</p>
<p>看到周围的队伍都在打开试题册开始看题于是我们也开始了。</p>
<p>直到过了一会监考人员过来告诉我们说不要打开试题册。</p>
<p>A 是一个构造题——算是吧——给你 $n$ 个点为根的 DFS 序，让你还原出整棵树。保证有解。</p>
<p>一开始我有一个想法，就是类似于二叉树前中后序遍历的相互转化一样。</p>
<p>一个点的子树必定对应了 DFS 序上的一段连续区间。</p>
<p>后来一想，这是在所有 DFS 序都以 $1$ 号点为根的前提下的性质。</p>
<p>可能在求以 $2$ 号点为根的 DFS 序的时候，一上来直接访问 $1$ 号点。这样就出锅了。</p>
<p>看了看 B。乍一看是个很板子的树上背包，但是数据范围给的很大。</p>
<p>$n k^2$ 差不多有 $1.4 \times 10^9$ 那么大。</p>
<p>后来再仔细一看，B 的时间给了 $\mathtt{8s}$。</p>
<p>或许正解真的就是 $\Theta(n k^2)$ 卡常吧。</p>
<p>C 是一个看上去就很容易搞的数据结构题。</p>
<p>无穷大的二位格点网格，初始点权均为 $0$。$m$ 次操作 / 询问，每次操作给所有点的点权加上</p>
<script type="math/tex; mode=display">
w \cdot \max\{d - \operatorname{dist}((x, y), (x_0, y_0)), 0\}</script><p>这里 $\operatorname{dist}$ 表示切比雪夫距离；每次询问就是给出一个矩形范围求点权和。</p>
<p>因为 $m$ 非常地小，甚至可以 $\Theta(m^2)$ 暴力枚举所有修改 - 询问的对来算贡献。</p>
<p>可惜最后没有写出来。</p>
<p>最后的 D 是一个 diaomao 知识问答。给了你六道判断题像是「中国科学技术大学是否位于中国的首都——北京」「中国科学技术大学是否流传着一则校园传说，说是第一教学楼的地底埋藏着黄金」。</p>
<p>比赛结束之后再次品鉴了科大食堂。</p>
<p>科大是每个队三个人给了一张临时饭卡，里面有 180 元。</p>
<p>还是非常豪华的。</p>
<p><img src="/img/游记/中科大校内 1.jpg" alt="中科大校内"></p>
<p><img src="/img/游记/中科大校内 2.jpg" alt="中科大校内"></p>
<p><img src="/img/游记/中科大校内 3.jpg" alt="中科大校内"></p>
<p>晚上和高中同学块一起去逛街。于是提出去之心城。</p>
<p>在路上的时候和他分享了新生赛的 C 题，就是那道莫队题。</p>
<p>块在一段时间的思考之后给出了一个在线的做法。</p>
<p>到了之心城之后发现，因为我也不熟，所以只是逛了逛就离开了。</p>
<p>只是到处走了走，到处看了看，然后就离开了。</p>
<p><img src="/img/游记/阿块的酒店 1.jpg" alt="阿块的酒店"></p>
<p><img src="/img/游记/阿块的酒店 2.jpg" alt="阿块的酒店"></p>
<blockquote>
<p>我「太失败了。」</p>
</blockquote>
<h2 id="ICPC-合肥-Day-2（2023-11-26）"><a href="#ICPC-合肥-Day-2（2023-11-26）" class="headerlink" title="ICPC 合肥 Day 2（2023-11-26）"></a>ICPC 合肥 Day 2（2023-11-26）</h2><p>早上 8：00 被鸭佬的非常吵闹的闹铃吵醒了。</p>
<p>到了考场之后本来想到 BJ 的队伍去看一看的，结果实在是没认出来。</p>
<p>打开题面一看。感觉 B 是一个还行的 $\Theta(n^3)$ 的 DP。</p>
<p>往后看了看感觉没有那种一看就非常简洁的题目。</p>
<p>这个时候听到隔壁在说 F 是签到题，于是去看，发现确实。</p>
<p>用了 15min 左右写了出来，一交发现 WA 了。</p>
<p>改了改又一交发现 TLE 了。</p>
<p>又仔细看了看题目描述发现读错题了。</p>
<p>改了改又一交发现又 TLE 了。</p>
<p>这个时候旁边公告说是评测机出锅了。于是跳过 F 开始看其他题。</p>
<p>然后队友去开 E，交了一发过了。</p>
<p>于是自己去开 G，感觉二分一下再写个 DP 可以，于是用了 1h 的时间写出来了。</p>
<p>这个时候评测机已经很卡了。随便交一发就需要测个 3min+。</p>
<p>然后 F 的重测还没好，于是就又交了一发过了。</p>
<p>虽然过了一会发现一开始的那发重测也过了。于是喜提 1h 多余的罚时。</p>
<p>这个时候去写 B，然后写到一半发现假了。</p>
<p>然后队友开始开 J。结果一直开到比赛结束都没有开出来。</p>
<p>中间我看着 L 可以写，就是个模拟，于是打算写。</p>
<p>写了些发现不对，又仔细分析了一下发现自己想得太简单了。</p>
<p>感受到了概率的玄妙之处。</p>
<p>最后 3 题末尾。滚榜的时候惊人地发现居然还有一块铜牌。</p>
<p><img src="/img/游记/合肥站滚榜.jpg" alt="合肥站滚榜"></p>
<p><img src="/img/游记/合肥站 J 题解.jpg" alt="合肥站 J 题解"></p>
<p>下午去科大小卖部把卡里剩下的 80 块钱全部花掉买了一大堆零食。</p>
<p>物尽其用 .jpg</p>
<p><img src="/img/游记/科大美食广场.jpg" alt="科大美食广场"></p>
<p><img src="/img/游记/美食广场机器人.jpg" alt="美食广场机器人"></p>
<p><img src="/img/游记/超市里大扫货.jpg" alt="超市里大扫货"></p>
<h2 id="ICPC-杭州-Day-0（2023-23-8）"><a href="#ICPC-杭州-Day-0（2023-23-8）" class="headerlink" title="ICPC 杭州 Day 0（2023-23-8）"></a>ICPC 杭州 Day 0（2023-23-8）</h2><p>下午和队友们乘坐高铁到达了杭州，然后坐地铁到达了酒店附近。</p>
<p>地铁还正好是在「打铁关」站换乘。这也太不吉利了。</p>
<p><img src="/img/游记/打铁关.jpg" alt="打铁关"></p>
<p>这个时候导航突然开始抽风，带着我们在酒店附近随机游走。</p>
<p><img src="/img/游记/夜间的杭州街头 1.jpg" alt="夜间的杭州街头"></p>
<p><img src="/img/游记/夜间的杭州街头 2.jpg" alt="夜间的杭州街头"></p>
<p><img src="/img/游记/夜间的杭州街头 3.jpg" alt="夜间的杭州街头"></p>
<p><img src="/img/游记/夜间的杭州街头 4.jpg" alt="夜间的杭州街头"></p>
<p><img src="/img/游记/夜间的杭州街头 5.jpg" alt="夜间的杭州街头"></p>
<p>酒店房间里面还是很高级的。</p>
<p><img src="/img/游记/名言警句.jpg" alt="名言警句"></p>
<p><img src="/img/游记/俯瞰夜间的杭州街头.jpg" alt="俯瞰夜间的杭州街头"></p>
<p>晚上和 HMD 一起去品鉴了麦当劳的板烧鸡腿堡套餐</p>
<p><img src="/img/游记/麦当劳店内.jpg" alt="麦当劳店内"></p>
<p>听说附近有音游机厅。跟着 HMD 去了最近的万达广场发现不对，机厅在另一家万达。</p>
<p>结果另一家万达离这里 2km 之远。而且还剩 1h 就有关门了于是今天晚上就放弃了。</p>
<p>最后一场区域赛了。希望这次能有大金牌吧。</p>
<h2 id="ICPC-杭州-Day-1（2023-23-9）"><a href="#ICPC-杭州-Day-1（2023-23-9）" class="headerlink" title="ICPC 杭州 Day 1（2023-23-9）"></a>ICPC 杭州 Day 1（2023-23-9）</h2><p>本来今天应该有热身赛的，但是懒得去打了。</p>
<p>两个队友倒是去打了。</p>
<p>他们好像开了两题，然后把 CD 两题发给了我。</p>
<p>场外求助 .jpg</p>
<p>C 题我一眼就知道是 CF 原题。</p>
<p>上网搜了搜真的给搜到了。是 CF1840G1/2 的数据范围强化版本。</p>
<p>看了看 CF 官方题解，研究了一下看懂了。</p>
<p>D 题是个奇妙的异或题目。不会。</p>
<h2 id="ICPC-杭州-Day-2（2023-23-10）"><a href="#ICPC-杭州-Day-2（2023-23-10）" class="headerlink" title="ICPC 杭州 Day 2（2023-23-10）"></a>ICPC 杭州 Day 2（2023-23-10）</h2><p>0：00 睡觉，7：00 起床。健康作息。</p>
<p><img src="/img/游记/俯瞰早晨的杭州街头.jpg" alt="俯瞰早晨的杭州街头"></p>
<p><img src="/img/游记/深圳站校徽墙.jpg" alt="深圳站校徽墙"></p>
<p>到了学校发现生态环境非常好。</p>
<p>河里面还有鹅。而且鹅叫得非常吵。</p>
<p><img src="/img/游记/鹅.jpg" alt="鹅"></p>
<p>到了考场，映入眼帘的便是……</p>
<p>便是原神手办！</p>
<p>每个队伍给发了三个盲盒手办。</p>
<p><img src="/img/游记/原神手办.jpg" alt="原神手办"></p>
<p><img src="/img/游记/三条可怜（冬季限定）.jpg" alt="三条可怜（冬季限定）"></p>
<p>9：00 开始，8：55 才下发纸质试题集。</p>
<p>看着好像很厚的一个文件袋。打开一看发现居然有三份英文题面和三份中文题面。</p>
<p>一打开题面。HMD 开始看 A。我从后往前看。</p>
<p>过了一会 HMD 的 A 有了想法但是发现假了。</p>
<p>这个时候我看其他队伍好像开始过 M，于是也开始想。</p>
<p>结果写了 30min+ 终于艰难地通过了。</p>
<p>然后鸭佬接手并过了 J。好像是个神奇的交互题的样子。</p>
<p>看了看 D，简单构造了一下就过了。</p>
<p>然后我看到了 H。感觉是一个挺简单的基环树概率 DP。</p>
<p>结果写了大半天喜提 20 多发 RE + WA。</p>
<p>另一边 HMD 在看 G，但是也是写了大半天喜提 WA。</p>
<p>最后三题。封榜前铜尾。这一揭榜必然打铁。</p>
<p>打铁关的诅咒 .jpg</p>
<p>感觉确实是水平不够。干败吓疯 .jpg</p>
<p>离开考场前打开了盲盒手办。是芭芭拉的。</p>
<p><img src="/img/游记/芭芭拉.jpg" alt="芭芭拉"></p>
<p>下午紧急买了高铁票赶回合肥。</p>
<p>落荒而逃（bushi</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>难题</tag>
        <tag>2023</tag>
        <tag>失败</tag>
      </tags>
  </entry>
  <entry>
    <title>ずっと面倒臭い時代の端で思い込んでいた少女だった</title>
    <url>/ccpc-final-2023-notes/</url>
    <content><![CDATA[<p>居然混到了一个 CCPC Final 的名额……</p>
<a id="more"></a>
<h2 id="Day-0（2024-3-29）"><a href="#Day-0（2024-3-29）" class="headerlink" title="Day 0（2024-3-29）"></a>Day 0（2024-3-29）</h2><p>熬了一个晚上，打算赶今天上午的飞机。</p>
<p>结果估算错了从学校到机场的时间。我本来以为只需要 30min 的结果花了我整整 1h+。</p>
<p>过安检的时候广播已经开始催了。</p>
<p>于是急得我从安检处跑步冲到登机口。（知识点，圈起来后面要考）</p>
<p>到了成都，还没出机场就开始和阿块快乐讨论大分块题。</p>
<p>结果到了酒店之后我突然意识到一个很严重的问题——我的电脑不见了。</p>
<p>相信聪明的读者到这里已经明白发生什么了吧——我过安检的时候太急了把电脑落下了。</p>
<p>于是联系了一下机场，说是让我周日晚上回去的时候取。</p>
<p>但是因为他们 21：00 下班，所以让我如果赶不上的话就第二天去取。</p>
<h2 id="Day-1（2024-3-30）"><a href="#Day-1（2024-3-30）" class="headerlink" title="Day 1（2024-3-30）"></a>Day 1（2024-3-30）</h2><p>一整个晚上几乎没有睡着。</p>
<p>不知道是不是趴在实验室的桌子上睡太久了，已经不习惯在床上睡觉了。</p>
<p>在酒店附近的一家乡村基解决了早餐之后前往赛场报道并参加热身赛。</p>
<p>因为比赛结束之后忘记带走题面了，所以笔者已经记不清哪道题是哪道题了。</p>
<p>只记得 B 题是个原题。</p>
<p>热身赛进行到一半甚至有提供午餐。每名选手两个三明治。</p>
<p>下午参加了慎老师邀请我参加的 THU 的致理杯。</p>
<p>把 Div. 2 的两道签到题和 Div. 1 的一道签到题写出来了。</p>
<p>后面的就不会了。</p>
<p>真不愧是 THU，强而有力的题目啊。</p>
<p>顺便一提，是借用的鸭的电脑打的。</p>
<p>晚上和阿稳，阿烜还有 zhuoer 一起致命公司捡垃圾。</p>
<p>当然，用的还是鸭的电脑。</p>
<h2 id="Day-2（2024-3-31）"><a href="#Day-2（2024-3-31）" class="headerlink" title="Day 2（2024-3-31）"></a>Day 2（2024-3-31）</h2><p>这个晚上也没睡好。</p>
<p>考虑到昨天差点没赶上，今天就没吃早餐了。</p>
<p>到赛场拿到题面一看——</p>
<p>从过题数量看出了签到题，然后因为很 sb 的错误调了 20min 才过。</p>
<p>然后用 40min 开出来第二题，然后就开始坐牢。</p>
<p>就这样毫无进展地到了比赛结束前 30min。</p>
<p>今天的午餐还是三明治。你们是有多喜欢三明治啊。</p>
<p>然后我看出来了一道题的解法，用了 20min 分钟写了出来并过了。</p>
<p>顺便一提，上面这个做法在赛后讲题的时候被出题人评价为「最简洁，但是正常人基本上想不出来的做法」。</p>
<p>三题，罚时还这么严重，这必然是一块牌子都捞不到了。</p>
<p>于是滚榜也没看夹着尾巴就跑了。</p>
<p>在这之后和 HMD 一起去街机厅打了一会音游。</p>
<p>17：00 赶往机场，结果到机场已经是 19：40 了。</p>
<p>于是非常失败地没能赶上飞机，被迫在机场过夜然后坐第二天早上的飞机。</p>
<h2 id="归途（2024-4-1）"><a href="#归途（2024-4-1）" class="headerlink" title="归途（2024-4-1）"></a>归途（2024-4-1）</h2><p>但是机场地椅子真的不适合睡觉。</p>
<p>于是又熬了一个通宵。<del>小心别猝死了。</del></p>
<p>但是这个时候我的手机已经完全没电了。</p>
<p>更绝望的是我的充电宝也没电了。</p>
<p>于是我通过利用鸭的电脑来充电的方法总算是苟到了合肥。</p>
<p>去失物招领处拿回电脑之后发现，电脑也没电了。</p>
<p>然后这个时候我的手机只剩 $1\%$ 的电量了。</p>
<p>于是我通过手机的超级省电模式继续拼命的苟，打了一辆出租车成功地返回了学校。</p>
<p>以上就是可怜队长极其失败的 CCPC Final 之旅。</p>
<p>话说回来，安大的校赛马上就要进行了啊。似乎还剩两周。</p>
<p>我是真的想把周五和阿块讨论的那道分块题扔进校赛，但是想想还是算了吧。给新人留点活路。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>难题</tag>
        <tag>2023</tag>
        <tag>失败</tag>
        <tag>CCPC Final</tag>
        <tag>成都</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 9</title>
    <url>/random-solution-pb-9/</url>
    <content><![CDATA[<p><a href="https://yukicoder.me/problems/no/2720">yukicoder contest 426 G. Sum of Subarray of Subsequence of…</a></p>
<a id="more"></a>
<p><strong>注意：本题解的记号可能与原题面存在出入。</strong></p>
<p>给你一个长度为 $N$ 的序列 $A$ 和一个长度为 $M$ 的字符串 $S$。$S$ 只包含 $\texttt{a}$ 和 $\texttt{s}$ 两种字符。</p>
<p>设 $a$ 为一序列。如下定义一系列函数 $f_0, f_1, \dots, f_M$：</p>
<ol>
<li>$f_0(a)$ 为 $a$ 中所有元素的和</li>
<li>对于 $i \gt 0$<ol>
<li>如果 $S_i = \texttt{a}$，$f_i(a)$ 为 $a$ 的所有 <strong>子区间（连续）</strong> 上的 $f_{i - 1}$ 的函数值的和</li>
<li>如果 $S_i = \texttt{a}$，$f_i(s)$ 为 $a$ 的所有 <strong>子序列（不一定连续）</strong> 上的 $f_{i - 1}$ 的函数值的和</li>
</ol>
</li>
</ol>
<p>让你求出 $f_M(A)$。对 $998244353$ 取模。</p>
<p>$1 \leqslant N, M \leqslant 10^5$。$0 \leqslant A_i \lt 998244353$。</p>
<p>$\texttt{4s/512MiB}$。</p>
<hr>
<p>不难发现，$f_i(a)$ 一定是 $a$ 中所有元素的某种带权和。</p>
<p>考虑设 $\lambda_i(x, y)$ 表示对于一个长度为 $x + y + 1$ 的序列 $a$，$f_i(a)$ 里 $a_{x + 1}$ 的权值。即</p>
<script type="math/tex; mode=display">
f_i(a) = \sum_{j = 1}^{|a|} \lambda_i(j - 1, |a| - j) a_j</script><p>至于为什么下标要写成这样，因为这样更直观：$a_{x + 1}$ 的左侧有 $x$ 个其他元素，右侧有 $y$ 个其他元素。</p>
<p>边界条件是</p>
<script type="math/tex; mode=display">
\lambda_0(p, q) = 1</script><p>再令 $\lambda_i$ 的 OGF 为</p>
<script type="math/tex; mode=display">
\Lambda_i(x, y) = \sum_{p \geqslant 0} \sum_{q \geqslant 0} \lambda_i(p, q) x^p y^q</script><p>如果 $S_i = \texttt{a}$</p>
<script type="math/tex; mode=display">
\lambda_i(p, q) = \sum_{r = 0}^p \sum_{s = 0}^q \lambda_{i - 1}(r, s)</script><script type="math/tex; mode=display">
\begin{aligned}
\Lambda_i(x, y) =& \sum_{p \geqslant 0} \sum_{q \geqslant 0} \lambda_i(p, q) x^p y^q \\
=& \sum_{p \geqslant 0} \sum_{q \geqslant 0} \sum_{r = 0}^p \sum_{s = 0}^q \lambda_{i - 1}(r, s) x^p y^q \\
=& \sum_{r \geqslant 0} \sum_{s \geqslant 0} \lambda_{i - 1}(r, s) \sum_{p \geqslant r} \sum_{q \geqslant s} x^p y^q \\
=& \sum_{r \geqslant 0} \sum_{s \geqslant 0} \lambda_{i - 1}(r, s) \frac{x^r y^s}{(1 - x) (1 - y)} \\
=& \frac{\Lambda_{i - 1}(x, y)}{(1 - x) (1 - y)}
\end{aligned}</script><p>如果 $S_i = \texttt{s}$</p>
<script type="math/tex; mode=display">
\lambda_i(p, q) = \sum_{r = 0}^p \sum_{s = 0}^q \binom{p}{r} \binom{q}{s} \lambda_{i - 1}(r, s)</script><script type="math/tex; mode=display">
\begin{aligned}
\Lambda_i(x, y) =& \sum_{p \geqslant 0} \sum_{q \geqslant 0} \lambda_i(p, q) x^p y^q \\
=& \sum_{p \geqslant 0} \sum_{q \geqslant 0} \sum_{r = 0}^p \sum_{s = 0}^q \binom{p}{r} \binom{q}{s} \lambda_{i - 1}(r, s) x^p y^q \\
=& \sum_{r \geqslant 0} \sum_{s \geqslant 0} \lambda_{i - 1}(r, s) \sum_{p \geqslant r} \sum_{q \geqslant s} \binom{p}{r} \binom{q}{s} x^p y^q \\
=& \sum_{r \geqslant 0} \sum_{s \geqslant 0} \lambda_{i - 1}(r, s) \frac{x^r y^s}{(1 - x)^{r + 1} (1 - y)^{s + 1}} \\
=& \frac{\Lambda_{i - 1}(x / (1 - x), y / (1 - y))}{(1 - x) (1 - y)}
\end{aligned}</script><p>我们想要求的是 $\Lambda_M(x, y)$ 的系数。</p>
<p>考虑从 $\Lambda_i(\tilde x, \tilde y)$ 到 $\Lambda_{i - 1}(\tilde x, \tilde y)$ 的过程。这里 $\tilde x$ 和 $\tilde y$ 表示到这一步的时候的实际的自变量。</p>
<p>首先会在柿子里面留下一个</p>
<script type="math/tex; mode=display">
\frac{1}{(1 - \tilde x) (1 - \tilde y)}</script><p>然后如果 $S_i = \texttt{s}$，两个自变量会分别变成</p>
<script type="math/tex; mode=display">
\frac{\tilde x}{1 - \tilde x}, \frac{\tilde y}{1 - \tilde y}</script><p>手玩以下可以发现，上面这个过程如果说进行了 $l$ 次，两个自变量会变成</p>
<script type="math/tex; mode=display">
\frac{x}{1 - lx}, \frac{y}{1 - ly}</script><p>这里的 $x, y$ 表示一开始代进 $\Lambda_M$ 的两个自变量。</p>
<p>然后每次再柿子里留下的那一部分会变成</p>
<script type="math/tex; mode=display">
\frac{1 - lx}{1 - (l + 1) x}, \frac{1 - ly}{1 - (l + 1) y}</script><p>并且到 $\Lambda_0$ 还没完。所以你可以想象后面还有一个 $\Lambda_{-1} \equiv 1$。</p>
<p>那么结论就是，存在 $r_0, r_1, \dots, r_{M + 1}$ 使得</p>
<script type="math/tex; mode=display">
\Lambda_M(x, y) = \prod_{j = 0}^{M + 1} (1 - jx)^{r_j} (1 - jy)^{r_j}</script><p>最后的答案就是</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \sum_{i = 1}^N [x^{i - 1} y^{n - i}] \Lambda_M(x, y) A_i \\
=& \sum_{i = 1}^N \left( [x^{i - 1}] \prod_{j = 0}^{M + 1} (1 - jx)^{r_j} \right) \left( [y^{n - i}] \prod_{j = 0}^{M + 1} (1 - jy)^{r_j} \right) A_i
\end{aligned}</script><p>然后你会发现 $x$ 和 $y$ 的部分完全分开了。而且两部分其实长得一模一样。</p>
<p>中间那两坨我们可以用分治 + NTT 的技巧求解。时间复杂度 $\Theta(N \log_2^2 N)$。</p>
<p><a href="https://yukicoder.me/submissions/971254">评测记录</a></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>yukicoder</tag>
        <tag>yukicoder contest</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔题解 Pb. 8</title>
    <url>/random-solution-pb-8/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc065/tasks/agc065_d">AtCoder Grand Contest 065 D. Not Intersect</a></p>
<p>史诗题目，震撼我的大脑和小脑。</p>
<p>试图挑战时隔已久的 AGC，结果被 A 题当头棒喝（悲</p>
<a id="more"></a>
<p>单位圆上分布着 $N$ 个可区分的标记点。试在这些标记点之间连恰好 $M$ 条边，且任意两条不同的边在除去标记点之外的地方不相交，这样的方案数。对 $10^9 + 7$ 取模。</p>
<p>$1 \leqslant N \leqslant 10^7$，$0 \leqslant M \leqslant N (N - 1) / 2$。</p>
<p>$\mathtt{3s/1024MB}$。</p>
<p>$N \leqslant 2$ 直接打表。</p>
<p>对于 $N \geqslant 3$ 的情况，我们令 $a_{n, m}$ 表示在题设条件上再追加「圆上相邻的标记点之间不连边」，这样的在 $n$ 个标记点之间连 $m$ 条边的方案数。令</p>
<script type="math/tex; mode=display">
f_n = \sum_{m \geqslant 0} a_{n + 3, m} y^m</script><script type="math/tex; mode=display">
F = \sum_{n \geqslant 0} f_n x^n</script><p>最终我们需要的答案是 $[x^{N - 2}] [y^M] {(1 + y)}^N F$。</p>
<p>对于</p>
<script type="math/tex; mode=display">
{(1 + y)}^{n + 3} f_n</script><p>考虑连到 $1$ 号标记点的边，可以分为以下几种情况：</p>
<p>$1$ 号标记点不和其他标记点连边：</p>
<p>那么我们将其无视即可。这部分的方案数为</p>
<script type="math/tex; mode=display">
{(1 + y)}^{n + 2} f_{n - 1}</script><p>和 $1$ 号标记点连边的标记点中，标号最小的是 $2$ 号：</p>
<p>那么只需要标记 $(1, 2)$ 必选即可。这部分的方案数为</p>
<script type="math/tex; mode=display">
y {(1 + y)}^{n + 2} f_n</script><p>和 $1$ 号标记点连边的标记点中，标号最小的是 $3$ 号：</p>
<p>考虑相邻边，那么除去 $(1, 2)$ 以外的 $n + 2$ 条相邻边还都可以连；考虑非相邻边，那么相当于孤立 $2$ 号标记点之后剩下的 $n + 2$ 个标记点之间连边。再算上必选的 $(1, 3)$，得到这部分的方案数为</p>
<script type="math/tex; mode=display">
y {(1 + y)}^{n + 2} f_{n - 1}</script><p>和 $1$ 号标记点连边的标记点中，标号最小的是 $n + 3$ 号：</p>
<p>那么只需标记 $(1, n + 3)$ 必选，然后孤立 $1$ 号标记点即可。这部分的方案数为</p>
<script type="math/tex; mode=display">
y {(1 + y)}^{n + 2} f_{n - 1}</script><p>和 $1$ 号标记点连边的标记点中，标号最小的是 $i$ 号（$4 \leqslant i \leqslant n + 2$）：</p>
<p>相当于将整个圆分成了两部分：左半部分共 $i - 1$ 个标记点；右半部分共 $(n + 3) - (i - 1) + 1 = n - i + 5$ 个标记点。再算上必选的 $(1, i)$，得到这部分的方案数为</p>
<script type="math/tex; mode=display">
[y^m] {(1 + y)}^{i - 1} f_{i - 4} \times y {(1 + y)}^{n - i + 4} f_{n - i + 2}</script><p>整理一下上面的柿子，我们可以得到</p>
<script type="math/tex; mode=display">
 f_n = (1 + 2y) f_{n - 1} + y (1 + y) \sum_{i = 0}^{n - 2} f_i \times f_{n - i - 2}</script><p>也就是说</p>
<script type="math/tex; mode=display">
F = 1 + x (1 + 2y) F + x^2 y (1 + y) F^2</script><p>这是一个关于 $F$ 的一元二次方程。根据 $[x^0] F = 1$，我们可以解得（当然这个柿子我是抄的官方题解）</p>
<script type="math/tex; mode=display">
F = \frac{(1 - x - 2xy) - (1 - x) \sqrt{1 - \frac{4xy}{(1 - x)^2}}}{2xy (1 + y)}</script><p>然后我们看到一坨很丑陋的柿子</p>
<script type="math/tex; mode=display">
\sqrt{1 - \frac{4xy}{(1 - x)^2}}</script><p>根据官方题解给出的奇妙结论</p>
<script type="math/tex; mode=display">
[x^n] [y^m] \sqrt{1 - \frac{4xy}{(1 - x)^2}} = [x^n] \frac{x^m}{(1 - x)^{2m}} \cdot [y^m] \sqrt{1 - 4y} = - \frac{2}{2m - 1} \frac{(n + m - 1)!}{(n - m)! (m - 1)! m!}</script><p>那么我们预处理以下阶乘和阶乘逆元就可以 $\Theta(1)$ 求单个 $[x^n] [y^m] F$ 了。</p>
<p>最终答案就是 $[x^{N - 2}] [y^M] {(1 + y)}^N F$。枚举两部分 $y$ 的次数就可以 $\Theta(N)$ 求了。</p>
<p>数学，妙不可言。</p>
<p>……什么，你问我说不应该是 $[x^{N - 3}]$ 吗？</p>
<p>不是很懂，反正我按照 $[x^{N - 2}]$ 求是对的，按照 $[x^{N - 3}]$ 求是错的。官方题解写的也是前者。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>AtCoder</tag>
        <tag>AGC</tag>
      </tags>
  </entry>
  <entry>
    <title>死するまで征く、この世界を彩るように</title>
    <url>/university/</url>
    <content><![CDATA[<p><strong>已完结。</strong></p>
<p>以不到 600 的高考成绩喜提安大（马哥大学）录取通知书。</p>
<p>然后颓废。</p>
<p><del>阿潮「靠！全都荒废了！」</del></p>
<p><del>经 典 永 流 传</del></p>
<a id="more"></a>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>早上 6 点出发，差不多快到下午 7 点才到。吃完饭已经 8 点了。</p>
<p>然后向阿块汇报了一下现状。</p>
<p>欸我这电脑的逗号键怎么坏了啊。好像有什么东西卡在下面了。</p>
<p>明天就要去报道了。那么现在是传统艺能的打退堂鼓的时间了。</p>
<p>话说回来，坐在车上没事干的时候回顾了一下卡农的《抚子色心灵》，才发现歌词几乎句句有据可考而且甚至看不大懂。</p>
<p>卡农的作词从某种意义上来说是不是退化了呢。虽然我也其实并不是很懂。</p>
<p>标题也是从里面<del>复制</del>摘抄出来的。</p>
<h2 id="Day-0（2021-9-22）"><a href="#Day-0（2021-9-22）" class="headerlink" title="Day 0（2021-9-22）"></a>Day 0（2021-9-22）</h2><p>一大早上就听见有一群屑在外面大喊大叫。</p>
<p>6 点就起来了。以后是不是都得这个点起来了啊。</p>
<p>小颓一会，8 点去报道。</p>
<p>似乎我是第一个到宿舍的，然后碰到了两个推销校园卡的。</p>
<p>稀里糊涂地就办了一个。然后马上到宿舍的 FYF dalao 也跟着我办了一个。</p>
<p>然后突然发现不大对劲。</p>
<p>然后 YZ dalao 也到了。</p>
<p>剩下一位名字不会读的 dalao 要晚上才能到。</p>
<p>在这之后因为某些原因磨蹭了很久，一直到 12 点才整完。</p>
<p>然后跟着同宿舍 dalao 去食堂吃午饭，感受到了大学食堂和高中食堂之间的差距。</p>
<p>因为最近几天还没有课，整个下午都没什么事干，然后想颓却放不开手脚，于是整个下午就这样荒废了。</p>
<p>然后晚上最后一位 dalao 到宿舍了。其他两位 dalao 一起帮着他铺床铺。</p>
<p><del>气抖冷为什么我就没人帮我还差点把褥子套当成床单直接铺上去了（好吧是我自己没问</del></p>
<p>晚上 10 点开了班会，虽然我不确定自己有听进去多少。</p>
<p>听说宿舍氛围太沉闷了。啊这，躲在角落里一个人乖巧地自闭 .jpg</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>虽然把报道的那一天当成 Day 0 了，但是今天一节课没有就当成 Day 1 真的好吗。</p>
<p>6：30 就被吵醒了，然而完全不想起。</p>
<p>9：00 开始选课。虽然昨天晚上同宿舍 dalao 一直在研究怎么选但是并没有因此而学到些什么。</p>
<p>虽然听说教务系统的服务器不大星但还是被卡到去世了甚至卡出乱码了。</p>
<p>首先似乎要选一门体育。能不能不选啊（光速逃（好吧好像不行</p>
<p>和同宿舍 dalao 一起选了乒乓球，虽然完全不会。不过还好没有喜提啦啦操。</p>
<p>然后似乎还要选一门公共艺术。然而看着十四页的列表完全不知道怎么选（光速逃 ×2</p>
<p>最后艰难地选了「绘画赏析与启智疗愈」。好吧别让我来画就星。</p>
<p>然后今天就没有事了。愉快地颓废 .jpg</p>
<p>话说回来，为什么课表里会有「军事理论」「形势与政策」「中国近现代史纲要」这种东西啊（苍蓝残想不通 .jpg</p>
<p>听说 Deltarune 出第二章了于是去玩了玩。虽然其实第一章我已经玩通过一遍了。</p>
<p>和平线真是和平啊。目前进度第二章打完三个播放器。</p>
<p>不过说实话，全是英文的确是完全看不懂只能理清剧情大概（留下了英语没学好的泪水 .jpg</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>7：00 才起来，就算这样整个人还是跟要去世了一样。于是早饭也没有吃。</p>
<p>8：30 进行了一个半小时的班会，虽然我并不觉得自己听进去了几个字。</p>
<p>然后 14：30 进行校史中的红色基因教育。那当然是一个字不听。整个宿舍全在打游戏。</p>
<p>16：30 线下班会。换句话说就是，要「自我介绍」了。</p>
<p><del>世界啊毁灭吧（无慈悲</del></p>
<p>在下面看着一群 dalao 上去一边自称社恐一边侃侃而谈只有我缩在最后一排乖巧地自闭。</p>
<p>结果没一会就到我了。好家伙这就是该来的总是会来的吗。</p>
<p>上去胡说八道了一通，顺便宣传了自己的题目组，虽然应该没什么用吧。</p>
<p>因为有些紧张于是通过给阿块留了几句话稍微缓解了一下。</p>
<p>然后下来才想起来好多该说的都没说。啊这我能不能用时间机器回到过去再来一遍啊（光速逃</p>
<p>本来打算不去吃晚饭直接回宿舍的，结果到了门口发现钥匙丢了于是去食堂等他们吃完。</p>
<p>欸不对啊我记得把钥匙放兜里了啊，它会不会是用瞬移自己走掉了呢？</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>早上天还没亮就被某种神秘力量叫醒了然后睡不着了。</p>
<p>而且不知道为什么这几天经常半夜莫名其妙醒过来。苍蓝残想不通 .jpg</p>
<p>早上去录入面部图像数据，然后领教材。</p>
<p>录入完数据差点没找到其他人，一问发现其他人都让回宿舍了，只留下寝室长把四人份的书搬回去。</p>
<p>然后果然一个人太少了，于是除了我以外的两位 dalao 也被叫去了。</p>
<p>等真正拿到书才发现居然这么多整整 26 本。而且竟然给体育也专门整了一本书。这是 ao 的（没那回事</p>
<p>把这一大坨子书扔到桌子上，瞬间觉得这屑桌子怎么这么小。</p>
<blockquote>
<p>「今天晚上一定有人预习，但我不说是谁。」 ——某 dalao</p>
</blockquote>
<p>最近一直在玩 Hades，突然发现这游戏的盾牌是可以把攻击正面挡下来的。我大受震撼。</p>
<p><del>一直以为这游戏强调输出，只要我先一步把对面打死我就不会被打到了。</del></p>
<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>8：00 开学典礼。</p>
<p>典礼最后一项要求唱校歌，然而并不会唱。甚至不看着歌词都听不清唱了些什么。</p>
<p><del>幻听「莘莘国士集资上香」（第三宇宙速度逃跑</del></p>
<p>明天就要开始上课了怎么办啊。</p>
<p>听说高数挂科的很多然而我还什么都不会啊怎么办啊。</p>
<p><del>世界啊毁灭吧（还是不要这样吧</del></p>
<p>Deltarune 第一章背景故事自带的 BGM 真好听我听爆 .jpg</p>
<p>后天就要抽血了怎么办啊我可以提前先去世一下吗（好像不行</p>
<h2 id="Day-5（2021-9-27）"><a href="#Day-5（2021-9-27）" class="headerlink" title="Day 5（2021-9-27）"></a>Day 5（2021-9-27）</h2><p>某种意义上的真正的大学的第一堂课。高数。上午一二节。</p>
<p>感觉可能至少三个月左右没动过脑子了有些去世。不过还好第一节课总体没讲什么。</p>
<p>然后三四节英语。三个月没接触过英语于是再次去世了。<del>当头一棒。</del></p>
<p>中午随便吃了点啥就去体检了。然而排队时间过长导致四班集体迟到（</p>
<p>下午五六节中国近现代史<del>，鬼才听这种课翘了翘了</del>。其实也没听进去几个字（心虚</p>
<p>然后今天就没有课了。快乐地颓废 .jpg</p>
<p>Hades 真好玩 .jpg（虽然其实今天还没来得及碰</p>
<p>17：00 到 19：00 晚自习，虽然只是预习了一个小时的数学然后对着英语课本发了一个小时的呆。</p>
<p>求极限好玄学啊感觉课本上的习题都只是瞪眼出答案然后证明。这要是万一瞪眼出不来答案那不就去世了吗。</p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>7：00 要去抽血。虽然整个宿舍都是睡过了 7：00 才起床。</p>
<p>去体育馆一看发现队伍长得跟什么一样然后当场去世了。</p>
<p>于是光明正大地插队。于是 8：30 就抽完了。</p>
<p>然后本来打算去吃点啥然而没发现啥想吃的，于是直接开溜了。</p>
<p>11：00 开始试着写了写阿块的神仙题。</p>
<p>13：30 似乎就写出来了（虽然中间吃去吃了个午饭</p>
<p>就这么个小东西也要写两个小时我好菜啊（倒地</p>
<p>测了两个（弱不禁风的）小样例发现没有什么大问题的样子</p>
<p>下一节课是高级语言程序设计（</p>
<p>不过因为是第一节课说不定只是去听老师瞎扯（小声</p>
<p>好吧还是讲了不少东西的。</p>
<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><p>早上 7：30 才挣扎着爬起来。</p>
<blockquote>
<p>阿块「这就是大学生活吗。」</p>
</blockquote>
<p>上午两节英语两节数学，虽然我感觉几乎没听进去什么。</p>
<p>qaq 可能这就是菜吧。</p>
<p>趁着下课时间跟阿块简单探讨了一下新题，顺便确定了国庆假期不回家留在学校。</p>
<p>然后中午在和阿块深入探讨分块问题。</p>
<p>说到区间修改区间数颜色，阿块想起来了一道 lxl 题于是去 Luogu 找。</p>
<p>找到之后一翻题解发现题解有一篇讲的做法还是阿块亲自教 TA 的。</p>
<blockquote>
<p>阿块「忘的一干二净，笑死。」</p>
<p>阿块「那我可要经典想当年了。」</p>
<p>阿块「你要说理论上我会的确实还挺多的。」</p>
<p>阿块「但是根本写不出来，笑死。」</p>
</blockquote>
<h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><p>上午没有课，于是整个宿舍集体睡到 9：00+ 才醒。</p>
<blockquote>
<p>阿块「这就是大学生活吗。」</p>
</blockquote>
<p>12：45 要上交写给四年后的自己的信，于是趁这个时候赶了赶。</p>
<p>听说字数要求最低 400，然而并不管这些糊了两段不到 200 字打算就这么交上去了。</p>
<blockquote>
<p>我「不会吧不会吧不会真的有人认真写这种东西吧。」</p>
</blockquote>
<p>回想起来，其实五天前就说让写这个东西了。</p>
<p>本来是想着五天写一篇 400 字的小作文绰绰有余，结果拖延症发作硬是给拖到今天早上，然后开始赶工。</p>
<p><del>好家伙真就人均拖延症晚期。</del></p>
<p>下午四节计算机导论。前两节讲计算机的发展历史。</p>
<p>晚上一二节是第一次</p>
<p>后两节摸底测试，考了些基础理论，中文打字，Word，Excel 还有 PowerPoint。笑死，忘得一干二净 .jpg</p>
<p>19：00 去上了人生第一节大学选修课。绘画鉴赏。</p>
<p>主要就是给您一幅画然后让您说这幅画哪里好哪里不好。</p>
<p>然后这个老师准备了很多大艺术家的画册一类的。上课积极回答问题可以加分，回答得越多得分越多；如果当上班长还会有分数保底。得分前几名就可以获得这些画册。</p>
<p>社恐原地去世。</p>
<h2 id="Day-9（2021-10-1）"><a href="#Day-9（2021-10-1）" class="headerlink" title="Day 9（2021-10-1）"></a>Day 9（2021-10-1）</h2><p>国庆假期第一天，因为整个宿舍没有人回家，于是集体睡大觉。</p>
<p>上午当然是愉快地颓废。</p>
<p>下午似乎他们在整什么美术用具购买。因为一直在玩游戏一眼没看，就让同宿舍 dalao 帮我全都整了。</p>
<p>晚上跟着同宿舍其他三位 dalao 出去逛超市顺便在外面吃完饭。</p>
<p>来回一共走了 8000+ 步吧听一位 dalao 说。其他人似乎都一点事没有的样子只有我累到去世。</p>
<blockquote>
<p>某 dalao「我靠我看你就是欠走。谁叫你成天坐在电脑前面玩游戏敲代码。就你这身体，你以后去当那个什么 007 你吃得消吗好家伙你吃不消的。」</p>
</blockquote>
<h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>国庆假期第二天。当然还是快乐地颓废。</p>
<p>关于 Hades，这游戏竟然第 10 次通关可以直接跳过最终 BOSS。然后还会看到 Staff 表。</p>
<p>也就是说，我终于真正意义上通关了这个游戏了吗。</p>
<p>然后王子就把他母亲接回阴间了。</p>
<p>然后王子就获得了一份还算正式的工作，从内部对冥府的防御工事进行武装突破，以此来揭露出其中的漏洞。同时把奥林匹斯众神一个个全都蒙在鼓里，让他们还以为自己是在一次一次地前往阳间找母亲。</p>
<p>话说回来你们阴间的这些个所谓防御工事，难道不是直接正面突破就能解决的东西吗（小声</p>
<p><img src="/img/20211002215736_1.jpg" alt="冥后归来"></p>
<blockquote>
<p>In the name of Persephone, the queen. Open the door!（虽然这句话没截图</p>
</blockquote>
<p>看了一下到目前为止总游戏时间 64h。</p>
<p>其实感觉如果一开始去看一些教程的话会进行地更快。虽然我不喜欢看那种东西。</p>
<p>虽然其实我也是看了一些的。看之前我甚至还以为好感度完全没用（小声</p>
<h2 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h2><p>不知道为什么又把图书馆捡起来了。</p>
<p>在下四层卡到去世之后中三层莫名流畅。</p>
<p>然后被普鲁托暴打。</p>
<p>然后中午闯进来两个学长就开始推销。给推销了几瓶洗鞋洗衣服总之可能啥都能洗的产品。</p>
<p>然后当场拿起 CTY 的鞋洗了几下做演示。</p>
<blockquote>
<p>CTY「那你直接把我整只鞋都给我洗了吧。」</p>
<p>学长「要收费。」</p>
<p>CTY「那可算了。」</p>
</blockquote>
<p>演示完之后学长给出了两个方案：200 买三瓶，或者是 300 买五瓶。</p>
<blockquote>
<p>CTY「我觉得三瓶就足够了。我是一个理性的消费者。」</p>
<p>学长「你看看，三瓶的话你们四个人分起来多不方便啊。五瓶的话你们每人单独用一瓶还可以留一瓶公用。」</p>
<p>CTY「我觉得我们三瓶全都公用谁想用谁就拿来用挺好。」</p>
<p>学长「你的这两个室友（FYF，YZ）怎么想。」</p>
<p>CTY「他们随我。他们都非常社恐的。——好吧其实我也社恐但我是寝室长。」</p>
<p>学长「那边那位学弟（我）呢？带着耳机听见了吧。」</p>
<p>CTY「ZYC 你好好想想。你一定要做一个理智的人。」</p>
<p>我「我都行。」</p>
</blockquote>
<p>然后学长提出 300 给我们六瓶。</p>
<blockquote>
<p>CTY「然后我就在想，如果我以后创业，跑到别人家去推销，我会想别人怎么对待我。如果我遇到的人一个个都不像我这样好说话，一听说我是传销的二话不说把我赶出去该怎么办。」</p>
<p>学长「那就支持一下吧。」</p>
<p>CTY「但是比起一个善良的人，我更愿意当一个理性的人。」</p>
</blockquote>
<p>然后 200 买了三瓶。然后学长又送了一瓶。于是整个宿舍均摊费用每人 50。</p>
<p>然后宿舍长就开始在宿舍里大声呐喊，说如果我们感觉被强制消费了就大声说出来，强扭的瓜不甜之类的。儿童的目光 .jpg</p>
<p>因为学校体育课要求跑步，同宿舍几个 dalao 就开始商量什么时候去跑步。</p>
<p>因为不是很饿，我就没去吃晚饭，在宿舍等另外三位 dalao 吃完回来。</p>
<blockquote>
<p>CTY「我晚饭吃多了跑不了了。」</p>
</blockquote>
<p>然后拖到 19：00。</p>
<blockquote>
<p>CTY「我想起来了 20：00 还有原神直播。」</p>
</blockquote>
<p>然后拖到 19：30。</p>
<blockquote>
<p>FYF「我想起来了我 21：00 还有游戏内社团活动。」</p>
</blockquote>
<p>然后拖到 19：50。</p>
<blockquote>
<p>CTY「好的直播要开始了。」</p>
</blockquote>
<p>于是今天并没有跑步。</p>
<h2 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h2><p>我竟然打过普鲁托了！（倒地</p>
<p>有一说一泪滴的书页好强啊，切成防御姿态拿上「关注与集中」然后几乎完全不攻击只用反击的招架骰子把普鲁托震晕了。</p>
<p>晕过去之后还剩 120+ 血，然而这个时候助理司书也都死得差不多了能打出有效输出的也就穿着泪滴衣服的 Hokma 了我还觉得一回合不大星结果一张「紫光凝剑」一刀下去 70+ 伤害于是普鲁托直接没了。</p>
<p>快进到总类层<del>阿尔加利亚反复多次暴打罗兰</del>。</p>
<p>为什么这个苍蓝脑残这么强啊（</p>
<p>为什么哲学层和宗教层的书页这个时候还是锁着的啊（</p>
<p>罗兰你星布星啊你是不是传说中的黑不拉几哑巴啊（</p>
<p>经过一个下午的反复尝试我觉得这样是布星的于是我把在哲学层用掉的塔尼娅的「傲然挺立」扣过来了。</p>
<p><del>然而这并没有什么用该被打死还是被打死 .jpg</del></p>
<p>关于打法，现在有两个想法。</p>
<p>想法一就是只要脑残用「崩坏序曲」就想办法把第一颗骰子拼过去。</p>
<p>然而对面第二回合开始每回合至少 3 层强壮，然后就容易翻车。</p>
<p>想法二就是首先第一回合攒出 3-2=1 层震颤，然后第二回合一口气攒出 1+3+3=7 层震颤。之后想办法把震颤的数值维护在脑残的速度骰子取值范围之外。</p>
<p>然而「独奏之刻」命中掉震颤，「不谐和音」拼点失败掉震颤。很容易一不小心震颤层数就被砍。</p>
<p>而且似乎是只要脑残有一颗速度骰子和这边的震颤层数相等，他这一回合使用的所有「心灵共振」都会触发特殊效果。这可太阴间了。</p>
<p>这个 Win 10 自带的输入法是不是有什么大病每次出来的第一个匹配项总能巧妙地出点差错。</p>
<p>晚上跟着同宿舍 dalao 去跑步。</p>
<p>要求跑 2.5km 然而我跑了 1.0km+ 就感觉要去世了于是临阵脱逃了。</p>
<p>我觉得我体育就不及格了吧（</p>
<h2 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h2><p>我打过苍蓝脑残了！！！（大叫并倒地</p>
<p>经过 40+ 次反复尝试，最终我找到了一种十分简单粗暴的策略：</p>
<p>第四张异想体书页拿「剧烈搏动」，然后在两个回合之内把脑残打晕并把他的红条削到 25。</p>
<p>然后我就真的做到了。于是下一回合脑残回满黄条并扔出来一张「最终旋律」，被放在了一颗 95 的速度骰子上。</p>
<p>然而我「Furioso」上一回合刚用完，于是我尝试扔出一张「卡莉斯塔工作室」。</p>
<p>第一次拼点 18：14，这一下给罗兰回了 18 点混乱，顺便脑残因为流血掉了 7 点血。</p>
<p>第二次拼点 19：12，这一刀下去 22 点伤害于是脑残直接没了。</p>
<p><del>话说回来脑残哪来的 7 层流血。</del></p>
<p><del>好吧原来是一张「Furioso」给了 5 层。</del></p>
<p>然后我就录屏了。我觉得这可以扔到 B 站上去。</p>
<p><a href="https://www.bilibili.com/video/bv1MT4y1f7zu">了解一下 qwq</a></p>
<p><del>然后被黑不拉几哑巴暴打。</del></p>
<p>有一说一漆黑噤默接待战真的流程太长了。</p>
<h2 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a>Day 14</h2><p><del>一觉醒来 10：30。</del></p>
<p>为什么这个黑不拉几哑巴三阶段这么硬啊。</p>
<p>仔细分析了一下我发现我的卡组里面没有回转的卡。</p>
<p>于是我尝试在卡组里塞了两张「苍穹之枪」。</p>
<p><del>然而并没有什么用不如说表现得还比以前差了整个语言层在三阶段直接团灭了。</del></p>
<p>吃完晚饭把试着把星天歌下回来玩了玩。</p>
<p>好家伙这游戏竟然没有决死。好家伙这游戏按一下 Esc 居然直接就退出了。</p>
<p>虽然之前看过视频不过还是，2 BOSS 的二符终符太阴间了。这种弹幕射击绝对是不可取的。</p>
<p>之前那个视频好像是直接上避了。</p>
<p>话说回来，三面标题竟然直接就叫「森の中の猫の小屋」。<strong>本 社 爆 破</strong>（指冲到制作组老家</p>
<p>好吧也许是之后才确定这个名字的。</p>
<p><del>顺便 6 BOSS 可爱 awsl（光速逃</del></p>
<p>……好吧原来宗教层和哲学层没有完全解放的话只能看到 A 结局。</p>
<p>然后我整个残响乐团就白打了！</p>
<p>脑残白打了！</p>
<p>黑不拉几哑巴白打了！</p>
<p><del>好吧似乎我需要动用一些不正当手段了。</del></p>
<p><del>写个被动能力「拼点开始时，对所有来宾造成 998244353 点混乱伤害和伤害」。</del></p>
<h2 id="Day-15"><a href="#Day-15" class="headerlink" title="Day 15"></a>Day 15</h2><p>国庆假期最后一天（悲</p>
<p>虽然好像其实也没干啥。</p>
<h2 id="Day-16（2021-10-8）"><a href="#Day-16（2021-10-8）" class="headerlink" title="Day 16（2021-10-8）"></a>Day 16（2021-10-8）</h2><p>国庆假期结束了（悲</p>
<p>然后迎接我的是两节比红茶还要催眠的高数课（大悲</p>
<p><del>「没有人规定必须要正着走路啊为什么你们不倒着走路呢？」</del></p>
<p>话说今天似乎是我生日啊。</p>
<p>不知道为什么把兔子捡回来又玩了玩。</p>
<p>但是为什么我是不是显示出错甚至闪退啊（</p>
<p>以及，哲学层解放战好难。去世了。</p>
<h2 id="Day-17"><a href="#Day-17" class="headerlink" title="Day 17"></a>Day 17</h2><p>上午没有课于是睡到 10：00。</p>
<p>起床再次尝试了一下哲学层解放战。自闭了。</p>
<p>三阶段好难控罪痕层数啊一不小心就 3 个 3 层了。</p>
<p>然后四阶段的骰子点数就离谱为什么它随手一扔就是两个 18-18 的清算好家伙我直接暴风疑惑。</p>
<p>下午的时候买的椅子到了。然后试图一个人把它搬到宿舍然后去世了。</p>
<p>搬到一半感觉胳臂快要断了于是叫了一位同宿舍 dalao 来帮着搬。</p>
<p>晚上连着三节艺术鉴赏，然后我们在老师的指示下进行 <strong>抽 象 派 艺 术 创 作</strong>。</p>
<p><img src="/img/流汗黄豆.jpg" alt="同小组代表作品「流汗黄豆」"></p>
<h2 id="Day-18"><a href="#Day-18" class="headerlink" title="Day 18"></a>Day 18</h2><p>VICTORY！</p>
<p>好家伙我终于打过哲学层解放战了。</p>
<p>因为四阶段有个形态 BOSS 会用一张命中扣光的 AOE，之前打的时候可能没怎么重视于是把光都给扣完了。</p>
<p>这次我打的时候特别重视了回光，在泪滴书页的防御架势里面塞了三张「能量转换」。于是成功做到了每回合开幕满光。</p>
<p>一鼓作气把宗教层解放战也打了。</p>
<blockquote>
<p>「……操。我真的，不想，再，面对它了。」</p>
</blockquote>
<p>话说回来这场解放战居然只有一个阶段。不过很难就是了。</p>
<p>一形态说每有一名使徒死亡就会使用一张书页「圣洗」我还一位会是什么 diaomao 没想到竟然给我这边回血回混乱抗性。</p>
<p>然后二形态上来一看红条黄条 666 还全抗性抵抗我差点吓死。</p>
<p>然后二形态上来就秒掉两个助理司书我直接暴风疑惑。</p>
<p>然后打着打着不知道为什么全抗性致命了。然后才发现是我没仔细看对面被动。</p>
<p>结果打死了对面突然原地复活然后甚至还把我这边所有司书一棒子敲晕了。</p>
<p>然后甚至还扔出来一张 66-66 的清算。</p>
<p>然后我一看 Hokma 的状态，我发现了 100 层守护和振奋。</p>
<p>然后下一回合除了 Hokma 以外所有司书被秒了。然后 Hokma 凭借着 100 层守护和振奋抗了对面一个回合的集火。</p>
<p>然后手里突然多了一张书页 666-666 清算，且造成真实伤害。</p>
<p>好家伙这算个什么演出我直接暴风疑惑。</p>
<p>然后使用作弊手段跳过了残响乐团接待战和漆黑噤默接待战。开始打总类层解放战。</p>
<p>馆长你星布星啊为什么你这些书页这些个骰子点数一个比一个小啊。</p>
<p>晚上的时候收到通知说军事理论课程到最后需要写论文。</p>
<p>一下是给定的论文课题，二选一。加粗部分是重点。</p>
<blockquote>
<p>课题一：2009 年开始，党中央 、 国务院 、 中央军委着眼建设一支强大的人民军队，作出重大战略安排，全面展开大学生征兵工作。你对这一战略安排有什么认识？<strong>你愿意在大学期间入伍吗？主要考虑是什么？</strong></p>
<p>课题二：学习和研究中国国防历史，<strong>通过比较中日甲午战争和抗美援朝战争，谈谈自己对国防和国防（军队）建设的体会和认识。</strong></p>
</blockquote>
<p>好家伙我直接龙卷风疑惑。</p>
<p>字数限制似乎是不超过 3000 字。啊这我写个 30 字交上去星布星啊。</p>
<h2 id="Day-19（2021-10-11）"><a href="#Day-19（2021-10-11）" class="headerlink" title="Day 19（2021-10-11）"></a>Day 19（2021-10-11）</h2><p>早上睡到 7：30 被同宿舍 dalao。</p>
<p>爬起来已经 7：45 了于是没去吃早饭直接跑去教室了。</p>
<p>一二节高数，讲极限。感觉海星。</p>
<p>三四节英语。好家伙一个字不听，在 QQ 群里和高中同学聊天。</p>
<p>下午一二节近现代史。笑死，一个字都不听 .jpg</p>
<p>晚上一二节是第一次上机课程。然后老师让我们自行研究代码。从下次上课开始正式开始学习自己写。</p>
<p>于是和同宿舍的另一位有一定基础的 dalao 一起教另外两位 dalao 阅读代码。</p>
<p>其实本来还戴着耳机打算听歌的来着，但是一看有老师学长到处转还有摄像头于是放弃了。</p>
<p>看戏 .jpg</p>
<p>晚上又尝试了一下总类层解放战。</p>
<p>发现如果第一回合安吉拉拼点全输掉拿一张「脉动」就有机会在后面的一个对面扔过来三张「瘆白之手」的回合苟住不被打晕。</p>
<p>然后切阶段竟然给自动存档。好家伙这场解放战可太良心了。</p>
<p>（↑ 被热望带着 25 层「渴望」爆揍了一顿之后滚回来的人）</p>
<p>（我还想为什么这样都能拼输结果一看好家伙 25 层强壮）</p>
<h2 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a>Day 20</h2><p>没什么可以记录的</p>
<h2 id="Day-21"><a href="#Day-21" class="headerlink" title="Day 21"></a>Day 21</h2><p>试图切掉 Luogu P7882。</p>
<p>然而经过多次反复尝试后我明白了，这不是我能做的题。</p>
<p>干败吓疯。告辞 .jpg</p>
<p>把 Rabi-Ribi 捡起来又玩了玩。</p>
<p>本来想试试 Hell 难度的 DLC 沙耶，结果被揍到自闭。于是开 BEX 难度。</p>
<p>不知道为什么，感觉比以前玩 Hell 难度的时候顺畅很多。很多以前觉得非常难的地方现在都没什么了。也许是我的技术提升了吧。</p>
<p>话说回来我的新电脑可能有什么大病。动不动就会出现一些乱七八糟的显示错误。包括但不限于角色立绘五官莫名其妙消失，小怪的像素图看不到头发变成大光头或者干脆只剩下一双兔耳朵在空中飘着，以及文本出错。</p>
<p>而且每打完一个 BOSS 就要给我玩一波闪退。就是那种击破瞬间突然游戏崩掉然后只能再打一遍的那种。</p>
<p>现在卡在 Noah 战。四连 BOSS 战还没有补给可太去世了。</p>
<p>第一场 Miru 战甚至还不能带 Ribbon。瞬间感觉 DPS 下降了好几个数量级。</p>
<p>在 Miru 战用掉了所有消耗性物品然后打不过了于是被迫 SL。</p>
<h2 id="Day-22"><a href="#Day-22" class="headerlink" title="Day 22"></a>Day 22</h2><p>下午四节计算机导论，其中三四节是上机课。</p>
<p>闲着没事翻了翻自己以前写的 Blog，发现自己竟然还研究过伯努利数这种神仙科技。</p>
<p>然后仔细阅读了一下还发现了一些小问题。</p>
<p>关于兔子，卡在（至少在我心目中的）整个游戏本篇（就是说不包括 DLC）最难 BOSS Milliam 了。</p>
<p>然后回去找了找发现以前的地图有好多道具落下没拿。</p>
<p>拿完之后道具收集率从 85%+ 提升到了 90%+。可海星。</p>
<h2 id="Day-23"><a href="#Day-23" class="headerlink" title="Day 23"></a>Day 23</h2><p>上午一二节高数。虽然听得懂但还是差点昏睡过去。</p>
<p><del>「坐后排的那些……这个，不要放弃。」</del></p>
<p>中午尝试了一下国内做的那个兔子高级技巧教程，见识到了瞬移以及各种乱七八糟的极限高跳极限远跳。</p>
<p>学不来，告辞。</p>
<h2 id="Day-24"><a href="#Day-24" class="headerlink" title="Day 24"></a>Day 24</h2><p>因为是周六然后只有晚上有两节课于是快乐地颓废。</p>
<p>看到 Luogu 有月赛于是报名了 Div 1。</p>
<p>切了 T1 然后 T2 因为一些玄学原因 WA 掉了。</p>
<p>然后看了看 T3 觉得不大会于是打算打一打 T4 的暴力，$O(nq\log a_i)$ 的那种。</p>
<p>但是打到一半突然高中同学群里面有人讲话，于是跑去聊天然后暴力也不打了。算了 140 分就 140 分吧。</p>
<p>晚上有第一节大学生心理健康课。然后气氛活跃得完全不像是在上课。</p>
<p>然后情景模拟。就是说有个小宇同学高中成绩很好然后上了大学退步了于是开始怀疑人生。需要有一个人扮演小宇同学然后另外一个人扮演心理委员去对他进行心理辅导。</p>
<blockquote>
<p>小宇「我学习不好。」</p>
<p>心理委员「学习不好那就要好好学习。」</p>
<p>小宇「我觉得你不适合干这行。」</p>
</blockquote>
<p>xswl（某种 高雅的 笑声）</p>
<p>晚上上完课正在像一道 Ynoi 的某个实现细节，突然阿块在群里冒泡了。</p>
<p>然后阿烜来了一句「阿块，我的阿块」。</p>
<p>于是我们纷纷复读，然后群里就出现了一大片「〇〇，我的 〇〇」。</p>
<p>然后逐渐发展成「〇〇……/se/se/se/se……我的 〇〇……/se/se/se/se」。</p>
<blockquote>
<p>zhuoer「突发恶疾了属于是。」</p>
</blockquote>
<h2 id="Day-25"><a href="#Day-25" class="headerlink" title="Day 25"></a>Day 25</h2><p>下午整个宿舍去图书馆转了一圈。</p>
<p>然而第一次去图书馆啥也不懂就跟乡下人进城一样乱逛。</p>
<p>然后打算去借书的地方看看。虽然其实一本书都没借就跑路了。</p>
<p>然后宿舍长自己留下来随便找了个地方，因为自习室都坐满了，然后打算写作业。剩下我们三个就回宿舍了。</p>
<p>一回到宿舍就看到大吊阿烜在群里宣传他们的 diaomao 队名。</p>
<blockquote>
<p>我「我觉得哪个都不好。」</p>
<p>wwr「确实。」</p>
</blockquote>
<p>晚上的时候第一次尝试了一下 BABA is YOU，虽然很早以前就听说过这游戏的大名了。</p>
<p>然后现在卡在 LAKE EX 2 了。</p>
<h2 id="Day-26（2021-10-18）"><a href="#Day-26（2021-10-18）" class="headerlink" title="Day 26（2021-10-18）"></a>Day 26（2021-10-18）</h2><p>好耶！我打穿图书馆主线了！</p>
<p>关于扭曲残响乐团，第一场我用的艺术层，本来想借着艺术层的回血手段用柳科长把他们全砍死，结果柳科长出师未捷身先死。</p>
<p>虽然到最后总而言之是勉强解决掉了对面四个。</p>
<p>然后第二场用语言层乱杀。</p>
<p>第三场还是用语言层，把脑残打成残血之后用哲学层补刀。</p>
<p>说实话扭曲残响乐团的配卡机制啥的完全没研究，一路莽过去的。</p>
<p>然后是最后的接待。<del>不过话说回来明明是剧情杀为什么还要求必须要坚持足够的回合数啊。</del></p>
<p>然后获得一个 Steam 成就，「一码归一码」（指观看 C 结局）。</p>
<p>「그건 그거고，이건 이거니까。」（鸣谢<a href="https://ocr.space/">此网站</a> 提供的文字识别服务）</p>
<p>打算写几个 mod 突然感觉自己那些想法一个比一个逊。然后美术工作也没办法搞。还是算了吧 .jpg</p>
<h2 id="Day-27"><a href="#Day-27" class="headerlink" title="Day 27"></a>Day 27</h2><p>下午又是三节 C 语言。日常看戏 + 划水。</p>
<h2 id="Day-28"><a href="#Day-28" class="headerlink" title="Day 28"></a>Day 28</h2><p>晚上卡着 18：20 去食堂，然后喜提最后一份麻辣香锅。</p>
<p>今天辅导员生日。然后见识到了二班三班的奇妙内卷。</p>
<p>生日蛋糕 + 祝福小视频 + 一整个黑板的祝词。甚至据说准备了五天。</p>
<p>好家伙，我直接好家伙。</p>
<h2 id="Day-29"><a href="#Day-29" class="headerlink" title="Day 29"></a>Day 29</h2><p>听说 Deltarune 的背景故事配上自带的 BGM 是可以唱出来的。试了一下然后发现并不大能。</p>
<p>仔细反思了一下自己最近颓废地有多厉害，然后我意识到了再这样下去是不可取的。</p>
<p>于是立志开始重拾 OI 功力。</p>
<p>从字符串相关算法开始吧。</p>
<p><del>说不定明天早上一起来就全给忘了。</del></p>
<p><del>算了吧还是明天吧。</del></p>
<h2 id="Day-30"><a href="#Day-30" class="headerlink" title="Day 30"></a>Day 30</h2><p>早上 8：00 才起来。然后一二节是高数于是早饭都来不及吃暴风赶到教室。</p>
<p>上完课跑去食堂买了个三明治，吃完才回宿舍。</p>
<p>一开电脑就看到百橙的新的角色 DLC，好家伙我直接当场。</p>
<p>首先是月夜姬梦。</p>
<blockquote>
<p>I always though Hime with -1 DEF is bad….</p>
<p>now they gave her -2 DEF! Great!</p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>我一直觉得姬梦的 -1 防御已经挺糟糕了……</p>
<p>结果她现在直接 -2 防御了！真棒！</p>
</blockquote>
<p>（摘抄自 Steam 某评测）</p>
<p>然而 Hyper 看上去很强。闪避成功时对对方追加自身本应受到的伤害，回合数是 5 的倍数时最终伤害两倍。</p>
<p><del>想起「萎缩的血翼」</del></p>
<p>于是马上打开游戏试了一把。</p>
<p>结果没带抽卡的卡。</p>
<p>好不容易抽到一张 Hyper，然后踩到 BOSS 格，想都不想直接扔出去。</p>
<p>然后对面 +2 攻击扔了个 6。然后我这边回合数不是 5 的倍数于是 +2 闪避躲不开。</p>
<p><del>真棒！</del></p>
<p>关于某社交界的菲尔涅特，不是很喜欢这个角色。<del>而且根本就完全变了个人吧！</del></p>
<p>不过说实话这身新衣服挺不错（</p>
<p>然后甜点品尝者的兔萌萌和 Dangerous 的由希有了新的语音，也就是说不再和原版共用语音了。</p>
<p>去听了听甜点品尝者的新语音好家伙这兔子变身前也太懒了。<del>当代大学生现状。</del></p>
<p>然后一变身不知道是不是错觉声音年轻好几岁（</p>
<p>在不久的将来应该还会有一个角色 DLC。好家伙 gkdgkd（</p>
<p>下午乒乓球课，打了一会球然后老师让我们跑 1000m。</p>
<p>结果跑了不到一圈就跑不动了于是耻辱跑路。</p>
<p><del>好吧希望我人没事。</del></p>
<h2 id="Day-31"><a href="#Day-31" class="headerlink" title="Day 31"></a>Day 31</h2><p>中午试着写了一下 19 年十二省联考的某串串题。</p>
<p>然后写了调了三个小时发现没写拆点。</p>
<p>写拆点写到一半转念一想好像又得写个倍增不然复杂度要去世。</p>
<p>然后自闭了写不下去了。</p>
<p>甚至写到这里我 DAG DP 还一行没写。</p>
<p>好家伙，现在我连这么不到 200 行的代码都写不出来了吗。</p>
<p>想当年我可是盯着 500+ 行的代码硬生生调试了一个星期才终于做出来一道题的。</p>
<p>果然经过一整个高三，一整个暑假还有大学的最初一个月已经功力尽失了吗。</p>
<p>翻 Luogu 关注列表，看到这么一个签名：</p>
<blockquote>
<p>高二学 OI 的一年，是我人生中最快乐的时光。</p>
</blockquote>
<p>……………………</p>
<p>………………</p>
<p>…………</p>
<p>……</p>
<p>有点想重开了。</p>
<h2 id="Day-32"><a href="#Day-32" class="headerlink" title="Day 32"></a>Day 32</h2><p>上午同宿舍其他三位 dalao 一起去了某个 1024 程序员节展览会。</p>
<p>早上 8：30 就开始有人敲门催，然而那个时候我们宿舍集体没起床。</p>
<p>然后拖到快 9：00 才走。</p>
<p>13：45 左右回来。然后一进门宿舍长就冲过来跟我说「还好你没去」「可无聊了」。</p>
<p>下午试图写题然而写不动，于是嘴巴了几道串串题。</p>
<h2 id="Day-33（2021-10-25）"><a href="#Day-33（2021-10-25）" class="headerlink" title="Day 33（2021-10-25）"></a>Day 33（2021-10-25）</h2><p>晚上一二节是 C 语言上机课。</p>
<p>然后一会宿舍就开始和同宿舍 dalao 辩论三目运算符里面能不能加逗号的问题。</p>
<p>然后我甚至跑去查了 C Reference，到最后发现是那位 dalao 读入的变量是 <code>double</code> 然而写了个 <code>%f</code>。</p>
<p>好家伙这么低级的错误都没看出来我怕不是要身败名裂（</p>
<p>然后一看 SD NOIP 群发现今年 CSP 提高组 T1 三分做法是假的？！</p>
<p>跑去 Luogu 翻了翻评论区发现题目给的大样例就不单峰。好家伙我要是在考场怕不是挂成蛤蟆。</p>
<p>算了反正我都退役了。</p>
<p><a href="https://www.bilibili.com/video/BV1JU4y1F7xo">推一首歌</a></p>
<p>ワンワンでツーカーでスリーフォー 　 エビバティショウタイム！♪</p>
<h2 id="Day-34"><a href="#Day-34" class="headerlink" title="Day 34"></a>Day 34</h2><p>下午三节 C 语言完了之后似乎有团日活动，然而不是团员于是溜回宿舍摸鱼。</p>
<p>在宿舍一个人撕烤了一下自己前两天想出来的奇妙的 duliu 题然后发现不会。</p>
<p><del>那我可要经典想当年了。</del></p>
<p><del>想当年我还给 Ynoi 写过 std 造过数据呢（</del></p>
<p>然后得知不是团员也需要去参加活动。然而这个时候我已经要去吃晚饭了。</p>
<p>晚自习一开始打算搞一搞数学作业。然而五分钟就搞完了于是继续撕烤自己的题然后没有思路。</p>
<p>闲着没事上 LOJ 搜了几道串串题嘴巴了两下。</p>
<p>晚自习回到宿舍突然想起来这周要交图库于是觉得不能再颓废下去了于是开始着手。</p>
<h2 id="Day-35"><a href="#Day-35" class="headerlink" title="Day 35"></a>Day 35</h2><p>上午一二节英语三四节数学。</p>
<p>好家伙最后一节是真的昏睡过去了。</p>
<p>14：30 有反电信诈骗讲座。试图鸽掉。</p>
<p>好吧还是跟着去了。</p>
<p>17：00 听说有人要来检查寝室的卫生情况，于是同宿舍 dalao 纷纷<del>奋发图强</del>地开始收拾。</p>
<p>17：00 一道没过两分钟查寝的人就来了。</p>
<p><strong>久 等 了 .jpg</strong></p>
<p>结果站在门口瞅了两圈就溜了。</p>
<p><strong>白 等 了 .jpg</strong></p>
<p>晚上把赶完的图库扔到附件里邮给班长了。</p>
<p>然后正文部分写了：</p>
<blockquote>
<p>（一些象征性的正文）</p>
</blockquote>
<p>于是班长给我回了一封：</p>
<blockquote>
<p>（一些象征性的回复）</p>
</blockquote>
<p>黄豆托腮 .jpg</p>
<p>尝试了一下渡鸦小队 mod。然后开幕就被一张大点数清算书页干烂了。</p>
<p>好家伙这是什么阴间玩意。</p>
<h2 id="Day-36"><a href="#Day-36" class="headerlink" title="Day 36"></a>Day 36</h2><p>绘画鉴赏课上完了一个游戏。就是三个人分成小组，然后其中两个人观察一幅绘画作品三分钟，另一个人不看；然后这两个人指挥第三个人将这幅作品复刻出来。每次两个小组，然后其他人投票决定哪个小组复刻的更好。</p>
<p>然后第二次的图是一朵白色的花。然后 A 组再画面的右下角加上了「艺术国际 vlog」的字样。</p>
<p>然后我们仔细一看原图的右下角，于是真的发现了艺术国际的水印。</p>
<p><strong>细 节 .jpg</strong></p>
<p>然后发现我的图书馆加载不了 MOD 了。于是试图重新下载。</p>
<p>然后发现还是加载不了。苍蓝残想不通 .jpg</p>
<h2 id="Day-37"><a href="#Day-37" class="headerlink" title="Day 37"></a>Day 37</h2><p>下午试着刷了刷图书馆的非主线成就。</p>
<p>比如说「被封印的黑暗大小丑」「黑森林里住着一头可怕的大怪兽！」。</p>
<p>但是因为这两个成就需要的异想体书页基本上都是红色的。然后就需要故意输掉频点攒负面情感。</p>
<p>但是因为我用的是通关了主线的顶配。然后一不小心就会拼赢。</p>
<p>然后故意拼输的话还会挨很多打。然后一不小心就会去世。</p>
<p>然后因为 Steam 会展示一些未获得的成就中全球获得率相对较高的，于是我就看到了：</p>
<ul>
<li>「我这可是施了法的魔弹」</li>
<li>「您往后稍稍！」</li>
</ul>
<p>当然还有宗教层的「我们未能击穿敌人的反甲」。</p>
<p>lmao</p>
<h2 id="Day-38"><a href="#Day-38" class="headerlink" title="Day 38"></a>Day 38</h2><p>先总结一下昨天晚上的 CF 比赛。就不专门写另外一篇了。</p>
<p>首先 A 题上来一眼没看出来写了个非常假的东西然后直接就交上去了。</p>
<p>然后一交发现 WA on test 2 突然反应过来正解。</p>
<p>等到切掉已经 10 min 了。</p>
<p>然后看 B 题。</p>
<p>这个是一眼就有思路然而关于 $n=k=2^c$ 的部分想了好久怎么特判拖了好久。</p>
<p>然后交了两次都是 WA on test 2。一看有个 <code>if</code> 后面没接 <code>else</code>。</p>
<p><strong>身 败 名 裂</strong></p>
<p>然后开始写 C 题。</p>
<p>有些紧张结果分类讨论的时候把自己脑子给绕进去了然后 WA on test 2 了一发。</p>
<p>看到 D 题的通过人数没有 E 题多于是去开 E 题。</p>
<p>然后推着推着推出来一个有点像分拆数的东西。然后觉得自己肯定写不出来就跑路了。</p>
<p>这个时候 AHU ACM 群里面有学长嘴巴了两下 D 题，于是尝试去写。</p>
<p>这个时候离比赛结束只剩半个小时了。写了一大串突然发现好像不大对劲是假的。于是就放弃去睡觉了。</p>
<p>第二天一看 Rank 2450。好吧等会看看会不会掉分。<del>希望不要。</del></p>
<p><del>算了掉就掉吧反正 Rating 这种东西不过是虚荣的工具罢了。</del></p>
<p>然后第二天要体测。体前屈，引体向上，肺活量，50m，立定跳远，1000m。</p>
<p>首先是第一项，体前屈。</p>
<p>尝试了两次以后喜提 1cm 的好成绩。</p>
<p>然后是第二项，引体向上。</p>
<blockquote>
<p>老师「觉得自己一个都做不了的直接来拿笔写个零吧。」</p>
</blockquote>
<p>然后同宿舍一位 dalao 试图写零结果一不小心写到身高那一栏去了。</p>
<p>接着是第三项，肺活量。</p>
<p>第一次 4000+，第二次 3800+。感觉海星。</p>
<p>然后是第四项，50m。</p>
<p>喜提 9.4s。比昨天的 9.3s 还要慢一点于是压线不及格。</p>
<p>接着是第五项，立定跳远。</p>
<p>xjb 一条结果没想到竟然跳出去 2m 整。</p>
<p>好家伙我一直以为我最多也就 1.6m+ 的来着。</p>
<p>最后是第六项，1000m。</p>
<p>不出所料地跑了一圈就累得去世了。然后跑了 600m+ 的时候实在是人快没了就放弃了。</p>
<blockquote>
<p>FYF「尼玛，开学一个月，先挂了一科。」</p>
<p>FYF「强烈建议公众号每周督促同学们体育锻炼。」</p>
</blockquote>
<p>然后中午也什么都不想吃了。</p>
<p>今天 22：35 还有一场 Div. 1 + Div. 2 的 CF。<del>看我挽回我的名誉 .jpg</del></p>
<p>然后 Steam 上一看《脑叶公司》打折 37。好家伙我直接当场。</p>
<p>然后晚上心理健康课进行了一场激烈的辩论赛。</p>
<p>《大学生应不应该谈恋爱》</p>
<h2 id="Day-39"><a href="#Day-39" class="headerlink" title="Day 39"></a>Day 39</h2><p>昨天晚上又打了一场 CF Div. 2。</p>
<p>当然是切完三题跑路的那种。</p>
<p>然后第二天早上起来一看 Rating 掉了 50+ 然后掉到只剩下 1660+ 了。</p>
<p><del>真棒！</del></p>
<p><del>什么时候才能变得有阿烜 $\lim_{x\rightarrow 0}(1+x)^x$ 强啊。</del></p>
<h2 id="Day-40（2021-11-1）"><a href="#Day-40（2021-11-1）" class="headerlink" title="Day 40（2021-11-1）"></a>Day 40（2021-11-1）</h2><p>获得成就：在一节高数课上至少睡 40 分钟。</p>
<p>但是说实话是真的困。</p>
<p>现在还只是刚开始讲导数，不是很难所以还顶得住。</p>
<p>后面讲到积分的时候，尤其是讲到换元积分法的时候，照这个节奏怕不是就要挂科了。</p>
<p>下午一二节近现代史。蛤蛤蛤我怎么会听这种东西。</p>
<p>晚上寝室长表示想吃外卖，于是我先发制人地预判了他要点什么并跟他点了一份一样的。</p>
<p>然后过了一会他点的到了于是他问我们有没有人愿意帮他去拿一下因为他要进行体育锻炼。</p>
<p>然后这个时候正好我点的也到了于是我就直接去拿了。</p>
<p>然后回来才听说他以为我只是出去了于是让同寝室另一位 dalao YZ 去帮他拿了。</p>
<blockquote>
<p>CTY「这波配合得不是很好。」</p>
</blockquote>
<p>然后他一看发现我和他点的是一样的。</p>
<blockquote>
<p>CTY「好家伙是不是我身为寝室长在寝室里带起了一股吃外卖的不正之风啊现在怎么都不去吃食堂了。」</p>
</blockquote>
<p>晚上一二节是 C 语言上机课。然后回来的路上听到有人在说「我们寝室最低水平三道题」。</p>
<p>当时把我吓得一哆嗦（内心里）因为我以为他们说的是 CF。</p>
<p>然后听到后面发现似乎不是因为他们还说什么「书上」「选择」之类的。</p>
<p>好家伙吓我一跳。</p>
<p>然后晚上突然有一位 19 级的学长加我 QQ。</p>
<p>然后一上来就扔给我一张我的 OIerDb 的截图问这是不是我。</p>
<p>好家伙原来我名气这么大的吗居然被一位完全不认识的 dalao 推荐去打 ICPC 了。</p>
<p><del>可把我牛逼坏了叉会儿腰。</del></p>
<p><del>别别别还是收敛一些比较好。</del></p>
<p>然后得知我是互院的之后：</p>
<blockquote>
<p>那位学长「我超，互院的未来。」</p>
<p>那位学长「互院又捡个宝。来 【 数据删除 】 击剑。」</p>
</blockquote>
<p>别别别不至于不至于。</p>
<h2 id="Day-41"><a href="#Day-41" class="headerlink" title="Day 41"></a>Day 41</h2><p>听说明天中午要开班会？</p>
<p>【 信息学奥林匹克竞赛粗口 】。</p>
<p>12：00 就上床了然而睡不大着于是看 QQ 群里学长聊天。</p>
<blockquote>
<p>学长 1 号（不便透露姓名）「支楞起来啊我的 【 橙子的 emoji】，速度适应一下 ICPC 赛制。」</p>
<p>学长 2 号（不便透露姓名）「你这橘子是什么勾八。」</p>
<p>学长 1 号「橙（成）子。」</p>
</blockquote>
<h2 id="Day-42"><a href="#Day-42" class="headerlink" title="Day 42"></a>Day 42</h2><p>好家伙那当然是不去。</p>
<p>反正肯定讲不了啥实质的东西。</p>
<p>上午上课的时候我们 ICPC 队伍的名字正式决定叫做「坐牢」了。英文名 In Jail。</p>
<blockquote>
<p>阿烜「这着实没啥意思。」</p>
</blockquote>
<p>晚上数学习题课下了回宿舍又复习了一遍之前的<a href="https://www.bilibili.com/video/BV1Kp4y1C79n">某个观赏谱</a>。</p>
<p><strong>请 您 读 谱 .jpg</strong></p>
<h2 id="Day-43"><a href="#Day-43" class="headerlink" title="Day 43"></a>Day 43</h2><p>qwq</p>
<h2 id="Day-44"><a href="#Day-44" class="headerlink" title="Day 44"></a>Day 44</h2><p>阿块……/se/se/se/se……我的阿块……/se/se/se/se</p>
<p>晚上数学习题课光明正大地不听课和慎老师进行亲切交流。</p>
<p>然后得知了慎老师现在在学数分和线代。</p>
<p>我看懂了，而且我大受震撼。</p>
<blockquote>
<p>我「（慎老师的班级）听上去像是成功人士聚集地。」</p>
<p>慎老师「听上去像是失败人根据地。」</p>
</blockquote>
<p>假假 /kk</p>
<p>听说 SD 又喜提省队名额 -1 个了。</p>
<p>好家伙我这一辈子能碰到 SD 被克扣多少次名额。</p>
<p>高一一次。高三一次。现在又一次。</p>
<h2 id="Day-45"><a href="#Day-45" class="headerlink" title="Day 45"></a>Day 45</h2><p>早上 9：00 才爬起来。</p>
<p>继续玩脑叶，然后稍微感受到了一点什么叫做白干公司。</p>
<p>本来三次融毁之后已经达到能源指标了但是我突然想尝试一下正午级别的考验是什么样的。</p>
<p>还没打完结果波迪突然跑出来了。</p>
<p>然后有点方然后一看小帮手也跑出来了。</p>
<p>然后我发现小帮手的攻击模式是一个大蓄力然后横扫整个房间。</p>
<p>然后我当机立断趁着它蓄力的时候疏散了所有员工。</p>
<p>打着打着突然发现焦化少女也跑出来了。</p>
<p>献祭了三位文职。</p>
<p>然后往上一看怎么亡蝶葬仪也跑出来了。</p>
<p>// 一级警报</p>
<p>亡蝶葬仪有一种攻击是把它那个棺材摆到面前然后扔出好多好多的蝴蝶覆盖住整个房间。然后白伤杀人。</p>
<p>于是在这里控制部某位勇气 V 的员工壮烈牺牲了。</p>
<p>话说回来这都 Day 18 都结束了为什么我培训部第一个任务都还没完成（</p>
<p>「请给我们爱！！！！！！！！」</p>
<p>重新开始这一天。</p>
<p>晚上第一次去实验室和学长们打 ICPC 模拟赛。</p>
<p>实际上中午的时候已经去探了一波路然后找到位置了。但是不敢进去（</p>
<p>结果一进去一看发现就很小两个隔间然后只有十台左右的电脑。</p>
<p>除了我以外就只有三位学长了。<del>人少得可怜。</del></p>
<p>然后开题。</p>
<p>首先找到一道签到题切掉。</p>
<p>然后找到一道逆序对建图染色的题。然后我读完题直接「我有一个想法」，学长表示震惊。</p>
<p>然后写挂了好几发才过。</p>
<p>然后我们盯上了两道看上去还算能做的题。一道构造，一道计算几何。</p>
<p>于是我写构造，学长们写计算几何。</p>
<p>最后的结果……那当然是全军覆没。</p>
<p>然后就「坐牢」了（指一题不会但又不能走就只能坐在电脑前面发呆</p>
<p>看了看其他队伍的名字感觉都好有意思啊。</p>
<p>然后我口胡了一下最后一题是个主席树。</p>
<p>这个时候已经 22：30 了于是我就跑路了。</p>
<p>不过有一说一，一到考场就开始犯低级失误，这个毛病真就一点没改。</p>
<p>听学长说至少要切掉三道题才能有个能看一点的排名。那我感觉其实我们快了（心虚</p>
<p>然后一回寝室发现甚至灯都关了。说是因为明天考试所以要早睡。</p>
<blockquote>
<p>我「那你们这么早上床你们睡得着吗？」</p>
<p>FYF「睡不着啊。」</p>
<p>我「那你们这么早上床干啥反正你们又睡不着。」</p>
<p>FYF「啊就但是，万一躺着躺着就睡着了呢？」</p>
</blockquote>
<p>滑稽流汗 .gif</p>
<p>然后晚上似乎是有什么大型游戏赛事。然后大概整个男生宿舍楼都在看。</p>
<p>然后大概 1：00 的时候突然整个男生宿舍楼炸开锅开始喊 NB。然后女生宿舍楼那边似乎是派出了一个代表试图把这边的声音怼下去。</p>
<p>场面一度十分混乱 .mp4</p>
<blockquote>
<p>？？？「好了好了，比赛结束了，打完了，我们不吵了行吧。睡觉了啊。」</p>
<p>？？？「真是有病的男人。」</p>
</blockquote>
<p>滑稽喝茶 .jpg</p>
<h2 id="Day-46"><a href="#Day-46" class="headerlink" title="Day 46"></a>Day 46</h2><p>今天下午似乎有英语考试的样子然而我还几乎，好吧我是说，完全没复习。</p>
<p>了解了一下线性预处理常数查询的 Method of Four Russians。</p>
<p>我看不懂，但我大受震撼 .jpg</p>
<p>不过话说回来这个该怎么翻译？四个俄罗斯人的算法？四毛子算法？</p>
<p>英语考试也就那样吧。</p>
<p>也就听力因为有点紧张有几个没听清。其他的都还好。</p>
<p>考完试跑去实验室搞昨天的 M 题。</p>
<p>题意是这样的：</p>
<blockquote>
<p>给定一个长度为 $n$ 的正整数序列 $a$。$m$ 次询问，每次询问给定一个区间 $[l,r]$，将 $a_l$ 到 $a_r$ 这 $r-l+1$ 个数取出来（不影响原序列）构成一个可重集 $S$。定义 $v$ 是好的当且仅当存在 $T\subseteq S$ 使得 $\sum_{x\in T}x=v$；$v$ 是不好的当且仅当 $v$ 不是好的。求最小的正整数使得它是不好的。强制在线。</p>
</blockquote>
<p>显然，对于 $S$ 中的一个数 $v$，设区间上严格比它小的所有数之和为 $s(v)$，那么 $v$ 是不好的当且仅当 $s(v)\lt v - 1$。</p>
<p>首先我想到的是二分。</p>
<p>然而今天仔细一想发现一个数是不是好的，这样一个问题不满足单调性。</p>
<p>然后我开始在脑海中回想我毕生所学过的数据结构 trick。</p>
<p>然后我想到一个东西叫做猫树。</p>
<p>对于一个区间 $[L,R]$，我们取这个区间的中点 $M$。然后对于 $i\in[L,M]$，预处理出 $[i,M]$ 上的答案；对于 $i\in(M,R]$，预处理出 $(M,i]$ 上的答案。然后向下分治。</p>
<p>显然任意一个询问区间一定能恰好分解成两个被预处理过的区间的并。</p>
<p>在这一过程中需要维护每个位置对应区间，也就是 $[i,M]$ 或 $(M,i]$ 上所有出现过的不好的数。</p>
<p>询问时，设询问区间上出现过的不好的数中最小的是 $v$，那么答案就是 $s(v)+1$。</p>
<p>假设 $v$ 是不好的，那么下一个不好的数显然至少是 $v+2$，再下一个至少是 $2v+4$，再下一个至少是 $4v+8$……也就是说每个区间内至多有 $\log a_i$ 个数是不好的。特别地，如果一个区间上所有出现过的数都是好的，这个区间上的答案就是区间和 $+1$。</p>
<p>而且注意到，两个区间合并时，如果一个数之前在两个区间上都是好的，那么它在新区间上也一定是好的；如果一个数之前至少在一个区间上是不好的，那么它有可能在新区间上是好的。这部分写个主席树暴力 check 即可。</p>
<p>这个区间合并的性质既可以用在分治时扩展区间，也可以用在询问时合并左右区间。</p>
<p>总时间复杂度 $O(n\log n\log a_i)$。</p>
<blockquote>
<p>Update 2021-12-28</p>
<p>emmm 深夜看自己 Blog 发现问题了。</p>
<p>假设 $v$ 是不好的，那么 $v+1$ 的确是好的。但是 $v+2,v+3,v+4\cdots$ 这些数都有可能是不好的。也就是说是好的数的数量是没有保证的。</p>
<p>身败名裂 .jpg</p>
</blockquote>
<p>……然而……喜提 TLE。</p>
<p>于是心灰意冷的我开始研究上午看到的另外一个神奇的数据结构搞法——$O(n)-O(1)$ RMQ。</p>
<p>首先假设序列 $a$ 中任意两个相邻数之差均为 $\pm 1$，那么我们可以使用 Method of Four Russians 做到 $O(n)-O(1)$ RMQ。</p>
<p>令块长 $B=\frac{\log n}{2}$，将原序列分成 $\frac{2n}{\log n}$ 个块，然后跑 ST 表。这部分的时间复杂度为</p>
<script type="math/tex; mode=display">
O\left(\frac{2n}{\log n}\log\frac{2n}{\log n}\right)=O(n)</script><p>然后考虑边角块。注意到差分不同的块只有 $2^{B-1}$ 种。那么对于每种块，我们预处理出其中所有子区间的最值，然后搞出原序列的每个块都属于哪种块，再结合上述的 ST 表，我们就能做到 $O(1)$ 查询了。</p>
<p>关于对于每种块预处理所有子区间的最值，这部分的时间复杂度为</p>
<script type="math/tex; mode=display">
O(2^{B-1}B^2)=O(\sqrt{n}\log^2n)=O(n)</script><p><strong>太 美 妙 了</strong></p>
<p>那么如果对相邻数之差不做保证该怎么做？</p>
<p>笛卡尔树转化成 LCA，然后欧拉序再转化成 RMQ。</p>
<p>然后有人肯定就要跑出来喊「欸你这不是又绕回去了吗！」</p>
<p>实际上真正的欧拉序是能够保证相邻两个点的深度差总是 $\pm 1$ 的。</p>
<p>至于如何实现，我的方法是，DFS 的时候，对于每一条从根指向叶子的边 $(u,v)$，把 $u,v$ 顺次加入欧拉序尾部，然后处理 $v$，处理完之后再把 $v,u$ 顺次加入欧拉序尾部。</p>
<p>但是这样可能会出现两个相同点相邻的情况。于是就在加点的时候特判一下这种情况，保证最终构造出来的欧拉序满足相邻点不同。</p>
<p>不过需要注意的是，我们需要的是点在原序列对应位置的值，而不是这个点的深度。因此我们预处理出的答案不应该是最小值本身，而应该是最小值的位置。当然如果有多个那就任取。</p>
<p>于是我们就得到了一个放之四海皆准的 $O(n)-O(1)$ RMQ 算法。</p>
<p><strong>ス 　 バ 　 ラ 　 シ 　 イ</strong></p>
<p>然而实现难度……怎么说呢，数组多到我都不会起名了真的。</p>
<p>在学校实验室干了两个小时愣是没干出来。到最后看着 22：30 了如果再不会寝室就回不去了于是只能耻辱跑路。</p>
<p>说实话在寝室写这段文字的时候我突然反应过来我的块的数量忘了 $\times 2$ 了。然后我数组照着 $\frac{n}{\log n}$ 开的。明天回实验室得先把这个改一下。</p>
<p>然后明天学长再次邀请我和另一名学长打练习赛。好家伙这次我一定要努力切掉三道题拿到大铜牌。</p>
<p>什么时候才能拿大奖牌啊 /kel</p>
<p>emmm Day 46 竟然写了这么多吗。</p>
<p>果然 <del>OI</del> ACM 能够充实我的大学生活（光速逃</p>
<p>对了，不出所料地，一回寝室关着灯锁着门。</p>
<p>好家伙一个个的这么早就上床。睡得着吗就上床。到最后不还是躺着发呆还不如写两道数学题明天下午考数学了也不看看自己能考几个分。</p>
<h2 id="Day-47（2021-11-8）"><a href="#Day-47（2021-11-8）" class="headerlink" title="Day 47（2021-11-8）"></a>Day 47（2021-11-8）</h2><p>今天数学考试。</p>
<p>说实话没啥难题。</p>
<p>然后关于练习赛，有一位学长因为有事于是取消了。</p>
<h2 id="Day-48"><a href="#Day-48" class="headerlink" title="Day 48"></a>Day 48</h2><p>上午把买来放在那里搁置了很久的《The Witness》掏出来玩了玩，然后得到了同寝室 dalao 的指点。</p>
<p>下午和学长一起练习沈阳的 ICPC 复现赛。</p>
<p>上来先秒掉一道签到题。</p>
<p>然后找到一道题：给定一个序列，将其分成尽可能多的连续段，使得将每个连续段从小到大排序后，整个序列能够变得单调不降。</p>
<p>经过和学长的一番讨论，我得出了这样一个算法：</p>
<p>对于每个数，处理出如果将整个序列从小到大排序后它会跑到哪个位置。如果有相同的数就保持相对位置不变。</p>
<p>如果 $a_i$ 排序后跑到了 $x_i$，那么 $i$ 和 $x_i$ 及其之间的所有数必须要被分到同一个连续段内。于是问题转化成给定 $n$ 个区间，求它们的并是多少个互不相交的区间。差分一波搞定。</p>
<p>然后学长帮我切掉了一道大模拟题（至少学长们这么说反正我也没看题）。</p>
<p>然后有这么一道题：给定一个序列初值均为 $0$，每次操作给定一个区间，将其上所有 $x$ 变为 $x+1$，或者查询区间最大值。</p>
<p><strong>大！分！块！</strong></p>
<p>好家伙我直接开始写。</p>
<p>然而写完发现我的写法需要对于每个块维护 $m$ 个并查集，这需要 $O(m\sqrt{n})$ 的空间然而这题 $n$ 和 $m$ 都是 $5\times 10^5$ 于是它甚至过不了编译。</p>
<p>:(</p>
<p>然后又有这么一道题：在某个神奇的异世界里，时针转一圈相当于一天，然后一天 $H$ 小时，一小时 $M$ 分钟。问有多少个整分钟满足时针分针所成角度 $\leqslant\alpha$。保证 $\alpha\leqslant\pi$。输入给出 $A$ 使得 $\alpha=\frac{2\pi A}{HM}$。</p>
<p>首先设当前时刻为 $i$ 点 $j$ 分，$0\leqslant i\lt H$，$0\leqslant j\lt M$。这个时候时针相对于零刻度转过的角度为 $\frac{2\pi i}{H}+\frac{2\pi j}{HM}=\frac{2\pi(iM+j)}{HM}$，同理分针为 $\frac{2\pi j}{M}$。因此问题转化为求满足</p>
<script type="math/tex; mode=display">
\left|\frac{2\pi(iM+j-jH)}{HM}\right|\leqslant\alpha\vee\left|\frac{2\pi(iM+j-jH)}{HM}\right|\geqslant 2\pi-\alpha</script><p>也即</p>
<script type="math/tex; mode=display">
|iM+(1-H)j|\leqslant A\vee|iM+(1-H)j|\geqslant HM-A</script><p>的二元组 $(i,j)$ 的数量。</p>
<p>显然我们可以将其转化成</p>
<script type="math/tex; mode=display">
\begin{cases}
&j\geqslant\frac{iM-A}{H-1}\\
&j\leqslant\frac{iM+A}{H-1}\\
\end{cases}</script><script type="math/tex; mode=display">
\begin{cases}
&j\leqslant\frac{iM-(HM-A)}{H-1}\\
&j\geqslant\frac{iM+(HM-A)}{H-1}\\
\end{cases}</script><p>这两个不等式组解集的并集。</p>
<p>于是考虑使用类欧几里得算法求解。</p>
<p>然而值得注意的是，我们还需要手动过滤掉 $j\geqslant M$ 的情况。</p>
<p>然而写了一个小时硬是没写出来。</p>
<p>到最后四个半小时就写出来三题。怕不是又要打铁。</p>
<h2 id="Day-49"><a href="#Day-49" class="headerlink" title="Day 49"></a>Day 49</h2><p>下午整个寝室跑到外面去逛商场，然后顺便叫上了隔壁寝室的 HTL 和 MSB 两位 dalao。</p>
<p>虽然真的只是去逛然后什么都没买就回来了。</p>
<p>好家伙走得我腿要断了。</p>
<h2 id="Day-50"><a href="#Day-50" class="headerlink" title="Day 50"></a>Day 50</h2><p>qwq</p>
<h2 id="Day-51"><a href="#Day-51" class="headerlink" title="Day 51"></a>Day 51</h2><p>深夜一边装 TeX Live 一边水群。</p>
<blockquote>
<p>19 级某学长「未定义行为（undefined behavior, ub）的意思是，无论编译器怎么实现，都是认为合理的。」</p>
<p>还是上面那位学长「我常举的例子是，即使你的编译器打印出一个变形金刚也是合理的。」</p>
</blockquote>
<h2 id="Day-52"><a href="#Day-52" class="headerlink" title="Day 52"></a>Day 52</h2><p>qwq</p>
<h2 id="Day-53"><a href="#Day-53" class="headerlink" title="Day 53"></a>Day 53</h2><p>qwq</p>
<h2 id="Day-54（2021-11-15）"><a href="#Day-54（2021-11-15）" class="headerlink" title="Day 54（2021-11-15）"></a>Day 54（2021-11-15）</h2><p>emmm 怎么说呢前面好几天只有一个 qwq 然后什么内容都没有主要是因为成天打游戏然后没什么好记录的然后就只能这样了。</p>
<p>今天查了一下期中考试的英语成绩然后发现是 82，然后全班最高分 92。海星吧可以接受。</p>
<h2 id="Day-55"><a href="#Day-55" class="headerlink" title="Day 55"></a>Day 55</h2><p>qwq</p>
<h2 id="Day-56"><a href="#Day-56" class="headerlink" title="Day 56"></a>Day 56</h2><p>qwq</p>
<h2 id="Day-57"><a href="#Day-57" class="headerlink" title="Day 57"></a>Day 57</h2><p>qwq</p>
<h2 id="Day-58"><a href="#Day-58" class="headerlink" title="Day 58"></a>Day 58</h2><p>qaq 感觉自己又混了四天啊。</p>
<p>看到旁边的 dalao 在写找出 $100$ 以内的所有质数的程序。</p>
<p>结果他直接整了个这个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">     <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     <span class="keyword">if</span>(i == <span class="number">2</span> || i == <span class="number">3</span> || i == <span class="number">5</span> || i == <span class="number">7</span>)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">     <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span> || i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span> || i % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码是我自己的码风</span></span><br><span class="line"><span class="comment">// 显然那位 dalao 不会刚学 C 语言就知道打空格而且我这是 C++ 的语法（指在 for 循环里定义变量）</span></span><br></pre></td></tr></table></figure>
<p>emmm 虽然做法挺离谱但显然这是正确的。</p>
<p>于是在旁边围观的我提出了一种全新的质数筛法：</p>
<p>如果我们需要找出 $N$ 以内的所有质数，我们只需要先找出 $\sqrt{N}$ 以内的所有质数，然后对于每个数，判断一下它是否能被 $\sqrt{N}$ 以内的质数整除即可。</p>
<p>那么我们发现这样做的时间复杂度是 $O(N\sqrt{N}+\cdots)$……</p>
<p>……笑容逐渐凝固 .jpg</p>
<p>我还不如去写个欧拉筛（</p>
<p>晚上数学习题课。</p>
<blockquote>
<p>老师「不会真的没人考满分吧？」</p>
<p>老师「你看这题都不用动脑子，脑子放宿舍都能考。」</p>
</blockquote>
<h2 id="Day-59"><a href="#Day-59" class="headerlink" title="Day 59"></a>Day 59</h2><p>今天似乎又运动会。那当然是不看。</p>
<p>整个下午缩在实验室敲代码。</p>
<p>进门前听到实验室里传出来激烈的敲打键盘的声音，然后以为学长在攻克难题。</p>
<p>结果推门进去一看发现是在打游戏。</p>
<p>晚上和学长练习 21 年 CCPC 桂林赛。</p>
<p>首先切掉 A 签到。</p>
<p>然后我搞出来一个贪心匹配的题。</p>
<p>然后有一道买边删边的题，题意有点复杂就算了。</p>
<p>然后我想出来一个找最小环的搞法，然而写了老半天然后 T 掉了。</p>
<p>然后旁边一位学长接过去接了个 Dij 然后过了。</p>
<p>然后有个题是，给定一个序列，保证是一个排列，每次交换一个逆序对，在 $\frac{n(n-1)}{2}$ 次操作内将原序列从小到大排好序。然后另一位学长直接给写好了。</p>
<p>然后我盯上了一道串串题：给定一个字符串，多次询问严格第 $k$ 小字串最靠左的出现位置。</p>
<p>然后我发现我 SA 忘了怎么写了然后学长给提供的板子用不惯于是翻了翻自己的 Blog。</p>
<p>这个时候已经 22：00 了。然后寝室 23：00 很有可能会关门。</p>
<p>结果我 SA 都建好了但是找第 $k$ 小的部分怎么写怎么不对劲。</p>
<p>就是说思路是有的但是代码不知道怎么回事敲不出来。</p>
<p>最后 22：50 不得不耻辱下机。</p>
<p>好家伙这么简单的题才切了四道怕不是又要打铁。</p>
<p>什么时候才能拿（除了铁牌以外的）大奖牌啊 /kel</p>
<p>对了想怎么写最小环的时候我翻了翻学长的某个两百多页的打板子然后发现<strong>没有</strong>。</p>
<blockquote>
<p>学长「你看我就说，别看这个板子看着挺全，真正要用的时候上面就没有。」</p>
</blockquote>
<h2 id="Day-60"><a href="#Day-60" class="headerlink" title="Day 60"></a>Day 60</h2><p>晚上玩了玩 Hades，结果弓二随便配祝福然后简简单单四连胜。</p>
<p>然后点了三级的极端措施结果被 3 BOSS 打成筛子（</p>
<p>好吧其实二见就通了。这下肯定得先打牛了不然场面太乱受不了。</p>
<p>这么一比没有极端措施加成的哈迪斯就太菜了。</p>
<p>有一说一，感觉满级弓二本身已经能乱杀了。再配点加攻击的祝福或者是「箭如雨下」「透甲排箭」「致命齐射」这样的附魔直接无敌。</p>
<p>哦对了宙斯的某个特殊攻击命中时打雷的祝福也可以考虑安排上。</p>
<p>把塔纳托斯给的纪念品升到满级了。每无伤一个房间 +2% 攻击。</p>
<p>然后把这个数值堆到 30% 以后：你（3 BOSS 国王）和你那徒有其表的战车令我感到可笑。</p>
<p>有一说一实在是太强了。四五个连招下去把牛打进二阶段，再四五个连招下去直接带走。</p>
<h2 id="Day-61（2021-11-22）"><a href="#Day-61（2021-11-22）" class="headerlink" title="Day 61（2021-11-22）"></a>Day 61（2021-11-22）</h2><p>今天通过新生赛选拔出来的 21 级新生可以去实验室了。</p>
<p>然而我只有下午三四节没有课于是一下第二节就冲去实验室了。</p>
<p>然后 17：35 有 CF。</p>
<p>然而我晚上还有课，不过还好是 C 语言的上机实验课，于是直接翘掉。</p>
<p>A 题五分钟搞完。还算可以。</p>
<p>结果 B 题构造连着暴毙了三次。然后才发现是最开始判断无解的时候漏了一种情况。</p>
<p>C 题二分又调了一辈子。</p>
<p>然后 D 题经过我大胆猜想成功一发通过。</p>
<p>于是目前为止喜提四题。</p>
<p><strong>翻 身 农 奴 把 歌 唱</strong>（指 CF 终于可以上分了</p>
<p>然后剩下三题全都不会了。</p>
<p>最后 Rank 1100+，海星吧我觉得。</p>
<p>最后趁着剩下的半个小时写了写 E 题虽然并没有过。</p>
<p><del>我是不会说晚上被带着极端措施加成的哈迪斯干烂了的。</del></p>
<p><del>不是但是为什么他攻击频率这么高啊。</del></p>
<h2 id="Day-62"><a href="#Day-62" class="headerlink" title="Day 62"></a>Day 62</h2><p>结果今天一上 CF 发现掉了 8 分。</p>
<p>:(</p>
<p>貧相な 　 心の 　 持ち主たちは</p>
<p>淘汰されてしまう 　 世界なんだよ ♪</p>
<h2 id="Day-63"><a href="#Day-63" class="headerlink" title="Day 63"></a>Day 63</h2><p>本来今天下午会有一场训练赛。</p>
<p>然而和我组队的两位学长都有事于是只剩下我一个人了。</p>
<p>然后因为今天用的是今年威海 CCPC 的题然后 pdf 文件周一的时候就被扔到群里了于是我已经看过题了。</p>
<p>我的个人印象大概是这样的：</p>
<ol>
<li>AG：简单题。</li>
<li>I：劲爆数论。但是不会。</li>
<li>M：劲爆概率论。但是也不会。</li>
<li>其他题更不会了。</li>
</ol>
<p>中午比赛刚开始的时候正好我外卖刚到于是正在吃。</p>
<p>然后 1h 切掉 AJD 三题然后坐牢了。</p>
<p>于是向学长要了一份题解。</p>
<p>结果发现 G 题竟然是一个根号 trick。好家伙我竟然在根号题上栽跟头了。</p>
<p><strong>身 败 名 裂</strong></p>
<p>然后 H 题竟然是最小割。我一直以为是个神仙树形 DP。</p>
<p>阿烜因为有两位神仙带他于是拿了大金牌。但是没有人带我啊。</p>
<p>我也想要大金牌 /kk</p>
<h2 id="Day-64"><a href="#Day-64" class="headerlink" title="Day 64"></a>Day 64</h2><p>突然发现周日上午有第一节军事理论。</p>
<p>然而我要打比赛啊（光速逃</p>
<p>晚上继续玩 Hades。然后这次超常发挥把蝴蝶的伤害加成堆到了 40%。</p>
<p>结果栽在老爹手上了。</p>
<p>:(</p>
<p>好吧一定是我不在状态了。</p>
<h2 id="Day-65"><a href="#Day-65" class="headerlink" title="Day 65"></a>Day 65</h2><p>上午一直想着要去找辅导员请假。然而到最后拖到吃午饭也没能付诸行动。</p>
<blockquote>
<p>WWJ「不要害怕。」</p>
<p>我「（害怕」</p>
</blockquote>
<p>然后正打算去上乒乓球结果辅导员突然叫我去座谈。</p>
<p>本来我还以为是什么严重的事结果就是一个关于心理健康状况的抽查然后我被选中了。</p>
<p>好家伙，我直接好家伙。</p>
<p>于是假条 get√（</p>
<h2 id="Day-66"><a href="#Day-66" class="headerlink" title="Day 66"></a>Day 66</h2><p>今天班级组织秋游。于是翘了跑去打上海 ICPC 的热身赛。</p>
<p>然后只有我和其中一位学长。另一位今天下午有课于是没能来。</p>
<p>跑到隔壁新校区然后见识到了什么是真正的大学。</p>
<p>跑去那边的 ACM 实验室然后见识到了什么是真正的实验室。</p>
<p><del>不像某地下室。</del></p>
<p>13：00 开始。</p>
<p>A 题给定 $n$ 个点 $(i,y_i)$，再加上 $(0, 0),(n+1,0)$ 一共 $n+2$ 个点。删去恰好两个点，然后相邻点连线，要求最小化最后得到的这条直线的长度。$2\leqslant n\leqslant 2\times 10^5$。</p>
<p>显然如果删去两个点，那么这两个点要么相邻，要么不相邻。于是预处理一下单独删去第 $i$ 个点和同时删去第 $i$ 和 $i+1$ 个点对答案产生的贡献，然后贪心选贡献最小的。</p>
<p>需要注意的是这里选单独贡献的时候要保证选的两个点不相邻。</p>
<p><del>结果因为把最小化读成最大化 WA 了两发。</del></p>
<p>B 题是给定一个 $n\times m$ 的矩阵 $a$，由 $a_{i,j}=r_i\cdot c_j$ 构造。想象一个 $n\times m$ 的方格，时刻 $0$ 没有杂草，从时刻 $1$ 开始每个时刻开始时第 $i$ 行第 $j$ 列长出 $a_{i,j}$ 棵杂草。$q$ 次操作，每次操作选择一个时刻，在这个时刻结束时割掉一行或者一列的杂草，割完以后这一行或一列的杂草数量归 $0$。所有询问的时刻严格递增。求所有操作割掉的杂草总量模 $10^9+7$。$1\leqslant n,m,q\leqslant 10^5$。</p>
<p>显然对于每一个格子，我们只需要关注最后一次割到它的操作即可。于是我们从后往前处理，每遇到一个操作，计算它的贡献，然后删去它影响的这一行或一列。</p>
<p>C 题给定二维平面上 $n$ 个点，保证 $4\mid n$，没有重点，没有三点共线。要求给出两条不重合的相交直线，将整个平面分成四部分，且每部分恰好有 $\frac{n}{4}$ 个点。这两条直线均不能经过 $n$ 个给出的点中的任意一个。无解输出 $-1$。$4\leqslant n\leqslant 5\times 10^4$，$\sum n\leqslant 10^5$，$|x_i|,|y_i|\leqslant 10^6$；使用两点式给出直线，且这两点横纵坐标绝对值不能超过 $10^9$。</p>
<p>emmm 好吧其实这道题我们没有切掉。</p>
<p>首先我们有一个想法是，求出这 $n$ 个点的「中位点」，也就是，横坐标是所有点横坐标中位数，且纵坐标同理的点。那么这两条直线一定交于这个中位点。</p>
<p>于是把所有点根据这个点求个极角排个序。</p>
<p>假设其中一条直线要穿过第 $k$ 个点和第 $k+1$ 个点之间的线段，这条直线也一定要穿过第 $k+\frac{n}{2}$ 个点和第 $k+\frac{n}{2}+1$ 个点之间的线段。我们可以容易地判断出这条直线是否存在。</p>
<p>同理，同样需要有一根直线穿过第 $k+\frac{n}{4}$ 个点和第 $k+\frac{n}{4}+1$ 个点之间的线段以及第 $k+\frac{3n}{4}$ 个点和第 $k+\frac{3n}{4}+1$ 个点之间的线段。</p>
<p>但是注意到这样求出来的直线很有可能并不经过任何整点。但是我们可以考虑选取这条直线上坐标绝对值足够大但是仍在题目要求范围内的两个点，然后在它们附近分别随便找一个整点代替。因为坐标绝对值足够大，这样的近似可以被认为是正确的。</p>
<p>结果喜提 WA。</p>
<p>:(</p>
<p>顺便，作为纪念，保留了热身赛的试题册。</p>
<h2 id="Day-67"><a href="#Day-67" class="headerlink" title="Day 67"></a>Day 67</h2><p>今天就是正式比赛了。</p>
<p>至于打得怎么样……emmm 一个小时切掉包括签到题在内的两道题，然后剩下两个小时调第三题。最后两个小时坐牢。</p>
<p>:(</p>
<p>怎么办啊为什么阿烜就有大金牌我就没有啊。</p>
<p>于是我下定决心开始刷思维题。</p>
<p><a href="https://www.luogu.com.cn/training/3961#problems">迪屁了解一下</a></p>
<h2 id="Day-68（2021-11-29）"><a href="#Day-68（2021-11-29）" class="headerlink" title="Day 68（2021-11-29）"></a>Day 68（2021-11-29）</h2><p>平静的一天。</p>
<h2 id="Day-69"><a href="#Day-69" class="headerlink" title="Day 69"></a>Day 69</h2><p>平静的一天。</p>
<h2 id="Day-70"><a href="#Day-70" class="headerlink" title="Day 70"></a>Day 70</h2><p>Challestend はただ静かに暮らしていた。</p>
<h2 id="Day-71"><a href="#Day-71" class="headerlink" title="Day 71"></a>Day 71</h2><p>平静的一天。</p>
<p>本来想在晚上写一下 <a href="http://codeforces.com/contest/558/problem/E">CF558E</a> 结果发现这个拆点太难写了于是放弃了。</p>
<h2 id="Day-72"><a href="#Day-72" class="headerlink" title="Day 72"></a>Day 72</h2><blockquote>
<p>Why do deaths end my torture? ♪</p>
<p>Why can’t anyone feel my hurt? ♪</p>
<p>Why’d you crown the most violent to be champions? ♪</p>
<p>In this inferno (inferno) ♪</p>
<p>We built for ourselves ♪</p>
</blockquote>
<h2 id="Day-73"><a href="#Day-73" class="headerlink" title="Day 73"></a>Day 73</h2><p>平静的一天。</p>
<h2 id="Day-74"><a href="#Day-74" class="headerlink" title="Day 74"></a>Day 74</h2><p>下午在实验室刷 CF 题然后刷到一道可以转化成多项式的题。</p>
<p>突然想起来自己多项式相关已经不会了（指 NTT 板子全忘了</p>
<p>于是跑去 Luogu 搜了一下多项式，感受到了走在时代最前沿的多项式重工业，包括但不限于拉格朗日反演，转置原理等神仙技巧和多项式符合逆，整式递推，边双计数，点双计数等神仙板子以及各种各样需要多步转化的神仙数数题。</p>
<p>我看不懂，但我大受震撼 .jpg</p>
<p><del>什么时候我才能和杜爷一样强啊（追星行为</del></p>
<h2 id="Day-75（2021-12-6）"><a href="#Day-75（2021-12-6）" class="headerlink" title="Day 75（2021-12-6）"></a>Day 75（2021-12-6）</h2><p>平静的一天。</p>
<p>试图翘 C 语言实验课然而同寝室 dalao 回来告诉我说又点名了。</p>
<p>:(</p>
<h2 id="Day-76"><a href="#Day-76" class="headerlink" title="Day 76"></a>Day 76</h2><p>平静的一天。</p>
<h2 id="Day-77"><a href="#Day-77" class="headerlink" title="Day 77"></a>Day 77</h2><p>平静的一天。</p>
<h2 id="Day-78"><a href="#Day-78" class="headerlink" title="Day 78"></a>Day 78</h2><p>平静的一天（其实也不是啦</p>
<p>下午整整四节计算机导论全程不听课玩手机。然后翻 CF 的时候发现一位黑红名 dalao 提到我了。</p>
<p>于是我过去一看发现是快半个月前的一场 Deltix Round 随机抽人送衣服然后我被抽中了。</p>
<p>苍蓝残想不通 .jpg</p>
<p>吓得我赶紧完善了一下 CF 的个人资料然后在那位 dalao 的评论下面回了句 Nice。</p>
<p>话说回来那个评论下面有好几个回复 Nice 的为什么有的就能 +7 有的就只有 -13 啊。</p>
<p>上面似乎还有一位许愿自己能够切掉四题的 dalao 结果 -17。</p>
<h2 id="Day-79"><a href="#Day-79" class="headerlink" title="Day 79"></a>Day 79</h2><p>平静的一天。</p>
<h2 id="Day-80"><a href="#Day-80" class="headerlink" title="Day 80"></a>Day 80</h2><p>平静的一天。</p>
<h2 id="Day-81"><a href="#Day-81" class="headerlink" title="Day 81"></a>Day 81</h2><p>晚上上课前突然反应过来四史作业没写于是一二节形势与政策光明正大地一个字不听补作业。</p>
<p>深夜 23：05 打 CF Div. 2。</p>
<p>结果比赛开始前三分钟我一刷新发现开始时间变成了 23：10。</p>
<p>于是我就等到 23：10，然后一刷新发现开始时间变成了 23：15。</p>
<p>啊这没见过世面原来这就是延迟吗（</p>
<p>结果比赛刚一开始 CF 突然崩掉了进不去了。</p>
<p>（滑稽流汗 .gif</p>
<p>吓得我试图使用 m1 镜像站虽然实际上并没有起到什么作用。</p>
<p>然后这直接导致了我看到 A 题题面的时候已经过去至少 2 min 了。</p>
<p><del>不过说实话其实影响不大。</del></p>
<p>难度的话，ABC 三题都不难。</p>
<p>D 题我通过玄学瞪眼法成功地强行找出了规律，并在 WA 了两发然后进行了一些小小的改动之后在 46 min 时切掉了。</p>
<p>然后 E 题一眼出来一个 $O(m\log^2n)$ 的写法（二分 + 树状数组），于是开始写。不过当然是 T 掉了。</p>
<p>然后我仔细撕烤，发现这个东西可以优化到 $O(m\log n)$。结果交上去还是 T 掉了。</p>
<p>苍蓝残想不通 .jpg</p>
<p>啊这不是说 CF 的评测机耐造吗为什么我一个 $O(m\log n)$ 跑 $10^6$ 而且还是 $4\text{s}$ 都能 T 掉。</p>
<p>算了还好我前四题罚时优秀。</p>
<p>我觉得这一波又可以来一次火箭式上分。</p>
<p>这上分，多是一件美事啊。（紧跟时事（指玩新梗</p>
<h2 id="Day-82（2021-12-13）"><a href="#Day-82（2021-12-13）" class="headerlink" title="Day 82（2021-12-13）"></a>Day 82（2021-12-13）</h2><p>平静的一天。</p>
<h2 id="Day-83"><a href="#Day-83" class="headerlink" title="Day 83"></a>Day 83</h2><p>平静的一天。</p>
<h2 id="Day-84"><a href="#Day-84" class="headerlink" title="Day 84"></a>Day 84</h2><p>平静的一天。</p>
<h2 id="Day-85"><a href="#Day-85" class="headerlink" title="Day 85"></a>Day 85</h2><p>平静的一天。</p>
<h2 id="Day-86"><a href="#Day-86" class="headerlink" title="Day 86"></a>Day 86</h2><p>平静的一天。</p>
<h2 id="Day-87"><a href="#Day-87" class="headerlink" title="Day 87"></a>Day 87</h2><p>晚上试图打 CF Educational Round。</p>
<p>结果开幕雷击 A 题交了五发没过。</p>
<p>然后心态爆炸只搞出来 BCE 三题然后就耻辱跑路了。</p>
<p>感觉 D 题其实也可以搞但是没搞出来。</p>
<blockquote>
<p>同级某 dalao 在群里「还有一个哥十几分钟写完 C，结果 A 错了 6 次，就挺离谱的。」</p>
</blockquote>
<p><img src="/img/TIM图片20181026163237.gif" alt=""></p>
<h2 id="Day-88"><a href="#Day-88" class="headerlink" title="Day 88"></a>Day 88</h2><p>平静的一天。</p>
<h2 id="Day-89（2021-12-20）"><a href="#Day-89（2021-12-20）" class="headerlink" title="Day 89（2021-12-20）"></a>Day 89（2021-12-20）</h2><p>平静的一天。</p>
<h2 id="Day-90"><a href="#Day-90" class="headerlink" title="Day 90"></a>Day 90</h2><p>平静的一天。</p>
<h2 id="Day-91"><a href="#Day-91" class="headerlink" title="Day 91"></a>Day 91</h2><p>平静的一天。</p>
<h2 id="Day-92"><a href="#Day-92" class="headerlink" title="Day 92"></a>Day 92</h2><p>平静的一天。</p>
<h2 id="Day-93"><a href="#Day-93" class="headerlink" title="Day 93"></a>Day 93</h2><p>上午一二节是高数。</p>
<p>然而因为某种未知的神秘力量，我和同宿舍其他三位 dalao 同时睡过了。</p>
<p>醒来发现已经 8：23 了。</p>
<p>苍蓝残想不通 .jpg</p>
<p>然后我和 FYF dalao 当机立断地决定不去了。</p>
<p>除此之外的话……平静的一天。</p>
<h2 id="Day-94"><a href="#Day-94" class="headerlink" title="Day 94"></a>Day 94</h2><p>成功地看到了 The Witness 的隐藏结局 ED。</p>
<p>虽然完全没有看懂。</p>
<p>感觉像是一个人躺在沙发上快死了然后突然醒过来拔掉身上的医疗器具一边扶着墙一边走到后院然后躺在那里然后就死透了。</p>
<p>？？？</p>
<p>总之我大受震撼。</p>
<h2 id="Day-95"><a href="#Day-95" class="headerlink" title="Day 95"></a>Day 95</h2><p>平静的一天。</p>
<h2 id="Day-96（2021-12-27）"><a href="#Day-96（2021-12-27）" class="headerlink" title="Day 96（2021-12-27）"></a>Day 96（2021-12-27）</h2><p>今天拿到了《高等数学（下册）》《线性代数》《离散数学》。</p>
<blockquote>
<p>把全新的高数课本放在面前，您感觉知识从里面不断涌出。</p>
<p>Laying out the brand new advanced mathematics textbook in front of you, you can feel knowledge springing out.</p>
<p>您充满了决心。</p>
<p>You are filled with DETERMINATION.</p>
</blockquote>
<p>晚上和慎老师和大吊阿烜进行了一些友好沟通。</p>
<blockquote>
<p>shzr「我现在可能处于一种，考验操作的游戏玩不了，考验策略的游戏没策略，的悲惨境地。」</p>
<p>我「那玩 gal。」</p>
<p>shzr「说得好！」</p>
</blockquote>
<p>过了一会。</p>
<blockquote>
<p>shzr「我向同学抱怨无聊后，她给我一个 iwanna。」</p>
<p>shzr「对我来说过于困难的游戏 .jpg」</p>
<p>shzr「iwanna 立竿见影。我现在直接不想碰电脑了。」</p>
<p>shzr「这是一个督促学习的好方法。我打算看两节课本再接着打了。」</p>
</blockquote>
<h2 id="Day-97"><a href="#Day-97" class="headerlink" title="Day 97"></a>Day 97</h2><p><a href="https://www.bilibili.com/video/BV1YM4y1c7RL">墙裂推荐 qwq</a></p>
<p>晚上光明正大地不去晚自习。</p>
<p>翻了翻《离散数学》的课本，虽然我没怎么看懂，但我大受震撼。</p>
<p>第一章主要讲述了逻辑表达式命题范式等等一系列乱七八糟的东西。</p>
<p>本来我还是看得很认真的，然后看到一半太抽象了看不下去了（光速逃</p>
<p>好家伙这就是最最底层的数学逻辑语言吗。感觉我见识到了什么叫做真正的力量。</p>
<p><img src="/img/TIM图片20181104191700.jpg" alt=""></p>
<p>而且这本书还很厚，两百多页而且很大。</p>
<p>看了一眼目录发现最后一章居然是图论。</p>
<p>晚上 21：30 有 CF。</p>
<p>本来想打的结果把时间记成 22：30（其实是完全忘了）结果 21：35 一看发现比赛已经开始了。</p>
<p>不过它有 Extra Registration。虽然这会使得我的罚时变得不是很理想不过我觉得我可以。</p>
<p>ABC 三题海星。切完之后 Rank 600+。</p>
<p>这个时候还剩 70min。</p>
<p>结果我的 D 题就是没写出来（</p>
<p>:(</p>
<p>最后 Rank 734。</p>
<p>其实最后 5min 我已经能够解决 $n=m$ 的情况了。</p>
<p>然后比赛后仔细一想并不是位置和初始位置重合就说明循环了，重合时的方向也是需要考虑的。</p>
<p>好家伙为什么我一个多小时连这点东西东西都想不出来（</p>
<p>好吧其实中间有半个小时是因为我看 $n,m$ 范围有点大（当时没看到是限制的 $nm\leqslant 10^5$ 还以为是 $n,m\leqslant 10^5$）以为 $O(mn)$ 要 T 掉于是想了半天怎么优化（光速逃</p>
<p>一定是因为寝室太嘈杂了影响了我的正常思考（光速逃</p>
<p>睡觉前学长交流了一下关于如果在实验室打完 CF 但是宿舍门已经锁了那么该怎么进去这样一个问题。</p>
<h2 id="Day-98"><a href="#Day-98" class="headerlink" title="Day 98"></a>Day 98</h2><p>晚上玩脑叶，然后突然意识到自己已经 Day 40 了然而一场核心抑制都没有打。</p>
<p>于是回滚到 Day 36 开始打黄昏考验。</p>
<p>第一次刷到的黄昏考验是红色黄昏。果然红色的考验都是最简单的（</p>
<p>不过打死之后还会生成低一个等级的同色的考验。</p>
<p>快打完的时候我几个员工被某些异想体吸引不受控制了。于是为了防止局面失去控制我果断地直接结束管理。</p>
<p>结果考验没打完然后不算任务完成没办法解锁核心抑制。</p>
<p>:(</p>
<p>于是第二次我特别注意了某些会吸引员工的异想体。</p>
<p>然后第二次刷到的还是红色黄昏。</p>
<p>为了方便（其实也是怂）我把所有员工全都疏散到了安保部主休息室，仅仅指派了那几个拿着 W 级 EGO 装备的员工去打考验。</p>
<p>然后快打完的时候突然屏幕两边开始出现某种绿色的幕布。</p>
<p><img src="/img/TIM图片20190510114159.jpg" alt=""></p>
<p><img src="/img/TIM图片20181016111652.jpg" alt=""></p>
<p>${n\choose m}$，垃圾游戏浪费了我两个小时的人生。</p>
<p>关于昨天晚上的 CF，他 Rating 算出来我竟然是 Rank 551，然后 Rating +18。</p>
<p>:)</p>
<p>深夜 23：30 继续快乐 CF。Good Bye 2021: 2022 is NEAR。这就是 2021 年的最后一场 CF 了。</p>
<p>果然如我所预料的一样，这个点基本上没什么噪音可以认真撕烤题目。</p>
<p>30 min 切 ABC。1.5 h 切 D。</p>
<p>其实这个 D 我可以更快的但是因为光去想大暴力了然后忽视了数据结构。</p>
<p>其实就是暴力题写多了懒得写数据结构了（光速逃</p>
<p>然后一看 Rank 1000+。</p>
<p><img src="/img/TIM图片20181104191700.jpg" alt=""></p>
<p>然后看了下公告发现是 Div. 1 + 2 混合场。</p>
<p>下一场 CF 就是明年 1 月 3 号的 Hello 2022 了。</p>
<p>然后关于我之前抽到的衣服，他终于联系我了（</p>
<p>不过有一说一虽然但是，我觉得在我放完寒假回来之前能不能真正拿到衣服都难说（</p>
<h2 id="Day-99"><a href="#Day-99" class="headerlink" title="Day 99"></a>Day 99</h2><p>中午日常玩脑叶。</p>
<p>这次抽到了绿色黄昏。</p>
<p>结果打到一半想起来下午还有课。</p>
<p>:(</p>
<p>告辞 .jpg</p>
<p>然后晚上沉默乐团给面子于是成功地解锁了核心抑制战。</p>
<p>首先打了控制部的核心抑制。</p>
<p>（我个人探索出来的）机制如下（还是扔到代码框里面吧别剧透太多了）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始核心抑制后，指派工作时四个工作选项会被随机打乱。但是每个选项变成哪个选项是固定的。比如说所有异想体的「本能」选项全部变成「压迫」，「压迫」变成「洞察」，「洞察」变成「本能」，「沟通」不变。</span><br><span class="line"></span><br><span class="line">每次触发熔毁警报时会重新打乱。</span><br><span class="line"></span><br><span class="line">熔毁等级达到 3 级以后无法取消已经下达的工作指令。</span><br></pre></td></tr></table></figure>
<p>然后是一些核心抑制战的共性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果要打某个部门的核心抑制战，那么那个部门当天无法部署员工，并且文职加成失效。</span><br><span class="line"></span><br><span class="line">在这一天，所有 Sephirah 不会在异想体出逃 / 员工恐慌 / 员工死亡 / 部门全灭时给出提醒。</span><br><span class="line"></span><br><span class="line">没有鼠标指针悬停提示（比如说正常情况下鼠标指针悬停在某个部门的文职加成等级上会提示您这个部门的文职加成但是现在没有了）。</span><br><span class="line"></span><br><span class="line">目标是触发 5 级的熔毁警报并集满能源。</span><br></pre></td></tr></table></figure>
<p>虽然感觉摸清机制之后难度也不算很高但是就是不知道为什么莫名其妙失误（</p>
<p>反正四五把就过了。</p>
<p>然后意识到一个问题就是回到记忆库会不会保留已经打过的核心抑制战进度。然后上网搜了一下发现不会。</p>
<p>不过 Day 37 打控制部抑制战是不是有那么亿点点晚啊（</p>
<p>睡觉前瞅了一眼 CF 发现……</p>
<p>我！紫！了！</p>
<p><strong>Candidate Master</strong></p>
<p><strong>CLT</strong></p>
<p><strong>Contest Rating: 1902</strong></p>
<h2 id="Day-100"><a href="#Day-100" class="headerlink" title="Day 100"></a>Day 100</h2><p>第一百天！</p>
<p>早上差点忘了一二节还有高数。</p>
<p>然而非常不想去想直接放假走人回家。</p>
<p>中午成功地一次通过了情报部的核心抑制。</p>
<p>机制如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始核心抑制后，游戏分辨率会降低。必须要将镜头拉到最大才能看到员工和异想体的轮廓以及各种数字。</span><br><span class="line"></span><br><span class="line">至于员工的各项属性的具体数值，像是伤害抗性 / 移动速度 / 工作成功率等则是完全看不清。</span><br><span class="line"></span><br><span class="line">熔毁等级达到 1 级以后，分辨率会进一步降低。此时就算将镜头拉到最大也已经无法看到清晰的轮廓。</span><br><span class="line"></span><br><span class="line">同时这一天的所有异想体不显示血条。</span><br><span class="line"></span><br><span class="line">熔毁等级达到 3 级以后，分辨率（大概）会进一步降低，并且整个屏幕的色调会开始变得阴间。此时只有将镜头拉到最大才能勉强辨识出部分细节。</span><br></pre></td></tr></table></figure>
<p>《卓尔不凡的视力》（确信</p>
<p>然后第二天选异想体的时候给我整了个 3A 风景区，「一无所有」「数据删除」「碧蓝新星」齐聚一堂。</p>
<p>于是我果断选了数删。</p>
<p>一开始我让整个公司属性最高资历最老的员工利弗尔去试图刚正面。</p>
<p>结果一进去啥也没干精神条先扣掉一半多。</p>
<p>我看懂了，而且我大受震撼 .jpg</p>
<p>一次工作判定 32 次，失败 7~8 次直接人给带走了。</p>
<p><del>不过至少比某乐团工作结果优就减少计数器要好处理。</del></p>
<p><del>「小伙子你太懂音乐了来让我给你来一曲。」</del></p>
<p>话说回来这么一想利弗尔也太难了每天面对的都是高鸟乐团数删这种级别的（</p>
<p>结果数删只给一把武器。于是让利弗尔反复工作拿了武器然后直接跑路（指回到记忆库）了。</p>
<p>晚上打培训部核心抑制。</p>
<p>机制如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（具体数据均为目测，可能不准）</span><br><span class="line"></span><br><span class="line">开始核心抑制后，所有员工所有属性减少：最大生命 / 最大精神 / 工作速度 -10，成功率 / 攻击速度 / 移动速度 -15。</span><br><span class="line"></span><br><span class="line">于此同时，画面中出现某种类似老旧显示器的暗色条纹。</span><br><span class="line"></span><br><span class="line">熔毁等级达到 1 级以后，减少量变成 20/25。</span><br><span class="line"></span><br><span class="line">与此同时暗色条纹加深。</span><br><span class="line"></span><br><span class="line">熔毁等级达到 3 级以后，减少量变成 30/35。</span><br><span class="line"></span><br><span class="line">同时，画面变得和情报部核心抑制一样看不大清并自带阴间滤镜。</span><br></pre></td></tr></table></figure>
<p>其实感觉这场核心抑制的机制听上去挺难处理的。</p>
<p>实际上也的确挺难处理，工作的时候不能向以前一样 18 个 E-BOX 里面 16+ 个 PE-BOX 了。</p>
<p>不过其实也还好。</p>
<p>而且这次正午挑战运气非常好地抽到了红色。正裁数删左右开弓几下带走。</p>
<p>于是就一遍过了。</p>
<p>下一天的异想体抽到了「穿刺天堂」。<del>听说这玩意是 C 的脑子。</del></p>
<p>因为我急着要再回滚一次打安保部核心抑制，于是让利弗尔顶着 -24% 成功率反复工作在一天以内搞出三把武器两件衣服然后跑路了。</p>
<p>然后打安保部核心抑制。</p>
<p>机制如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始核心抑制后，所有部门再生反应堆读条速度大幅度降低，且所有员工无法进行生命值和精神值的恢复（福利部任务给的子弹也会失效）。</span><br><span class="line"></span><br><span class="line">但是每触发一次熔毁，本性善良的 Netzach 就会为所有员工恢复全部的生命值和精神值。</span><br></pre></td></tr></table></figure>
<p>说实话没啥意思。听上去挺简单的。</p>
<p>但是第一次尝试的时候，因为我这一天拿的异想体是大鸟，然后不会管，于是寄了。</p>
<p>然后第二次乐团又跑出来了。</p>
<p>:(</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>emmm 没想到竟然恰好写了 100 天。</p>
<p>AHU 寒假提前放假（虽然之后还要上网课），1 月 1 号就走人了。</p>
<p>为了不让一篇文章的篇幅太长，这篇日记就到此为止吧。</p>
<p>祝愿看到了这里的您 AK Ynoi。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
</search>
