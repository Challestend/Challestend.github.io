<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces Round</title>
    <url>/cf1582contest-outnotes/</url>
    <content><![CDATA[<p>直角，口胡一下刚刚过去的一场 CF 的题。</p>
<p>其实本来想打的然而没仔细看时间以为还是 22：35 开始结果一看 18：05 就开始了于是没赶上。</p>
<p><a href="http://codeforces.com/contest/1582">传送门</a></p>
<a id="more"></a>
<h2 id="A-Luntik-and-Concerts"><a href="#A-Luntik-and-Concerts" class="headerlink" title="A. Luntik and Concerts"></a>A. Luntik and Concerts</h2><p>给出 $a$ 个 $1$，$b$ 个 $2$ 和 $c$ 个 $3$。把这些数字分配到两个集合 $S_1,S_2$ 里，并最小化 $\left|\sum_{x\in S_1}x-\sum_{x\in S_2}x\right|$。</p>
<p>多组数据。$1\leqslant a,b,c\leqslant 10^9$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>观察样例之后大胆猜想最小值一定是 $0$ 或 $1$。</p>
<p>于是 $a+2b+3c$ 为奇数时答案为 $1$，为偶数时答案为 $0$。</p>
<p>虽然只是个猜想不过看上去很靠谱而且如果是在考场上的话已经可以开始写了。</p>
<p>至于证明，肯定分类讨论几波就出来了就不整了（光速逃</p>
<h2 id="B-Luntik-and-Subsequences"><a href="#B-Luntik-and-Subsequences" class="headerlink" title="B. Luntik and Subsequences"></a>B. Luntik and Subsequences</h2><p>给定一个长度为 $n$ 的序列 $a$。令 $S=\sum_{i=1}^{n}a_i$，求 $a$ 有多少个子序列的和等于 $S-1$。</p>
<p>多组数据。$1\leqslant n\leqslant 60$，$0\leqslant a_i\leqslant 10^9$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>注意到一个满足条件的子序列一定是 $a$ 删掉恰好一个 $1$ 和若干个 $0$ 得到的。</p>
<p>设 $a$ 中有 $c_0$ 个 $0$，$c_1$ 个 $1$，则答案为 $c_1\cdot 2^{c_0}$。</p>
<p><del>所以说为啥数据范围这么小。</del></p>
<h2 id="C-Grandma-Capa-Knits-a-Scarf"><a href="#C-Grandma-Capa-Knits-a-Scarf" class="headerlink" title="C. Grandma Capa Knits a Scarf"></a>C. Grandma Capa Knits a Scarf</h2><p>给定一个长度为 $n$ 的字符串。从中删去若干个同种字符（可以一个不删或全部删去）使得原字符串变成回文串。无解输出 $-1$；否则输出至少需要删去多少个字符。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，字符集小写字母。$\sum n\leqslant 2\times 10^5$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>首先，如果给定字符串最左侧和最右侧的字符相同，我们可以将它们删去，即不考虑它们。重复这个动作直到字符串最左侧和最右侧的字符变得不同（或者字符串变为空串，那么答案就是 $0$）。</p>
<p>假设我们选择删去最左侧的字符，将其记为 $c$。重复上述动作，如果最左侧和最右侧的字符相同，就将它们删去；如果不同，这两个字符中有 $c$ 就将其删去然后计数器 $+1$，没有 $c$ 就无解。直到字符串变为空串或者得出无解结论。</p>
<p><del>不过说实话看上去有点假。</del></p>
<h2 id="D-Vupsen-Pupsen-and-0"><a href="#D-Vupsen-Pupsen-and-0" class="headerlink" title="D. Vupsen, Pupsen and 0"></a>D. Vupsen, Pupsen and 0</h2><p>给定一个长度为 $n$ 的序列 $a$，$a_i\neq 0$。试构造一个同样长度为 $n$ 的序列 $b$，$b_i\neq 0$ 且 $\sum_{i=1}^{n}|b_i|\leqslant 10^9$，使得 $\sum_{i=1}^{n}a_ib_i=0$。</p>
<p>多组数据。$2\leqslant n\leqslant 10^5$，$0\lt|a_i|\leqslant 10^4$。$\sum n\leqslant 2\times 10^5$。</p>
<p>$\texttt{1s/512MB}$。</p>
<p>注意到对于任意实数 $x,y$，有 $y\cdot x + (-x)\cdot y = 0$。于是对于 $a_{2k-1},a_{2k}$，我们构造 $b_{2k-1}=a_{2k},b_{2k}=-a_{2k-1}$。</p>
<p>但是这样 $a_n$ 可能会单出来，于是我们就将其和 $a_1$ 再配对一次即可。</p>
<p>注意到此时 $\sum_{i=1}^{n}|b_i|\leqslant\sum_{i=1}^{n}|a_i|+|a_1|$……好像超了。</p>
<p>好家伙管他的直接 xjb 一通乱凑得了。</p>
<h2 id="E-Pchelyonok-and-Segments"><a href="#E-Pchelyonok-and-Segments" class="headerlink" title="E. Pchelyonok and Segments"></a>E. Pchelyonok and Segments</h2><p>给定一个长度为 $n$ 的序列 $a$。构造 $k$ 个区间 $[l_1,r_1],[l_2,r_2],\cdots,[l_k,r_k]$ 满足：</p>
<ol>
<li>$r_i-l_i+1=k-i+1$。</li>
<li>若 $i\lt j$ 则 $r_i\lt l_j$。</li>
<li>若 $i\lt j$ 则 $\sum_{x=l_i}^{r_i}a_x\lt\sum_{x=l_j}^{r_j}a_x$。</li>
</ol>
<p>只需输出 $k$ 的最大值。</p>
<p>多组数据。$1\leqslant n\leqslant 10^5$，$1\leqslant a_i\leqslant 10^9$。$\sum n\leqslant 10^5$。</p>
<p>$\texttt{2s/512MB}$。</p>
<p>令 <code>f[i][j]</code> 表示在原序列的第 $i$ 个后缀构造 $j$ 个区间时最左侧的区间上 $a_i$ 的和的最大值。</p>
<p>显然靠右的区间上 $a_i$ 的和越大，靠左的区间就会有越多的选择。</p>
<p>注意到 $j$ 一定和 $\sqrt{n-i+1}$ 同级，这使得我们可以 $O(n\sqrt{n})$ 暴力搞。</p>
<p>转移的时候就对于每个 $j$ 维护一下所有 <code>f[i][j]</code> 的最大值就好。</p>
<h2 id="F-and-G"><a href="#F-and-G" class="headerlink" title="F and G"></a>F and G</h2><p>不会（理直气壮</p>
<p>自己去看 CF 的题解吧（光速逃</p>
]]></content>
      <categories>
        <category>口胡</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>一位退役选手试图嘴巴 CSP-S 2021 的题目</title>
    <url>/csps2021-cloud-notes/</url>
    <content><![CDATA[<p>现在一行代码也不想写于是来 xjb 嘴巴题。</p>
<p>所有题目均可在 Luogu 上找到。</p>
<p>话说回来今年提高组也和普及组一样一天四题了吗。</p>
<a id="more"></a>
<h2 id="T1-廊桥分配"><a href="#T1-廊桥分配" class="headerlink" title="T1 廊桥分配"></a>T1 廊桥分配</h2><p>设我们分配给国内航班 $p$ 个廊桥，分配给国际航班 $n-p$ 个廊桥。</p>
<p>脑补一下可以发现这个东西随着 $p$ 的增加似乎是先增加再减少的。</p>
<p>于是大力三分。</p>
<p>什么？假的？告辞。</p>
<h2 id="T2-括号序列"><a href="#T2-括号序列" class="headerlink" title="T2 括号序列"></a>T2 括号序列</h2><p>仔细阅读题面之后，我们发现：如果将若干个合法的超级括号序列拼在一起，那么两个序列之间的地方可以任意插入星号（只要连续的星号不超过 $k$ 个）；但是最左侧的序列的左侧，和最右侧的序列的右侧，这两个位置只有一个位置能够插入星号，而另一个位置则不能。</p>
<p>仔细思考之后我们发现，这很有可能是某种区间 DP。</p>
<p>然而我不会 DP。</p>
<h2 id="T3-回文"><a href="#T3-回文" class="headerlink" title="T3 回文"></a>T3 回文</h2><p>我们可以容易地注意到，$b_1$ 一定是 $a_1$ 或 $a_{2n}$。</p>
<p>假设 $b_1=a_1$，再设 $a_x=a_1$，那么一定有 $b_{2n}=a_x$。</p>
<p>考虑 $b_2$，则其一定为 $a_2$ 或 $a_{2n}$；考虑 $b_{2n-1}$，其一定为 $a_{x-1}$ 或 $a_{x+1}$。</p>
<p>如果 $a_2,a_{2n-1},a_{x-1},a_{x+1}$ 四个数互不相同，则问题显然无解（在 $b_1=a_1$ 的情况下）（还有一种情况是 $b_1=a_{2n}$）。</p>
<p>如果 $a_2=a_{2n-1}\neq a_{x-1}=a_{x+1}$，同样无解。</p>
<p>如果 $a_2,a_{2n-1}$ 中存在一个数，$a_{x-1},a_{x+1}$ 中存在一个数，且这两个数相等，令其为 $c$，则 $b_2=b_{2n-1}=c$。</p>
<p>如果 $a_2,a_{2n-1}$ 和 $a_{x-1},a_{x+1}$ 两两对应相等，设这两个值为 $d,e$，则 $b_2=b_{2n-1}=d,b_3=b_{2n-2}=e$ 或反之，取操作序列字典序较小的。</p>
<p>以此类推，我们就可以构造出 $b$ 了。</p>
<p>可以看到，会使选项增加的分类讨论仅有对于 $b_1$ 的讨论一处，而之后的过程均为线性的。因此此算法的时间复杂度是线性的。</p>
<h2 id="T4-交通规划"><a href="#T4-交通规划" class="headerlink" title="T4 交通规划"></a>T4 交通规划</h2><p>一个 simple 的想法是，对于一个附加点，它附近的点尽量和它染成一个颜色。</p>
<p>那么如果两个附加点颜色不同，我们就需要在这两个点之间创造出一条「分界线」。</p>
<p>仔细分析，我们发现这条「分界线」其实就是将这两个点割开的一组割边。</p>
<p>那么就简单了，搞一波网络流（或者其他算法）求出最小割即可。</p>
<p>不过多组询问可能需要一些技巧吧应该不能每次暴力建图暴力跑网络流。</p>
<h2 id="分数结算"><a href="#分数结算" class="headerlink" title="分数结算"></a>分数结算</h2><p>理想：100 + 0 + 100 + 100 = 300（大嘘</p>
<p>现实：三分被搞 + 不会 DP + 构造假了 + 网络流暴毙 = 滚蛋回家</p>
]]></content>
      <categories>
        <category>口胡</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>死するまで征く、この世界を彩るように</title>
    <url>/university/</url>
    <content><![CDATA[<p><strong>更新至 2021-12-1。</strong></p>
<p>以不到 600 的高考成绩喜提安大（马哥大学）录取通知书。</p>
<p>然后颓废。</p>
<p><del>阿潮「靠！全都荒废了！」</del></p>
<p><del>经 典 永 流 传</del></p>
<a id="more"></a>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>早上 6 点出发，差不多快到下午 7 点才到。吃完饭已经 8 点了。</p>
<p>然后向阿块汇报了一下现状。</p>
<p>欸我这电脑的逗号键怎么坏了啊。好像有什么东西卡在下面了。</p>
<p>明天就要去报道了。那么现在是传统艺能的打退堂鼓的时间了。</p>
<p>话说回来，坐在车上没事干的时候回顾了一下卡农的《抚子色心灵》，才发现歌词几乎句句有据可考而且甚至看不大懂。</p>
<p>卡农的作词从某种意义上来说是不是退化了呢。虽然我也其实并不是很懂。</p>
<p>标题也是从里面<del>复制</del>摘抄出来的。</p>
<h2 id="Day-0（2021-9-22）"><a href="#Day-0（2021-9-22）" class="headerlink" title="Day 0（2021-9-22）"></a>Day 0（2021-9-22）</h2><p>一大早上就听见有一群屑在外面大喊大叫。</p>
<p>6 点就起来了。以后是不是都得这个点起来了啊。</p>
<p>小颓一会，8 点去报道。</p>
<p>似乎我是第一个到宿舍的，然后碰到了两个推销校园卡的。</p>
<p>稀里糊涂地就办了一个。然后马上到宿舍的 FYF dalao 也跟着我办了一个。</p>
<p>然后突然发现不大对劲。</p>
<p>然后 YZ dalao 也到了。</p>
<p>剩下一位名字不会读的 dalao 要晚上才能到。</p>
<p>在这之后因为某些原因磨蹭了很久，一直到 12 点才整完。</p>
<p>然后跟着同宿舍 dalao 去食堂吃午饭，感受到了大学食堂和高中食堂之间的差距。</p>
<p>因为最近几天还没有课，整个下午都没什么事干，然后想颓却放不开手脚，于是整个下午就这样荒废了。</p>
<p>然后晚上最后一位 dalao 到宿舍了。其他两位 dalao 一起帮着他铺床铺。</p>
<p><del>气抖冷为什么我就没人帮我还差点把褥子套当成床单直接铺上去了（好吧是我自己没问</del></p>
<p>晚上 10 点开了班会，虽然我不确定自己有听进去多少。</p>
<p>听说宿舍氛围太沉闷了。啊这，躲在角落里一个人乖巧地自闭.jpg</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>虽然把报道的那一天当成 Day 0 了，但是今天一节课没有就当成 Day 1 真的好吗。</p>
<p>6：30 就被吵醒了，然而完全不想起。</p>
<p>9：00 开始选课。虽然昨天晚上同宿舍 dalao 一直在研究怎么选但是并没有因此而学到些什么。</p>
<p>虽然听说教务系统的服务器不大星但还是被卡到去世了甚至卡出乱码了。</p>
<p>首先似乎要选一门体育。能不能不选啊（光速逃（好吧好像不行</p>
<p>和同宿舍 dalao 一起选了乒乓球，虽然完全不会。不过还好没有喜提啦啦操。</p>
<p>然后似乎还要选一门公共艺术。然而看着十四页的列表完全不知道怎么选（光速逃×2</p>
<p>最后艰难地选了「绘画赏析与启智疗愈」。好吧别让我来画就星。</p>
<p>然后今天就没有事了。愉快地颓废.jpg</p>
<p>话说回来，为什么课表里会有「军事理论」「形势与政策」「中国近现代史纲要」这种东西啊（苍蓝残想不通.jpg</p>
<p>听说 Deltarune 出第二章了于是去玩了玩。虽然其实第一章我已经玩通过一遍了。</p>
<p>和平线真是和平啊。目前进度第二章打完三个播放器。</p>
<p>不过说实话，全是英文的确是完全看不懂只能理清剧情大概（留下了英语没学好的泪水.jpg</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>7：00 才起来，就算这样整个人还是跟要去世了一样。于是早饭也没有吃。</p>
<p>8：30 进行了一个半小时的班会，虽然我并不觉得自己听进去了几个字。</p>
<p>然后 14：30 进行校史中的红色基因教育。那当然是一个字不听。整个宿舍全在打游戏。</p>
<p>16：30 线下班会。换句话说就是，要「自我介绍」了。</p>
<p><del>世界啊毁灭吧（无慈悲</del></p>
<p>在下面看着一群 dalao 上去一边自称社恐一边侃侃而谈只有我缩在最后一排乖巧地自闭。</p>
<p>结果没一会就到我了。好家伙这就是该来的总是会来的吗。</p>
<p>上去胡说八道了一通，顺便宣传了自己的题目组，虽然应该没什么用吧。</p>
<p>因为有些紧张于是通过给阿块留了几句话稍微缓解了一下。</p>
<p>然后下来才想起来好多该说的都没说。啊这我能不能用时间机器回到过去再来一遍啊（光速逃</p>
<p>本来打算不去吃晚饭直接回宿舍的，结果到了门口发现钥匙丢了于是去食堂等他们吃完。</p>
<p>欸不对啊我记得把钥匙放兜里了啊，它会不会是用瞬移自己走掉了呢？</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>早上天还没亮就被某种神秘力量叫醒了然后睡不着了。</p>
<p>而且不知道为什么这几天经常半夜莫名其妙醒过来。苍蓝残想不通.jpg</p>
<p>早上去录入面部图像数据，然后领教材。</p>
<p>录入完数据差点没找到其他人，一问发现其他人都让回宿舍了，只留下寝室长把四人份的书搬回去。</p>
<p>然后果然一个人太少了，于是除了我以外的两位 dalao 也被叫去了。</p>
<p>等真正拿到书才发现居然这么多整整 26 本。而且竟然给体育也专门整了一本书。这是 ao 的（没那回事</p>
<p>把这一大坨子书扔到桌子上，瞬间觉得这屑桌子怎么这么小。</p>
<blockquote>
<p>「今天晚上一定有人预习，但我不说是谁。」  ——某 dalao</p>
</blockquote>
<p>最近一直在玩 Hades，突然发现这游戏的盾牌是可以把攻击正面挡下来的。我大受震撼。</p>
<p><del>一直以为这游戏强调输出，只要我先一步把对面打死我就不会被打到了。</del></p>
<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>8：00 开学典礼。</p>
<p>典礼最后一项要求唱校歌，然而并不会唱。甚至不看着歌词都听不清唱了些什么。</p>
<p><del>幻听「莘莘国士集资上香」（第三宇宙速度逃跑</del></p>
<p>明天就要开始上课了怎么办啊。</p>
<p>听说高数挂科的很多然而我还什么都不会啊怎么办啊。</p>
<p><del>世界啊毁灭吧（还是不要这样吧</del></p>
<p>Deltarune 第一章背景故事自带的 BGM 真好听我听爆.jpg</p>
<p>后天就要抽血了怎么办啊我可以提前先去世一下吗（好像不行</p>
<h2 id="Day-5（2021-9-27）"><a href="#Day-5（2021-9-27）" class="headerlink" title="Day 5（2021-9-27）"></a>Day 5（2021-9-27）</h2><p>某种意义上的真正的大学的第一堂课。高数。上午一二节。</p>
<p>感觉可能至少三个月左右没动过脑子了有些去世。不过还好第一节课总体没讲什么。</p>
<p>然后三四节英语。三个月没接触过英语于是再次去世了。<del>当头一棒。</del></p>
<p>中午随便吃了点啥就去体检了。然而排队时间过长导致四班集体迟到（</p>
<p>下午五六节中国近现代史<del>，鬼才听这种课翘了翘了</del>。其实也没听进去几个字（心虚</p>
<p>然后今天就没有课了。快乐地颓废.jpg</p>
<p>Hades 真好玩.jpg（虽然其实今天还没来得及碰</p>
<p>17：00 到 19：00 晚自习，虽然只是预习了一个小时的数学然后对着英语课本发了一个小时的呆。</p>
<p>求极限好玄学啊感觉课本上的习题都只是瞪眼出答案然后证明。这要是万一瞪眼出不来答案那不就去世了吗。</p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>7：00 要去抽血。虽然整个宿舍都是睡过了 7：00 才起床。</p>
<p>去体育馆一看发现队伍长得跟什么一样然后当场去世了。</p>
<p>于是光明正大地插队。于是 8：30 就抽完了。</p>
<p>然后本来打算去吃点啥然而没发现啥想吃的，于是直接开溜了。</p>
<p>11：00 开始试着写了写阿块的神仙题。</p>
<p>13：30 似乎就写出来了（虽然中间吃去吃了个午饭</p>
<p>就这么个小东西也要写两个小时我好菜啊（倒地</p>
<p>测了两个（弱不禁风的）小样例发现没有什么大问题的样子</p>
<p>下一节课是高级语言程序设计（</p>
<p>不过因为是第一节课说不定只是去听老师瞎扯（小声</p>
<p>好吧还是讲了不少东西的。</p>
<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><p>早上 7：30 才挣扎着爬起来。</p>
<blockquote>
<p>阿块「这就是大学生活吗。」</p>
</blockquote>
<p>上午两节英语两节数学，虽然我感觉几乎没听进去什么。</p>
<p>qaq 可能这就是菜吧。</p>
<p>趁着下课时间跟阿块简单探讨了一下新题，顺便确定了国庆假期不回家留在学校。</p>
<p>然后中午在和阿块深入探讨分块问题。</p>
<p>说到区间修改区间数颜色，阿块想起来了一道 lxl 题于是去 Luogu 找。</p>
<p>找到之后一翻题解发现题解有一篇讲的做法还是阿块亲自教 TA 的。</p>
<blockquote>
<p>阿块「忘的一干二净，笑死。」</p>
<p>阿块「那我可要经典想当年了。」</p>
<p>阿块「你要说理论上我会的确实还挺多的。」</p>
<p>阿块「但是根本写不出来，笑死。」</p>
</blockquote>
<h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><p>上午没有课，于是整个宿舍集体睡到 9：00+ 才醒。</p>
<blockquote>
<p>阿块「这就是大学生活吗。」</p>
</blockquote>
<p>12：45 要上交写给四年后的自己的信，于是趁这个时候赶了赶。</p>
<p>听说字数要求最低 400，然而并不管这些糊了两段不到 200 字打算就这么交上去了。</p>
<blockquote>
<p>我「不会吧不会吧不会真的有人认真写这种东西吧。」</p>
</blockquote>
<p>回想起来，其实五天前就说让写这个东西了。</p>
<p>本来是想着五天写一篇 400 字的小作文绰绰有余，结果拖延症发作硬是给拖到今天早上，然后开始赶工。</p>
<p><del>好家伙真就人均拖延症晚期。</del></p>
<p>下午四节计算机导论。前两节讲计算机的发展历史。</p>
<p>晚上一二节是第一次</p>
<p>后两节摸底测试，考了些基础理论，中文打字，Word，Excel 还有 PowerPoint。笑死，忘得一干二净.jpg</p>
<p>19：00 去上了人生第一节大学选修课。绘画鉴赏。</p>
<p>主要就是给您一幅画然后让您说这幅画哪里好哪里不好。</p>
<p>然后这个老师准备了很多大艺术家的画册一类的。上课积极回答问题可以加分，回答得越多得分越多；如果当上班长还会有分数保底。得分前几名就可以获得这些画册。</p>
<p>社恐原地去世。</p>
<h2 id="Day-9（2021-10-1）"><a href="#Day-9（2021-10-1）" class="headerlink" title="Day 9（2021-10-1）"></a>Day 9（2021-10-1）</h2><p>国庆假期第一天，因为整个宿舍没有人回家，于是集体睡大觉。</p>
<p>上午当然是愉快地颓废。</p>
<p>下午似乎他们在整什么美术用具购买。因为一直在玩游戏一眼没看，就让同宿舍 dalao 帮我全都整了。</p>
<p>晚上跟着同宿舍其他三位 dalao 出去逛超市顺便在外面吃完饭。</p>
<p>来回一共走了 8000+ 步吧听一位 dalao 说。其他人似乎都一点事没有的样子只有我累到去世。</p>
<blockquote>
<p>某 dalao「我靠我看你就是欠走。谁叫你成天坐在电脑前面玩游戏敲代码。就你这身体，你以后去当那个什么 007 你吃得消吗好家伙你吃不消的。」</p>
</blockquote>
<h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>国庆假期第二天。当然还是快乐地颓废。</p>
<p>关于 Hades，这游戏竟然第 10 次通关可以直接跳过最终 BOSS。然后还会看到 Staff 表。</p>
<p>也就是说，我终于真正意义上通关了这个游戏了吗。</p>
<p>然后王子就把他母亲接回阴间了。</p>
<p>然后王子就获得了一份还算正式的工作，从内部对冥府的防御工事进行武装突破，以此来揭露出其中的漏洞。同时把奥林匹斯众神一个个全都蒙在鼓里，让他们还以为自己是在一次一次地前往阳间找母亲。</p>
<p>话说回来你们阴间的这些个所谓防御工事，难道不是直接正面突破就能解决的东西吗（小声</p>
<p><img src="/img/20211002215736_1.jpg" alt="冥后归来"></p>
<blockquote>
<p>In the name of Persephone, the queen. Open the door!（虽然这句话没截图</p>
</blockquote>
<p>看了一下到目前为止总游戏时间 64h。</p>
<p>其实感觉如果一开始去看一些教程的话会进行地更快。虽然我不喜欢看那种东西。</p>
<p>虽然其实我也是看了一些的。看之前我甚至还以为好感度完全没用（小声</p>
<h2 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h2><p>不知道为什么又把图书馆捡起来了。</p>
<p>在下四层卡到去世之后中三层莫名流畅。</p>
<p>然后被普鲁托暴打。</p>
<p>然后中午闯进来两个学长就开始推销。给推销了几瓶洗鞋洗衣服总之可能啥都能洗的产品。</p>
<p>然后当场拿起 CTY 的鞋洗了几下做演示。</p>
<blockquote>
<p>CTY「那你直接把我整只鞋都给我洗了吧。」</p>
<p>学长「要收费。」</p>
<p>CTY「那可算了。」</p>
</blockquote>
<p>演示完之后学长给出了两个方案：200 买三瓶，或者是 300 买五瓶。</p>
<blockquote>
<p>CTY「我觉得三瓶就足够了。我是一个理性的消费者。」</p>
<p>学长「你看看，三瓶的话你们四个人分起来多不方便啊。五瓶的话你们每人单独用一瓶还可以留一瓶公用。」</p>
<p>CTY「我觉得我们三瓶全都公用谁想用谁就拿来用挺好。」</p>
<p>学长「你的这两个室友（FYF，YZ）怎么想。」</p>
<p>CTY「他们随我。他们都非常社恐的。——好吧其实我也社恐但我是寝室长。」</p>
<p>学长「那边那位学弟（我）呢？带着耳机听见了吧。」</p>
<p>CTY「ZYC 你好好想想。你一定要做一个理智的人。」</p>
<p>我「我都行。」</p>
</blockquote>
<p>然后学长提出 300 给我们六瓶。</p>
<blockquote>
<p>CTY「然后我就在想，如果我以后创业，跑到别人家去推销，我会想别人怎么对待我。如果我遇到的人一个个都不像我这样好说话，一听说我是传销的二话不说把我赶出去该怎么办。」</p>
<p>学长「那就支持一下吧。」</p>
<p>CTY「但是比起一个善良的人，我更愿意当一个理性的人。」</p>
</blockquote>
<p>然后 200 买了三瓶。然后学长又送了一瓶。于是整个宿舍均摊费用每人 50。</p>
<p>然后宿舍长就开始在宿舍里大声呐喊，说如果我们感觉被强制消费了就大声说出来，强扭的瓜不甜之类的。儿童的目光.jpg</p>
<p>因为学校体育课要求跑步，同宿舍几个 dalao 就开始商量什么时候去跑步。</p>
<p>因为不是很饿，我就没去吃晚饭，在宿舍等另外三位 dalao 吃完回来。</p>
<blockquote>
<p>CTY「我晚饭吃多了跑不了了。」</p>
</blockquote>
<p>然后拖到 19：00。</p>
<blockquote>
<p>CTY「我想起来了 20：00 还有原神直播。」</p>
</blockquote>
<p>然后拖到 19：30。</p>
<blockquote>
<p>FYF「我想起来了我 21：00 还有游戏内社团活动。」</p>
</blockquote>
<p>然后拖到 19：50。</p>
<blockquote>
<p>CTY「好的直播要开始了。」</p>
</blockquote>
<p>于是今天并没有跑步。</p>
<h2 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h2><p>我竟然打过普鲁托了！（倒地</p>
<p>有一说一泪滴的书页好强啊，切成防御姿态拿上「关注与集中」然后几乎完全不攻击只用反击的招架骰子把普鲁托震晕了。</p>
<p>晕过去之后还剩 120+ 血，然而这个时候助理司书也都死得差不多了能打出有效输出的也就穿着泪滴衣服的 Hokma 了我还觉得一回合不大星结果一张「紫光凝剑」一刀下去 70+ 伤害于是普鲁托直接没了。</p>
<p>快进到总类层<del>阿尔加利亚反复多次暴打罗兰</del>。</p>
<p>为什么这个苍蓝脑残这么强啊（</p>
<p>为什么哲学层和宗教层的书页这个时候还是锁着的啊（</p>
<p>罗兰你星布星啊你是不是传说中的黑不拉几哑巴啊（</p>
<p>经过一个下午的反复尝试我觉得这样是布星的于是我把在哲学层用掉的塔尼娅的「傲然挺立」扣过来了。</p>
<p><del>然而这并没有什么用该被打死还是被打死.jpg</del></p>
<p>关于打法，现在有两个想法。</p>
<p>想法一就是只要脑残用「崩坏序曲」就想办法把第一颗骰子拼过去。</p>
<p>然而对面第二回合开始每回合至少 3 层强壮，然后就容易翻车。</p>
<p>想法二就是首先第一回合攒出 3-2=1 层震颤，然后第二回合一口气攒出 1+3+3=7 层震颤。之后想办法把震颤的数值维护在脑残的速度骰子取值范围之外。</p>
<p>然而「独奏之刻」命中掉震颤，「不谐和音」拼点失败掉震颤。很容易一不小心震颤层数就被砍。</p>
<p>而且似乎是只要脑残有一颗速度骰子和这边的震颤层数相等，他这一回合使用的所有「心灵共振」都会触发特殊效果。这可太阴间了。</p>
<p>这个 Win 10 自带的输入法是不是有什么大病每次出来的第一个匹配项总能巧妙地出点差错。</p>
<p>晚上跟着同宿舍 dalao 去跑步。</p>
<p>要求跑 2.5km 然而我跑了 1.0km+ 就感觉要去世了于是临阵脱逃了。</p>
<p>我觉得我体育就不及格了吧（</p>
<h2 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h2><p>我打过苍蓝脑残了！！！（大叫并倒地</p>
<p>经过 40+ 次反复尝试，最终我找到了一种十分简单粗暴的策略：</p>
<p>第四张异想体书页拿「剧烈搏动」，然后在两个回合之内把脑残打晕并把他的红条削到 25。</p>
<p>然后我就真的做到了。于是下一回合脑残回满黄条并扔出来一张「最终旋律」，被放在了一颗 95 的速度骰子上。</p>
<p>然而我「Furioso」上一回合刚用完，于是我尝试扔出一张「卡莉斯塔工作室」。</p>
<p>第一次拼点 18：14，这一下给罗兰回了 18 点混乱，顺便脑残因为流血掉了 7 点血。</p>
<p>第二次拼点 19：12，这一刀下去 22 点伤害于是脑残直接没了。</p>
<p><del>话说回来脑残哪来的 7 层流血。</del></p>
<p><del>好吧原来是一张「Furioso」给了 5 层。</del></p>
<p>然后我就录屏了。我觉得这可以扔到 B 站上去。</p>
<p><a href="https://www.bilibili.com/video/bv1MT4y1f7zu">了解一下 qwq</a></p>
<p><del>然后被黑不拉几哑巴暴打。</del></p>
<p>有一说一漆黑噤默接待战真的流程太长了。</p>
<h2 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a>Day 14</h2><p><del>一觉醒来 10：30。</del></p>
<p>为什么这个黑不拉几哑巴三阶段这么硬啊。</p>
<p>仔细分析了一下我发现我的卡组里面没有回转的卡。</p>
<p>于是我尝试在卡组里塞了两张「苍穹之枪」。</p>
<p><del>然而并没有什么用不如说表现得还比以前差了整个语言层在三阶段直接团灭了。</del></p>
<p>吃完晚饭把试着把星天歌下回来玩了玩。</p>
<p>好家伙这游戏竟然没有决死。好家伙这游戏按一下 Esc 居然直接就退出了。</p>
<p>虽然之前看过视频不过还是，2 BOSS 的二符终符太阴间了。这种弹幕射击绝对是不可取的。</p>
<p>之前那个视频好像是直接上避了。</p>
<p>话说回来，三面标题竟然直接就叫「森の中の猫の小屋」。<strong>本 社 爆 破</strong>（指冲到制作组老家</p>
<p>好吧也许是之后才确定这个名字的。</p>
<p><del>顺便 6 BOSS 可爱 awsl（光速逃</del></p>
<p>……好吧原来宗教层和哲学层没有完全解放的话只能看到 A 结局。</p>
<p>然后我整个残响乐团就白打了！</p>
<p>脑残白打了！</p>
<p>黑不拉几哑巴白打了！</p>
<p><del>好吧似乎我需要动用一些不正当手段了。</del></p>
<p><del>写个被动能力「拼点开始时，对所有来宾造成 998244353 点混乱伤害和伤害」。</del></p>
<h2 id="Day-15"><a href="#Day-15" class="headerlink" title="Day 15"></a>Day 15</h2><p>国庆假期最后一天（悲</p>
<p>虽然好像其实也没干啥。</p>
<h2 id="Day-16（2021-10-8）"><a href="#Day-16（2021-10-8）" class="headerlink" title="Day 16（2021-10-8）"></a>Day 16（2021-10-8）</h2><p>国庆假期结束了（悲</p>
<p>然后迎接我的是两节比红茶还要催眠的高数课（大悲</p>
<p><del>「没有人规定必须要正着走路啊为什么你们不倒着走路呢？」</del></p>
<p>话说今天似乎是我生日啊。</p>
<p>不知道为什么把兔子捡回来又玩了玩。</p>
<p>但是为什么我是不是显示出错甚至闪退啊（</p>
<p>以及，哲学层解放战好难。去世了。</p>
<h2 id="Day-17"><a href="#Day-17" class="headerlink" title="Day 17"></a>Day 17</h2><p>上午没有课于是睡到 10：00。</p>
<p>起床再次尝试了一下哲学层解放战。自闭了。</p>
<p>三阶段好难控罪痕层数啊一不小心就 3 个 3 层了。</p>
<p>然后四阶段的骰子点数就离谱为什么它随手一扔就是两个 18-18 的清算好家伙我直接暴风疑惑。</p>
<p>下午的时候买的椅子到了。然后试图一个人把它搬到宿舍然后去世了。</p>
<p>搬到一半感觉胳臂快要断了于是叫了一位同宿舍 dalao 来帮着搬。</p>
<p>晚上连着三节艺术鉴赏，然后我们在老师的指示下进行 <strong>抽 象 派 艺 术 创 作</strong>。</p>
<p><img src="/img/流汗黄豆.jpg" alt="同小组代表作品「流汗黄豆」"></p>
<h2 id="Day-18"><a href="#Day-18" class="headerlink" title="Day 18"></a>Day 18</h2><p>VICTORY！</p>
<p>好家伙我终于打过哲学层解放战了。</p>
<p>因为四阶段有个形态 BOSS 会用一张命中扣光的 AOE，之前打的时候可能没怎么重视于是把光都给扣完了。</p>
<p>这次我打的时候特别重视了回光，在泪滴书页的防御架势里面塞了三张「能量转换」。于是成功做到了每回合开幕满光。</p>
<p>一鼓作气把宗教层解放战也打了。</p>
<blockquote>
<p>「……操。我真的，不想，再，面对它了。」</p>
</blockquote>
<p>话说回来这场解放战居然只有一个阶段。不过很难就是了。</p>
<p>一形态说每有一名使徒死亡就会使用一张书页「圣洗」我还一位会是什么 diaomao 没想到竟然给我这边回血回混乱抗性。</p>
<p>然后二形态上来一看红条黄条 666 还全抗性抵抗我差点吓死。</p>
<p>然后二形态上来就秒掉两个助理司书我直接暴风疑惑。</p>
<p>然后打着打着不知道为什么全抗性致命了。然后才发现是我没仔细看对面被动。</p>
<p>结果打死了对面突然原地复活然后甚至还把我这边所有司书一棒子敲晕了。</p>
<p>然后甚至还扔出来一张 66-66 的清算。</p>
<p>然后我一看 Hokma 的状态，我发现了 100 层守护和振奋。</p>
<p>然后下一回合除了 Hokma 以外所有司书被秒了。然后 Hokma 凭借着 100 层守护和振奋抗了对面一个回合的集火。</p>
<p>然后手里突然多了一张书页 666-666 清算，且造成真实伤害。</p>
<p>好家伙这算个什么演出我直接暴风疑惑。</p>
<p>然后使用作弊手段跳过了残响乐团接待战和漆黑噤默接待战。开始打总类层解放战。</p>
<p>馆长你星布星啊为什么你这些书页这些个骰子点数一个比一个小啊。</p>
<p>晚上的时候收到通知说军事理论课程到最后需要写论文。</p>
<p>一下是给定的论文课题，二选一。加粗部分是重点。</p>
<blockquote>
<p>课题一：2009年开始，党中央、国务院、中央军委着眼建设一支强大的人民军队，作出重大战略安排，全面展开大学生征兵工作。你对这一战略安排有什么认识？<strong>你愿意在大学期间入伍吗？主要考虑是什么？</strong></p>
<p>课题二：学习和研究中国国防历史，<strong>通过比较中日甲午战争和抗美援朝战争，谈谈自己对国防和国防（军队）建设的体会和认识。</strong></p>
</blockquote>
<p>好家伙我直接龙卷风疑惑。</p>
<p>字数限制似乎是不超过 3000 字。啊这我写个 30 字交上去星布星啊。</p>
<h2 id="Day-19（2021-10-11）"><a href="#Day-19（2021-10-11）" class="headerlink" title="Day 19（2021-10-11）"></a>Day 19（2021-10-11）</h2><p>早上睡到 7：30 被同宿舍 dalao。</p>
<p>爬起来已经 7：45 了于是没去吃早饭直接跑去教室了。</p>
<p>一二节高数，讲极限。感觉海星。</p>
<p>三四节英语。好家伙一个字不听，在 QQ 群里和高中同学聊天。</p>
<p>下午一二节近现代史。笑死，一个字都不听.jpg</p>
<p>晚上一二节是第一次上机课程。然后老师让我们自行研究代码。从下次上课开始正式开始学习自己写。</p>
<p>于是和同宿舍的另一位有一定基础的 dalao 一起教另外两位 dalao 阅读代码。</p>
<p>其实本来还戴着耳机打算听歌的来着，但是一看有老师学长到处转还有摄像头于是放弃了。</p>
<p>看戏.jpg</p>
<p>晚上又尝试了一下总类层解放战。</p>
<p>发现如果第一回合安吉拉拼点全输掉拿一张「脉动」就有机会在后面的一个对面扔过来三张「瘆白之手」的回合苟住不被打晕。</p>
<p>然后切阶段竟然给自动存档。好家伙这场解放战可太良心了。</p>
<p>（↑被热望带着 25 层「渴望」爆揍了一顿之后滚回来的人）</p>
<p>（我还想为什么这样都能拼输结果一看好家伙 25 层强壮）</p>
<h2 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a>Day 20</h2><p>没什么可以记录的</p>
<h2 id="Day-21"><a href="#Day-21" class="headerlink" title="Day 21"></a>Day 21</h2><p>试图切掉 Luogu P7882。</p>
<p>然而经过多次反复尝试后我明白了，这不是我能做的题。</p>
<p>干败吓疯。告辞.jpg</p>
<p>把 Rabi-Ribi 捡起来又玩了玩。</p>
<p>本来想试试 Hell 难度的 DLC 沙耶，结果被揍到自闭。于是开 BEX 难度。</p>
<p>不知道为什么，感觉比以前玩 Hell 难度的时候顺畅很多。很多以前觉得非常难的地方现在都没什么了。也许是我的技术提升了吧。</p>
<p>话说回来我的新电脑可能有什么大病。动不动就会出现一些乱七八糟的显示错误。包括但不限于角色立绘五官莫名其妙消失，小怪的像素图看不到头发变成大光头或者干脆只剩下一双兔耳朵在空中飘着，以及文本出错。</p>
<p>而且每打完一个 BOSS 就要给我玩一波闪退。就是那种击破瞬间突然游戏崩掉然后只能再打一遍的那种。</p>
<p>现在卡在 Noah 战。四连 BOSS 战还没有补给可太去世了。</p>
<p>第一场 Miru 战甚至还不能带 Ribbon。瞬间感觉 DPS 下降了好几个数量级。</p>
<p>在 Miru 战用掉了所有消耗性物品然后打不过了于是被迫 SL。</p>
<h2 id="Day-22"><a href="#Day-22" class="headerlink" title="Day 22"></a>Day 22</h2><p>下午四节计算机导论，其中三四节是上机课。</p>
<p>闲着没事翻了翻自己以前写的 Blog，发现自己竟然还研究过伯努利数这种神仙科技。</p>
<p>然后仔细阅读了一下还发现了一些小问题。</p>
<p>关于兔子，卡在（至少在我心目中的）整个游戏本篇（就是说不包括 DLC）最难 BOSS Milliam 了。</p>
<p>然后回去找了找发现以前的地图有好多道具落下没拿。</p>
<p>拿完之后道具收集率从 85%+ 提升到了 90%+。可海星。</p>
<h2 id="Day-23"><a href="#Day-23" class="headerlink" title="Day 23"></a>Day 23</h2><p>上午一二节高数。虽然听得懂但还是差点昏睡过去。</p>
<p><del>「坐后排的那些……这个，不要放弃。」</del></p>
<p>中午尝试了一下国内做的那个兔子高级技巧教程，见识到了瞬移以及各种乱七八糟的极限高跳极限远跳。</p>
<p>学不来，告辞。</p>
<h2 id="Day-24"><a href="#Day-24" class="headerlink" title="Day 24"></a>Day 24</h2><p>因为是周六然后只有晚上有两节课于是快乐地颓废。</p>
<p>看到 Luogu 有月赛于是报名了 Div 1。</p>
<p>切了 T1 然后 T2 因为一些玄学原因 WA 掉了。</p>
<p>然后看了看 T3 觉得不大会于是打算打一打 T4 的暴力，$O(nq\log a_i)$ 的那种。</p>
<p>但是打到一半突然高中同学群里面有人讲话，于是跑去聊天然后暴力也不打了。算了 140 分就 140 分吧。</p>
<p>晚上有第一节大学生心理健康课。然后气氛活跃得完全不像是在上课。</p>
<p>然后情景模拟。就是说有个小宇同学高中成绩很好然后上了大学退步了于是开始怀疑人生。需要有一个人扮演小宇同学然后另外一个人扮演心理委员去对他进行心理辅导。</p>
<blockquote>
<p>小宇「我学习不好。」</p>
<p>心理委员「学习不好那就要好好学习。」</p>
<p>小宇「我觉得你不适合干这行。」</p>
</blockquote>
<p>xswl（某种 高雅的 笑声）</p>
<p>晚上上完课正在像一道 Ynoi 的某个实现细节，突然阿块在群里冒泡了。</p>
<p>然后阿烜来了一句「阿块，我的阿块」。</p>
<p>于是我们纷纷复读，然后群里就出现了一大片「〇〇，我的〇〇」。</p>
<p>然后逐渐发展成「〇〇……/se/se/se/se……我的〇〇……/se/se/se/se」。</p>
<blockquote>
<p>zhuoer「突发恶疾了属于是。」</p>
</blockquote>
<h2 id="Day-25"><a href="#Day-25" class="headerlink" title="Day 25"></a>Day 25</h2><p>下午整个宿舍去图书馆转了一圈。</p>
<p>然而第一次去图书馆啥也不懂就跟乡下人进城一样乱逛。</p>
<p>然后打算去借书的地方看看。虽然其实一本书都没借就跑路了。</p>
<p>然后宿舍长自己留下来随便找了个地方，因为自习室都坐满了，然后打算写作业。剩下我们三个就回宿舍了。</p>
<p>一回到宿舍就看到大吊阿烜在群里宣传他们的 diaomao 队名。</p>
<blockquote>
<p>我「我觉得哪个都不好。」</p>
<p>wwr「确实。」</p>
</blockquote>
<p>晚上的时候第一次尝试了一下 BABA is YOU，虽然很早以前就听说过这游戏的大名了。</p>
<p>然后现在卡在 LAKE EX 2 了。</p>
<h2 id="Day-26（2021-10-18）"><a href="#Day-26（2021-10-18）" class="headerlink" title="Day 26（2021-10-18）"></a>Day 26（2021-10-18）</h2><p>好耶！我打穿图书馆主线了！</p>
<p>关于扭曲残响乐团，第一场我用的艺术层，本来想借着艺术层的回血手段用柳科长把他们全砍死，结果柳科长出师未捷身先死。</p>
<p>虽然到最后总而言之是勉强解决掉了对面四个。</p>
<p>然后第二场用语言层乱杀。</p>
<p>第三场还是用语言层，把脑残打成残血之后用哲学层补刀。</p>
<p>说实话扭曲残响乐团的配卡机制啥的完全没研究，一路莽过去的。</p>
<p>然后是最后的接待。<del>不过话说回来明明是剧情杀为什么还要求必须要坚持足够的回合数啊。</del></p>
<p>然后获得一个 Steam 成就，「一码归一码」（指观看 C 结局）。</p>
<p>「그건 그거고，이건 이거니까。」（鸣谢<a href="https://ocr.space/">此网站</a>提供的文字识别服务）</p>
<p>打算写几个 mod 突然感觉自己那些想法一个比一个逊。然后美术工作也没办法搞。还是算了吧.jpg</p>
<h2 id="Day-27"><a href="#Day-27" class="headerlink" title="Day 27"></a>Day 27</h2><p>下午又是三节 C 语言。日常看戏 + 划水。</p>
<h2 id="Day-28"><a href="#Day-28" class="headerlink" title="Day 28"></a>Day 28</h2><p>晚上卡着 18：20 去食堂，然后喜提最后一份麻辣香锅。</p>
<p>今天辅导员生日。然后见识到了二班三班的奇妙内卷。</p>
<p>生日蛋糕 + 祝福小视频 + 一整个黑板的祝词。甚至据说准备了五天。</p>
<p>好家伙，我直接好家伙。</p>
<h2 id="Day-29"><a href="#Day-29" class="headerlink" title="Day 29"></a>Day 29</h2><p>听说 Deltarune 的背景故事配上自带的 BGM 是可以唱出来的。试了一下然后发现并不大能。</p>
<p>仔细反思了一下自己最近颓废地有多厉害，然后我意识到了再这样下去是不可取的。</p>
<p>于是立志开始重拾 OI 功力。</p>
<p>从字符串相关算法开始吧。</p>
<p><del>说不定明天早上一起来就全给忘了。</del></p>
<p><del>算了吧还是明天吧。</del></p>
<h2 id="Day-30"><a href="#Day-30" class="headerlink" title="Day 30"></a>Day 30</h2><p>早上 8：00 才起来。然后一二节是高数于是早饭都来不及吃暴风赶到教室。</p>
<p>上完课跑去食堂买了个三明治，吃完才回宿舍。</p>
<p>一开电脑就看到百橙的新的角色 DLC，好家伙我直接当场。</p>
<p>首先是月夜姬梦。</p>
<blockquote>
<p>I always though Hime with -1 DEF is bad….</p>
<p>now they gave her -2 DEF! Great!</p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>我一直觉得姬梦的 -1 防御已经挺糟糕了……</p>
<p>结果她现在直接 -2 防御了！真棒！</p>
</blockquote>
<p>（摘抄自 Steam 某评测）</p>
<p>然而 Hyper 看上去很强。闪避成功时对对方追加自身本应受到的伤害，回合数是 5 的倍数时最终伤害两倍。</p>
<p><del>想起「萎缩的血翼」</del></p>
<p>于是马上打开游戏试了一把。</p>
<p>结果没带抽卡的卡。</p>
<p>好不容易抽到一张 Hyper，然后踩到 BOSS 格，想都不想直接扔出去。</p>
<p>然后对面 +2 攻击扔了个 6。然后我这边回合数不是 5 的倍数于是 +2 闪避躲不开。</p>
<p><del>真棒！</del></p>
<p>关于某社交界的菲尔涅特，不是很喜欢这个角色。<del>而且根本就完全变了个人吧！</del></p>
<p>不过说实话这身新衣服挺不错（</p>
<p>然后甜点品尝者的兔萌萌和 Dangerous 的由希有了新的语音，也就是说不再和原版共用语音了。</p>
<p>去听了听甜点品尝者的新语音好家伙这兔子变身前也太懒了。<del>当代大学生现状。</del></p>
<p>然后一变身不知道是不是错觉声音年轻好几岁（</p>
<p>在不久的将来应该还会有一个角色 DLC。好家伙 gkdgkd（</p>
<p>下午乒乓球课，打了一会球然后老师让我们跑 1000m。</p>
<p>结果跑了不到一圈就跑不动了于是耻辱跑路。</p>
<p><del>好吧希望我人没事。</del></p>
<h2 id="Day-31"><a href="#Day-31" class="headerlink" title="Day 31"></a>Day 31</h2><p>中午试着写了一下 19 年十二省联考的某串串题。</p>
<p>然后写了调了三个小时发现没写拆点。</p>
<p>写拆点写到一半转念一想好像又得写个倍增不然复杂度要去世。</p>
<p>然后自闭了写不下去了。</p>
<p>甚至写到这里我 DAG DP 还一行没写。</p>
<p>好家伙，现在我连这么不到 200 行的代码都写不出来了吗。</p>
<p>想当年我可是盯着 500+ 行的代码硬生生调试了一个星期才终于做出来一道题的。</p>
<p>果然经过一整个高三，一整个暑假还有大学的最初一个月已经功力尽失了吗。</p>
<p>翻 Luogu 关注列表，看到这么一个签名：</p>
<blockquote>
<p>高二学 OI 的一年，是我人生中最快乐的时光。</p>
</blockquote>
<p>……………………</p>
<p>………………</p>
<p>…………</p>
<p>……</p>
<p>有点想重开了。</p>
<h2 id="Day-32"><a href="#Day-32" class="headerlink" title="Day 32"></a>Day 32</h2><p>上午同宿舍其他三位 dalao 一起去了某个 1024 程序员节展览会。</p>
<p>早上 8：30 就开始有人敲门催，然而那个时候我们宿舍集体没起床。</p>
<p>然后拖到快 9：00 才走。</p>
<p>13：45 左右回来。然后一进门宿舍长就冲过来跟我说「还好你没去」「可无聊了」。</p>
<p>下午试图写题然而写不动，于是嘴巴了几道串串题。</p>
<h2 id="Day-33（2021-10-25）"><a href="#Day-33（2021-10-25）" class="headerlink" title="Day 33（2021-10-25）"></a>Day 33（2021-10-25）</h2><p>晚上一二节是 C 语言上机课。</p>
<p>然后一会宿舍就开始和同宿舍 dalao 辩论三目运算符里面能不能加逗号的问题。</p>
<p>然后我甚至跑去查了 C Reference，到最后发现是那位 dalao 读入的变量是 <code>double</code> 然而写了个 <code>%f</code>。</p>
<p>好家伙这么低级的错误都没看出来我怕不是要身败名裂（</p>
<p>然后一看 SD NOIP 群发现今年 CSP 提高组 T1 三分做法是假的？！</p>
<p>跑去 Luogu 翻了翻评论区发现题目给的大样例就不单峰。好家伙我要是在考场怕不是挂成蛤蟆。</p>
<p>算了反正我都退役了。</p>
<p><a href="https://www.bilibili.com/video/BV1JU4y1F7xo">推一首歌</a></p>
<p>ワンワンでツーカーでスリーフォー　エビバティショウタイム！♪</p>
<h2 id="Day-34"><a href="#Day-34" class="headerlink" title="Day 34"></a>Day 34</h2><p>下午三节 C 语言完了之后似乎有团日活动，然而不是团员于是溜回宿舍摸鱼。</p>
<p>在宿舍一个人撕烤了一下自己前两天想出来的奇妙的 duliu 题然后发现不会。</p>
<p><del>那我可要经典想当年了。</del></p>
<p><del>想当年我还给 Ynoi 写过 std 造过数据呢（</del></p>
<p>然后得知不是团员也需要去参加活动。然而这个时候我已经要去吃晚饭了。</p>
<p>晚自习一开始打算搞一搞数学作业。然而五分钟就搞完了于是继续撕烤自己的题然后没有思路。</p>
<p>闲着没事上 LOJ 搜了几道串串题嘴巴了两下。</p>
<p>晚自习回到宿舍突然想起来这周要交图库于是觉得不能再颓废下去了于是开始着手。</p>
<h2 id="Day-35"><a href="#Day-35" class="headerlink" title="Day 35"></a>Day 35</h2><p>上午一二节英语三四节数学。</p>
<p>好家伙最后一节是真的昏睡过去了。</p>
<p>14：30 有反电信诈骗讲座。试图鸽掉。</p>
<p>好吧还是跟着去了。</p>
<p>17：00 听说有人要来检查寝室的卫生情况，于是同宿舍 dalao 纷纷<del>奋发图强</del>地开始收拾。</p>
<p>17：00 一道没过两分钟查寝的人就来了。</p>
<p><strong>久 等 了.jpg</strong></p>
<p>结果站在门口瞅了两圈就溜了。</p>
<p><strong>白 等 了.jpg</strong></p>
<p>晚上把赶完的图库扔到附件里邮给班长了。</p>
<p>然后正文部分写了：</p>
<blockquote>
<p>（一些象征性的正文）</p>
</blockquote>
<p>于是班长给我回了一封：</p>
<blockquote>
<p>（一些象征性的回复）</p>
</blockquote>
<p>黄豆托腮.jpg</p>
<p>尝试了一下渡鸦小队 mod。然后开幕就被一张大点数清算书页干烂了。</p>
<p>好家伙这是什么阴间玩意。</p>
<h2 id="Day-36"><a href="#Day-36" class="headerlink" title="Day 36"></a>Day 36</h2><p>绘画鉴赏课上完了一个游戏。就是三个人分成小组，然后其中两个人观察一幅绘画作品三分钟，另一个人不看；然后这两个人指挥第三个人将这幅作品复刻出来。每次两个小组，然后其他人投票决定哪个小组复刻的更好。</p>
<p>然后第二次的图是一朵白色的花。然后 A 组再画面的右下角加上了「艺术国际 vlog」的字样。</p>
<p>然后我们仔细一看原图的右下角，于是真的发现了艺术国际的水印。</p>
<p><strong>细 节.jpg</strong></p>
<p>然后发现我的图书馆加载不了 MOD 了。于是试图重新下载。</p>
<p>然后发现还是加载不了。苍蓝残想不通.jpg</p>
<h2 id="Day-37"><a href="#Day-37" class="headerlink" title="Day 37"></a>Day 37</h2><p>下午试着刷了刷图书馆的非主线成就。</p>
<p>比如说「被封印的黑暗大小丑」「黑森林里住着一头可怕的大怪兽！」。</p>
<p>但是因为这两个成就需要的异想体书页基本上都是红色的。然后就需要故意输掉频点攒负面情感。</p>
<p>但是因为我用的是通关了主线的顶配。然后一不小心就会拼赢。</p>
<p>然后故意拼输的话还会挨很多打。然后一不小心就会去世。</p>
<p>然后因为 Steam 会展示一些未获得的成就中全球获得率相对较高的，于是我就看到了：</p>
<ul>
<li>「我这可是施了法的魔弹」</li>
<li>「您往后稍稍！」</li>
</ul>
<p>当然还有宗教层的「我们未能击穿敌人的反甲」。</p>
<p>lmao</p>
<h2 id="Day-38"><a href="#Day-38" class="headerlink" title="Day 38"></a>Day 38</h2><p>先总结一下昨天晚上的 CF 比赛。就不专门写另外一篇了。</p>
<p>首先 A 题上来一眼没看出来写了个非常假的东西然后直接就交上去了。</p>
<p>然后一交发现 WA on test 2 突然反应过来正解。</p>
<p>等到切掉已经 10 min 了。</p>
<p>然后看 B 题。</p>
<p>这个是一眼就有思路然而关于 $n=k=2^c$ 的部分想了好久怎么特判拖了好久。</p>
<p>然后交了两次都是 WA on test 2。一看有个 <code>if</code> 后面没接 <code>else</code>。</p>
<p><strong>身 败 名 裂</strong></p>
<p>然后开始写 C 题。</p>
<p>有些紧张结果分类讨论的时候把自己脑子给绕进去了然后 WA on test 2 了一发。</p>
<p>看到 D 题的通过人数没有 E 题多于是去开 E 题。</p>
<p>然后推着推着推出来一个有点像分拆数的东西。然后觉得自己肯定写不出来就跑路了。</p>
<p>这个时候 AHU ACM 群里面有学长嘴巴了两下 D 题，于是尝试去写。</p>
<p>这个时候离比赛结束只剩半个小时了。写了一大串突然发现好像不大对劲是假的。于是就放弃去睡觉了。</p>
<p>第二天一看 Rank 2450。好吧等会看看会不会掉分。<del>希望不要。</del></p>
<p><del>算了掉就掉吧反正 Rating 这种东西不过是虚荣的工具罢了。</del></p>
<p>然后第二天要体测。体前屈，引体向上，肺活量，50m，立定跳远，1000m。</p>
<p>首先是第一项，体前屈。</p>
<p>尝试了两次以后喜提 1cm 的好成绩。</p>
<p>然后是第二项，引体向上。</p>
<blockquote>
<p>老师「觉得自己一个都做不了的直接来拿笔写个零吧。」</p>
</blockquote>
<p>然后同宿舍一位 dalao 试图写零结果一不小心写到身高那一栏去了。</p>
<p>接着是第三项，肺活量。</p>
<p>第一次 4000+，第二次 3800+。感觉海星。</p>
<p>然后是第四项，50m。</p>
<p>喜提 9.4s。比昨天的 9.3s 还要慢一点于是压线不及格。</p>
<p>接着是第五项，立定跳远。</p>
<p>xjb 一条结果没想到竟然跳出去 2m 整。</p>
<p>好家伙我一直以为我最多也就 1.6m+ 的来着。</p>
<p>最后是第六项，1000m。</p>
<p>不出所料地跑了一圈就累得去世了。然后跑了 600m+ 的时候实在是人快没了就放弃了。</p>
<blockquote>
<p>FYF「尼玛，开学一个月，先挂了一科。」</p>
<p>FYF「强烈建议公众号每周督促同学们体育锻炼。」</p>
</blockquote>
<p>然后中午也什么都不想吃了。</p>
<p>今天 22：35 还有一场 Div. 1 + Div. 2 的 CF。<del>看我挽回我的名誉.jpg</del></p>
<p>然后 Steam 上一看《脑叶公司》打折 37。好家伙我直接当场。</p>
<p>然后晚上心理健康课进行了一场激烈的辩论赛。</p>
<p>《大学生应不应该谈恋爱》</p>
<h2 id="Day-39"><a href="#Day-39" class="headerlink" title="Day 39"></a>Day 39</h2><p>昨天晚上又打了一场 CF Div. 2。</p>
<p>当然是切完三题跑路的那种。</p>
<p>然后第二天早上起来一看 Rating 掉了 50+ 然后掉到只剩下 1660+ 了。</p>
<p><del>真棒！</del></p>
<p><del>什么时候才能变得有阿烜 $\lim_{x\rightarrow 0}(1+x)^x$ 强啊。</del></p>
<h2 id="Day-40（2021-11-1）"><a href="#Day-40（2021-11-1）" class="headerlink" title="Day 40（2021-11-1）"></a>Day 40（2021-11-1）</h2><p>获得成就：在一节高数课上至少睡 40 分钟。</p>
<p>但是说实话是真的困。</p>
<p>现在还只是刚开始讲导数，不是很难所以还顶得住。</p>
<p>后面讲到积分的时候，尤其是讲到换元积分法的时候，照这个节奏怕不是就要挂科了。</p>
<p>下午一二节近现代史。蛤蛤蛤我怎么会听这种东西。</p>
<p>晚上寝室长表示想吃外卖，于是我先发制人地预判了他要点什么并跟他点了一份一样的。</p>
<p>然后过了一会他点的到了于是他问我们有没有人愿意帮他去拿一下因为他要进行体育锻炼。</p>
<p>然后这个时候正好我点的也到了于是我就直接去拿了。</p>
<p>然后回来才听说他以为我只是出去了于是让同寝室另一位 dalao YZ 去帮他拿了。</p>
<blockquote>
<p>CTY「这波配合得不是很好。」</p>
</blockquote>
<p>然后他一看发现我和他点的是一样的。</p>
<blockquote>
<p>CTY「好家伙是不是我身为寝室长在寝室里带起了一股吃外卖的不正之风啊现在怎么都不去吃食堂了。」</p>
</blockquote>
<p>晚上一二节是 C 语言上机课。然后回来的路上听到有人在说「我们寝室最低水平三道题」。</p>
<p>当时把我吓得一哆嗦（内心里）因为我以为他们说的是 CF。</p>
<p>然后听到后面发现似乎不是因为他们还说什么「书上」「选择」之类的。</p>
<p>好家伙吓我一跳。</p>
<p>然后晚上突然有一位 19 级的学长加我 QQ。</p>
<p>然后一上来就扔给我一张我的 OIerDb 的截图问这是不是我。</p>
<p>好家伙原来我名气这么大的吗居然被一位完全不认识的 dalao 推荐去打 ICPC 了。</p>
<p><del>可把我牛逼坏了叉会儿腰。</del></p>
<p><del>别别别还是收敛一些比较好。</del></p>
<p>然后得知我是互院的之后：</p>
<blockquote>
<p>那位学长「我超，互院的未来。」</p>
<p>那位学长「互院又捡个宝。来【数据删除】击剑。」</p>
</blockquote>
<p>别别别不至于不至于。</p>
<h2 id="Day-41"><a href="#Day-41" class="headerlink" title="Day 41"></a>Day 41</h2><p>听说明天中午要开班会？</p>
<p>【信息学奥林匹克竞赛粗口】。</p>
<p>12：00 就上床了然而睡不大着于是看 QQ 群里学长聊天。</p>
<blockquote>
<p>学长 1 号（不便透露姓名）「支楞起来啊我的【橙子的 emoji】，速度适应一下 ICPC 赛制。」</p>
<p>学长 2 号（不便透露姓名）「你这橘子是什么勾八。」</p>
<p>学长 1 号「橙（成）子。」</p>
</blockquote>
<h2 id="Day-42"><a href="#Day-42" class="headerlink" title="Day 42"></a>Day 42</h2><p>好家伙那当然是不去。</p>
<p>反正肯定讲不了啥实质的东西。</p>
<p>上午上课的时候我们 ICPC 队伍的名字正式决定叫做「坐牢」了。英文名 In Jail。</p>
<blockquote>
<p>阿烜「这着实没啥意思。」</p>
</blockquote>
<p>晚上数学习题课下了回宿舍又复习了一遍之前的<a href="https://www.bilibili.com/video/BV1Kp4y1C79n">某个观赏谱</a>。</p>
<p><strong>请 您 读 谱.jpg</strong></p>
<h2 id="Day-43"><a href="#Day-43" class="headerlink" title="Day 43"></a>Day 43</h2><p>qwq</p>
<h2 id="Day-44"><a href="#Day-44" class="headerlink" title="Day 44"></a>Day 44</h2><p>阿块……/se/se/se/se……我的阿块……/se/se/se/se</p>
<p>晚上数学习题课光明正大地不听课和慎老师进行亲切交流。</p>
<p>然后得知了慎老师现在在学数分和线代。</p>
<p>我看懂了，而且我大受震撼。</p>
<blockquote>
<p>我「（慎老师的班级）听上去像是成功人士聚集地。」</p>
<p>慎老师「听上去像是失败人根据地。」</p>
</blockquote>
<p>假假 /kk</p>
<p>听说 SD 又喜提省队名额 -1 个了。</p>
<p>好家伙我这一辈子能碰到 SD 被克扣多少次名额。</p>
<p>高一一次。高三一次。现在又一次。</p>
<h2 id="Day-45"><a href="#Day-45" class="headerlink" title="Day 45"></a>Day 45</h2><p>早上 9：00 才爬起来。</p>
<p>继续玩脑叶，然后稍微感受到了一点什么叫做白干公司。</p>
<p>本来三次融毁之后已经达到能源指标了但是我突然想尝试一下正午级别的考验是什么样的。</p>
<p>还没打完结果波迪突然跑出来了。</p>
<p>然后有点方然后一看小帮手也跑出来了。</p>
<p>然后我发现小帮手的攻击模式是一个大蓄力然后横扫整个房间。</p>
<p>然后我当机立断趁着它蓄力的时候疏散了所有员工。</p>
<p>打着打着突然发现焦化少女也跑出来了。</p>
<p>献祭了三位文职。</p>
<p>然后往上一看怎么亡蝶葬仪也跑出来了。</p>
<p>// 一级警报</p>
<p>亡蝶葬仪有一种攻击是把它那个棺材摆到面前然后扔出好多好多的蝴蝶覆盖住整个房间。然后白伤杀人。</p>
<p>于是在这里控制部某位勇气 V 的员工壮烈牺牲了。</p>
<p>话说回来这都 Day 18 都结束了为什么我培训部第一个任务都还没完成（</p>
<p>「请给我们爱！！！！！！！！」</p>
<p>重新开始这一天。</p>
<p>晚上第一次去实验室和学长们打 ICPC 模拟赛。</p>
<p>实际上中午的时候已经去探了一波路然后找到位置了。但是不敢进去（</p>
<p>结果一进去一看发现就很小两个隔间然后只有十台左右的电脑。</p>
<p>除了我以外就只有三位学长了。<del>人少得可怜。</del></p>
<p>然后开题。</p>
<p>首先找到一道签到题切掉。</p>
<p>然后找到一道逆序对建图染色的题。然后我读完题直接「我有一个想法」，学长表示震惊。</p>
<p>然后写挂了好几发才过。</p>
<p>然后我们盯上了两道看上去还算能做的题。一道构造，一道计算几何。</p>
<p>于是我写构造，学长们写计算几何。</p>
<p>最后的结果……那当然是全军覆没。</p>
<p>然后就「坐牢」了（指一题不会但又不能走就只能坐在电脑前面发呆</p>
<p>看了看其他队伍的名字感觉都好有意思啊。</p>
<p>然后我口胡了一下最后一题是个主席树。</p>
<p>这个时候已经 22：30 了于是我就跑路了。</p>
<p>不过有一说一，一到考场就开始犯低级失误，这个毛病真就一点没改。</p>
<p>听学长说至少要切掉三道题才能有个能看一点的排名。那我感觉其实我们快了（心虚</p>
<p>然后一回寝室发现甚至灯都关了。说是因为明天考试所以要早睡。</p>
<blockquote>
<p>我「那你们这么早上床你们睡得着吗？」</p>
<p>FYF「睡不着啊。」</p>
<p>我「那你们这么早上床干啥反正你们又睡不着。」</p>
<p>FYF「啊就但是，万一躺着躺着就睡着了呢？」</p>
</blockquote>
<p>滑稽流汗.gif</p>
<p>然后晚上似乎是有什么大型游戏赛事。然后大概整个男生宿舍楼都在看。</p>
<p>然后大概 1：00 的时候突然整个男生宿舍楼炸开锅开始喊 NB。然后女生宿舍楼那边似乎是派出了一个代表试图把这边的声音怼下去。</p>
<p>场面一度十分混乱.mp4</p>
<blockquote>
<p>？？？「好了好了，比赛结束了，打完了，我们不吵了行吧。睡觉了啊。」</p>
<p>？？？「真是有病的男人。」</p>
</blockquote>
<p>滑稽喝茶.jpg</p>
<h2 id="Day-46"><a href="#Day-46" class="headerlink" title="Day 46"></a>Day 46</h2><p>今天下午似乎有英语考试的样子然而我还几乎，好吧我是说，完全没复习。</p>
<p>了解了一下线性预处理常数查询的 Method of Four Russians。</p>
<p>我看不懂，但我大受震撼.jpg</p>
<p>不过话说回来这个该怎么翻译？四个俄罗斯人的算法？四毛子算法？</p>
<p>英语考试也就那样吧。</p>
<p>也就听力因为有点紧张有几个没听清。其他的都还好。</p>
<p>考完试跑去实验室搞昨天的 M 题。</p>
<p>题意是这样的：</p>
<blockquote>
<p>给定一个长度为 $n$ 的正整数序列 $a$。$m$ 次询问，每次询问给定一个区间 $[l,r]$，将 $a_l$ 到 $a_r$ 这 $r-l+1$ 个数取出来（不影响原序列）构成一个可重集 $S$。定义 $v$ 是好的当且仅当存在 $T\subseteq S$ 使得 $\sum_{x\in T}x=v$。求最小的正整数使得它不是好的。强制在线。</p>
</blockquote>
<p>显然，对于 $S$ 中的一个数 $v$，设区间上严格比它小的所有数之和为 $s(v)$，那么 $v$ 不是好的当且仅当 $s(v)\lt v - 1$。</p>
<p>首先我想到的是二分。</p>
<p>然而今天仔细一想发现一个数是不是好的，这样一个问题不满足单调性。</p>
<p>然后我开始在脑海中回想我毕生所学过的数据结构 trick。</p>
<p>然后我想到一个东西叫做猫树。</p>
<p>对于一个区间 $[L,R]$，我们取这个区间的中点 $M$。然后对于 $i\in[L,M]$，预处理出 $[i,M]$ 上的答案；对于 $i\in(M,R]$，预处理出 $(M,i]$ 上的答案。然后向下分治。</p>
<p>显然任意一个询问区间一定能恰好分解成两个被预处理过的区间的并。</p>
<p>在这一过程中需要维护每个位置对应区间，也就是 $[i,M]$ 或 $(M,i]$ 上所有出现过的且不是好的的数。</p>
<p>询问时，设询问区间上出现过的且不是好的的数中最小的是 $v$，那么答案就是 $s(v)+1$。</p>
<p>假设 $v$ 不是好的，那么下一个不是好的的数显然至少是 $v+2$，再下一个至少是 $2v+4$，再下一个至少是 $4v+8$……也就是说每个区间内至多有 $\log a_i$ 个数不是好的。特别地，如果一个区间上所有出现过的数都是好的，这个区间上的答案就是区间和 $+1$。</p>
<p>而且注意到，两个区间合并时，如果一个数之前在两个区间上都是好的，那么它在新区间上也一定是好的；如果一个数之前至少在一个区间上不是好的，那么它有可能在新区间上是好的。这部分写个主席树暴力 check 即可。</p>
<p>这个区间合并的性质既可以用在分治时扩展区间，也可以用在询问时合并左右区间。</p>
<p>总时间复杂度 $O(n\log n\log a_i)$。</p>
<p>……然而……喜提 TLE。</p>
<p>于是心灰意冷的我开始研究上午看到的另外一个神奇的数据结构搞法——$O(n)-O(1)$ RMQ。</p>
<p>首先假设序列 $a$ 中任意两个相邻数之差均为 $\pm 1$，那么我们可以使用 Method of Four Russians 做到 $O(n)-O(1)$ RMQ。</p>
<p>令块长 $B=\frac{\log n}{2}$，将原序列分成 $\frac{2n}{\log n}$ 个块，然后跑 ST 表。这部分的时间复杂度为</p>
<script type="math/tex; mode=display">O\left(\frac{2n}{\log n}\log\frac{2n}{\log n}\right)=O(n)</script><p>然后考虑边角块。注意到差分不同的块只有 $2^{B-1}$ 种。那么对于每种块，我们预处理出其中所有子区间的最值，然后搞出原序列的每个块都属于哪种块，再结合上述的 ST 表，我们就能做到 $O(1)$ 查询了。</p>
<p>关于对于每种块预处理所有子区间的最值，这部分的时间复杂度为</p>
<script type="math/tex; mode=display">O(2^{B-1}B^2)=O(\sqrt{n}\log^2n)=O(n)</script><p><strong>太 美 妙 了</strong></p>
<p>那么如果对相邻数之差不做保证该怎么做？</p>
<p>笛卡尔树转化成 LCA，然后欧拉序再转化成 RMQ。</p>
<p>然后有人肯定就要跑出来喊「欸你这不是又绕回去了吗！」</p>
<p>实际上真正的欧拉序是能够保证相邻两个点的深度差总是 $\pm 1$ 的。</p>
<p>至于如何实现，我的方法是，DFS 的时候，对于每一条从根指向叶子的边 $(u,v)$，把 $u,v$ 顺次加入欧拉序尾部，然后处理 $v$，处理完之后再把 $v,u$ 顺次加入欧拉序尾部。</p>
<p>但是这样可能会出现两个相同点相邻的情况。于是就在加点的时候特判一下这种情况，保证最终构造出来的欧拉序满足相邻点不同。</p>
<p>不过需要注意的是，我们需要的是点在原序列对应位置的值，而不是这个点的深度。因此我们预处理出的答案不应该是最小值本身，而应该是最小值的位置。当然如果有多个那就任取。</p>
<p>于是我们就得到了一个放之四海皆准的 $O(n)-O(1)$ RMQ 算法。</p>
<p><strong>ス　バ　ラ　シ　イ</strong></p>
<p>然而实现难度……怎么说呢，数组多到我都不会起名了真的。</p>
<p>在学校实验室干了两个小时愣是没干出来。到最后看着 22：30 了如果再不会寝室就回不去了于是只能耻辱跑路。</p>
<p>说实话在寝室写这段文字的时候我突然反应过来我的块的数量忘了 $\times 2$ 了。然后我数组照着 $\frac{n}{\log n}$ 开的。明天回实验室得先把这个改一下。</p>
<p>然后明天学长再次邀请我和另一名学长打练习赛。好家伙这次我一定要努力切掉三道题拿到大铜牌。</p>
<p>什么时候才能拿大奖牌啊 /kel</p>
<p>emmm Day 46 竟然写了这么多吗。</p>
<p>果然 <del>OI</del> ACM 能够充实我的大学生活（光速逃</p>
<p>对了，不出所料地，一回寝室关着灯锁着门。</p>
<p>好家伙一个个的这么早就上床。睡得着吗就上床。到最后不还是躺着发呆还不如写两道数学题明天下午考数学了也不看看自己能考几个分。</p>
<h2 id="Day-47（2021-11-8）"><a href="#Day-47（2021-11-8）" class="headerlink" title="Day 47（2021-11-8）"></a>Day 47（2021-11-8）</h2><p>今天数学考试。</p>
<p>说实话没啥难题。</p>
<p>然后关于练习赛，有一位学长因为有事于是取消了。</p>
<h2 id="Day-48"><a href="#Day-48" class="headerlink" title="Day 48"></a>Day 48</h2><p>上午把买来放在那里搁置了很久的《The Witness》掏出来玩了玩，然后得到了同寝室 dalao 的指点。</p>
<p>下午和学长一起练习沈阳的 ICPC 复现赛。</p>
<p>上来先秒掉一道签到题。</p>
<p>然后找到一道题：给定一个序列，将其分成尽可能多的连续段，使得将每个连续段从小到大排序后，整个序列能够变得单调不降。</p>
<p>经过和学长的一番讨论，我得出了这样一个算法：</p>
<p>对于每个数，处理出如果将整个序列从小到大排序后它会跑到哪个位置。如果有相同的数就保持相对位置不变。</p>
<p>如果 $a_i$ 排序后跑到了 $x_i$，那么 $i$ 和 $x_i$ 及其之间的所有数必须要被分到同一个连续段内。于是问题转化成给定 $n$ 个区间，求它们的并是多少个互不相交的区间。差分一波搞定。</p>
<p>然后学长帮我切掉了一道大模拟题（至少学长们这么说反正我也没看题）。</p>
<p>然后有这么一道题：给定一个序列初值均为 $0$，每次操作给定一个区间，将其上所有 $x$ 变为 $x+1$，或者查询区间最大值。</p>
<p><strong>大！分！块！</strong></p>
<p>好家伙我直接开始写。</p>
<p>然而写完发现我的写法需要对于每个块维护 $m$ 个并查集，这需要 $O(m\sqrt{n})$ 的空间然而这题 $n$ 和 $m$ 都是 $5\times 10^5$ 于是它甚至过不了编译。</p>
<p>:(</p>
<p>然后又有这么一道题：在某个神奇的异世界里，时针转一圈相当于一天，然后一天 $H$ 小时，一小时 $M$ 分钟。问有多少个整分钟满足时针分针所成角度 $\leqslant\alpha$。保证 $\alpha\leqslant\pi$。输入给出 $A$ 使得 $\alpha=\frac{2\pi A}{HM}$。</p>
<p>首先设当前时刻为 $i$ 点 $j$ 分，$0\leqslant i\lt H$，$0\leqslant j\lt M$。这个时候时针相对于零刻度转过的角度为 $\frac{2\pi i}{H}+\frac{2\pi j}{HM}=\frac{2\pi(iM+j)}{HM}$，同理分针为 $\frac{2\pi j}{M}$。因此问题转化为求满足</p>
<script type="math/tex; mode=display">\left|\frac{2\pi(iM+j-jH)}{HM}\right|\leqslant\alpha\vee\left|\frac{2\pi(iM+j-jH)}{HM}\right|\geqslant 2\pi-\alpha</script><p>也即</p>
<script type="math/tex; mode=display">|iM+(1-H)j|\leqslant A\vee|iM+(1-H)j|\geqslant HM-A</script><p>的二元组 $(i,j)$ 的数量。</p>
<p>显然我们可以将其转化成</p>
<script type="math/tex; mode=display">\begin{cases}
&j\geqslant\frac{iM-A}{H-1}\\
&j\leqslant\frac{iM+A}{H-1}\\
\end{cases}</script><script type="math/tex; mode=display">\begin{cases}
&j\leqslant\frac{iM-(HM-A)}{H-1}\\
&j\geqslant\frac{iM+(HM-A)}{H-1}\\
\end{cases}</script><p>这两个不等式组解集的并集。</p>
<p>于是考虑使用类欧几里得算法求解。</p>
<p>然而值得注意的是，我们还需要手动过滤掉 $j\geqslant M$ 的情况。</p>
<p>然而写了一个小时硬是没写出来。</p>
<p>到最后四个半小时就写出来三题。怕不是又要打铁。</p>
<h2 id="Day-49"><a href="#Day-49" class="headerlink" title="Day 49"></a>Day 49</h2><p>下午整个寝室跑到外面去逛商场，然后顺便叫上了隔壁寝室的 HTL 和 MSB 两位 dalao。</p>
<p>虽然真的只是去逛然后什么都没买就回来了。</p>
<p>好家伙走得我腿要断了。</p>
<h2 id="Day-50"><a href="#Day-50" class="headerlink" title="Day 50"></a>Day 50</h2><p>qwq</p>
<h2 id="Day-51"><a href="#Day-51" class="headerlink" title="Day 51"></a>Day 51</h2><p>深夜一边装 TeX Live 一边水群。</p>
<blockquote>
<p>19 级某学长「未定义行为（undefined behavior, ub）的意思是，无论编译器怎么实现，都是认为合理的。」</p>
<p>还是上面那位学长「我常举的例子是，即使你的编译器打印出一个变形金刚也是合理的。」</p>
</blockquote>
<h2 id="Day-52"><a href="#Day-52" class="headerlink" title="Day 52"></a>Day 52</h2><p>qwq</p>
<h2 id="Day-53"><a href="#Day-53" class="headerlink" title="Day 53"></a>Day 53</h2><p>qwq</p>
<h2 id="Day-54（2021-11-15）"><a href="#Day-54（2021-11-15）" class="headerlink" title="Day 54（2021-11-15）"></a>Day 54（2021-11-15）</h2><p>emmm 怎么说呢前面好几天只有一个 qwq 然后什么内容都没有主要是因为成天打游戏然后没什么好记录的然后就只能这样了。</p>
<p>今天查了一下期中考试的英语成绩然后发现是 82，然后全班最高分 92。海星吧可以接受。</p>
<h2 id="Day-55"><a href="#Day-55" class="headerlink" title="Day 55"></a>Day 55</h2><p>qwq</p>
<h2 id="Day-56"><a href="#Day-56" class="headerlink" title="Day 56"></a>Day 56</h2><p>qwq</p>
<h2 id="Day-57"><a href="#Day-57" class="headerlink" title="Day 57"></a>Day 57</h2><p>qwq</p>
<h2 id="Day-58"><a href="#Day-58" class="headerlink" title="Day 58"></a>Day 58</h2><p>qaq 感觉自己又混了四天啊。</p>
<p>看到旁边的 dalao 在写找出 $100$ 以内的所有质数的程序。</p>
<p>结果他直接整了个这个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span> || i == <span class="number">3</span> || i == <span class="number">5</span> || i == <span class="number">7</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span> || i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span> || i % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码是我自己的码风</span></span><br><span class="line"><span class="comment">// 显然那位 dalao 不会刚学 C 语言就知道打空格而且我这是 C++ 的语法（指在 for 循环里定义变量）</span></span><br></pre></td></tr></table></figure>
<p>emmm 虽然做法挺离谱但显然这是正确的。</p>
<p>于是在旁边围观的我提出了一种全新的质数筛法：</p>
<p>如果我们需要找出 $N$ 以内的所有质数，我们只需要先找出 $\sqrt{N}$ 以内的所有质数，然后对于每个数，判断一下它是否能被 $\sqrt{N}$ 以内的质数整除即可。</p>
<p>那么我们发现这样做的时间复杂度是 $O(N\sqrt{N}+\cdots)$……</p>
<p>……笑容逐渐凝固.jpg</p>
<p>我还不如去写个欧拉筛（</p>
<p>晚上数学习题课。</p>
<blockquote>
<p>老师「不会真的没人考满分吧？」</p>
<p>老师「你看这题都不用动脑子，脑子放宿舍都能考。」</p>
</blockquote>
<h2 id="Day-59"><a href="#Day-59" class="headerlink" title="Day 59"></a>Day 59</h2><p>今天似乎又运动会。那当然是不看。</p>
<p>整个下午缩在实验室敲代码。</p>
<p>进门前听到实验室里传出来激烈的敲打键盘的声音，然后以为学长在攻克难题。</p>
<p>结果推门进去一看发现是在打游戏。</p>
<p>晚上和学长练习 21 年 CCPC 桂林赛。</p>
<p>首先切掉 A 签到。</p>
<p>然后我搞出来一个贪心匹配的题。</p>
<p>然后有一道买边删边的题，题意有点复杂就算了。</p>
<p>然后我想出来一个找最小环的搞法，然而写了老半天然后 T 掉了。</p>
<p>然后旁边一位学长接过去接了个 Dij 然后过了。</p>
<p>然后有个题是，给定一个序列，保证是一个排列，每次交换一个逆序对，在 $\frac{n(n-1)}{2}$ 次操作内将原序列从小到大排好序。然后另一位学长直接给写好了。</p>
<p>然后我盯上了一道串串题：给定一个字符串，多次询问严格第 $k$ 小字串最靠左的出现位置。</p>
<p>然后我发现我 SA 忘了怎么写了然后学长给提供的板子用不惯于是翻了翻自己的 Blog。</p>
<p>这个时候已经 22：00 了。然后寝室 23：00 很有可能会关门。</p>
<p>结果我 SA 都建好了但是找第 $k$ 小的部分怎么写怎么不对劲。</p>
<p>就是说思路是有的但是代码不知道怎么回事敲不出来。</p>
<p>最后 22：50 不得不耻辱下机。</p>
<p>好家伙这么简单的题才切了四道怕不是又要打铁。</p>
<p>什么时候才能拿（除了铁牌以外的）大奖牌啊 /kel</p>
<p>对了想怎么写最小环的时候我翻了翻学长的某个两百多页的打板子然后发现<strong>没有</strong>。</p>
<blockquote>
<p>学长「你看我就说，别看这个板子看着挺全，真正要用的时候上面就没有。」</p>
</blockquote>
<h2 id="Day-60"><a href="#Day-60" class="headerlink" title="Day 60"></a>Day 60</h2><p>晚上玩了玩 Hades，结果弓二随便配祝福然后简简单单四连胜。</p>
<p>然后点了三级的极端措施结果被 3 BOSS 打成筛子（</p>
<p>好吧其实二见就通了。这下肯定得先打牛了不然场面太乱受不了。</p>
<p>这么一比没有极端措施加成的哈迪斯就太菜了。</p>
<p>有一说一，感觉满级弓二本身已经能乱杀了。再配点加攻击的祝福或者是「箭如雨下」「透甲排箭」「致命齐射」这样的附魔直接无敌。</p>
<p>哦对了宙斯的某个特殊攻击命中时打雷的祝福也可以考虑安排上。</p>
<p>把塔纳托斯给的纪念品升到满级了。每无伤一个房间 +2% 攻击。</p>
<p>然后把这个数值堆到 30% 以后：你（3 BOSS 国王）和你那徒有其表的战车令我感到可笑。</p>
<p>有一说一实在是太强了。四五个连招下去把牛打进二阶段，再四五个连招下去直接带走。</p>
<h2 id="Day-61（2021-11-22）"><a href="#Day-61（2021-11-22）" class="headerlink" title="Day 61（2021-11-22）"></a>Day 61（2021-11-22）</h2><p>今天通过新生赛选拔出来的 21 级新生可以去实验室了。</p>
<p>然而我只有下午三四节没有课于是一下第二节就冲去实验室了。</p>
<p>然后 17：35 有 CF。</p>
<p>然而我晚上还有课，不过还好是 C 语言的上机实验课，于是直接翘掉。</p>
<p>A 题五分钟搞完。还算可以。</p>
<p>结果 B 题构造连着暴毙了三次。然后才发现是最开始判断无解的时候漏了一种情况。</p>
<p>C 题二分又调了一辈子。</p>
<p>然后 D 题经过我大胆猜想成功一发通过。</p>
<p>于是目前为止喜提四题。</p>
<p><strong>翻 身 农 奴 把 歌 唱</strong>（指 CF 终于可以上分了</p>
<p>然后剩下三题全都不会了。</p>
<p>最后 Rank 1100+，海星吧我觉得。</p>
<p>最后趁着剩下的半个小时写了写 E 题虽然并没有过。</p>
<p><del>我是不会说晚上被带着极端措施加成的哈迪斯干烂了的。</del></p>
<p><del>不是但是为什么他攻击频率这么高啊。</del></p>
<h2 id="Day-62"><a href="#Day-62" class="headerlink" title="Day 62"></a>Day 62</h2><p>结果今天一上 CF 发现掉了 8 分。</p>
<p>:(</p>
<p>貧相な　心の　持ち主たちは</p>
<p>淘汰されてしまう　世界なんだよ♪</p>
<h2 id="Day-63"><a href="#Day-63" class="headerlink" title="Day 63"></a>Day 63</h2><p>本来今天下午会有一场训练赛。</p>
<p>然而和我组队的两位学长都有事于是只剩下我一个人了。</p>
<p>然后因为今天用的是今年威海 CCPC 的题然后 pdf 文件周一的时候就被扔到群里了于是我已经看过题了。</p>
<p>我的个人印象大概是这样的：</p>
<ol>
<li>AG：简单题。</li>
<li>I：劲爆数论。但是不会。</li>
<li>M：劲爆概率论。但是也不会。</li>
<li>其他题更不会了。</li>
</ol>
<p>中午比赛刚开始的时候正好我外卖刚到于是正在吃。</p>
<p>然后 1h 切掉 AJD 三题然后坐牢了。</p>
<p>于是向学长要了一份题解。</p>
<p>结果发现 G 题竟然是一个根号 trick。好家伙我竟然在根号题上栽跟头了。</p>
<p><strong>身 败 名 裂</strong></p>
<p>然后 H 题竟然是最小割。我一直以为是个神仙树形 DP。</p>
<p>阿烜因为有两位神仙带他于是拿了大金牌。但是没有人带我啊。</p>
<p>我也想要大金牌 /kk</p>
<h2 id="Day-64"><a href="#Day-64" class="headerlink" title="Day 64"></a>Day 64</h2><p>突然发现周日上午有第一节军事理论。</p>
<p>然而我要打比赛啊（光速逃</p>
<p>晚上继续玩 Hades。然后这次超常发挥把蝴蝶的伤害加成堆到了 40%。</p>
<p>结果栽在老爹手上了。</p>
<p>:(</p>
<p>好吧一定是我不在状态了。</p>
<h2 id="Day-65"><a href="#Day-65" class="headerlink" title="Day 65"></a>Day 65</h2><p>上午一直想着要去找辅导员请假。然而到最后拖到吃午饭也没能付诸行动。</p>
<blockquote>
<p>WWJ「不要害怕。」</p>
<p>我「（害怕」</p>
</blockquote>
<p>然后正打算去上乒乓球结果辅导员突然叫我去座谈。</p>
<p>本来我还以为是什么严重的事结果就是一个关于心理健康状况的抽查然后我被选中了。</p>
<p>好家伙，我直接好家伙。</p>
<p>于是假条 get√（</p>
<h2 id="Day-66"><a href="#Day-66" class="headerlink" title="Day 66"></a>Day 66</h2><p>今天班级组织秋游。于是翘了跑去打上海 ICPC 的热身赛。</p>
<p>然后只有我和其中一位学长。另一位今天下午有课于是没能来。</p>
<p>跑到隔壁新校区然后见识到了什么是真正的大学。</p>
<p>跑去那边的 ACM 实验室然后见识到了什么是真正的实验室。</p>
<p><del>不像某地下室。</del></p>
<p>13：00 开始。</p>
<p>A 题给定 $n$ 个点 $(i,y_i)$，再加上 $(0, 0),(n+1,0)$ 一共 $n+2$ 个点。删去恰好两个点，然后相邻点连线，要求最小化最后得到的这条直线的长度。$2\leqslant n\leqslant 2\times 10^5$。</p>
<p>显然如果删去两个点，那么这两个点要么相邻，要么不相邻。于是预处理一下单独删去第 $i$ 个点和同时删去第 $i$ 和 $i+1$ 个点对答案产生的贡献，然后贪心选贡献最小的。</p>
<p>需要注意的是这里选单独贡献的时候要保证选的两个点不相邻。</p>
<p><del>结果因为把最小化读成最大化 WA 了两发。</del></p>
<p>B 题是给定一个 $n\times m$ 的矩阵 $a$，由 $a_{i,j}=r_i\times c_j$ 构造。想象一个 $n\times m$ 的方格，时刻 $0$ 没有杂草，从时刻 $1$ 开始每个时刻开始时第 $i$ 行第 $j$ 列长出 $a_{i,j}$ 棵杂草。$q$ 次操作，每次操作选择一个时刻，在这个时刻结束时割掉一行或者一列的杂草，割完以后这一行或一列的杂草数量归 $0$。所有询问的时刻严格递增。求所有操作割掉的杂草总量模 $10^9+7$。$1\leqslant n,m,q\leqslant 10^5$。</p>
<p>显然对于每一个格子，我们只需要关注最后一次割到它的操作即可。于是我们从后往前处理，每遇到一个操作，计算它的贡献，然后删去它影响的这一行或一列。</p>
<p>C 题给定二维平面上 $n$ 个点，保证 $4\mid n$，没有重点，没有三点共线。要求给出两条不重合的相交直线，将整个平面分成四部分，且每部分恰好有 $\frac{n}{4}$ 个点。这两条直线均不能经过 $n$ 个给出的点中的任意一个。无解输出 $-1$。$4\leqslant n\leqslant 5\times 10^4$，$\sum n\leqslant 10^5$，$|x_i|,|y_i|\leqslant 10^6$；使用两点式给出直线，且这两点横纵坐标绝对值不能超过 $10^9$。</p>
<p>emmm 好吧其实这道题我们没有切掉。</p>
<p>首先我们有一个想法是，求出这 $n$ 个点的「中位点」，也就是，横坐标是所有点横坐标中位数，且纵坐标同理的点。那么这两条直线一定交于这个中位点。</p>
<p>于是把所有点根据这个点求个极角排个序。</p>
<p>假设其中一条直线要穿过第 $k$ 个点和第 $k+1$ 个点之间的线段，这条直线也一定要穿过第 $k+\frac{n}{2}$ 个点和第 $k+\frac{n}{2}+1$ 个点之间的线段。我们可以容易地判断出这条直线是否存在。</p>
<p>同理，同样需要有一根直线穿过第 $k+\frac{n}{4}$ 个点和第 $k+\frac{n}{4}+1$ 个点之间的线段以及第 $k+\frac{3n}{4}$ 个点和第 $k+\frac{3n}{4}+1$ 个点之间的线段。</p>
<p>但是注意到这样求出来的直线很有可能并不经过任何整点。但是我们可以考虑选取这条直线上坐标绝对值足够大但是仍在题目要求范围内的两个点，然后在它们附近分别随便找一个整点代替。因为坐标绝对值足够大，这样的近似可以被认为是正确的。</p>
<p>结果喜提 WA。</p>
<p>:(</p>
<p>顺便，作为纪念，保留了热身赛的试题册。</p>
<h2 id="Day-67"><a href="#Day-67" class="headerlink" title="Day 67"></a>Day 67</h2><p>今天就是正式比赛了。</p>
<p>至于打得怎么样……emmm 一个小时切掉包括签到题在内的两道题，然后剩下两个小时调第三题。最后两个小时坐牢。</p>
<p>:(</p>
<p>怎么办啊为什么阿烜就有大金牌我就没有啊。</p>
<p>于是我下定决心开始刷思维题。</p>
<p><a href="https://www.luogu.com.cn/training/3961#problems">迪屁了解一下</a></p>
<h2 id="Day-68（2021-11-29）"><a href="#Day-68（2021-11-29）" class="headerlink" title="Day 68（2021-11-29）"></a>Day 68（2021-11-29）</h2><p>平静的一天。</p>
<h2 id="Day-69"><a href="#Day-69" class="headerlink" title="Day 69"></a>Day 69</h2><p>平静的一天。</p>
<h2 id="Day-70"><a href="#Day-70" class="headerlink" title="Day 70"></a>Day 70</h2><p>Challestend はただ静かに暮らしていた。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hades</title>
    <url>/hades/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1145360/Hades/">Steam 页面</a></p>
<a id="more"></a>
<p>买了有一段时间的游戏了。</p>
<p>最近因为换了新电脑，捡起来又玩了玩。</p>
<p>然后玩累了放了半个多月，然后又捡起来了。</p>
<p>头铁不开作弊模式。然后前天终于通关了。</p>
<p><img src="/img/20210912175705_1.jpg" alt="结算画面（话说清场是指 clear……？"></p>
<p>关于为什么拿了厄里斯形态又拿人体炸弹，这个是因为升级厄里斯形态的时候我还遇到过人体炸弹。但是人体炸弹太好用了。</p>
<p>有一说一应该是这把大炮太好用了。打 3 BOSS 的时候我直接一边绕著而走一边用特殊攻击打，直接把他俩苟死了。打得那叫一个厚颜无耻，那叫一个卑鄙下流，怕不是观众都得跳下来揍主角一顿。这也配自称英雄吗。</p>
<p>整个游戏的话，给人的第一印象大概会是「文本量好大」吧。每次遇到每个 BOSS，每个友好 NPC 都会有不同的对话，粗略估计一百个小时见不着重样的。（虽然我游戏时间也才二十多个小时）</p>
<p>然后就是，按键频率太高了。键盘大概没法玩吧虽然我也没试过。用手柄玩，连着玩上两三把就能把我右手大拇指快累断了。</p>
<p>不过也可能是我太菜了吧。毕竟我一直是闭着眼睛 ABXY 四个键瞎 jb 按。</p>
<p>操作逐渐失去理性.jpg</p>
<p>还有就是，这游戏的关键资源竟然每一关每种武器只能拿一次，想拿第二次就必须要加难度。这也太去世了。这游戏真换成近战武器怕不是没法玩。毕竟近身打就意味着会挨打。</p>
<p>听说这游戏可以用来当作第一款 Rogue 游戏来玩。表示怀疑。</p>
<p>不过给永久升级还是很好的。不过凭这游戏的难度不给永久升级怕不是逼人开作弊了。</p>
<p>话又说回来了（指强行扯开话题），最近把 Slay 下回来玩了玩又卸了。之前从创意工坊下了下乱七八糟的 mod 解锁了很多乱七八糟的成就，像是一回合打死 BOSS 啥的。看着这些成就莫名其妙觉得难受于是就卸了。</p>
<p>不过我还是很好奇一回合打死 BOSS 这像是人干得出来的事吗。</p>
<p>弱者为何要战斗.jpg</p>
<p>不过话说回来，我居然发现 Markdown 里被用单对波浪线包括的内容会以下标的形式显示。~就像这样。~然后我就发现上传上去就不行了，也许是 VS Code 的某种神奇的 feature 吧。</p>
<p><img src="/img/20210912175920_1.jpg" alt="刚刚从地底下爬出来的冥界王子第一次看到太阳（Undertale 既视感"></p>
<p><img src="/img/20210912175957_1.jpg" alt="阳间的希腊风景"></p>
<p>话说回来，竟然连阴间也是要送礼的。这个世界怎么了.jpg</p>
<p>写了这么久才 800+ 字，10 分钟不到就能读完。为什么凑字数这么难啊。</p>
<p>不过话说回来，我 VS Code 内部的字数统计显示已经 1300+ 了。很神奇.jpg</p>
<p>话说回来，我这是用了多少遍「话说回来」了啊。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>Rogue</tag>
        <tag>希腊神话背景</tag>
        <tag>剧情丰富</tag>
        <tag>肝</tag>
      </tags>
  </entry>
  <entry>
    <title>熔铁少女</title>
    <url>/marufusha/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1456820/_/">Steam 页面</a></p>
<p>之前这里有一些文字，但是处于某些原因我还是删去了。</p>
<a id="more"></a>
<p>之前不知道什么时候逛 Steam 看到的游戏。</p>
<p>昨天刚刚发售。于是来玩了。</p>
<p>像素风横板的快节奏射击游戏。至少官方这么说。</p>
<blockquote>
<p>为了能够应对越来越棘手的强敌，你需要用扣除税金后杯水车薪的报酬来购买卡片，强化角色。</p>
</blockquote>
<p>有一说一这税金收的是真的屑。最后 20 天敌人都攻进宿舍了还搁着照收不误。</p>
<p>以下是系统简介。</p>
<p>每天的工资扣去税金只能剩下个位数。</p>
<p>结算完工资后会随机三个升级项目可以购买。包括但不限于获得新武器，提升属性，雇佣同伴。</p>
<p>除了默认的武器以外，所有武器有耐久度，用完就废了。</p>
<p>提升属性时如果对应属性已经加满就转而获得一块钱。</p>
<p>同时只能雇佣一个同伴。重复雇佣可以升级。</p>
<p>最后雇佣的同伴不同，BAD ENDING 也会不同。</p>
<p>GOOD ENDING 都一样。</p>
<p>但是我必须大声喊一句没一个好结局！！！！！！！！！！！！</p>
<p><del>qaq 多可爱的女孩子啊就这么杀了您不心痛吗。</del></p>
<p><del>欸话说回来，有考虑加入 18+ 内容吗。</del></p>
<p><del>您看看前线的这些士兵们每天过的多枯燥啊为什么不来一点娱乐项目呢（光速逃</del></p>
<p>总而言之，一款挺无聊的无脑突突突的游戏。</p>
<p>刷成就刷了一个下午，还剩下最后一个不雇佣任何同伴通关的成就。有点难先放放。</p>
<p>（↑说得好像你还会把这游戏捡起来一样）</p>
<p>不是很推荐。但如果您问我这游戏值不值这个价，我评论不了。</p>
<p>那么最后，菲莉塞特 yyds。</p>
<p><img src="/img/QQ截图20210827213656.png" alt="チラッ（"></p>
<p>顺便附上一个<a href="https://www.bilibili.com/video/BV1ty4y1G7jn">（疑似正在更新中的）全结局收集</a>。</p>
<p>翻评测的时候看到一条觉得说的挺不错的。</p>
<p>原文：</p>
<blockquote>
<p>「何一つ残らないゲー無」と低評価入れようかと思いましたが…逆に言えばそれだけこの短い時間でキャラクター達に感情移入させられたということです。</p>
<p>そしてその濃密な短時間を生み出したのは細部まで作りこまれた世界観がなせる技なのだと思います。</p>
<p>できれば彼女達の笑って過ごす未来がみたかったですが溶鉄のマルフーシャとはそういう残酷な世界なのでしょう…</p>
</blockquote>
<p>大意：</p>
<blockquote>
<p>「到头来一无所剩的游戏」，本来是想像这样给出低评价的……但是反过来想的话，这也是一款能在如此短暂的游戏时长内让玩家对角色倾入感情的游戏啊。</p>
<p>（第二句话说实话不是很懂）</p>
<p>可以的话想看到她们笑着度过的未来，但是熔铁少女就是这样一个残酷的世界吧……</p>
</blockquote>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>像素</tag>
        <tag>少女</tag>
        <tag>反乌托邦世界观</tag>
        <tag>刀</tag>
      </tags>
  </entry>
  <entry>
    <title>简单随笔</title>
    <url>/how-am-i-doing/</url>
    <content><![CDATA[<p>还有不到一个月我就要去大学报道了（悲</p>
<p>快乐无比的暑假生活马上就要迎来结局了。</p>
<p><del>这让我失去了 决心。</del></p>
<p><del>喂，这前面可是地狱啊！</del></p>
<a id="more"></a>
<h2 id="颓废"><a href="#颓废" class="headerlink" title="颓废"></a>颓废</h2><p>回想一下，发现这两个月什么都没干。</p>
<p>想过要写点东西然而写了半个小时就写不下去了。</p>
<p>可能我并不适合创作吧。</p>
<p>脑海中会不时地浮现出一些片段，然而没有办法缝合起来。</p>
<h2 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h2><p>最近换了一台电脑。比之前那台配置好了不少。当然也贵了不少。</p>
<p>试着重新捡起《废墟图书馆》玩了玩，发现不卡了。</p>
<p>从头开始玩发现，认真玩的话前期还是不算太难的。</p>
<p>然后现在卡在殷红迷雾了。有一说一卡莉强到不讲道理了。</p>
<p>比如说某张杀死目标或令目标陷入混乱就再次重新打出的书页。</p>
<p>第一次看我还觉得这个触发条件太严格了，直到有一次我五个司书被这玩意一网打尽。</p>
<p><del>Geburah「这 TM 是啥？」</del></p>
<p>近期可能会写一篇相关的 blog。</p>
<p>但是也可能就鸽了。没人看感觉写的动力不大。</p>
<h2 id="VTB"><a href="#VTB" class="headerlink" title="VTB"></a>VTB</h2><p>然后最近又在 Steam 上找到一个 VTB 模拟器。</p>
<p>想着当成是个 2D 捏人游戏于是买了。</p>
<p>虽然可能的选项非常少，但是捏出来看久了还觉得挺可爱？</p>
<p>游戏性的话就那样吧。不专门安利了。</p>
<p>把捏出来的成果放一下吧：</p>
<p><img src="\img\20210816111128_1.jpg" alt="随便写点啥"></p>
<p>名字叫「<ruby>夢宮<rt>むきゅう</rt></ruby>　きりこ」，「きりこ」写成汉字的话是「雾子」。</p>
<h2 id="Steam-愿望单"><a href="#Steam-愿望单" class="headerlink" title="Steam 愿望单"></a>Steam 愿望单</h2><p>当然最近也在 Steam 上看到了其他比较想玩的。</p>
<p>比如说大逆终于上 Steam 了。</p>
<p>比如说既然换了个好电脑想玩玩莱莎的炼金工房。</p>
<p>然后现在在等打折。</p>
<h2 id="OI-出题"><a href="#OI-出题" class="headerlink" title="OI 出题"></a>OI 出题</h2><p>就算是现在还是想出一些题的。</p>
<p>翻了翻之前记录下来的题，发现很多都很有意思。</p>
<p>然而我当时一直在想新题就忽视了这些有意思的老题了。</p>
<p>现在新的 idea 有些少了，想着要不要把这些老题翻出来解一解。</p>
<p>但是还是没什么动力。</p>
<p>虽然就现在我是没什么举行正式比赛的可能性了，但是还是不想公开这些题。</p>
<p>不过说起正式比赛，之前 CrOI 第一次正式比赛几乎已经配置好了。然而最后还是弃掉了。</p>
<p>现在就算再扔出来也不会有人做了吧。毕竟我自己都不写 OI 了。</p>
<p>阿块现在毕竟高四肯定没时间。其他人一提起分块就告辞。</p>
<p>说不定这样下去这些题就要发霉了。要不要干脆公开了算了？</p>
<p>这些题里面有一看就不能做的，有看上去能做但我没细想的，也有一看就很简单的。</p>
<p>总之是各种各样乱七八糟的 idea 糅合在一起。甚至还有我做梦梦到的。</p>
<h2 id="补充-I"><a href="#补充-I" class="headerlink" title="补充 I"></a>补充 I</h2><p>阳的主题曲好好听啊。</p>
<blockquote>
<p>Children of the city see only the neon stars</p>
<p>Reflected on the murky gutter sky</p>
<p>Don’t ask me why I desperately wish to be included in the city’s night</p>
<p>致 Challestend：</p>
<p>在北京时间公元 2021 年 9 月 12 日 00：00 之前写完《逆转潮流》的剧本。</p>
</blockquote>
<h2 id="补充-II"><a href="#补充-II" class="headerlink" title="补充 II"></a>补充 II</h2><p>邵好强啊。</p>
<h2 id="补充-III"><a href="#补充-III" class="headerlink" title="补充 III"></a>补充 III</h2><p>打过殷红迷雾了。</p>
<p>但说实话我也很迷，打着打着不知道什么时候给对面打晕了。</p>
<p>这场战斗让我明白了人海战术的重要性。</p>
<p><del>然后把迷雾的书烧到剩最后一本被泪滴抢了（悲</del></p>
<p>第二次用两层把迷雾削成残血然后 Geburah 一张「血舞弥漫」带走了。还解锁一个成就。</p>
<p>然后去打泪滴。<del>这么说好像最后一击好像也是「血舞弥漫」。</del></p>
<p><del>一本书里面塞了十几张战斗书页，不愧是您。</del></p>
<h2 id="补充-IV"><a href="#补充-IV" class="headerlink" title="补充 IV"></a>补充 IV</h2><p>查了一下自己在 Steam 上的总消费金额，发现竟然有 $956.76。</p>
<p>也就是人民币 6196.11 元。</p>
<p>我看懂了，而且我大受震撼.jpg</p>
<h2 id="补充-V"><a href="#补充-V" class="headerlink" title="补充 V"></a>补充 V</h2><p>邵好强啊。</p>
<h2 id="补充-VI"><a href="#补充-VI" class="headerlink" title="补充 VI"></a>补充 VI</h2><p>干了一下午六协。</p>
<p>突然注意到我语言层和哲学层还没完全解放，没有 E.G.O. 书页，总体强度不比艺术层大多少。</p>
<p>于是去打异想体。</p>
<p>自然层解放战最终阶段什么乱七八糟一堆玩意，直接上去照脸揍不就行了整的什么花里胡哨的。</p>
<p>语言层解放战让我切实明白了「最强之人」是什么意思。</p>
<p>E.G.O. 展现 + 血雾 + 强壮一共 14+ 的骰子点数加成我就问您怕不怕。反正我是怕了。</p>
<h2 id="补充-VII"><a href="#补充-VII" class="headerlink" title="补充 VII"></a>补充 VII</h2><p>打过邵了。</p>
<p><del>我太牛逼了，哈哈！</del></p>
<p>战术的话，首先用哲学层抽烟耗血<del>，虽然整个哲学层就算全灭了邵还剩 600+ 血</del>。</p>
<p>然后换语言层战神组合刚。</p>
<p>但是并没有什么效果。反而是这边被耗到残血了。</p>
<p>还死了一位助理司书。</p>
<p>然后异想体出尸山了。</p>
<p>我当机立断地把剩下三位助理司书喂给 Geburah，照着邵的逆鳞骰子一刀给她砍晕了。</p>
<p>然后下一幕直接砍死了。</p>
<p><del>我太牛逼了，哈哈！</del></p>
<p>杂质的第一战要求 rnfmabj，泪滴和邵的书。</p>
<p><del>然而我都没有。</del></p>
<p>烧三本烧不出东西于是一咬牙把第四本也给烧了。</p>
<p>当一位废墟图书馆玩家试图从书籍中获取知识时.jpg</p>
<h2 id="补充-VIII"><a href="#补充-VIII" class="headerlink" title="补充 VIII"></a>补充 VIII</h2><p>刚知道怎么打邵。</p>
<p>原来逆鳞骰子不是一直不能打。</p>
<p>威力有效的回合是可以打的，这样她下一回合就算叠强壮也没有用会被无效化掉。</p>
<p><del>原来如此这就是为什么我这么菜吗。</del></p>
<h2 id="补充-IX"><a href="#补充-IX" class="headerlink" title="补充 IX"></a>补充 IX</h2><p>因为昨天晚上熬夜打 Hana 协会，早上起来已经 11 点了。</p>
<p><del>看了一会儿沙雕视频，</del>总之是到了 12 点。</p>
<p>一开电脑发现有一位不认识的 dalao 评论了我的 Blog。</p>
<p>妈耶现在我的 Blog 真的输出到信息组以外了吗。</p>
<p><del>不对其实可能早就输出出去了。</del></p>
<p>dalao 给捉了一只虫。那么好的已经修复 √</p>
<p>话说回来，虽然写的时候因为想着是随便写可能没怎么用心，</p>
<p>被别人看到的话还是会想「我写的足够好了吗」。</p>
<p><del>要知道那篇可是全程口胡一行代码都没有的。</del></p>
<p>突然反应过来，我搁着 QQ 聊天呢一句话分一段。</p>
<h2 id="补充-X"><a href="#补充-X" class="headerlink" title="补充 X"></a>补充 X</h2><p>一早上<del>（指 13 点）</del>起来发现百橙有新活动了。</p>
<p>是一个新的世界 BOSS。</p>
<p>500W 血的精污游泳圈聚合体（</p>
<p>剧情的话就是兔萌萌拉着由希教自己游泳然后魅樱追上去造了一个巨大怪物给她们打。</p>
<p><del>兔萌萌「您就不会点别的了是吗？」</del></p>
<p>其实还有凯在呢。</p>
<p>不像其他 BOSS，这个 BOSS 不会在地图上乱逛。</p>
<p>但是它生成小怪会扣自己血<del>，说不定真就是从自己身上扯下来的</del>。</p>
<h2 id="补充-XI"><a href="#补充-XI" class="headerlink" title="补充 XI"></a>补充 XI</h2><p>试着打了 Codeforces Round #741 (Div. 2)。</p>
<p>本来想在群里拉几个人开黑的，结果没有拉到人。</p>
<p>用了近 50 分钟才切掉三道题，然后弃疗了。</p>
<p>其实也没完全弃疗，最后 15 min 想出了 D 题的解法的雏形。</p>
<p>虽然其实就差了那么一两步。</p>
<p>但是还是没赶上。</p>
<p>最后一个 FST 都没有。于是取得了三题的好成绩。</p>
<p>排名 1919，最后 Rating 掉了 40。</p>
<p>虽然其实我觉得早就该掉了。毕竟我现在这个 Rating 是开黑开出来的。</p>
<p>Steam 愿望单里有游戏发售了。《熔铁少女》。23 点多给我发了封邮件然而没看到。</p>
<p>明天玩玩。</p>
<p><del>虽然还只是看了几张截图但是阿莉比娜 suki（光速逃</del></p>
<p><del>（↑无可救药的 lsp）</del></p>
<h2 id="补充-XII"><a href="#补充-XII" class="headerlink" title="补充 XII"></a>补充 XII</h2><p>话说回来，信息组里面好像军训完了的都有。然后我甚至还在暑假模式。阿稳好像也是。</p>
<blockquote>
<p>zhuoer「我现在已经不会走路了。」</p>
<p>阿陶「开学几天你就会再次学会走路的。」</p>
</blockquote>
<p>害怕（大一新生限定）.jpg</p>
<p>原来如此，VS Code 内部的字数统计把空格标点符号甚至换行符都给算进去了。</p>
<h2 id="补充-XIII"><a href="#补充-XIII" class="headerlink" title="补充 XIII"></a>补充 XIII</h2><p>在 B 站找到了写图书馆 mod 用的 dll 的教程。</p>
<p>然后发现我甚至残响乐团还没打。于是去打。</p>
<p>累到半死才打过菲利普和艾琳。</p>
<p>才发现残响乐团也会掉书页。</p>
<p>不过话说回来，我哲学层和宗教层还没解放……应该没啥问题吧……</p>
<p>至少我不想再把这些 BOSS 打一遍了。</p>
<p>话说回来格蕾塔一上来就在面前摆上三大块肉啊该说果然是主厨吗（</p>
<p>开饭.jpg</p>
<p>话说回来，司书在图书馆内死去的话应该是会变成书而不会留下尸体的。四舍五入一下就是她在吃书（不是</p>
<p>大肉之书.jpg</p>
<h2 id="Finn"><a href="#Finn" class="headerlink" title="Finn"></a>Finn</h2><p><del>其实标题是个人名。</del></p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>弹幕结界：红色禁果</title>
    <url>/red-forbidden-fruit/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1388230/DANMAKAI_Red_Forbidden_Fruit/">Steam 页面</a></p>
<font color=#DD0000><ruby>志<rt>ココロザシ</rt></ruby>ナカバニテ<ruby>死<rt>シ</rt>ス</ruby></font>

<a id="more"></a>
<p><br>闲着没事逛 Steam 发现的 STG。</p>
<p>是原来某个叫做《星天歌：魔界的日常》的游戏的续作。虽然前作我只是云过，是个风格类似东方旧作的类东方 STG。</p>
<p>上 B 站看了一下，然而只能找到<a href="https://www.bilibili.com/video/BV1zr4y1c7g7">一个 20 年的视频</a>。然而我明确地记得我第一次了解到这个游戏是只有我和阿块去了的一轮省队集训，也就是 19 年左右。</p>
<p>不是很懂.jpg</p>
<p>说一下系统。</p>
<p>击破敌人掉绿宝石，可以 +1 火力，收集很多可以奖残。</p>
<p>每 400 绿宝石奖一残。3200 绿宝石，也就是 8 个奖残之后改为 800 绿宝石奖一残。</p>
<p>一般混关应该可以拿到 4800 的奖残，也就第是 11 个。加上三面道中的一个 Extend 和初始的残机，一共 14 残。<del>别看这么多一会就撞没了。</del></p>
<p>擦弹掉红宝石而且自动吸取，只能 +1 火力。</p>
<p>火力分 1~4 的等级。等级 2 以上时可以按 X 清空火力槽扔雷。</p>
<p>用雷消去的弹幕会变成白宝石，可以增加收集绿宝石时的得分。</p>
<p>没有上线回收。</p>
<p>总体来讲，糟点就是几乎没有什么保命措施。雷一扔出去了很容易被弹幕包围不知所措连续去世。</p>
<p>没错，这游戏就是个猴子游戏，扭不来弹幕死路一条。</p>
<p>还有就是，收集宝石会加 Rank，被弹或扔雷会降 Rank。Rank 越高弹幕越难，虽然我一上手就是 Lunatic 自带锁定 Rank Max。</p>
<p>通了本篇之后解锁 Extra 和 Challenge。</p>
<p>Challenge 就是，把某个角色的所有符卡在 Rank Max 的情况下 NN 击破，就可以解锁一张隐藏符卡。</p>
<p>不知道是要同一难度的所有符卡还是什么，反正我把 Lunatic 的所有符卡击破就解锁了。</p>
<p>还有就是，实战是真的会自带 debuff 的。</p>
<p>单关练习里面什么小缝我不敢钻，一上实战好家伙比谁都怂。</p>
<p><img src="/img/TIM图片20181209192946.jpg" alt=""></p>
<p>以下是一些截图</p>
<p><img src="/img/20210721141838_1.jpg" alt="经典老番之裙底安定"></p>
<p><img src="/img/20210721141223_1.jpg" alt="说不定这位其实是小红帽"></p>
<p><img src="/img/20210721142216_1.jpg" alt="玄学避弹（有一说一我真的搞不懂为什么我没死在这张符卡）"></p>
<p>初通 MISS 情况：三面关底二符，终符；四面关底二非；五面关底二非×2，二符×2；六面关底一符，三非，四符，终符。</p>
<p>没想到四面 BOSS 竟然给面子只杀了我一次，二符三非三符连起来我竟然没有死。我大受震撼.jpg</p>
<p>然后五面 BOSS 打崩了死了四次。我再次大受震撼.jpg</p>
<p>总而言之就是一个超级无敌野蛮的猴子游戏，换句话说就是吃状态。状态不好一面循环。</p>
<p><del>有一说一一面关底一符难的。</del></p>
<p>如果您想要观看我的初通 Replay 并以此嘲讽我有多菜，可以联系我 qwq</p>
<p>最后吐槽一句这游戏中文翻译做的不好。很多地方语句逻辑莫名其妙的。</p>
<p>还有别看第一个角色 POWER 是五颗星，实战就她输出最低。</p>
<p><del>果然金发的女孩子无论在什么世界里都是只有被迫害的份吗（悲</del></p>
<p><del>欸等会隐藏角色也是金发啊（惊觉</del></p>
<p>啊，什么，BGM？不重要，反正都不咋样。<del>其实是还没空听。</del></p>
<hr>
<p>2021 年 7 月 23 日凌晨更新：</p>
<p>通关之后解锁了一个隐藏角色 Angelica。似乎是 Eldied 捡来的猫？</p>
<p>至少 Eldied 的 Challenge 符卡的符卡说明里这么写。当然我是直接翻的游戏源文件看到的。</p>
<p>高火力诱导，整个游戏输出最高的机体。反正我是怕了。</p>
<p>称号是「かわいい黒猫」，嗯确实可爱。</p>
<p><del>说不定其实项圈也是萌点。</del></p>
<p><del>而且是唯一一个答应 Yami 说还会去找她玩的 qwq</del></p>
<p>ED 里和 Cocoa 好上了，ED 就是两只猫一起喵喵乱叫。</p>
<p><del>以及吐槽一下 Cocoa 的猫弹幕太出戏了。甚至 BGM 里还有猫叫。那种真的猫叫。</del></p>
<p>看评测说低难度版本的弹幕在 Rank 相同的情况下几乎都比高难度版本难出很多。</p>
<p>实际试了一下感觉也就个别情况吧。</p>
<p>但是低难度版本的弹幕 Rank 一高确实变化很大。</p>
<p><del>而且写那个评测的那位还来了句这游戏难度太低。原来如此这就是 dalao 吗。干败吓疯.jpg</del></p>
<p>而且才发现原来三个机体对应的 EX 道中 BOSS 不一样。</p>
<p>Eldied 对应 Tenka；Diana 对应 Beliel；Angelica 对应 Cocoa。</p>
<p>闲着没事来强行音译一下人名们吧！（为什么人名要用们</p>
<ol>
<li>Eldied=Pristage：艾尔蒂朵=普里斯塔姬</li>
<li>Diana=Muster=Cruel：戴安娜=玛丝塔=可露艾尔</li>
<li>Angelica=Pristage：安洁莉卡=普里斯塔姬</li>
<li>Shallna=Naga：夏尔那=那加</li>
<li>Cocoa=Biscuit：可可亚=比斯凯特</li>
<li>Beliel=Silverheart：贝莉艾尔=希尔波哈特</li>
<li>Almi=Almiraj：亚尔米=亚尔米拉吉</li>
<li>Beatrice=Silverheart：贝雅特莉奇=希尔波哈特</li>
</ol>
<p>虽然说写出来的是英文名和中文翻译，但实际上这些都是根据日文名音译过来的。</p>
<p><del>所以就不要吐槽为什么 Beatrice 不是「比特莱丝」了因为日语读作「ベアトリーチェ」。</del></p>
<p><del>也许是写设定的英语没学好。</del></p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>STG</tag>
        <tag>猴子</tag>
        <tag>猫</tag>
      </tags>
  </entry>
  <entry>
    <title>OI Team Meeting：2021-07-17</title>
    <url>/oi-team-meeting-210717/</url>
    <content><![CDATA[<p>2021 年 7 月 17 日，星期六。</p>
<p>SLYZ 2018 级信息竞赛组内部的同学聚会！</p>
<p>计划：到了地方看着办。</p>
<a id="more"></a>
<p>前一天我还因为是几乎第一次一个人出门想要临阵脱逃，这个时候</p>
<blockquote>
<p>阿块「我觉得车到山前必有路吧。」</p>
</blockquote>
<p>第二天 8：00 左右坐上车，差不多 10：00 左右到北门。</p>
<p>想着去找找他们，然后发现了迎面走来的阿稳。</p>
<p>几分钟之后我们又发现了阿块和 R。</p>
<blockquote>
<p>阿稳「我靠阿块变这么壮了。」</p>
</blockquote>
<p>然后我们打算先进门，于是四个人一起在建筑里随机游走。</p>
<p>然后我们看到了一个舞台，一些老年人在上面表演。</p>
<blockquote>
<p>阿稳「老年文工团。」</p>
<p>阿块「我听不清，但我大受震撼.jpg」</p>
</blockquote>
<p>然后我们遇到了阿陶和阿烜。</p>
<p>zhuoer 似乎要 11：30 才能来。</p>
<p>于是我们继续随机游走到四楼电影院，在那里就坐了。</p>
<p>这个时候阿块向我安利了《元气骑士》。于是我开始和他们打联机。</p>
<blockquote>
<p>我「这场面好混乱啊……欸我怎么死了。」</p>
</blockquote>
<p>过了一会</p>
<blockquote>
<p>我「是谁打死了我……而我又打死了谁……」</p>
<p>我「……！」</p>
<p>我「是……我打死了我！」</p>
</blockquote>
<p>然后等 zhuoer 来了我们打算去吃饭，于是下到三楼。</p>
<p>然而除了我，阿块和 R 以外的四个人两两一组便闲聊便只顾着往前走。</p>
<blockquote>
<p>阿块「打扰一下，你们有在看去哪家吃吗？」</p>
<p>阿陶「没有。」</p>
</blockquote>
<p>然后走着走着我们发现我们绕回起点了。然后我们决定再绕一圈。</p>
<p>第二圈绕到一半，阿稳提议说去吃火锅，然后 zhuoer 说他刚好拿到一张火锅店的票。</p>
<blockquote>
<p>阿稳「有你怎么不早说！」</p>
<p>zhuoer「我说了你不听啊。」</p>
</blockquote>
<p>然后我们去吃火锅。点了一份双人套餐，本来以为他会有两个锅，但实际上是一个锅砍成两半一边一种底料。</p>
<p>于是我们就又点了一份。</p>
<p>在这期间我们聊了很多话题，包括但不限于：</p>
<ol>
<li>上了大学去哪</li>
<li>Steam 18+ 游戏盘点（我「话题变得奇怪了.jpg」）</li>
<li>高考前在干什么（阿稳「高考前一天晚上我还在看番。」）</li>
</ol>
<p>我还给阿块展示了一下主席自交的后代预测。</p>
<p>吃完饭我们打算去超市逛一圈，然后不知道为什么跑去 B1F 的停车场绕了一大圈。停车场真就热死了。</p>
<p>从超市出来我们发现了两个买彩票的机器，然后阿块身先士卒地上去买了一张。</p>
<p>买的时候他还会问你是否已年满 18 岁。<del>形式主义提问。</del></p>
<p>似乎是刮开之后每三个一样的图案就可以获得那一行的奖金。</p>
<p>第一行</p>
<blockquote>
<p>阿块「哎呀不一样。」</p>
</blockquote>
<p>第二行</p>
<blockquote>
<p>阿块「5 块钱！很好我回本了。」</p>
</blockquote>
<p>剩下几行略。最后</p>
<blockquote>
<p>阿块「很好我赚了 15。」</p>
</blockquote>
<p>然后把票还给机器，上面就会有一个二维码，扫那个拿钱。</p>
<blockquote>
<p>阿稳「欸那如果说我抢在那个买彩票的人之前扫上这个二维码钱是不是就是我的了？」</p>
</blockquote>
<p>然后 zhuoer 又买了一张中了 20，扫码的时候真就自己没扫上给阿稳扫上了。</p>
<blockquote>
<p>阿稳「欸等会他说不定要确认的。」</p>
<p>机器「已将奖金打入您的微信钱包。」</p>
<p>阿稳「********。你快过来我把钱还你。」</p>
</blockquote>
<p>等两个人跟上我们之后</p>
<blockquote>
<p>R「哟！这不是赚了 20 块的阿稳和亏了 5 块的 zhuoer 么！」</p>
</blockquote>
<p>14：00 左右，其他几个人想去玩剧本杀，想带上我。</p>
<blockquote>
<p>我「剧本杀怎么玩啊没玩过。」</p>
<p>阿烜「没事的成爷，到时候你就照着剧本说蛤话就可以了。」</p>
</blockquote>
<p>然后我们就去玩了。</p>
<blockquote>
<p>阿烜「要不我们约定以后每年暑假都来这儿聚一聚吧。」</p>
<p>zhuoer「靠这破地方说不定过两年就给拆了。」</p>
</blockquote>
<p>阿稳说因为我话不多，想给我分一个简单一点的剧本。</p>
<p>（虽然实际上我拿到的并没有多简单</p>
<p>然后开始游戏后我因为不知道说什么于是全程掉线。</p>
<blockquote>
<p>阿稳「成爷怎么挂机啊。」</p>
</blockquote>
<p>过了一会</p>
<blockquote>
<p>zhuoer「不是，现在的问题是我们对成爷的角色一无所知。」</p>
</blockquote>
<p>然后，说实话知道游戏结束我也没能理清楚整个剧情。</p>
<p>啥玩意啊咋回事啊.jpg</p>
<blockquote>
<p>插播一则旧闻：</p>
<p>慎老师「我们接着做那个机房模拟器吧！」</p>
<p>我「这是 ao 的 qwq」</p>
<p>慎老师「ao 是啥啊。」</p>
<p>我「啊这。ao 就是好的意思（」</p>
<p>慎老师「嗷。」</p>
</blockquote>
<p>还有，这个 Win 10 自带的中文输入法真就太拉了。</p>
<hr>
<p>2021 年 7 月 21 日更新：</p>
<p>块块给捉了几只虫 qwq</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>同学聚会</tag>
        <tag>颓废</tag>
      </tags>
  </entry>
  <entry>
    <title>《キミガシネ》最终章前编 B 部分简评</title>
    <url>/kimigashine/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7b32ab785252ec6861f3f19a9556b552f217a7a4bba932ba75bf62700ca9984f">35a38ec48261007c19c17531251046751928eec990ebc90b81468155098643b53434599e5a94bb1f19896fc1de3673c3218151691017f848f720ecb4fba06653a64041ecd1dd76820cb8013c2fffd1d02ae9873e29812a2c805b445f256938485b3566945fe841efea08b9a3b72b308c7475effc86ed39b63a60311f8559badd290a8023ff309239f4e2813648661f2051aac2ada7f2446421b99ac5574d9e7dccc3efd31bce34b9f5268851956d0ae900db207e1bc796f14e56d85ac1fbe56909e5730de58f407c6b01d3ed7c7310c2ea5ee48f2270dca51b8dfeb3b2260ae0a56d9de2a557c6d818911e0383c9beeb56e5d0c8af95690f2d521b1c35109467d760c45574a0c7b2557a2295c7fde5f931475bf689ef6753d9761464a0f97c03e6b9532e2a1305a9c2510b10667044f9c33270fa0a2d800459566cffd7450c1c5055a8a04cd291a1e899fd00bc7130146a570c999740499cd10c50a70fdb9bc0a4899866947214c536ff545464cf4963efa73fdbc2682b57a3059898b70cd1f8d70b13bb35917a87938a253c984aedec23cd13f3bef0ded8d70db114256ec527c10850ceeb6e2c85fe605c762828344ffaf5265c68d2c7adfb355d082022f4d6bac3d5501d7d99ad9ee0f14c85c1c48af74ab58c578b542f492ab4c2740349beba815b49a7474375b40e4eb8e5de4476d295f64b592d0dbc9b715251f8fd9a469c030c3c507612381ebd15c0689470dcbc5ecd0ca62d6036655010da4537c2abfbfa528cb475935be2cb41b53c82e5876862988fb96fe37aac10d57051399f48a9c3b1bfa7850b3f9a631307d65dfadb82b5b02c81ec0a6227fdcde04a8dedf2c59466d75d9dd32a67c51677aefd4e13639076c494366920850efca49f69ada6163f9751cb368527d70175cf96ff3c2a707281c4fdd24ce411fcf200bf797ca6bf7f0f0ffc667d3167e32b9181bf92cc3b3a986b19362782317ea77ad3e7657cd419ea824bfee8bc9658403ee8594d55075d7501014904f75a83aacd7b1c22b96cf0ab667020083d1ecc618940c0227a12ea6955209a8d8b9f9df2087f0df9a49225d6571d2f7fe50b94423b60142d52b1dc5f7e96cab8dd27d5f1ad82dc8dc331d92bf1a78fc8b57aa3b8810530a1aa8caa26f59e776cabe1c0f250a056933a56733aba36ac823c5de0be95118da69bd9e25ba8787512373d56eb316fb99d8fb47ea43f7c641fc0bd5e806506d3cebcb71e8dac6a1445d996356100cd3ec40da6f928dafb65a3e5074aacd33f11f7eb81e3c8fbe57d4cda42dfec4421453cc7b31fd94db3251d624251d2914e206b65ba980ee8cb6e489fe5daca8afa52bc63f5c51f796642307f968a29ff5d0b7510a0ba4e92c0f61936d7d257aec57dd54cd8d2ed529fe3309d99d7ed1e63713d631a62c39d52fe00a3e71e35372e91e719f0dda0d8237e3ccfb2c64ff7df081cb34fbb3823ec0c011a2d54bea24cad0f705deb3d1d94ec43a785d33abf2849d4364d812b1df910943a82cecc293334f96fd372ee4c7eec12dda10afa0a53da7a6d316baa5093d3e761d10fdfd0eb61d4089c9137bfd11fac345832bb9bfd03eac42c1c0f71c196745600f52870c45b778d38f68b0abd620e7f56b2bdbbb71167d300d0e31caaf5a36e972b1d46443a12e88cd8498ae64a6284849d274aa81fe93914097bd48ed4fad3dcd49a77a3bd24c51bb7ab519ceaa4e749b0a0eb83523505360748e7986b0e6133b52411770b6b50530b5d64112fef2ebe344df454b886d394cf290967e374419ccc61ddd23bcc49ec66d1e42bcea216d2eb4a50842f7e5d478fe18e4a35df1f61728d7eb2dea1348b6de06e280d80be1354783651caa6776887ef8f4cc1747eb34344237d230b7a0290a210540f3a4bcdff07484e684c963c57ff105957e989fb75fa4816f89b5be3f4888f6858ecac729bf5f495fc70669d93d6a9648d305b8fbe5658dd2d9f0430e8f05e7e0111030cfbb7e1223c7b214f085cbb9f8d8ababd5849780c5de5f1d45c4a692ebc525630093c7216e98080eb5df3ed71a31abcf9b2a41524c9690c6b6168603976b2b506946f5a6068795efe4a830de88545f7b7e633d9260986bfb32702b8f5afd115cc41cd6aef3a3efc2ebb227c5333b429cfdff34d05b622fad3a2058292080af1a9ca3ece5ea15efa6825b6f2101094581891374d7e3720ed1bb5dd765c0f2d4a87953c92246df913d757fc534ab4df95a1ee2b22d201b04dcddea7f22b1713f520ddd5af0992db29933df4fa47e3aa7b8cd933bdec5673421e156ad619dc382a2899006b1776888c699d943213e51fddf80ca0510b3da679b0ac38916ff1d99af219c96249ddba6faae9330eca1308e5935da6b82bb1b0f0382ebdfc6867bff9b30154fdc51174b9542fd5e93e081c5df27e55bf8fde13bf379fcae16329316986850a2b3450f7b0448e0d2682eb461ad7aa9aa96abd91d133b96a04507f596aa15cad2a0690feaf82ab697cdf4f84c171a0ed871b6720d2394c098646299bc9ae42a0a707bd9c33960991ccaf917ce8574775c0c3afd389d1628c2c731c2e1b205291c538210ae40d1a23238133fa69a7726ca814fe8167c5b98fd27ef398dcc902efb6b4f8f2b8cf4ae2c9a80334b3abeb2e32f3f6c4a1987c3ba9630bcf7b2dff65bdf6c4d1f7d213778550a5b24c4385e42d935d7c257f8fdb054e84b60365267bd60ee84bd4e92786d10d756aa8f2634790b777987211d14522dd5b9ac360e4205591cbe16a26f28e1ddd3674a16f76ed1c17542a6ab5be6802fd6ee9137b79315d7c355c962342925b74c9f1ba47b3c41831ec606b4914822e2fe7cee258c0b7fbd02ba8d7725bed304b1db131f4271d036a9ef109f532f5f57882b7aaf74f915d56bdb332a425e57f79b79c1a7d981c4c17a76d013ee5f59718b85a128f3c139bd62673f53b841cbe0583dfa5579e0f66ced49647e10ae0d618d9876854e23b525c67c974dfc1e91f33afad67f1482527123def6e41b66df1501a3541c173de5d27f88f089f255d3bd4f3600f144088e8b58b0e959cb1d5600aa0bc95005b672a34f5a7ee820247d277fb926136d89ed5a6718a53b956d11f850d064376b8f49358360872b0d50fc2e088ab89cd01400147faf6c08f3d2108268d70d65daee41114a78b47ab47888a437ff729d6acad1e6427a700553f0605bbc98e04d88a3a88ad0c706121e0fbd0db9c9b39af674290f05ee8ff65d952de14fe5d57afe2d378c0da95eec99dd2cff23ad62e91cbbaae50a7ab4e7ea279d3aaa03041819724a4282a46b0cc3a2233f2e22b1602e97d25a7e6cb4a2b02097193a6ed07919eb75b454c5b9ec4dbaee57a44d6f5ae7e7de03b85d20704a786bb3cb98909c9ea5936e3ce2f2ea9e33cedf50a2d067f9004a9a1c52f792370dd764712b331619ece05073a5db84fa60209a93414a72887e0df600f7fad32a26c29bb868277ef0914d5ac763c74dc5ee7bd381978045ce4e3462ac5ce580e984c091ac2c66e4665a60f7304088c636e1fb31aadc97e60789c52238de81899d2f0c257573a30545f80314324f7e49c28e3875709e0ca34e03578b94562e03ce2e6071d644f42e1ff8c1b31236f4a8b5c7b33c0651035b791e58175ba0ad58733f8eb36fbbcb76f1f442a1122b782e52798ffa7e585f4eb097176a70f8ddfb0ded386b63d4e2ae4a7467b0990317ba876a2a6f7af8d15d623d184e430adbec50840cb095f25f16fb365599e0c5c11efdbba6c49c77ba529cb5a757cd99b3e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码继续阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>颓废（没那回事）</category>
      </categories>
      <tags>
        <tag>推理</tag>
        <tag>解谜</tag>
      </tags>
  </entry>
  <entry>
    <title>《常世ノ塔》简要测评</title>
    <url>/tokoyo-no-tou/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1393420/TOKOYO_The_Tower_of_Perpetuity/">Steam 页面</a></p>
<blockquote>
<p>$ git status</p>
<p>Nothing to commit, working tree clean</p>
</blockquote>
<a id="more"></a>
<p>闲着没事逛 Steam 翻到的游戏。</p>
<p>每天 23 点刷新一次的塔。刷新完之后可以有两条路线，而且路线中间可以来回切换——流程中有固定的切换点。</p>
<p>本质上当然是更接近平台跳跃，虽然 Steam 上有「Rogue 恶魔城」这样的标签。</p>
<p>稍微玩了 3 个小时左右。</p>
<p>要说第一印象的话，那就是手感不怎么好了。</p>
<p>虽然说跳跃的时候可以通过调节按键时间的长短来调节跳跃的高低，但是实际上可调节的范围并没有多少。轻轻按一下还是跳起来很高。</p>
<p>然后就是重力加速度太大了，或者说角色太重了。空中跳平台的话，滞空时间一长就不知道掉到哪里去了。</p>
<p>然后跑步有惯性？一类的，经常上平台的时候跑过头。</p>
<p>还有为什么没有下蹲啊。</p>
<p>然后关于角色。</p>
<p>默认角色ココア——可可亚？心爱？一类的名字——以及最重要的，男孩子——但是因为太可爱了成为了魔界的女仆长——我是说，当然，这是 ao 的<del>，正太控狂喜</del>。</p>
<p>其他角色倒是没怎么了解过，虽然除了ココア之外还有 4 个可选角色。</p>
<p>角色不同大概只有一个不同，那就是用出来的技能不同——顺便一提这游戏没有普攻，蓝条没有满放不出技能的时候就没有攻击手段了——虽然不知道为什么要这么设计。</p>
<p>总感觉玩多了血压上来了。</p>
<p>最远到 5st Region。可能是我太菜了吧。告辞。失礼了。</p>
<p>话说回来这游戏每天更新地图的时候不整点彩蛋啥的吗。</p>
<p>更新完地图不到一个小时就有人通关了，这就是 dalao 吗。</p>
<p><img src="/img/QQ截图20210623003006.png" alt="好多平台啊"></p>
<p><img src="/img/QQ截图20210623003144.png" alt="留下你的遗言吧"></p>
<p><img src="/img/QQ截图20210623005332.png" alt="关于排行榜上只有自己一个人是一种什么体验"></p>
<blockquote>
<p>插播一条新闻：</p>
<p>在独一无二·绝对无敌·天下无双的伟大的 OI 之神慎老师的启发下，我打算实现一款类似于模拟 OIer 的游戏——在这款游戏中可以像 OIer 一样学习、娱乐、社交……</p>
<p>但是想实现的要素太多，一时间整理不过来。所以说——有没有谁愿意帮我写一点。</p>
</blockquote>
<p>最近突然喜欢用破折号了也不知道为什么。</p>
<hr>
<p>6 月 25 日凌晨 3 点左右更新：</p>
<p>我终于通关啦！！！</p>
<p><img src="/img/QQ截图20210625031745.png" alt="排行榜截图（因为退了一次所以没有 Recent You）"></p>
<p>最终 BOSS 见了 3 次过了。</p>
<p>其实本来初见可以过的但是前两个 BOSS 都会开护盾然而最终 BOSS 不开护盾直接可以打，不知道以为还要等护盾结束然后跟她耗了好长时间。</p>
<p>还有就是，全身判定的打击判定是真的大，这个最终 BOSS 再一次用实际行动告诉了我这一点。</p>
<p>以及，冷静下来玩真的会有加成。</p>
<p>顺便一提，那个 W-W 是路线，两个 W 意思是两次都选白线。类似地 B 就是黑线。</p>
<p>个人觉得白线比黑线简单的概率大一些。</p>
<p>有关剧情：</p>
<blockquote>
<p>「人们在创作的时候，会有很多半途而废的 idea。</p>
<p>那些 idea 像碎片一样聚集在一起，构成了这座塔。</p>
<p>她（ヂト）应该是这座塔里管理这些 idea 的，更加上位的存在。」</p>
<p>至少，ココア的姐姐，魔界七贤者之一ルアルア如是说。</p>
<p>当然，这只是简要意思，一定会有被曲解的部分，看看就好。</p>
</blockquote>
<p>最后还有个 To Be continued…?，嘛不过毕竟这游戏才是 EA。</p>
<p>不过说实话，50 层已经够难了，如果继续往上堆层数的话真不一定受得了了。</p>
<p>然后就是，虽然我之前一直在说这游戏手感怎么怎么差，通关一次之后我明白了——本质上只是我不会玩平台跳跃而已。</p>
<p>告辞。失礼了。</p>
<hr>
<p>6 月 26 日 11 点左右更新：</p>
<p>其实今天凌晨 0 点左右看的时候发现一个人没通关时，我是有些震惊的。</p>
<p>直到我看到了今天的白线最终 BOSS。</p>
<p>しにぞこないナナハ。野蛮。几乎每一招都能杀人。</p>
<p>其中有一招是，她扔出一串手榴弹——或者类似的东西——以抛物线轨道瞄向玩家位置，然后落地炸开一大片。反正我是不会躲。</p>
<p>反观黑线最终 BOSS——暗い星のルゥラ——当然这个名字我是凭记忆打的可能会错，总而言之就是她就很菜了。</p>
<p>虽然技能和昨天在白线时不一样，但还是就那样了。</p>
<p>还有就是，不知道是昨天随机到的道中比较简单，今天的比较难，还是今天我状态不在，道中打得十分去世——进 47 层时，也就是进最终 BOSS 前的补给点时身上只剩下 20+ HP。</p>
<p>最后也是差一下就要在最终 BOSS 9961 了。</p>
<p>顺便一提，9961 是指 BOSS 剩最后一滴血时 Game Over。类比.jpg</p>
<p><img src="/img/QQ截图20210626105537.png" alt="不知道为什么今天没有不知火游良说不定是 dalao 玩够了跑路了"></p>
<p>顺便一提，上图右半边是因为截这张图的时候是打完最终 BOSS 屏幕闪白的一瞬间，所以什么都看不清。</p>
<p>顺便一提，第二次用ココア通关的时候又确认了一遍剧情，上面总结的应该没啥问题。</p>
<hr>
<p>6 月 27 日凌晨 3 点左右更新：</p>
<p>又遇到一个新的最终 BOSS，而且似乎和ココア认识？虽然名字忘了。</p>
<p>初见 9961。二见就通了。难度一般。至少比某个死不掉的家伙弱。</p>
<p><img src="/img/TOKOYO_NO_TOU_2021_6_27_2_20_35.png" alt="喜提（虽然只是暂时的）第一"></p>
<p>顺便一提，这次不知道是状态好了还是什么，满血进的 47 层，因此就不需要支付分数回血了。但是我今天的分数反而比昨天低了近 10000 分。神奇.jpg</p>
<p>还有，手感这种东西，玩多了是真的能适应下来的。</p>
<p>冷静下来想了想，我好想突然明白为什么ナナハ难打了。</p>
<p>到目前为止我一共遇到过三个不同的最终 BOSS，只有她的房间是没有空中平台的——这也就意味着提供给玩家的躲避空间是最少的。</p>
<p>……大概吧。</p>
<hr>
<p>不知道是什么时候的更新：</p>
<p>玩不下去了。告辞。失礼了。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>2D</tag>
        <tag>像素风</tag>
        <tag>平台跳跃</tag>
      </tags>
  </entry>
  <entry>
    <title>東方覚醒珠（※二次創作） ~ Fan-made Virtual Autography</title>
    <url>/fan-made-virtual-autography/</url>
    <content><![CDATA[<p><a href="https://store.steampowered.com/app/1104610/__Fanmade_Virtual_Autography/">Steam 页面</a></p>
<blockquote>
<p><ruby>弾<rt>たま</rt>を<rt> </rt>撃<rt>う</rt>つ<rt> </rt>遊<rt>あそ</rt>びのプレイヤーよ<rt> </rt></ruby>、</p>
<p><ruby>玉<rt>たま</rt>を<rt> </rt>打<rt>う</rt>つ<rt> </rt>遊<rt>あそ</rt>びの<rt> </rt>前<rt>まえ</rt>に<rt> </rt>敗北<rt>はいぼく</rt>せよ<rt> </rt></ruby>！</p>
</blockquote>
<p><del>双关真好玩（</del></p>
<a id="more"></a>
<p>没错，就是这么一款 Steam 上刚出（指两周前）的东方同人……STG？某种意义上算是吧，因为这游戏主要强调的还是 RPG 的部分。</p>
<p>弹幕方面——尤其是 5 Boss，基本不能躲，然后 124 Boss 莫名其妙地糟，其他的其实还好。</p>
<p>尤其是 Ex Boss，说实话除了四符，八符，时符和终符以外并没有什么拿得出手的弹幕。</p>
<p><del>但实际上从混关角度考虑，时符终符两张糟卡放在一起从 RPG 的角度来说十分麻烦，再加上这个时候这边的资源也已经被耗得差不多了。</del></p>
<p>玩法：</p>
<p>如上文所言，这游戏重点在 RPG。</p>
<ol>
<li>本质上是单关练习。自机这边需要带上四个「单位」，按照游戏中的说法是「<ruby>地珠<rt>ちず</rt></ruby>」。单位分红白二色。</li>
<li>通过击破杂鱼敌人和 Boss 的非符或符卡来收集道具。</li>
<li>道具也分红白二色，可以给同色的单位充能。充满一次可以获得一次攻击的机会。</li>
<li>敌方也有单位。自机每 miss 一次也会给对方送过去一些道具，而且这些道具一定会使得对方所有单位获得一次攻击机会。</li>
<li>游戏进行到某些特定节点的时候，会出现 Party Battle 事件，就是敌我双方的单位互相攻击，自机一定先手。</li>
<li>自机方的单位会攻击敌方的单位，一旦某个单位的 HP 降到 0 了，它就不能攻击了。</li>
<li>另一方面，敌方一定会直接攻击自机本体，也就是说自机方的单位不会出现 HP 降到 0 无法攻击的情况。</li>
<li>当然自己本体的 HP 降到 0 了就真的满身疮痍了。</li>
<li>在 6 Boss 的 Final Spell 和 Ex 道中，会出现一些 <strong>特殊的 Party Battle</strong>。</li>
<li>单位有 spell turn 这个属性。大部分单位以 4 或 5 为主，当然也有几个 3 和一个 8。</li>
<li>单位每充满 spell turn 次，就可以扔雷。扔完一个雷就需要重新充满 spell turn 次才可以扔下一个。</li>
<li>虽然一次指扔一个雷，但是扔雷的时候处于能够扔雷的状态的单位越多，雷的威力也会越强。</li>
</ol>
<p>其实，因为我也没有认真读设定文档，还不知道这个游戏到底讲了一个什么故事。</p>
<p>但是还是不可避免地被 5 Boss 这个叫「<ruby>仙覚寺<rt>せんがくじ</rt></ruby>　<ruby>鞠子<rt>まりこ</rt></ruby>」的角色留下了深刻的印象。</p>
<p>首先一登场二话不说切 BGM（而且她的 BGM 的氛围和 5 道中一个天上一个地下），然后直接怼到自机脸上开始自顾自地说自话。</p>
<p>——没错，直接怼到自机脸上。不管这个时候自机往哪跑她都会跟着。</p>
<p>然后等到魔理沙一句「会わせてくれないか？」之后更加变本加厉地直接把自己的对话框盖住了魔理沙的对话框。</p>
<p>BGM 叫「<ruby>偏執<rt>へんしゅう</rt>の<rt> </rt>朱筆<rt>しゅひつ</rt></ruby>」，好吧的确挺「偏执」的。</p>
<p>而且，设定上她似乎是给「和歌」，或者说「弹幕」做注解的。也许是因为这个原因，弹幕强度高不说，她在 5 关底虽然只有一个单位，但是血非常厚（44444），攻击也很高，基本上两三下就可以直接送自机上路。</p>
<p>——从某种意义上来说她才是这游戏的本体。</p>
<p><del>因为这个 5 Boss 我还自闭了有一阵子。</del></p>
<p>不过话说回来，这游戏竟然还有汉字注音（</p>
<p>以及，以下是一些截图。</p>
<p><img src="/img/20210404190325_1.jpg" alt="本篇难度选择"></p>
<p><img src="/img/20210404190314_1.jpg" alt="本篇关卡选择"></p>
<p><img src="/img/20210404190455_1.jpg" alt="仙覚寺鞠子叫你认汉字.jpg"></p>
<p><img src="/img/20210404190640_1.jpg" alt="1 Boss 当 Ex 道中"></p>
<p>那么就这些了。</p>
<big><big><center><ruby>このブログを<rt> </rt>読<rt>よ</rt>んで<rt> </rt>下<rt>くだ</rt>さった<rt> </rt>貴方<rt>あなた</rt>に、いや<rt> </rt>重<rt>し</rt>け<rt> </rt>吉事<rt>よごと</rt>！</ruby></center></big></big>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
        <tag>STG</tag>
        <tag>RPG</tag>
      </tags>
  </entry>
  <entry>
    <title>東方鬼葬剣（とうほうきそうけん） ~ Infinite Blade Pavilion</title>
    <url>/touhou-kisouken-infinite-blade-pavilion/</url>
    <content><![CDATA[<blockquote>
<p>「靠为什么刚开学才一个星期我已经感觉过了一辈子了。」</p>
</blockquote>
<p>SLYZ 2018 级 24 班朝代，皇帝及年号更替史：</p>
<ul>
<li>YHN，立「精朝」，称「精太祖」，开元（忘了），后自谥「精虚帝」。</li>
<li>YHN，改「精朝」为「楠朝」，称「楠太宗」，开元「真虚」。</li>
<li>时生物听写，太宗大挫，改元「太虚」。</li>
</ul>
<a id="more"></a>
<p>总而言之就是介绍一个叫做鬼葬剑<del>或者说鬼那啥剑</del>的游戏。</p>
<p>一年前发布的体验版，当时号称东方史上最难同人 STG，并且真的做到了。</p>
<p><del>然后正式版难度大砍。</del></p>
<p><del>不过有一说一体验版的确有一些无理了。</del></p>
<p><del>而且可以续关，虽然是星莲船的续关。我是不会说体验版是连续关都不可以的。</del></p>
<p>似乎ミルカ写的剧本（大概？）都会找一些神话故事作为蓝本。邪星章是旧约新约圣经，导命树是北欧神话，桃源宫是克苏鲁神话，真珠岛是埃及神话。</p>
<p>这次轮到中华神话了。</p>
<p>我是指，六面 Boss 是「<ruby>蚩<rt>し</rt>尤<rt>ゆう</rt></ruby>」，萝莉（确信）。</p>
<p><del>「<ruby>八<rt>や</rt>蘇<rt>そ</rt>神<rt>がみ</rt></ruby> <ruby>秋<rt>しゅう</rt>雨<rt>う</rt></ruby>」（指正</del></p>
<p><del>其实这游戏所有角色都是萝莉（光速逃</del></p>
<p><del>但是我永远喜欢那谁谁まぐら（超光速逃</del></p>
<p><del>去 THBWiki 翻了翻发现是「<ruby>饕<rt>と</rt>喰<rt>ぐ</rt>楽<rt>ら</rt></ruby> まぐら」（奇怪的名字</del></p>
<p>灵梦线（其实是因为这游戏太难了而我又太菜了于是初见只能考虑梦 A）五面中 Boss（跑过来客串的四面 Boss）对话：</p>
<blockquote>
<p>まぐら「これ以上踏み込むと御大将に殺されますわよ。」</p>
<p>霊夢「いい加減しつこいわよ！」</p>
<p><em>（スペルカード宣言・爪牙「ユーワンズァオヤー」）</em></p>
<p><em>（スペルガード撃破）</em></p>
<p>まぐら「うごごご・・・だが・・・、<br>　　　　我が主の封印は、空高く解かれるのだ！」</p>
<p>霊夢「だまれ小悪党！」</p>
</blockquote>
<p>秋雨终符之前其实也有一些台词的。但是因为是图像，在游戏代码里面找不到文字。那么我就回忆一下视频里：</p>
<blockquote>
<center>我が名は蚩尤</center>

<center><font color=##FF0000>鬼</font>として<font color=#FF0000>葬</font>られたものたちの<font color=#FF0000>剣</font>となり！</center>

</blockquote>
<p><strong>结 尾 点 题</strong></p>
<p><strong>文 题 呼 应</strong></p>
<p><strong>升 华 主 题</strong></p>
<p>好吧，其实我现在在游戏里（虽然说是最高难度 Lunatic）连秋雨终符都见不到（</p>
<p>但是不得不说这游戏的弹幕都太野蛮了。比如说，我们有：</p>
<ul>
<li>一面吊打砂哥（？</li>
<li>二面很酷很炫</li>
<li>三面版底出缝</li>
<li>四面劲爆砌墙</li>
<li>五面斩了再说</li>
<li>六面花样爆菊</li>
</ul>
<p><strong>黄 金 精 神</strong>（等等好像哪里不对</p>
<p>好。写完了。睡觉。</p>
<p>链接：</p>
<ul>
<li><a href="https://www.freem.ne.jp/win/game/20533">在 Bullet Forge 上下载该游戏</a></li>
<li><a href="https://thwiki.cc/%E6%9D%B1%E6%96%B9%E9%AC%BC%E8%91%AC%E5%89%A3_%EF%BD%9E_Infinite_Blade_Pavilion.">在 THBWiki 上查阅相关资料</a></li>
<li><a href="https://www.bilibili.com/video/BV1ev411C7aN">观看相关视频</a>（其实这个我也没看，我看的是另外一个 NBNC 的）</li>
</ul>
<hr>
<p>9-11 补充：</p>
<p>不得不说，这游戏相比起体验版来说真的是削得超级多：</p>
<ul>
<li>梦 A 的面包片的发射频率快了 2 ~ 3 倍左右</li>
<li>道中杂鱼敌人血量大幅度降低，弹幕强度大幅度削弱</li>
<li>Boss 血量大幅度降低</li>
<li>资源变多</li>
</ul>
<p>我初通的时候道中几乎没背板，只是稍微记了一下一些比较麻烦的地方。</p>
<p>结果到最后 7 残见秋雨 5 残通。</p>
<p><del>什么嘛，我打得不是挺好的吗（自许</del></p>
<p>然后试了一下剩下 5 个机体：</p>
<ul>
<li>梦 B 就一个直线机跑得还贼慢</li>
<li>魔 A 说是贯通激光其实还是没法用</li>
<li>魔 B 攻击太鶸</li>
<li>妖 AB 吊毛机体用不来</li>
</ul>
<p>顺便还想补充一下。感觉这游戏 SpellPractice 有问题。很多在 SpellPractice 里面形状固定的弹幕到了 ScenePractice 里面就变成了随机的了。</p>
<p>给人感觉最明显的应该是二面二符・死凶「窮奇のデスサイズ地獄変」。ScenePractice 里可以看到四个分身的初始角度是随机地，结果 SpellPractice 里直接给固定了。</p>
<p>太懒了就不截图什么的了。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
      </tags>
  </entry>
  <entry>
    <title>SpellCardsCollectionSecond</title>
    <url>/spell-cards-collection-second/</url>
    <content><![CDATA[<p>Juan_feng 使用了 AK Ynoi 之术！</p>
<p>效果拔群！</p>
<p><strong>内含大量图片！（真的很大）</strong></p>
<a id="more"></a>
<p>最近想突然写一个 OI 模拟人生。</p>
<p>和慎老师交流之后，确定了「设计一个两名玩家见面之后的决斗方式」这样的总体方针。</p>
<p>最后我们确定了「传统的回合制 RPG」「卡牌对决」这样的两种方案。</p>
<p>然后为了设计招式名称，我很快想到从 Nono 443 设计的丰富的符卡库里面找一些灵感。</p>
<p>突然发现 SpellCardsCollectionSecond 还在更新，于是去玩了一下。版本号 <code>0b.39</code>。</p>
<h3 id="b0-39-已实装符卡"><a href="#b0-39-已实装符卡" class="headerlink" title="b0.39 已实装符卡"></a><code>b0.39</code> 已实装符卡</h3><h4 id="寒波「Cold-Stream」（寒流）"><a href="#寒波「Cold-Stream」（寒流）" class="headerlink" title="寒波「Cold Stream」（寒流）"></a>寒波「Cold Stream」（寒流）</h4><p><img src="/img/SCCS/寒波0.png" alt=""></p>
<p>随便扭扭.jpg</p>
<h4 id="流星「Comet-Shower」（彗星之浴）"><a href="#流星「Comet-Shower」（彗星之浴）" class="headerlink" title="流星「Comet Shower」（彗星之浴）"></a>流星「Comet Shower」（彗星之浴）</h4><p><img src="/img/SCCS/流星0.png" alt=""></p>
<p>随便扭扭.jpg</p>
<h4 id="月相「Blind-Wall」（盲目之壁）"><a href="#月相「Blind-Wall」（盲目之壁）" class="headerlink" title="月相「Blind Wall」（盲目之壁）"></a>月相「Blind Wall」（盲目之壁）</h4><p><img src="/img/SCCS/月相0.png" alt=""></p>
<p>小玉随机，且只能看到一半；激光奇数。</p>
<p>随便扭扭.jpg</p>
<h4 id="增幅「Howl-Amplify」（怒吼放大）"><a href="#增幅「Howl-Amplify」（怒吼放大）" class="headerlink" title="增幅「Howl Amplify」（怒吼放大）"></a>增幅「Howl Amplify」（怒吼放大）</h4><p><img src="/img/SCCS/增幅0.png" alt=""></p>
<p>红弹回音式反弹；蓝弹奇数。</p>
<p>随便扭扭.jpg</p>
<h4 id="把驻「Splash-Anchor」（溅射锚击）"><a href="#把驻「Splash-Anchor」（溅射锚击）" class="headerlink" title="把驻「Splash Anchor」（溅射锚击）"></a>把驻「Splash Anchor」（溅射锚击）</h4><p><img src="/img/SCCS/把驻0.png" alt=""></p>
<p>锚奇数，回来的时候会有水滴弹，way 数会不断增加。</p>
<p>随便扭扭.jpg</p>
<h4 id="爪痕「染血的狂爪」"><a href="#爪痕「染血的狂爪」" class="headerlink" title="爪痕「染血的狂爪」"></a>爪痕「染血的狂爪」</h4><p><img src="/img/SCCS/爪痕0.png" alt=""></p>
<p>随机 + 有些初见杀的狙。</p>
<p>随便扭扭.jpg</p>
<h4 id="辻风「弹幕尘旋风」"><a href="#辻风「弹幕尘旋风」" class="headerlink" title="辻风「弹幕尘旋风」"></a>辻风「弹幕尘旋风」</h4><p><img src="/img/SCCS/辻风0.png" alt=""></p>
<p>好像 yuke 和梦旧市都玩过这种弹幕？</p>
<p>随便扭扭.jpg</p>
<h4 id="北风「Northern-Gust」（北方阵风）"><a href="#北风「Northern-Gust」（北方阵风）" class="headerlink" title="北风「Northern Gust」（北方阵风）"></a>北风「Northern Gust」（北方阵风）</h4><p><img src="/img/SCCS/北风0.png" alt=""></p>
<p>随便扭扭.jpg</p>
<h4 id="阳光「Solar-Ray-Fall」（太阳射线落）"><a href="#阳光「Solar-Ray-Fall」（太阳射线落）" class="headerlink" title="阳光「Solar Ray Fall」（太阳射线落）"></a>阳光「Solar Ray Fall」（太阳射线落）</h4><p><img src="/img/SCCS/阳光0.png" alt=""></p>
<p>激光打到自机会变成麟弹狙。</p>
<p>诶真好玩.jpg</p>
<h4 id="月日「Miniature-Eclipse」（微型日食）"><a href="#月日「Miniature-Eclipse」（微型日食）" class="headerlink" title="月日「Miniature Eclipse」（微型日食）"></a>月日「Miniature Eclipse」（微型日食）</h4><p><img src="/img/SCCS/月日0.png" alt=""></p>
<p>露娜本体会把桑尼的激光变成米弹；但是血很少且不会复活所以需要控枪。</p>
<p><del>话说回来那激光也不是完全无缝啊 TAS 大概能躲吧。</del></p>
<h4 id="现像「虚-像-投-影Virtual-Projection」"><a href="#现像「虚-像-投-影Virtual-Projection」" class="headerlink" title="现像「虚　像　投　影Virtual Projection」"></a>现像「<ruby>虚　像　投　影<rt>Virtual Projection</rt></ruby>」</h4><p><img src="/img/SCCS/现像0.png" alt=""></p>
<p>趁着弹幕虚化，一遍向上冲异变躲紫铳弹。</p>
<h4 id="雷庭「天空中的龙之巢」"><a href="#雷庭「天空中的龙之巢」" class="headerlink" title="雷庭「天空中的龙之巢」"></a>雷庭「天空中的龙之巢」</h4><p><img src="/img/SCCS/雷庭0.png" alt=""></p>
<p><img src="/img/SCCS/雷庭1.png" alt=""></p>
<p>随便扭扭.jpg</p>
<h4 id="结界「多重捕缚阵」"><a href="#结界「多重捕缚阵」" class="headerlink" title="结界「多重捕缚阵」"></a>结界「多重捕缚阵」</h4><p><img src="/img/SCCS/结界0.png" alt=""></p>
<p>随便扭扭.jpg</p>
<h4 id="祈愿「风祝的祝福」"><a href="#祈愿「风祝的祝福」" class="headerlink" title="祈愿「风祝的祝福」"></a>祈愿「风祝的祝福」</h4><p><img src="/img/SCCS/祈愿0.png" alt=""></p>
<p>有一说一，到后面发弹频率狂暴之后还有点麻烦的。</p>
<h4 id="残响「Reverberate-Echo」（反响回声）"><a href="#残响「Reverberate-Echo」（反响回声）" class="headerlink" title="残响「Reverberate Echo」（反响回声）"></a>残响「Reverberate Echo」（反响回声）</h4><p><img src="/img/SCCS/残响0.png" alt=""></p>
<p>中玉打到板顶版底反弹出发光点弹，发光中玉，光玉三层。</p>
<p>随便扭扭.jpg</p>
<h4 id="咆哮「Hunting-Howls」（猎杀咆哮）"><a href="#咆哮「Hunting-Howls」（猎杀咆哮）" class="headerlink" title="咆哮「Hunting Howls」（猎杀咆哮）"></a>咆哮「Hunting Howls」（猎杀咆哮）</h4><p><img src="/img/SCCS/咆哮0.png" alt=""></p>
<p><img src="/img/SCCS/咆哮1.png" alt=""></p>
<p>扔出两拨人弹，然后把它们变成自机狙的狗弹。</p>
<p>需要引到角落否则很麻烦。</p>
<h4 id="星条「Old-Glory」（旧日荣耀）"><a href="#星条「Old-Glory」（旧日荣耀）" class="headerlink" title="星条「Old Glory」（旧日荣耀）"></a>星条「Old Glory」（旧日荣耀）</h4><p><img src="/img/SCCS/星条0.png" alt=""></p>
<p><img src="/img/SCCS/星条1.png" alt=""></p>
<p>美国国旗.jpg</p>
<p>横向的红白激光每个一段时间就会触发一次；被蓝色激光围住的大星弹打到版底会变成小星弹；所有弹幕都在向下移动。</p>
<p>说实话我也不知道怎么躲，随缘吧。</p>
<h4 id="星月「Tiny-Satellites」（极小的卫星）"><a href="#星月「Tiny-Satellites」（极小的卫星）" class="headerlink" title="星月「Tiny Satellites」（极小的卫星）"></a>星月「Tiny Satellites」（极小的卫星）</h4><p><img src="/img/SCCS/星月0.png" alt=""></p>
<p>整个游戏最无聊的符卡。</p>
<h4 id="魔涡「Deep-Mealstrom」（深涡）"><a href="#魔涡「Deep-Mealstrom」（深涡）" class="headerlink" title="魔涡「Deep Mealstrom」（深涡）"></a>魔涡「Deep Mealstrom」（深涡）</h4><p><img src="/img/SCCS/魔涡0.png" alt=""></p>
<p>怎么说呢……随便扭扭吧也没啥好说的。</p>
<h4 id="突风「叶团扇-Downburst（爆发）」"><a href="#突风「叶团扇-Downburst（爆发）」" class="headerlink" title="突风「叶团扇 Downburst（爆发）」"></a>突风「叶团扇 Downburst（爆发）」</h4><p><img src="/img/SCCS/突风0.png" alt=""></p>
<p><img src="/img/SCCS/突风1.png" alt=""></p>
<p>中玉打到版底炸成开花麟弹链，然后麟弹又变成带环小玉自然下落。</p>
<p>旧版本玩过的符卡，用金发孩子的话需要左右大幅度横拉，总之很糟就是了。</p>
<h4 id="离散「调-律-搅-乱Tune-Shaker」"><a href="#离散「调-律-搅-乱Tune-Shaker」" class="headerlink" title="离散「调　律　搅　乱Tune Shaker」"></a>离散「<ruby>调　律　搅　乱<rt>Tune Shaker</rt></ruby>」</h4><p><img src="/img/SCCS/离散0.png" alt=""></p>
<p>一堆狙加上乱七八糟的随机弹。</p>
<p>随便扭扭.jpg</p>
<h4 id="狱炎「Abyss-Prominence」（深渊流行）"><a href="#狱炎「Abyss-Prominence」（深渊流行）" class="headerlink" title="狱炎「Abyss Prominence」（深渊流行）"></a>狱炎「Abyss Prominence」（深渊流行）</h4><p><img src="/img/SCCS/狱炎0.png" alt=""></p>
<p>其实我也不知道 Abyss Prominence 该咋翻译。</p>
<p>月球可以消去黑红弹和部分大星弹；必须要借着月球的掩护逆穿黑红弹否则会被封死。</p>
<p>比较典型的看上去简单玩起来难的类型。</p>
<h4 id="「原初之光」"><a href="#「原初之光」" class="headerlink" title="「原初之光」"></a>「原初之光」</h4><p><img src="/img/SCCS/原初之光0.png" alt=""></p>
<p>大毒瘤纯狐 /kk</p>
<h4 id="乾坤「如同两位神明大人所说」"><a href="#乾坤「如同两位神明大人所说」" class="headerlink" title="乾坤「如同两位神明大人所说」"></a>乾坤「如同两位神明大人所说」</h4><p><img src="/img/SCCS/乾坤0.png" alt=""></p>
<p><img src="/img/SCCS/乾坤1.png" alt=""></p>
<p>青蛙弱诱导弹，蛇 y 轴狙。</p>
<p>我的解法是奇数波往早苗头上引，偶数波等发弹完大力拉上去。</p>
<h4 id="结晶「Fallen-Fractal」（坠落分型）"><a href="#结晶「Fallen-Fractal」（坠落分型）" class="headerlink" title="结晶「Fallen Fractal」（坠落分型）"></a>结晶「Fallen Fractal」（坠落分型）</h4><p><img src="/img/SCCS/结晶0.png" alt=""></p>
<p>新的 BGM！</p>
<p>……还有新的难度。</p>
<h4 id="日星「Little-Supernova」（小小的超新星）"><a href="#日星「Little-Supernova」（小小的超新星）" class="headerlink" title="日星「Little Supernova」（小小的超新星）"></a>日星「Little Supernova」（小小的超新星）</h4><p><img src="/img/SCCS/日星0.png" alt=""></p>
<p>研究了一段时间的符卡。</p>
<p>最后我找到的解法就是……版底左右晃。</p>
<h4 id="雷鱼「带电游泳弹」"><a href="#雷鱼「带电游泳弹」" class="headerlink" title="雷鱼「带电游泳弹」"></a>雷鱼「带电游泳弹」</h4><p><img src="/img/SCCS/雷鱼0.png" alt=""></p>
<p>激光靠近你会在你身边生成很密的麟弹，就像放电一样很有意思。</p>
<p>大概绕圈吧。</p>
<h4 id="反击「Interception-Charge」（截断蓄力）"><a href="#反击「Interception-Charge」（截断蓄力）" class="headerlink" title="反击「Interception Charge」（截断蓄力）"></a>反击「Interception Charge」（截断蓄力）</h4><p><img src="/img/SCCS/反击0.png" alt=""></p>
<p>本质上是捕获自机子弹变成大玉；然而金发孩子主要用激光所以木大！</p>
<h4 id="怪奇「Jevodan（杰沃丹）的野兽」"><a href="#怪奇「Jevodan（杰沃丹）的野兽」" class="headerlink" title="怪奇「Jevodan（杰沃丹）的野兽」"></a>怪奇「Jevodan（杰沃丹）的野兽」</h4><p><img src="/img/SCCS/怪奇0.png" alt=""></p>
<p>「杰沃丹」这个翻译来自于 <a href="https://zh.moegirl.org.cn/%E6%A2%B5%E8%92%82%E5%86%88%E5%A5%87%E8%BF%B9%E8%B0%83%E6%9F%A5%E5%AE%98#">https://zh.moegirl.org.cn/%E6%A2%B5%E8%92%82%E5%86%88%E5%A5%87%E8%BF%B9%E8%B0%83%E6%9F%A5%E5%AE%98#</a></p>
<p>影狼会不停地横冲直撞，并撕碎沿路上的人弹。反而是圈越小越容易突破出去。</p>
<p>总之就是尽快钻到人弹圈外就好了。</p>
<h4 id="传说「三角海域之魔」"><a href="#传说「三角海域之魔」" class="headerlink" title="传说「三角海域之魔」"></a>传说「三角海域之魔」</h4><p><img src="/img/SCCS/传说0.png" alt=""></p>
<p>船长和两颗鬼火之间的三角形，如果自机进去会生成白色激光，会封死三角形内全部的区域；锚奇数，打到版边的水滴弹大概是随机吧。</p>
<p>大概只能固定走位。</p>
<h4 id="「经年的憎恶」"><a href="#「经年的憎恶」" class="headerlink" title="「经年的憎恶」"></a>「经年的憎恶」</h4><p><img src="/img/SCCS/经年的憎恶0.png" alt=""></p>
<p>随便扭扭.jpg</p>
<h4 id="秘术「古代传来的神技」"><a href="#秘术「古代传来的神技」" class="headerlink" title="秘术「古代传来的神技」"></a>秘术「古代传来的神技」</h4><p><img src="/img/SCCS/秘术0.png" alt=""></p>
<p><img src="/img/SCCS/秘术1.png" alt=""></p>
<p>固定 + 狙。</p>
<p>随便扭扭.jpg</p>
<h4 id="神鸟「迦楼罗天翔」"><a href="#神鸟「迦楼罗天翔」" class="headerlink" title="神鸟「迦楼罗天翔」"></a>神鸟「迦楼罗天翔」</h4><p><img src="/img/SCCS/神鸟0.png" alt=""></p>
<p><img src="/img/SCCS/神鸟1.png" alt=""></p>
<p>大概算是整个游戏第三难的符卡。</p>
<p>绿色的麟弹圈速度很快，上穿一定要果断；然后一边处理麟弹圈一边左右移动躲中玉狙或者看准或弹链的缝。</p>
<h4 id="变动「波-纹-偏-移Ripple-Shifter」"><a href="#变动「波-纹-偏-移Ripple-Shifter」" class="headerlink" title="变动「波　纹　偏　移Ripple Shifter」"></a>变动「<ruby>波　纹　偏　移<rt>Ripple Shifter</rt></ruby>」</h4><p><img src="/img/SCCS/变动0.png" alt=""></p>
<p><img src="/img/SCCS/变动1.png" alt=""></p>
<p><img src="/img/SCCS/变动2.png" alt=""></p>
<p><img src="/img/SCCS/变动3.png" alt=""></p>
<p><img src="/img/SCCS/变动4.png" alt=""></p>
<p><img src="/img/SCCS/变动5.png" alt=""></p>
<p><img src="/img/SCCS/变动6.png" alt=""></p>
<p>大概算是整个游戏第二难的符卡。</p>
<p>一共三波，循环；每一波都是红蓝弹绕着版面中心旋转，其中红弹逆时针，蓝弹顺时针；比较特殊的是第三波，红蓝弹重叠会在特定位置形成无缝。</p>
<p>最后一张截图就是差点被封死然后击破了。</p>
<h4 id="電中「超高压-Voltecker（伏特克）」"><a href="#電中「超高压-Voltecker（伏特克）」" class="headerlink" title="電中「超高压 Voltecker（伏特克）」"></a>電中「超高压 Voltecker（伏特克）」</h4><p><img src="/img/SCCS/电中0.png" alt=""></p>
<p><img src="/img/SCCS/电中1.png" alt=""></p>
<p><img src="/img/SCCS/电中2.png" alt=""></p>
<p>所以说 Voltecker 是个啥玩意（</p>
<p>带核弹撞人 + 扔核弹 + 泛狙到纯随机的闪电。</p>
<h4 id="击沉「Abyss-Sinker」（深渊坠沉）"><a href="#击沉「Abyss-Sinker」（深渊坠沉）" class="headerlink" title="击沉「Abyss Sinker」（深渊坠沉）"></a>击沉「Abyss Sinker」（深渊坠沉）</h4><p><img src="/img/SCCS/击沉0.png" alt=""></p>
<p><img src="/img/SCCS/击沉1.png" alt=""></p>
<p><img src="/img/SCCS/击沉2.png" alt=""></p>
<p><img src="/img/SCCS/击沉3.png" alt=""></p>
<p>锚本身是固定的，扔出去后会在轨迹上留下发光小玉，收回来的时候回把小玉打碎成水滴弹；下一波锚彻底砸下来之前上一波的水滴弹不会消失。</p>
<p>三波，循环，但其实后两波有点像的。</p>
<h4 id="转移「次-元-飞-跃Parallel-Switching」"><a href="#转移「次-元-飞-跃Parallel-Switching」" class="headerlink" title="转移「次　元　飞　跃Parallel Switching」"></a>转移「<ruby>次　元　飞　跃<rt>Parallel Switching</rt></ruby>」</h4><p><img src="/img/SCCS/转移0.png" alt=""></p>
<p><img src="/img/SCCS/转移1.png" alt=""></p>
<p><img src="/img/SCCS/转移2.png" alt=""></p>
<p>毫无疑问的整个游戏最难符卡。</p>
<p>弹幕本身是无缝的，分红蓝两色，其中有一种颜色的弹幕没有判定（就是半透明的子弹）；如果穿过没有判定的弹链会导致判定状态切换，即之前没有判定的颜色变得有判定，有判定的颜色变得没有判定。</p>
<p>典型的看上去难玩起来更难的类型。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>如果后面又有更新了的话大概这边也会更新吧。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
        <tag>Nono 443</tag>
      </tags>
  </entry>
  <entry>
    <title>「2020 省选联考 A 卷 D1T2」组合数问题</title>
    <url>/sdoi2020-d1t2-solution/</url>
    <content><![CDATA[<p>从现在开始我 blog 写题解要附上简要题意（</p>
<a id="more"></a>
<p>给定 $m$ 次多项式 $F(x)=\sum_{i=0}^{m}f_{i}x^{i}$，试求</p>
<script type="math/tex; mode=display">\sum_{k=0}^{n}{n\choose k}F(k)x^{k}\</script><p>在 $\operatorname{mod}p$ 意义下的值。</p>
<p>其中 $1\leqslant n,x,p\leqslant 10^{9},0\leqslant f_{i}\leqslant 10^{9},1\leqslant m\leqslant\min(n,1000)$。</p>
<p>不过话说回来，D2 早上去机房听烜说这是道衡水的原题，而且还是比原题简单的那种。</p>
<p>首先我们把 $F(k)$ 拆开，得到</p>
<script type="math/tex; mode=display">\sum_{i=0}^{m}f_{i}\sum_{k=0}^{n}{n\choose k}k^{i}x^{k}</script><p>考虑到 $m$ 比较小，我们可以对于外层 $\sum$ 的每一项单独求值。定义</p>
<script type="math/tex; mode=display">\begin{aligned}
G_{n,t}(x)&=\sum_{k=0}^{n}{n\choose k}k^{t}x^{k}\\
&=\sum_{k=0}^{n}\left({n-1\choose k}+{n-1\choose k-1}\right)k^{t}x^{k}\\
&=\sum_{k=0}^{n}{n-1\choose k}k^{t}x^{k}+\sum_{k=0}^{n}{n-1\choose k-1}k^{t}x^{k}\\
&=\sum_{k=0}^{n-1}{n-1\choose k}k^{t}x^{k}+\sum_{k=0}^{n-1}{n-1\choose k}(k+1)^{t}x^{k+1}\\
&=\sum_{k=0}^{n-1}{n-1\choose k}k^{t}x^{k}+x\sum_{i=0}^{t}{t\choose i}\sum_{k=0}^{n-1}{n-1\choose k}k^{t}x^{k}\\
&=G_{n-1,t}(x)+x\sum_{i=0}^{t}{t\choose i}G_{n-1,i}(x)
\end{aligned}</script><p>于是我们构造矩阵</p>
<script type="math/tex; mode=display">A=\begin{bmatrix}
{0\choose 0}x+1&0&0&\cdots&0&0&1\\
{1\choose 0}x&{1\choose 1}x+1&0&\cdots&0&0&0\\
{2\choose 0}x&{2\choose 1}x&{2\choose 2}x+1&\cdots&0&0&0\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\
{m-1\choose 0}x&{m-1\choose 1}x+1&{m-1\choose 2}x&\cdots&{m-1\choose m-1}x+1&0&0\\
{m\choose 0}x&{m\choose 1}x&{m\choose 2}x&\cdots&{m\choose m-1}x&{m\choose m}x+1&0\\
0&0&0&\cdots&0&0&1
\end{bmatrix}</script><p>和初始向量</p>
<script type="math/tex; mode=display">S=\begin{bmatrix}
1\\
0\\
0\\
\vdots\\
0\\
0\\
1
\end{bmatrix}</script><p>那么</p>
<script type="math/tex; mode=display">A^{n}S=\begin{bmatrix}
G_{n,0}(x)\\
G_{n,1}(x)\\
G_{n,2}(x)\\
\vdots\\
G_{n,m-1}(x)\\
G_{n,m}(x)\\
1
\end{bmatrix}</script><p>虽然我在我的另一个 blog 里写过了，不过由于某些原因那个 blog 倒了，于是我在这里再写一遍。</p>
<p>如果直接使用矩阵快速幂来计算 $A^{n}$ 的话，复杂度是 $O(m^{3}\log n)$ 的，但是这还不够。</p>
<p>考虑我们能不能构造出一个奇妙的序列 $c_{0},c_{1},\cdots,c_{m+1}$ 使得 $C(A)=\sum_{i=0}^{m+1}c_{i}A^{i}=A^{n}$。</p>
<p>如果我们构造出来了，令 $S_{k}$ 表示 $S$ 从上往下第 $k$ 维的值，从 $0$ 开始标号。那么</p>
<script type="math/tex; mode=display">(A^{n}S)_{k}=\left(\sum_{i=0}^{m+1}c_{i}A^{i}S\right)_{k}=\sum_{i=0}^{m+1}c_{i}(A^{i}S)_{k}</script><p>注意到 $(A^{i}S)_{k}$ 就是 $G_{i,k}(x)$，不过如果 $k=m+1$ 就是 $1$。这样我们就可以在 $O(m^{2})$ 的复杂度内计算出答案。</p>
<p>我们设 $A^{n}=P(A)Q(A)+C(A)$，如果我们能够找到一个 $m+2$ 次多项式 $H$ 使得 $Q(A)=0$，就可以有 $C(A)=A^{n}\operatorname{mod}Q(A)$。</p>
<hr>
<p>一下是一些为了求出 $H$ 所必要的矩阵相关知识。</p>
<p>对于矩阵 $A$，如果等式 $(\lambda I-A)v=0$ 成立，我们称 $\lambda$ 是 $A$ 的一个特征值，$v$ 是 $A$ 的一组特征向量。</p>
<p>有两个<del>连 shadowice dalao 都不会证的</del>结论：</p>
<ol>
<li>满足 $\text{Det}(A)\neq 0$，即满秩的 $n\times n$ 的矩阵 $A$ 拥有 $n$ 组线性无关的特征向量。</li>
<li>当且仅当 $\text{Det}(\lambda I-A)=0$ 时存在这样的 $v$。</li>
</ol>
<p>显然我们刚才构造的矩阵 $A$ 是满秩的。于是根据 Cayley-Hamilton 定理，有 $\prod_{k=0}^{m+1}(\lambda_{k}I-A)=0$，其中 $\lambda_{0},\lambda_{1},\cdots,\lambda_{m+1}$ 表示 $A$ 的 $m+2$ 组特征向量。</p>
<p>于是 $Q(A)=\prod_{k=0}^{m+1}(\lambda_{k}I-A)$。</p>
<p>考虑另外一个多项式 $R(\lambda)=\text{Det}(\lambda I-A)$，<del>根据 shadowice dalao 的 blog，</del>这两个多项式的系数对应相等。</p>
<p>而显然 $\text{Det}(\lambda I-A)=(\lambda-1)(\lambda-x-1)^{m+1}$，使用分治 NTT 可以在 $O(m\log^{2}m)$ 的复杂度内计算出来。</p>
<p>那么总结一下：</p>
<ol>
<li>计算 $R(\lambda)=\text{Det}(\lambda I-A)=(\lambda-1)(\lambda-x-1)^{m+1}$，复杂度 $O(m\log^{2}m)$。</li>
<li>设 $R(\lambda)=\sum_{i=0}^{m+2}q_{i}\lambda^{i}$，有 $Q(A)=\sum_{i=0}^{m+2}q_{i}A^{i}=0$。</li>
<li>计算 $C(A)=A^{n}\operatorname{mod}Q(A)$，时间复杂度 $O(m\log m\log n)$。</li>
<li>设 $C(A)=\sum_{i=0}^{m+1}c_{i}A^{i}$，有 $(A^{n}S)_{k}=\sum_{i=0}^{m+1}c_{i}(A^{i}S)_{k}$，也即 $G_{n,k}(x)=\sum_{i=0}^{m+1}c_{i}G_{i,k}(x)$。</li>
<li>对于所有的 $0\leqslant i\leqslant m+1,0\leqslant k\leqslant m$ 计算 $G_{i,k}(x)$，我们发现 $G$ 的暴力递推式可以转化成 EGF，于是做 $m$ 遍卷积，复杂度 $O(m^{2}\log m)$。</li>
</ol>
<p>那么总体的复杂度相当于 $O(m^{2}\log m)$。</p>
<p>然而我一点都不想写这个玩意（</p>
]]></content>
      <categories>
        <category>口胡</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>NTT</tag>
        <tag>多项式</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2020 游记」五月蠅いなお前なんて大嫌いだ</title>
    <url>/sdoi2020-notes/</url>
    <content><![CDATA[<p>闲着没事干写篇游记。</p>
<a id="more"></a>
<blockquote>
<p>鉴于 NOI2020 拟于 8 月份举办以及各省目前的疫情防控情况，NOI 科学委员会经过研究决定：由 CCF 统一命题和评测的 NOI2020 省队选拔安排在 6 月 20 日 - 21 日（周六周日）举行。统一省选安排两试，时间为每天上午 8 点半到 13 点。</p>
</blockquote>
<p>以上文字引用自<a href="http://www.noi.cn/newsview.html?id=1215&amp;hash=618DAD&amp;type=1"> CCF 关于 NOI2020 省选举办时间和方式的通知</a>。</p>
<p><del>标题的「五月蠅いな」和「お前なんて大嫌いだ」是两句话，因为「五月蠅い」后面要直接跟名词不能加「な」qwq</del></p>
<h3 id="Day-∞"><a href="#Day-∞" class="headerlink" title="Day -∞"></a>Day -∞</h3><p>颓废一时爽，一直颓废一直爽<del>，回去做题火葬场</del>。</p>
<h3 id="Day-17（2020-6-2）"><a href="#Day-17（2020-6-2）" class="headerlink" title="Day -17（2020-6-2）"></a>Day -17（2020-6-2）</h3><p>因为合格考没过被迫开始补政治和语文。</p>
<p><del>呐，世界，毁灭吧（无端</del></p>
<p>不知道为什么从中午开始一直头疼，躺了一整个下午总算好点了。</p>
<p>躺在床上的时候突然就想，自己加入信息组已经两年了啊。</p>
<p>曹爷（ID 忘了，Luogu 上叫第一发言者），DEVILK，SuperGoodGame，star_dust，hachimanjy，RiverFun，wavwing，Bj2002，Colorfulmist，SnoWY，Ciyang，ArachnidaKing，Red_dye……</p>
<p>我突然想起来了，以前每天晚上，我们在宿舍里，一边闻着曹爷的大臭脚一边谈笑风生，然后抢曹爷被子时的事情。</p>
<p>我突然想起来了，曾经有过一个晚上，DEVILK 手把手帮我调生日蛋糕时的事情。</p>
<p>我突然想起来了，2018 年的 NOIp，我们在宿舍里，玩算法版谁是卧底时的事情。</p>
<p>我突然想起来了，曾经有过一个晚上，我帮着 hachimanjy 搭建 GitHub 博客时的事情。</p>
<p>当初我去自招的时候见到 RiverFun 是什么心情呢？我已经不知道了。</p>
<p>一开始因为误打误撞进了信息组，wavwing（好像）还惹出了不少事。当时我还只能跟着他后面不做声，结果现在也变成爷字辈了。</p>
<p>我突然想起来了，第一次合格考我回到机房时，Bj2002 大喊一声「您们看看谁来了！」时的事情。</p>
<p>我突然想起来了，当初我为了和 asuldb 深入交流，不畏 Colorfulmist 的潮之力毅然调座位时的事情。结果调过去遇到的第一道题就是一道神仙虚树反演题 <code>Surprise Me!</code>（</p>
<p>我突然想起来了，我以前手把手教 SnoWY 学算法时的事情。结果他现在文化课 OI 两开花随手吊打我。</p>
<p>我突然想起来了，以前闲下来没事干的时候，成天就知道往 Taduro 的座位旁边凑时的事情。</p>
<p>我突然想起来了，以前和 Juan_feng 一起调试 <code>五彩斑斓的世界</code>，<code>未来日记</code> 时的事情。结果后来自己参与了 std 编写的题 <code>文化课</code>（一开始叫 <code>四则运算基础练习题</code>）也被收入 Ynoi<br>了。还是活成了自己讨厌的模样（大雾</p>
<p>我突然想起来了，2019 年一轮省队集训，Day 9，被 nzhtl1477 拍着肩膀说「珂以啊！」时的事情。</p>
<p>我突然想起来了，省队选拔前夕，拿着小本本跑回宿舍记录 Colorfulmist 名人名言时的事情。</p>
<p>我突然想起来了，2019 年一轮省队选拔，Day 1 考完，我和 asuldb 几个人一起在教学楼后面谈笑风生时的事情。</p>
<p>也许真就像那句话所说吧：</p>
<blockquote>
<p>哪有什么突然想起，只是一直藏在心底罢了。</p>
</blockquote>
<p>插播一则旧闻：</p>
<blockquote>
<p>潮子与 asuldb 论 SAM。潮子潮之曰：你的 SAM 没有 A，SM，A 不了。次日，asuldb 遇 SAM 题，得正解。然倍增毙，爆零也。遂叹曰：潮爷奶的准，我的 SAM 就是 A 不了。</p>
</blockquote>
<p>经 典 咏 流 传。</p>
<h3 id="Day-10（2020-6-9）"><a href="#Day-10（2020-6-9）" class="headerlink" title="Day -10（2020-6-9）"></a>Day -10（2020-6-9）</h3><p>我终于通关 Slay the Spire 了！（倒地</p>
<p><del>为什么我这么菜啊 /kk</del></p>
<p>用新角色观者打了一发，感觉不知道为什么就是好像很厉害（大雾</p>
<h3 id="Day-0（2020-6-19）"><a href="#Day-0（2020-6-19）" class="headerlink" title="Day 0（2020-6-19）"></a>Day 0（2020-6-19）</h3><p>中间竟然有连着 9 天没有更新（</p>
<p>而且连 Wiki 也没有（</p>
<p>其实是有一天 GitHub 突然 push 不上去了于是懒得搞了于是咕掉了（</p>
<p>明天就是 Day 1 了 /kk</p>
<p>大概考完这场省选我就要退役了吧 /kk</p>
<p>想着要说点什么，想来想去，还是这句话：</p>
<p>「何も問題は無いようじゃがの～」</p>
<p><del>最近在看 BUG 之风，看得我拳☆銃☆大☆爆☆発。</del></p>
<p><del>「そして、オレだけが<ruby>再<rt>リ</rt>起<rt>タ</rt>不<rt>イ</rt>能<rt>ヤ</rt></ruby>しない事を許可しろ！」</del></p>
<h3 id="Day-1（2020-6-20）"><a href="#Day-1（2020-6-20）" class="headerlink" title="Day 1（2020-6-20）"></a>Day 1（2020-6-20）</h3><p>前一天晚上定了一个五点整的闹钟，结果<del>因为某种神秘的原因</del>提前十分钟就起来了。</p>
<p>七点几分出的家门，到了机房大概有半多了。进门看到块坐在稳稳的位置上，陶就坐在旁边他自己的位置上。</p>
<p>跟他们说最近在玩 Slay the Spire，陶表示不知道。于是给他看了一下 PKUWC 的同名题目。</p>
<p>以前烜写过这道题的题解，说这是 SB 题。可惜我现在还是不会。直接去问他，他表示早就忘了。</p>
<p>进考场之后也没啥。看他们都在拼命打板子，但是我觉得打了也没用，所以反复确认试题。</p>
<p>一共三道题，<code>icefire</code>，<code>problem</code> 和 <code>shop</code>，从大样例的数量来看全部都是传统题。</p>
<p>解压密码一团乱码。</p>
<p>具体的题意应该迟早会上传到各大 OJ 上，这里就不赘述了。</p>
<p>一开始看了一个小时 T1 毫无进展，于是去看 T2。</p>
<p>稍微推了推就推出来一个矩阵的做法，$O(m^{3}\log n)$，结合暴力可以拿到 60 pts。</p>
<p>然后再回去看 T1 发现这个东西是单峰的，于是写了个三分套树状数组，$O(n\log^{2}n)$，60 pts。但实际上因为是三分所以其中一个 $\log$ 是以 $1.5$ 为底数的，常数会大。可以改成二分，但无论如何都是 60 pts。</p>
<p>做到这里就已经没时间了，T3 直接输出样例走人。</p>
<p>出考场和机房中 dalao 讨论题，发现烜 T1 想出了正解但是没有写出来。据他说是线段树，但是说实话我表示怀疑。</p>
<p>被天下第一的胡块块邀请到了他的家里。现在我写这些东西的时候也是在他家里。</p>
<p>块说自己在家里经常健身，于是我顺便拜见了一下他的健身器械。</p>
<p>被块暴力安利了炉石传说。其实我第一次听说炉石传说还是「你必须攻击该具有嘲讽的随从」的来着。</p>
<p>一个下午就打完了新手教学（</p>
<p>块「你是我见过的新手教学打得最认真的。」</p>
<p>算了吧还是 Slay 好玩（</p>
<h3 id="Day-2（2020-6-21）"><a href="#Day-2（2020-6-21）" class="headerlink" title="Day 2（2020-6-21）"></a>Day 2（2020-6-21）</h3><p>又定了一个五点的闹钟，结果又提前十分钟起来了。</p>
<p>不到七点就走了，到了机房还没开门。</p>
<p>重新抽了座位，然而两天都是二号考场。</p>
<p>瞅一眼压缩包里面，<code>count</code>，<code>transfer</code> 和 <code>tree</code>，传统题。</p>
<p>……？！<code>count</code>！这一定是一道计数题，看我写个 NTT 板子。</p>
<p>结果写了半个小时没写出来 /kk</p>
<p>解压密码和昨天一样是乱码。</p>
<p>打开一看发现 <code>count</code> 是 T3，生成树题。</p>
<p>于是三道题来回看了又看，一直在「想到新思路 -&gt; 开始写代码 -&gt; 写到一半发现假了 -&gt; 自闭」这样循环。</p>
<p>到最后突然发现 T3 可以莫比乌斯反演套矩阵树，然后突然发现自己不会矩阵树。写了半个小时没写出来，弃疗了。</p>
<p>最终成绩：60+60+0+30+10+30=190。我没了 /kk</p>
<p>烜「这套题暴力分贼肥啊你怎么回事啊。」</p>
<p>最后的最后，loli 让我们下午回家，明天开始学文化课。大概这就是我打的最后一场正式的 OI 比赛了吧。</p>
<p>对了差点忘了说了，昨天听说块没看过 JO5 但是被剧透过，于是带着他看了第一话。</p>
<p><del>黄金精神，指偷别人钱抢别人行李给别人发好人卡。</del></p>
<p><del>「めーはもう……めーはもう……めーはもう推しだ！」</del></p>
<p><del>「大丈夫ですかブチャラティ？」</del></p>
<h3 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h3><blockquote>
<p>今番良晤，豪兴不浅，</p>
<p>他日江湖相逢，再当杯酒言欢。</p>
<p>咱们就此别过。</p>
<p>江湖路远，各位请一路珍重。</p>
</blockquote>
<p><del>虽然是从花花的犇犇里抄来的。</del></p>
<p>插播一则新闻：</p>
<blockquote>
<p>真实成绩：60+60+0+0+10+10=140。看来是 D2T1 整个写炸了，D2T3 莫名其妙丢了 20 pts。</p>
</blockquote>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>东方催狐谭（とうほうさいこたん） ~ Servants of Harvest Wish</title>
    <url>/touhou-saikotan-servants-of-harvest-wish/</url>
    <content><![CDATA[<blockquote>
<p>この美しい景色も秋の贈り物……</p>
<p>滝のように落ちていく紅葉、通りすがる人達に微笑む山……</p>
<p>この絶景を目の前にして、言葉が詰まらない方がおかしいと思わない？</p>
</blockquote>
<a id="more"></a>
<p>以上文字选自魔理沙线六面 BOSS 开打前对话。</p>
<p>如果您对东方圈有一定了解，您可能会知道有一款叫做 <code>東方落流星（とうほうらくりゅうせい） ~ The Shattered Sky</code> 的游戏。催狐谭是那个游戏作者的新作。</p>
<p>关于前作落流星，我其实并没有玩过，主要原因就是它的立绘实在是……太抽象了。</p>
<p>然而本作催狐谭的立绘还是可以的。</p>
<p>摘自 THBWiki 的故事背景：</p>
<blockquote>
<p>由于不知名的原因，幻想乡中所有稻谷迅速凋零。</p>
<p>如此下去，人类不久便会陷入饥饿之中。</p>
<p>四位少女决定出发寻找异变的原因并解决异变。</p>
</blockquote>
<p>总体的剧情就是，EX BOSS 为了给自己创造一个新的肉身，从六面 BOSS 那里偷来了如意宝珠。如意宝珠的消失导致了异变。</p>
<p>后来 EX BOSS 让自己的两个手下把宝珠还回去，结果她俩被自机揍了一顿溜回来了。</p>
<p>EX BOSS 感到十分 excited，于是设计把自机引了过来想会会她们。</p>
<p>本作一共有四个自机：灵梦，魔理沙，早苗和龙子（前作落流星五面 BOSS），每个自机都有 AB 两个配置。当然我是只用过魔 A，而且是两三发就通了的那种。</p>
<p>本作的特殊系统比较简单。击破敌人可以获得特殊道具，收集一定数量可以进入一个特殊模式。在这个模式下按 X 可以扔出风神录一样的灵击然后结束该模式，在该模式中收集到的道具越多，灵击圈就越大。虽然可以决死，但是<strong>被弹之后如果不扔决死是会掉残的</strong>。我初通的时候就是因为这个在一面抱 B 撞了（</p>
<p>每一面击破 BOSS 之前收集足够多的特殊道具可以开启 Last Word，不能扔雷，被弹会强制结束符卡而不会掉残。</p>
<p>以及传统艺能，六面 BOSS 的 Last Word 被弹会掉残，以及自机全程处于特殊模式中，普通的雷被换成了原本可以结束该模式的灵击。</p>
<p>我在看过视频剧透的情况下 Lunatic 三发通，而且还是在一面抱 B 撞，四面最后一只大蝴蝶耗俩雷，五道中完全没背板的情况下；Extra 一发通。机体都是魔 A。</p>
<p>所以说这游戏其实也不难，当然我是指 Lunatic 和 Extra 。至于 URA（在 Lunatic 选项处连打 <code>Shift</code> 解锁）和 Lunatic Extra，不好意思我不敢碰。</p>
<p>而且据说，这游戏每一个 BOSS 都有一张异常符卡，是满足一些乱七八糟的条件（比如 EX BOSS 的异常符卡需要在满足一些条件的情况下 NN EX 道中，然后 EX BOSS 的 BGM 甚至还会换曲风，甚至似乎这个才是原曲）之后会额外追加的一张符卡。如果能在实战（单关练习也行，但是 BOSS 练习或符卡练习不行）收掉这张符卡，就会解锁最后的 Overdrive 符卡。</p>
<p>干败吓疯，干败吓疯。</p>
<p>最后是一些链接：</p>
<ul>
<li><a href="https://www.bulletforge.org/u/eredom/p/dong-fang-cui-hu-tan-servants-of-harvest-wish">在 Bullet Forge 上下载该游戏</a></li>
<li><a href="https://thwiki.cc/%E6%9D%B1%E6%96%B9%E5%82%AC%E7%8B%90%E8%AD%9A_%EF%BD%9E_Servants_of_Harvest_Wish.">在 THBWiki 上查阅相关资料</a></li>
<li><a href="https://space.bilibili.com/1418000">观看相关视频</a></li>
</ul>
<p>以及，也许近期会做一个 Lunatic 和 Extra 初通 Replay 的解说。</p>
]]></content>
      <categories>
        <category>颓废</category>
      </categories>
      <tags>
        <tag>东方</tag>
      </tags>
  </entry>
  <entry>
    <title>Challestend的脑内切题清单</title>
    <url>/solving-problems-in-brain/</url>
    <content><![CDATA[<p>如标题所示。</p>
<p>觉得比较简单或者懒得写代码的题。</p>
<p><del>wzx「你怎么还懒得写代码啊。你把这些题都写了就有事干了。」</del></p>
<p>可能有时候会闲着没事写几道。</p>
<a id="more"></a>
<h3 id="「CF915F」Imbalance-Value-of-a-Tree"><a href="#「CF915F」Imbalance-Value-of-a-Tree" class="headerlink" title="「CF915F」Imbalance Value of a Tree"></a><a href="http://codeforces.com/problemset/problem/915/F">「CF915F」Imbalance Value of a Tree</a></h3><p>最大值和最小值分开求。</p>
<p>大力并查集。</p>
<p>以上。</p>
<h3 id="「CF455D」Serega-and-Fun"><a href="#「CF455D」Serega-and-Fun" class="headerlink" title="「CF455D」Serega and Fun"></a><a href="http://codeforces.com/problemset/problem/455/D">「CF455D」Serega and Fun</a></h3><p>大力块链。</p>
<p>记得loli以前考过这题。</p>
<p><del>结果那次数据随机放跑了暴力。</del></p>
<h3 id="「CF1182E」Product-Oriented-Recurrence"><a href="#「CF1182E」Product-Oriented-Recurrence" class="headerlink" title="「CF1182E」Product Oriented Recurrence"></a><a href="http://codeforces.com/problemset/problem/1182/E">「CF1182E」Product Oriented Recurrence</a></h3><p>令</p>
<script type="math/tex; mode=display">g_{i}=\ln f_{i}</script><p>那么</p>
<script type="math/tex; mode=display">g_{n}=(2n-6)\ln c+g_{n-1}+g_{n-2}+g_{n-3}</script><p>一定存在这样的$k_{0},k_{1},k_{2},k_{3}$，使得</p>
<script type="math/tex; mode=display">g_{n}=k_{0}\ln c+k_{1}g_{1}+k_{2}g_{2}+k_{3}g_{3}</script><p>于是</p>
<script type="math/tex; mode=display">f_{n}=c^{k_{0}}\cdot f_{1}^{k_{1}}\cdot f_{2}^{k_{2}}\cdot f_{3}^{k_{3}}</script><h3 id="「CF1093E」Product-Oriented-Recurrence"><a href="#「CF1093E」Product-Oriented-Recurrence" class="headerlink" title="「CF1093E」Product Oriented Recurrence"></a><a href="http://codeforces.com/problemset/problem/1093/E">「CF1093E」Product Oriented Recurrence</a></h3><p>定义$f_{i}$表示$a_{i}$在$b$中对应的下标，$g_{i}$表示$b_{i}$在$a$中对应的下标。</p>
<p>操作一就是在询问</p>
<script type="math/tex; mode=display">\sum_{i=l_{a}}^{r_{a}}[f_{i}\in[l_{b},r_{b}]]</script><p>操作二就交换一下$f_{g_{x}}$和$f_{g_{y}}$，$g_{x}$和$g_{y}$。</p>
<p>大力分块。</p>
<h3 id="「CF446C」DZY-Loves-Fibonacci-Numbers"><a href="#「CF446C」DZY-Loves-Fibonacci-Numbers" class="headerlink" title="「CF446C」DZY Loves Fibonacci Numbers"></a><a href="http://codeforces.com/problemset/problem/446/C">「CF446C」DZY Loves Fibonacci Numbers</a></h3><p><del>通过查阅题解，</del>我们知道斐波那契数拥有如下性质</p>
<script type="math/tex; mode=display">F_{n+m}=F_{n+1}F_{m}+F_{n}F_{m-1}</script><p>考虑使用数学归纳法证明。首先</p>
<script type="math/tex; mode=display">F_{n+0}=F_{n+1}F_{0}+F_{n}F_{-1}</script><p>……不从$1$开始。</p>
<script type="math/tex; mode=display">F_{n+1}=F_{n+1}F_{1}+F_{n}F_{0}=F_{n+1}</script><script type="math/tex; mode=display">F_{n+2}=F_{n+1}F_{2}+F_{n}F_{1}=F_{n+1}+F_{n}=F_{n+2}</script><script type="math/tex; mode=display">\begin{aligned}
F_{n+m}&=F_{n+m-1}+F_{n+m-2}\\
&=F_{n+1}F_{m-1}+F_{n}F_{m-2}+F_{n+1}F_{m-2}+F_{n}F_{m-3}\\
&=F_{n+1}F_{m}+F_{n}F_{m-1}
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">\sum_{i=1}^{x}F_{L+i}=F_{L+1}\sum_{i=1}^{x}F_{i}+F_{L}\sum_{i=0}^{x-1}F_{i}</script><p>然后大力线段树（细节略）。</p>
<p><a href="http://codeforces.com/contest/446/submission/58884107">我甚至还写了</a>。</p>
]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>「CF1114E」Arithmetic Progression</title>
    <url>/cf1114e-solution/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1114/problem/E">传送门</a></p>
<p>大概是写的第一道正常一点的交互题吧（</p>
<a id="more"></a>
<p>因为原序列是打乱的等差数列，任意两项的差一定形如$kd$，其中$k\in\mathbb{N}^{+}$。</p>
<p>于是我们想到，如果我们提取出序列中的一些项，比如说前$m$项，差分，然后求出这些数的gcd，就有可能是原等差数列的公差。</p>
<p>但这并不一定，因为这个gcd也有可能是$kd$的形式。</p>
<p>那么把原序列随机打乱就行了。</p>
<p>求出公差之后二分找原序列最大值即可。</p>
<p>实测$m$最大可以取到$30$。</p>
<p>这样就可以A了。</p>
<p><a href="http://codeforces.com/contest/1114/submission/58430411">评测记录</a>。</p>
<p>那么问题来了，这个算法的正确率到底有多大（</p>
<p>我们将这个问题抽象为以下模型：</p>
<blockquote>
<p>给定一长度为$n$的随机排列$p$和一正整数$m$，$1\leqslant m\lt n$，令</p>
<script type="math/tex; mode=display">q_{i}=|p_{i+1}-p_{i}|\quad(i\in[1,m])</script><p>试求</p>
<script type="math/tex; mode=display">P\left(\gcd_{i=1}^{m}q_{i}=1\right)</script></blockquote>
<p>不会。告辞.jpg</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>交互</tag>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title>「XRound2F」永恒（大概算得上是篇题解）</title>
    <url>/luogu-p5439-solution-probably/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5439">传送门</a></p>
<a id="more"></a>
<p>读完题面，我们很快就想到统计每对点对对答案的贡献，然后累加起来。</p>
<p>于是问题转化成，对于每对点对，求出它们所对应的字符串的lcp长度与树上同时经过它们的路径数量之积并求和。</p>
<p>考虑点分治。</p>
<p>对于一个分治中心，我们可以将答案分成两部分，第一部分是分治中心与子树内其它点的贡献，第二部分是分治中心不同子树内的点对的贡献。</p>
<p>对于第一部分，我们直接枚举子树内其它点，然后直接求其与分治中心在Trie上对应节点的lca的深度，然后乘上其自身的子树大小，与其所在的分治中心的对应子树大小。我们可以通过使用LCT维护Trie来解决。</p>
<p>对于第二部分，我们在对于一个点计算完它第一部分的贡献之后，查询之前已经完全枚举过的其他子树内的所有点的子树大小与其与该节点在Trie上对应节点的lca的深度之积并求和。<del>虽然我不是很懂怎么描述，但是反正这个东西LCT是可以搞的。</del></p>
<p>计算完以上两部分并累加，我们就得到了答案。不难得出，上述算法的时间复杂度为$O(n\log^{2}n)$。</p>
<p><a href="https://www.luogu.org/record/22194363">https://www.luogu.org/record/22194363</a></p>
<p><del>然后评测结果就长这样（</del></p>
<p>这时我们点开算法标签，发现里面有个虚树。于是我们来思考用虚树怎么做。</p>
<p>关于上文的第一部分，这个没救，唯一的优化方法就是$O(1)$求lca。</p>
<p>而关于第二部分，如果我们定义两个点之间的距离为它们的子树大小之积再乘以它们在Trie上对应节点的lca深度，我们要求的其实就是除去分治中心外所有点对的距离之和，再减去同一子树内所有点对的距离之和。很明显这可以用虚树实现。</p>
<p>经过这样两个优化，我们成功地<del>在想象中</del>将时间复杂度降到了$O(n\log n)$。</p>
<p>然而我不会虚树:(</p>
<p>虽然T了但还是贴一下代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size,val,sum,add;</span><br><span class="line">    SplayNode *ftr,*lc,*rc;</span><br><span class="line">&#125;;</span><br><span class="line">SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;ftr==<span class="literal">NULL</span>||(p-&gt;ftr-&gt;lc!=p&amp;&amp;p-&gt;ftr-&gt;rc!=p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;lc-&gt;val=(p-&gt;lc-&gt;val+p-&gt;add)%mod;</span><br><span class="line">        p-&gt;lc-&gt;sum=(p-&gt;lc-&gt;sum+<span class="number">1L</span>L*p-&gt;lc-&gt;size*p-&gt;add%mod)%mod;</span><br><span class="line">        p-&gt;lc-&gt;add=(p-&gt;lc-&gt;add+p-&gt;add)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;rc-&gt;val=(p-&gt;rc-&gt;val+p-&gt;add)%mod;</span><br><span class="line">        p-&gt;rc-&gt;sum=(p-&gt;rc-&gt;sum+<span class="number">1L</span>L*p-&gt;rc-&gt;size*p-&gt;add%mod)%mod;</span><br><span class="line">        p-&gt;rc-&gt;add=(p-&gt;rc-&gt;add+p-&gt;add)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    p-&gt;size=<span class="number">1</span>;</span><br><span class="line">    p-&gt;sum=p-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;size+=p-&gt;lc-&gt;size;</span><br><span class="line">        p-&gt;sum=(p-&gt;sum+p-&gt;lc-&gt;sum)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;size+=p-&gt;rc-&gt;size;</span><br><span class="line">        p-&gt;sum=(p-&gt;sum+p-&gt;rc-&gt;sum)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    re SplayNode* q=p-&gt;ftr;</span><br><span class="line">    pushDown(q);</span><br><span class="line">    pushDown(p);</span><br><span class="line">    p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;lc==q)</span><br><span class="line">            p-&gt;ftr-&gt;lc=p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;rc==q)</span><br><span class="line">            p-&gt;ftr-&gt;rc=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rc==p)&#123;</span><br><span class="line">        q-&gt;rc=p-&gt;lc;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rc!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;rc-&gt;ftr=q;</span><br><span class="line">        p-&gt;lc=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;lc=p-&gt;rc;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lc!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;lc-&gt;ftr=q;</span><br><span class="line">        p-&gt;rc=q;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;ftr=p;</span><br><span class="line">    pushUp(q);</span><br><span class="line">    pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;!isRoot(p);rotate(p))</span><br><span class="line">        <span class="keyword">if</span>(!isRoot(p-&gt;ftr))</span><br><span class="line">            rotate((p-&gt;ftr-&gt;ftr-&gt;lc==p-&gt;ftr)==(p-&gt;ftr-&gt;lc==p)?p-&gt;ftr:p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    pushDown(p);</span><br><span class="line">    splay(p);</span><br><span class="line">    p-&gt;rc=<span class="literal">NULL</span>;</span><br><span class="line">    pushUp(p);</span><br><span class="line">    <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;)&#123;</span><br><span class="line">        pushDown(q-&gt;ftr);</span><br><span class="line">        splay(q-&gt;ftr);</span><br><span class="line">        q-&gt;ftr-&gt;rc=q;</span><br><span class="line">        pushUp(q-&gt;ftr);</span><br><span class="line">        q=q-&gt;ftr;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">LCA</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    pushDown(p);</span><br><span class="line">    access(p);</span><br><span class="line">    splay(q);</span><br><span class="line">    q-&gt;rc=<span class="literal">NULL</span>;</span><br><span class="line">    pushUp(q);</span><br><span class="line">    <span class="keyword">for</span>(p=q;p-&gt;ftr!=<span class="literal">NULL</span>;)&#123;</span><br><span class="line">        pushDown(p-&gt;ftr);</span><br><span class="line">        splay(p-&gt;ftr);</span><br><span class="line">        p-&gt;ftr-&gt;rc=p;</span><br><span class="line">        pushUp(p-&gt;ftr);</span><br><span class="line">        p=p-&gt;ftr;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(q);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(re SplayNode* p,re <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    p-&gt;val=(p-&gt;val+x)%mod;</span><br><span class="line">    p-&gt;sum=(p-&gt;sum+<span class="number">1L</span>L*p-&gt;size*x%mod)%mod;</span><br><span class="line">    p-&gt;add=(p-&gt;add+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ec,rt,sz,cntsum,ans;</span><br><span class="line"><span class="keyword">int</span> des[<span class="number">2</span>*maxn+<span class="number">1</span>],suc[<span class="number">2</span>*maxn+<span class="number">1</span>],las[maxn+<span class="number">1</span>],id[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> size[maxn+<span class="number">1</span>],mxs[maxn+<span class="number">1</span>],vis[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn+<span class="number">1</span>],stk[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    des[++ec]=y;</span><br><span class="line">    suc[ec]=las[x];</span><br><span class="line">    las[x]=ec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRt</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr)</span></span>&#123;</span><br><span class="line">    size[cur]=<span class="number">1</span>;</span><br><span class="line">    mxs[cur]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])</span><br><span class="line">        <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">            getRt(des[i],cur);</span><br><span class="line">            size[cur]+=size[des[i]];</span><br><span class="line">            mxs[cur]=max(mxs[cur],size[des[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    mxs[cur]=max(mxs[cur],sz-size[cur]);</span><br><span class="line">    <span class="keyword">if</span>(!rt||mxs[rt]&gt;mxs[cur])</span><br><span class="line">        rt=cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr,re <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    stk[++stk[<span class="number">0</span>]]=cur;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    cnt[cur]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])</span><br><span class="line">        <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">            res=(res+calc(des[i],cur,root))%mod;</span><br><span class="line">            cnt[cur]+=cnt[des[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    ans=(ans+<span class="number">1L</span>L*cnt[cur]*(query(mempool+id[cur])-cntsum+mod)%mod+mod)%mod;</span><br><span class="line">    re SplayNode* x=LCA(mempool+id[cur],mempool+id[root]);</span><br><span class="line">    access(x);</span><br><span class="line">    re <span class="keyword">int</span> dx=x-&gt;lc!=<span class="literal">NULL</span>?x-&gt;lc-&gt;size:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (res+<span class="number">1L</span>L*cnt[cur]*dx%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr)</span></span>&#123;</span><br><span class="line">    vis[cur]=<span class="number">1</span>;</span><br><span class="line">    cntsum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur],j=<span class="number">0</span>;i;i=suc[i])</span><br><span class="line">        <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">            re <span class="keyword">int</span> tmp=calc(des[i],cur,cur);</span><br><span class="line">            ans=(ans+<span class="number">1L</span>L*(n-cnt[des[i]])*tmp%mod)%mod;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;stk[<span class="number">0</span>];++j,update(mempool+id[stk[j]],cnt[stk[j]]),cntsum=(cntsum+cnt[stk[j]])%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(;stk[<span class="number">0</span>];update(mempool+id[stk[stk[<span class="number">0</span>]]],mod-cnt[stk[stk[<span class="number">0</span>]]]),--stk[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])</span><br><span class="line">        <span class="keyword">if</span>(des[i]!=ftr&amp;&amp;!vis[des[i]])&#123;</span><br><span class="line">            rt=des[i];</span><br><span class="line">            sz=size[des[i]];</span><br><span class="line">            getRt(des[i],cur);</span><br><span class="line">            divide(rt,cur);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cltstream::read(x);</span><br><span class="line">        <span class="keyword">if</span>(x)&#123;</span><br><span class="line">            connect(x,i);</span><br><span class="line">            connect(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        pushUp(mempool+i);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cltstream::read(x);</span><br><span class="line">        <span class="keyword">if</span>(x)</span><br><span class="line">            (mempool+i)-&gt;ftr=mempool+x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::read(id[i]);</span><br><span class="line">    rt=<span class="number">0</span>;</span><br><span class="line">    sz=n;</span><br><span class="line">    getRt(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    divide(rt,<span class="number">0</span>);</span><br><span class="line">    cltstream::write(ans);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>点分治</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5349」幂</title>
    <url>/luogu-p5349-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5349">传送门</a></p>
<a id="more"></a>
<p><del>其实挺休闲的一道题（</del></p>
<script type="math/tex; mode=display">\sum_{i=0}f(i)r^{i}=\sum_{i=0}\sum_{j=0}^{m}f_{j}i^{j}r^{i}=\sum_{j=0}^{m}f_{j}\sum_{i=0}i^{j}r^{i}</script><p>于是我们设</p>
<script type="math/tex; mode=display">g_{n}=\sum_{i=0}i^{n}r^{i}</script><script type="math/tex; mode=display">\begin{aligned}
g_{n}&=\sum_{i=0}i^{n}r^{i}\\
&=\sum_{i=0}(i-1+1)^{n}r^{i}\\
&=\sum_{i=0}\sum_{j=0}^{n}\binom{n}{j}(i-1)^{j}r^{i}\\
&=\sum_{j=0}^{n}\binom{n}{j}\sum_{i=0}(i-1)^{j}r^{i}\\
&=n!\sum_{j=0}^{n}\cfrac{\sum_{i=0}(i-1)^{j}r^{i-1}}{j!}\cfrac{r}{(n-j)!}\\
\cfrac{g_{n}}{n!}&=\sum_{j=0}^{n}\cfrac{g_{j}}{j!}\cfrac{r}{(n-j)!}\\
\end{aligned}</script><p>我们不难发现卷积的形式。于是此题完。告辞。</p>
<p><del>怎么这么短啊（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn];</span><br><span class="line"><span class="keyword">int</span> n,r;</span><br><span class="line"><span class="keyword">int</span> fac[maxn],fnv[maxn],F[maxn],G[maxn],H[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;x=<span class="number">1L</span>L*x*x%mod,y&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[maxn];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;++i)</span><br><span class="line">        G[i]=tmp[i]=<span class="number">0</span>;</span><br><span class="line">    G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">            tmp[k]=F[k];</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        NTT(tmp,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            G[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;maxn;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(r);</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=fnv[<span class="number">0</span>]=fnv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        fnv[i]=(mod<span class="number">-1L</span>L*mod/i*fnv[mod%i]%mod)%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        fac[i]=<span class="number">1L</span>L*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        fnv[i]=<span class="number">1L</span>L*fnv[i<span class="number">-1</span>]*fnv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cltstream::read(F[i]);</span><br><span class="line">        H[i]=(mod<span class="number">-1L</span>L*r*fnv[i]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ++H[<span class="number">0</span>];</span><br><span class="line">    Inv(H,G,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*fac[i]%mod;</span><br><span class="line">    re <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        ans=(ans+<span class="number">1L</span>L*F[i]*G[i]%mod)%mod;</span><br><span class="line">    cltstream::write(ans);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>常系数齐次线性递推式第n项的计算</title>
    <url>/linear-ditui-learning-notes/</url>
    <content><![CDATA[<p>没想到我竟然还有再次回到机房的一天。</p>
<p><del>在家颓了两个月了（</del></p>
<p>没想到我竟然还有再次开始写题的一天。</p>
<p><del>luogu都掉蓝了（</del></p>
<p>没想到我竟然还有再次更新blog的一天。</p>
<p><del>上一次还是五月份的时候（</del></p>
<p>我也不知道为什么我要学这么个东西（指标题），而且它好像还没什么用。</p>
<p>反正我就是学了。</p>
<p><del>谁能告诉我递推怎么翻译成英语。扔给google它拼命告诉我recursion（</del></p>
<p>好像扯得有点多的样子。</p>
<p><a href="https://www.luogu.org/problem/P4723">传送门</a></p>
<a id="more"></a>
<p>首先我们分析一下我们需要干什么(?)。</p>
<p>我们需要计算一个满足以下三个要求的递推数列：</p>
<ol>
<li>「常系数」，指递推过程中用到的系数与下标$n$无关。</li>
<li>「齐次」，指递推式中不存在常数项。</li>
<li>「线性」，指递推式中仅存在一次项（算上系数是二次）。</li>
</ol>
<p><del>不过好像存在常数项也能做的样子。</del></p>
<p>此类递推式一般具有以下形式</p>
<script type="math/tex; mode=display">a_{n}=\sum_{i=1}^{k}f_{i}a_{n-i}</script><p>其中$f_{1},f_{2},\cdots,f_{k}$为系数数列。</p>
<p>上式仅针对于$n\geqslant k$的情况，$n\lt k$时$a_{n}$会被给出。</p>
<p>如下定义初始向量$S$</p>
<script type="math/tex; mode=display">\begin{bmatrix}
&a_{0}&\\
&a_{1}\\
&a_{2}\\
&\vdots\\
&a_{k-3}\\
&a_{k-2}\\
&a_{k-1}
\end{bmatrix}</script><p>如下构造矩阵$A$</p>
<script type="math/tex; mode=display">\begin{bmatrix}
&0&1&0&\cdots&0&0&0&\\
&0&0&1&\cdots&0&0&0\\
&0&0&0&\cdots&0&0&0\\
&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\
&0&0&0&\cdots&0&1&0\\
&0&0&0&\cdots&0&0&1\\
&f_{k}&f_{k-1}&f_{k-2}&\cdots&f_{3}&f_{2}&f_{1}
\end{bmatrix}</script><p>我们有</p>
<script type="math/tex; mode=display">a_{n}=(A^{n}S)_{0}</script><p>于是我们计算出$A^{n}$即可。但该过程需要的时间复杂度是$O(k^{3}\log n)$的。</p>
<p>假设，我们有了一个奇妙的序列$q_{0},q_{1},\cdots,q_{k-1}$，它满足</p>
<script type="math/tex; mode=display">A^{n}=\sum_{i=0}^{k-1}q_{i}A^{i}</script><p>这样一来，我们就可以在$O(k^{4})$的时间复杂度内……</p>
<p>不，实际上我们并不需要知道整个$A^{n}$，我们仅需要知道$A^{n}S$，或者更进一步地，知道$(A^{n}S)_{0}$即可。</p>
<p>我们把上式两边乘以$S$，然后整理</p>
<script type="math/tex; mode=display">\begin{aligned}
A^{n}S&=\left(\sum_{i=0}^{k-1}q_{i}A^{i}\right)S\\
A^{n}S&=\sum_{i=0}^{k-1}q_{i}A^{i}S\\
A^{n}S&=\sum_{i=0}^{k-1}q_{i}(A^{i}S)\\
(A^{n}S)_{0}&=\sum_{i=0}^{k-1}q_{i}(A^{i}S)_{0}\\
a_{n}&=\sum_{i=0}^{k-1}q_{i}a_{i}
\end{aligned}</script><p>我们于是得到这样的式子。这使得我们能够在$O(k)$的时间复杂度内计算答案。</p>
<p>然后我们考虑如何构造$q_{i}$。</p>
<p>注意到$\sum_{i=0}^{k-1}q_{i}A^{i}$的次数比$A^{n}$低，我们令</p>
<script type="math/tex; mode=display">A^{n}=P(A)G(A)+Q(A)</script><p>其中$P,G,Q$是三个矩阵多项式，并且我们钦定$G$的次数是$k$，$PG$的次数是$n$。</p>
<p>如果说，这个$G$还满足$G(A)=0$，我们就有</p>
<script type="math/tex; mode=display">A^{n}=\sum_{i=0}^{k-1}q_{i}A^{i}=Q(A)</script><p>也就是说，我们要求的$q_{i}$，就是$Q$的系数，而$Q$是$A^{n}$对$G$取模的结果。</p>
<p>这一过程可以通过快速幂实现，只是取模从整数取模变成了多项式取模。时间复杂度$O(k\log k\log n)$。</p>
<p>于是我们考虑如何构造$G$的系数$g_{i}$。</p>
<p>通过查阅题解(??)，我们得知</p>
<script type="math/tex; mode=display">g_{i}=\begin{cases}
&-f_{k-i}\;\;\;\;\;\;\;\;&(i\lt k)\\
&1&(i=k)
\end{cases}</script><p><del>证明？不会，告辞。</del></p>
<p>总结一下就是：</p>
<ol>
<li>构造多项式$G$。</li>
<li>计算多项式$Q=A^{n}\operatorname{mod} G$。</li>
<li>计算$a_{n}=\sum_{i=0}^{k-1}q_{i}a_{i}$。</li>
</ol>
<blockquote>
<p>Updated on 2019-08-04</p>
<p><img src="/images/TIM截图20190804192526.png" alt=""></p>
<p>告辞.jpg</p>
</blockquote>
]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>向量</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>大概算是个斯特林数总结？</title>
    <url>/strling-number-notes/</url>
    <content><![CDATA[<p>看到wzx写了个斯特林数总结，于是也想来写一个。</p>
<a id="more"></a>
<h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>将$n$个有标号的元素放入$m$个无标号的集合，且不允许空集的方案数。记为${n\brace m}$。</p>
<h4 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h4><script type="math/tex; mode=display">{n\brace m}={n-1\brace m-1}+m{n-1\brace m}</script><p>考虑第$n$个元素单独构成一个集合还是加入之前的某个集合即可。</p>
<script type="math/tex; mode=display">{n\brace 0}=1\qquad(n\geqslant 0)</script><script type="math/tex; mode=display">{n\brace n}=0\qquad(n\gt 0)</script><h4 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h4><script type="math/tex; mode=display">{n\brace m}=\cfrac{1}{m!}\sum_{i=0}^{m}(-1)^{i}{m\choose i}(m-i)^{n}=\sum_{i=0}^{m}\cfrac{(-1)^{i}}{i!}\cfrac{(m-i)^{n}}{(m-i)!}</script><p>大力容斥即可。</p>
<p>不难发现等式最右边形成了卷积的形式，这使得我们能够在$O(n\log n)$的时间复杂度内计算出${n\brace i}$。</p>
<h4 id="自然数的次幂及幂和"><a href="#自然数的次幂及幂和" class="headerlink" title="自然数的次幂及幂和"></a>自然数的次幂及幂和</h4><script type="math/tex; mode=display">m^{n}=\sum_{i=1}^{m}{m\choose i}i!{n\brace i}</script><p>考虑将$n$个有标号的元素任意地放入$m$个有标号的集合。每个元素都有$m$种选择，因此总方案数为$m^{n}$。</p>
<p>在这一过程中，可能只有部分集合非空。我们枚举这些非空集合的排列，然后将所有元素放入这些集合，并且这次不允许空集。</p>
<p>显然上述两种方法是等价的。</p>
<p>利用上面这个公式，我们还可以计算自然数的幂和。</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{i=0}^{n-1}i^{m}&=[m=0]+\sum_{i=1}^{n-1}i^{m}\\
&=[m=0]+\sum_{i=1}^{n-1}\sum_{j=1}^{i}{i\choose j}j!{m\brace j}\\
&=[m=0]+\sum_{j=1}^{n-1}j!{m\brace j}\sum_{i=j}^{n-1}{i\choose j}\\
&=[m=0]+\sum_{j=1}^{n-1}j!{m\brace j}{n\choose j+1}\\
&=[m=0]+\sum_{j=1}^{n-1}{m\brace j}\cfrac{n^{\underline{j+1}}}{j+1}
\end{aligned}</script><p>关于$\sum_{i=j}^{n-1}{i\choose j}={n\choose j+1}$，我们可以认为，等式左边枚举了一个最左侧的位置，然后再在这个位置右侧选择$j$个元素。</p>
<h4 id="次幂转下降幂"><a href="#次幂转下降幂" class="headerlink" title="次幂转下降幂"></a>次幂转下降幂</h4><script type="math/tex; mode=display">x^{n}=\sum_{i=0}^{n}{n\brace i}x^{\underline{i}}</script><p>考虑数学归纳法。</p>
<script type="math/tex; mode=display">\begin{aligned}
x^{n+1}&=x\cdot x^{n}\\
&=\sum_{i=0}^{n}{n\brace i}x\cdot x^{\underline{i}}\\
&=\sum_{i=0}^{n}{n\brace i}(x-i+i)x^{\underline{i}}\\
&=\sum_{i=0}^{n}{n\brace i}x^{\underline{i+1}}+\sum_{i=0}^{n}{n\brace i}ix^{\underline{i}}\\
&=\sum_{i=0}^{n+1}{n\brace i-1}x^{\underline{i}}+\sum_{i=0}^{n+1}{n\brace i}ix^{\underline{i}}\\
&=\sum_{i=0}^{n+1}{n+1\brace i}x^{\underline{i}}
\end{aligned}</script><h3 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3><p>这里我们讨论无符号第一类斯特林数。</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>$n$个有标号的元素构成$m$个圆排列的方案数。记为${n\brack m}$。</p>
<h4 id="递推式-1"><a href="#递推式-1" class="headerlink" title="递推式"></a>递推式</h4><script type="math/tex; mode=display">{n\brack m}={n-1\brack m-1}+(n-1){n-1\brack m}</script><p>考虑第$n$个元素单独构成一个圆排列还是插入到之前的某个元素之前即可。</p>
<script type="math/tex; mode=display">{n\brack 0}=1\qquad(n\geqslant 0)</script><script type="math/tex; mode=display">{n\brack n}=0\qquad(n\gt 0)</script><h4 id="通项公式-1"><a href="#通项公式-1" class="headerlink" title="通项公式"></a>通项公式</h4><p>大概……没有吧。</p>
<h4 id="下降幂转次幂"><a href="#下降幂转次幂" class="headerlink" title="下降幂转次幂"></a>下降幂转次幂</h4><script type="math/tex; mode=display">x^{\underline{n}}=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}x^{i}</script><p>考虑数学归纳法。</p>
<script type="math/tex; mode=display">\begin{aligned}
x^{\underline{n+1}}&=(x-n)x^{\underline{n}}\\
&=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}(x-n)x^{i}\\
&=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}x^{i+1}+\sum_{i=0}^{n}(-1)^{n-i+1}{n\brack i}nx^{i}\\
&=\sum_{i=0}^{n+1}(-1)^{n-i+1}{n\brack i-1}x^{i}+\sum_{i=0}^{n+1}(-1)^{n-i+1}{n\brack i}nx^{i}\\
&=\sum_{i=0}^{n+1}(-1)^{n-i+1}{n+1\brack i}x^{i}
\end{aligned}</script><h3 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h3><p>观察下面两个式子</p>
<script type="math/tex; mode=display">\begin{aligned}
x^{n}&=\sum_{i=0}^{n}{n\brace i}x^{\underline{i}}\\
x^{\underline{n}}&=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}x^{i}
\end{aligned}</script><p>将它们套在一起</p>
<script type="math/tex; mode=display">x^{\underline{n}}=\sum_{i=0}^{n}(-1)^{n-i}{n\brack i}\sum_{j=0}^{i}{i\brace j}x^{\underline{j}}\\=\sum_{j=0}^{n}\sum_{i=j}^{n}(-1)^{n-i}{n\brack i}{i\brace j}x^{\underline{j}}</script><p>于是</p>
<script type="math/tex; mode=display">\sum_{i=m}^{n}(-1)^{n-i}{n\brack i}{i\brace m}=[m=n]</script>]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>不会起标题（理直气壮）</title>
    <url>/polynomial-xxx-notes/</url>
    <content><![CDATA[<p>从APIO回来发现luogu多了几道NTT的板子题，于是来写一下。</p>
<p>关于游记……可能不会发了。</p>
<a id="more"></a>
<h3 id="普通多项式转下降幂多项式"><a href="#普通多项式转下降幂多项式" class="headerlink" title="普通多项式转下降幂多项式"></a><a href="https://www.luogu.org/problemnew/show/P5383">普通多项式转下降幂多项式</a></h3><script type="math/tex; mode=display">x^{n}=\sum_{i=0}^{n}S(n,i)x^{\underline{i}}</script><script type="math/tex; mode=display">\begin{aligned}
\sum_{i=0}^{n-1}f_{i}x^{i}&=\sum_{i=0}^{n-1}f_{i}\sum_{j=0}^{i}S(i,j)x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{i=0}^{n-1}S(i,j)f_{i}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{i=0}^{n-1}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}f_{i}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{1}{(j-k)!}\sum_{i=0}^{n-1}(j-k)^{i}f_{i}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{F(j-k)}{(j-k)!}x^{\underline{j}}\\
&=\sum_{j=0}^{n-1}g_{j}x^{\underline{j}}
\end{aligned}</script><p>所以</p>
<script type="math/tex; mode=display">g_{i}=\sum_{j=0}^{i}\cfrac{(-1)^{j}}{j!}\cfrac{F(i-j)}{(i-j)!}</script><p>其中求$F(i-j)$需要多点求值。然而我不会。</p>
<p>告辞。</p>
<h3 id="下降幂多项式转普通多项式"><a href="#下降幂多项式转普通多项式" class="headerlink" title="下降幂多项式转普通多项式"></a><a href="https://www.luogu.org/problemnew/show/P5393">下降幂多项式转普通多项式</a></h3><script type="math/tex; mode=display">x^{\underline{n}}=\sum_{i=0}^{n}(-1)^{n-i}s(n,i)x^{i}</script><script type="math/tex; mode=display">\begin{aligned}
\sum_{i=0}^{n-1}f_{i}x^{\underline{i}}&=\sum_{i=0}^{n-1}f_{i}\sum_{j=0}^{i}(-1)^{i-j}s(i,j)x^{j}\\
&=\sum_{j=0}^{n-1}\sum_{i=0}^{n-1}(-1)^{i-j}s(i,j)f_{i}x^{j}
\end{aligned}</script><p>……告辞。</p>
<h3 id="下降幂多项式乘法"><a href="#下降幂多项式乘法" class="headerlink" title="下降幂多项式乘法"></a><a href="https://www.luogu.org/problemnew/show/P5394">下降幂多项式乘法</a></h3><p>根据提示，一个下降幂多项式可以唯一确定一个次数相同的普通多项式，我们只需要转过去乘起来再转回来就好了！</p>
<p>……大概吧。</p>
<h3 id="第二类斯特林数·行"><a href="#第二类斯特林数·行" class="headerlink" title="第二类斯特林数·行"></a><a href="https://www.luogu.org/problemnew/show/P5395">第二类斯特林数·行</a></h3><p>紫题警告。不过的确简单。第二类斯特林数的通项公式推一推就能推成卷积形式。</p>
<h3 id="第二类斯特林数·列"><a href="#第二类斯特林数·列" class="headerlink" title="第二类斯特林数·列"></a><a href="https://www.luogu.org/problemnew/show/P5396">第二类斯特林数·列</a></h3><p><del>不会。抄的题解。</del></p>
<p>定义</p>
<script type="math/tex; mode=display">S_{m}(x)=\sum_{i=0}^{+\infty}S(i,m)x^{i}</script><p>利用第二类斯特林数的递推公式</p>
<script type="math/tex; mode=display">S(n,m)=S(n-1,m-1)+mS(n-1,m)</script><p>我们有</p>
<script type="math/tex; mode=display">\begin{aligned}
S_{m}(x)&=\sum_{i=0}^{+\infty}S(i,m)x^{i}\\
&=\sum_{i=0}^{+\infty}(S(i-1,m-1)+mS(i-1,m))x^{i}\\
&=S_{m-1}(x)x+mS_{m}(x)x\\
&=\cfrac{S_{m-1}(x)x}{1-mx}\\
&=\cfrac{x^{m}}{\prod_{i=1}^{m}(1-ix)}
\end{aligned}</script><p>关于类似$\prod(1-ix)$这种的怎么计算……我怎么觉得我提过好几遍了呢（</p>
<h3 id="第一类斯特林数·行"><a href="#第一类斯特林数·行" class="headerlink" title="第一类斯特林数·行"></a><a href="https://www.luogu.org/problemnew/show/P5408">第一类斯特林数·行</a></h3><p>思路与「第二类斯特林数·列」类似。</p>
<script type="math/tex; mode=display">s(n,m)=s(n-1,m-1)+(n-1)s(n-1,m)</script><script type="math/tex; mode=display">\begin{aligned}
s_{n}(x)&=\sum_{i=0}^{+\infty}s(n,i)x^{i}\\
&=\sum_{i=0}^{+\infty}(s(n-1,i-1)+(n-1)s(n-1,i))x^{i}\\
&=(n-1+x)s_{n-1}(x)\\
&=\prod_{i=0}^{n-1}(i+x)
\end{aligned}</script><h3 id="第一类斯特林数·列"><a href="#第一类斯特林数·列" class="headerlink" title="第一类斯特林数·列"></a><a href="https://www.luogu.org/problemnew/show/P5409">第一类斯特林数·列</a></h3><p>我们发现「第二类斯特林数·列」和「第一类斯特林数·行」的思路行不通了。</p>
<p><del>题解，打开。</del></p>
<p>我们来观察一下这个式子</p>
<script type="math/tex; mode=display">(1+x)^{t}</script><p><del>似乎并没有什么用。</del></p>
<script type="math/tex; mode=display">\begin{aligned}
(1+x)^{t}&=\sum_{i=0}^{t}C(t,i)x^{i}\\
&=\sum_{i=0}^{+\infty}C(t,i)x^{i}\\
&=\sum_{i=0}^{+\infty}\cfrac{t^{\underline{i}}}{i!}x^{i}\\
&=\sum_{i=0}^{+\infty}\cfrac{1}{i!}\sum_{j=0}^{i}(-1)^{i-j}s(i,j)t^{j}x^{i}\\
&=\sum_{j=0}^{+\infty}\sum_{i=j}^{+\infty}\cfrac{1}{i!}(-1)^{i-j}s(i,j)x^{i}t^{j}\\
(1+x)^{t}&=e^{t\ln(1+x)}\\
&=\sum_{i=0}^{+\infty}\cfrac{(1+x)^{i}}{i!}t^{i}\\
&=\sum_{i=0}^{+\infty}\cfrac{1}{i!}\sum_{j=0}^{i}C(i,j)x^{j}t^{i}
\end{aligned}</script><p>根据上面两个不同的整理过程，我们有</p>
<script type="math/tex; mode=display">\sum_{i=0}^{+\infty}\sum_{j=i}^{+\infty}\cfrac{1}{j!}(-1)^{j-i}s(j,i)x^{j}t^{i}=\sum_{i=0}^{+\infty}\cfrac{1}{i!}\sum_{j=0}^{i}C(i,j)x^{j}t^{i}</script><p>进一步地</p>
<script type="math/tex; mode=display">\sum_{j=i}^{+\infty}\cfrac{1}{j!}(-1)^{j-i}s(j,i)x^{j}=\cfrac{1}{i!}\sum_{j=0}^{i}C(i,j)x^{j}</script>]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「CF570D」Tree Requests</title>
    <url>/cf570d-solution/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/570/D">传送门</a></p>
<a id="more"></a>
<p>听说是道dsu on tree的题。然而我不会dsu（</p>
<p>我们把题目给的字母$c$转化成$2^{c-\mathrm{a}}$。这样如果一些节点的权值异或和是$2^{k}(k\in\mathbb{N}^{+})$或$0$，它们就能够排列成回文串。</p>
<p>我们想到，如果我们能将这些节点重新编号，使得每个询问涉及到的所有节点的新编号都是一个连续的区间，我们就可以直接提取出前缀和。</p>
<p>那么如何编号？BFS序。</p>
<p>一个显然的性质是，如果我们在构建DFS序和BFS序时访问每条边的顺序一致，那么对于深度相同且BFS序递增的一段区间，它们的DFS序一定也是递增的。</p>
<p>于是我们在构建BFS序时预处理每个深度的节点的对应区间，然后二分定位到$v_{i}$的子树内的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ec;</span><br><span class="line"><span class="keyword">int</span> des[maxn+<span class="number">1</span>],suc[maxn+<span class="number">1</span>],las[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn+<span class="number">1</span>],dep[maxn+<span class="number">1</span>],size[maxn+<span class="number">1</span>],h[maxn+<span class="number">1</span>],p[maxn+<span class="number">1</span>],bfn[maxn+<span class="number">1</span>],lwr[maxn+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">1</span>],val[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    des[++ec]=y;</span><br><span class="line">    suc[ec]=las[x];</span><br><span class="line">    las[x]=ec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(re <span class="keyword">int</span> cur,re <span class="keyword">int</span> ftr)</span></span>&#123;</span><br><span class="line">    dfn[cur]=++dfn[<span class="number">0</span>];</span><br><span class="line">    dep[cur]=dep[ftr]+<span class="number">1</span>;</span><br><span class="line">    size[cur]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[cur];i;i=suc[i])&#123;</span><br><span class="line">        dfs(des[i],cur);</span><br><span class="line">        size[cur]+=size[des[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cltstream::read(x);</span><br><span class="line">        connect(x,i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    h[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;head&lt;tail;)&#123;</span><br><span class="line">        re <span class="keyword">int</span> x=h[++head];</span><br><span class="line">        p[head]=dfn[x];</span><br><span class="line">        bfn[x]=head;</span><br><span class="line">        dep[x]&gt;dep[h[head<span class="number">-1</span>]]&amp;&amp;(lwr[dep[x]]=head);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=las[x];i;i=suc[i])</span><br><span class="line">            h[++tail]=des[i];</span><br><span class="line">    &#125;</span><br><span class="line">    lwr[dep[h[n]]+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        re <span class="keyword">char</span> c=cltstream::gc();</span><br><span class="line">        <span class="keyword">for</span>(;c&lt;<span class="string">'a'</span>||c&gt;<span class="string">'z'</span>;c=cltstream::gc());</span><br><span class="line">        a[i]=<span class="number">1</span>&lt;&lt;(c-<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        val[i]=val[i<span class="number">-1</span>]^a[h[i]];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cltstream::read(x);</span><br><span class="line">        cltstream::read(y);</span><br><span class="line">        re <span class="keyword">int</span> L=<span class="built_in">std</span>::lower_bound(p+lwr[y],p+lwr[y+<span class="number">1</span>],dfn[x])-p;</span><br><span class="line">        re <span class="keyword">int</span> R=<span class="built_in">std</span>::lower_bound(p+lwr[y],p+lwr[y+<span class="number">1</span>],dfn[x]+size[x])-p<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=R)&#123;</span><br><span class="line">            re <span class="keyword">int</span> v=val[R]^val[L<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>((v&amp;(v<span class="number">-1</span>))==<span class="number">0</span>)</span><br><span class="line">                cltstream::pc(<span class="string">'Y'</span>),cltstream::pc(<span class="string">'e'</span>),cltstream::pc(<span class="string">'s'</span>),cltstream::pc(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cltstream::pc(<span class="string">'N'</span>),cltstream::pc(<span class="string">'o'</span>),cltstream::pc(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cltstream::pc(<span class="string">'Y'</span>),cltstream::pc(<span class="string">'e'</span>),cltstream::pc(<span class="string">'s'</span>),cltstream::pc(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>BFS序</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2019R2游记」不会起标题了</title>
    <url>/sdoi2019r2-notes/</url>
    <content><![CDATA[<p>我好菜啊。</p>
<a id="more"></a>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>上午loli搞了场模拟赛。</p>
<p>发的第一套题目好像学长们都做过，于是又发了第二套。</p>
<p>然后神仙hz随手秒了T2。</p>
<p>想我这种辣鸡只能在旁边看着。</p>
<p>到最后还是没有人认真写，快乐地颓废了一个上午。</p>
<p>下午当然是回家。</p>
<p>感觉自己最近日渐颓废。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>一觉睡到11点，然后去学校坐车。</p>
<p>因为人很少所以可以一个人占两个位，虽然我一轮时也是这么坐的。</p>
<p>一路上一边听音乐一边睡觉不知不觉到了济南。</p>
<p>然后翻山越岭走了1km的路去试机。济南的坡多到爆炸。</p>
<p>去抽签发现抽到了最后一个编号83号，这一定预示着我要垫底了。</p>
<p>试机的时候什么也没干，就那么看着其他的神仙敲键盘。</p>
<p>……差点忘了一件事，考场的键盘Ctrl不在最左下角，最左下角是Fn，再往右才是Ctrl，按起来肥肠别扭。</p>
<p>本来loli是想让我们出去吃的，结果我们集体跳车，就只剩下hz、cst、dsq三个人在那<del>，想想还有点尬</del>。</p>
<p>于是什么也没吃。</p>
<p>晚上玩了玩鬼形兽，不知道是因为资源太少还是啥，糟了好一段时间才通。</p>
<p>睡觉前loli日常奶人。</p>
<h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>总之是7点下去吃了早饭。然后再次翻山越岭去考场。</p>
<p>开考前可以随便动键盘，然而就算这样也没干啥。</p>
<p>解压密码画风似乎海星的样子。</p>
<p>首先大概扫了一眼三道题。回来看T1，我们发现这是一道简单题。</p>
<p>然而我却因为这道题调了1h+。自闭。</p>
<p>T2不会，什么毒瘤题部分分都不给的。</p>
<p>T3大概会20左右。</p>
<p>除了考场发现人均120，这样要是一不小心写挂了哪直接就没了啊。</p>
<p>咕掉了下午的讲题。</p>
<p>成绩发下来发现自己100+0+10=110，海星。</p>
<p>然后同级的其他神仙：</p>
<ul>
<li>cst：100+0+10=110</li>
<li>shzr：50+0+20=70</li>
<li>wyx：50+0+0=50</li>
<li>wzx：0+0+20=20</li>
</ul>
<p><del>然后一看rqy甚至也0+100+0=100，但是他切了T2啊orz。</del></p>
<p>大概看了一下群里发的题解，不过自然是什么也看不懂。</p>
<p>快乐地颓了一个下午。</p>
<p><del>闲着没事开了一把桃源宫PH，结果打到终符loli突然杀了进来。</del></p>
<p>然后莫名其妙被loli奶了一口，「zyc比较稳」<del>，于是伏笔就这么埋下了</del>。</p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>本来对今天也没报多少希望。</p>
<p>拿到压缩包发现今天似乎没有大样例。</p>
<p>解压完之后，还是扫一眼三道题。感觉一道都不会的样子。</p>
<p>去看了看T2，发现好像是个阶梯Nim……但是我不会啊。</p>
<p>开始打表。结果好像真的打出规律来了。</p>
<p>于是头铁玩了5h的T2。并且喜提爆零。</p>
<p>看他们好像都会T1的样子……自闭。</p>
<p>并没有怎么看成绩。反正都爆零了就这样吧。</p>
<p>听wzx说shzr从最开始稳到现在，结果最后一天翻车让wyx翻进女队。</p>
<p>走到最后来发现自己什么也没有，就这样回去了。</p>
<p>大概这就是菜鸡的命运吧。</p>
<p>回头一看，似乎自从一轮D2炸掉之后，我就不应该报太大希望的。</p>
<p>虽然说勉强苟进了二轮，但是这并没有什么用。</p>
<p>告辞。然后一想到后面还有合格考……去世.jpg</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>论一条咸鱼如何瞎搞「WC2015」未来程序</title>
    <url>/luogu-p4920-solving-notes/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4920">传送门</a></p>
<p><del>说不定还会持续更新？（</del></p>
<a id="more"></a>
<h3 id="2019-04-26"><a href="#2019-04-26" class="headerlink" title="2019-04-26"></a>2019-04-26</h3><p>闲得没事翻到这道题了想试一试。</p>
<p>首先看到测试点1。</p>
<p>很明显的一个$a\times b\operatorname{mod}c$。</p>
<p>啊什么爆<code>unsigned long long</code>？Python了解一下（</p>
<p>然后去看测试点2。</p>
<p>差不多能总结出这么一个规律来</p>
<script type="math/tex; mode=display">a_{0}=1\;\;\;\;b_{0}=0\;\;\;\;c_{0}=0</script><script type="math/tex; mode=display">a_{n}=a_{n-1}+2b_{n-1}+c_{n-1}\;\;\;\;b_{n}=a_{n-1}+b_{n-1}\;\;\;\;c_{n}=a_{n-1}</script><script type="math/tex; mode=display">\text{Ans}=a_{n}-2b_{n}+c_{n}</script><p>然后手动打表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$</th>
<th style="text-align:center">$a_{n}$</th>
<th style="text-align:center">$b_{n}$</th>
<th style="text-align:center">$c_{n}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$9$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$4$</td>
</tr>
<tr>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$25$</td>
<td style="text-align:center">$15$</td>
<td style="text-align:center">$9$</td>
</tr>
<tr>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$64$</td>
<td style="text-align:center">$40$</td>
<td style="text-align:center">$25$</td>
</tr>
</tbody>
</table>
</div>
<p>然后发现$a_{n}=F_{n+1}^{2}$，于是推出$b_{n}=\sum_{i=0}^{n}F_{i}^{2}$，$c_{n}=F_{n}^{2}$。</p>
<p>有一个结论是$\sum_{i=0}^{n}F_{i}^{2}=F_{n}F_{n+1}$，证明也不难。于是就这样xjb写了个矩乘。</p>
<p>然后去看测试点3。</p>
<p>自然数$k$次方和，恩没难……等等四次方和是啥（</p>
<p><a href="https://www.zybang.com/question/cd5fa7b364c5ac9f3194eac2525ae6aa.html">https://www.zybang.com/question/cd5fa7b364c5ac9f3194eac2525ae6aa.html</a></p>
<p>光速逃（</p>
<p>然后去看测试点4。</p>
<p>如果把<code>1</code>看成黑点，<code>0</code>看成白点，<code>type=0</code>就是在遍历所有黑点对，直接一个$\text{cnt}(\text{cnt}-1)$解决。</p>
<p><code>type=1</code>就是对于每个黑点，求出其到所有白点的曼哈顿距离的最小值，再求和。</p>
<p>不难想到枚举这个最小值，虽然复杂度很假但是数据随机啊（</p>
<p>然后去看测试点5。</p>
<p>很明显的仅包含黑点的矩形的计数……等等，这不就是半个<a href="https://www.luogu.org/problemnew/show/P5300">与或和</a>吗（</p>
<p>然后我就突然回想起来了，那道题WA成0分的记忆。</p>
<p>先把前4个点交上去看看吧。然后10+1+10+6=27。</p>
<p>诶我测试点4怎么6分啊……一看发现<code>type=0</code>写成了$\cfrac{1}{2}\text{cnt}(\text{cnt}-1)$……</p>
<p>关于测试点2……先放一放。</p>
<p>然后去看测试点6。</p>
<p>感觉不怎么会光速弃疗。</p>
<p>然后去看测试点7。</p>
<p>经过一番分析，我发现这是在求给定数独字典序最小的解，然后第$i$组数据输出前$i$行？（并不是）</p>
<p>打了个爆搜然后跑到死也只跑出来前三组。</p>
<p>哦不我连搜索都不会写了，我失败了:(</p>
<p>然后去看测试点8。</p>
<p>大致可以抽象成是给你7个点，每个点权值$w_{i}\in[1,n]\cap\mathbb{N}$，再给你一些边，对于一条边$(x,y)$，必须要有$w_{x}\lt w_{y}$，求方案数。</p>
<p>第1问给了一条链，很明显方案数就是$C_{n}^{7}$。</p>
<p>看到后9问好像十分麻烦，先跳过吧。</p>
<p>然后去看测试点9。</p>
<p>一上来一坨字符画一样的东西差点吓到我。</p>
<p>从VSCode右边的缩略图里能够很明显看出是一个人。</p>
<p>在仔细阅读了代码之后，我发现这是10道解答题。</p>
<p>然后……诶好像差不多该溜了。</p>
<h3 id="2019-04-27"><a href="#2019-04-27" class="headerlink" title="2019-04-27"></a>2019-04-27</h3><p>一大早上被比我不知道强到哪里去了的asuldb安利了一道<a href="/luogu-p5176-solution/">看上去很吓人的题</a>。</p>
<p>继续来搞这道提答。</p>
<p>答上了测试点9的前两问，然后去看测试点10……？？！！</p>
<p>这是什么鬼东西怎么这么一大坨子函数……</p>
<p>一开始没看源文件大小，后来一看发现竟然有1000+KB。</p>
<p>吓得我电脑都卡了。</p>
<p>发现本质上是让求<code>_()</code>这个函数的调用次数。于是我就让这个函数返回1，其他函数返回它调用的所有函数的返回值之和。</p>
<p>然后……算是勉强凑出来前3问，5行左右。</p>
<p>一交……诶我后两个点怎么还RE了？</p>
<p>不会是我没交4和5的<code>.out</code>文件吧……然后发现还真是，补上去两个空文件之后评测结果正常了，10+1+10+10+0+0+0+1+2+5=39。</p>
<p>然后发现测试点7实际上是将整个数独压成一行复读$i$遍。（好像也不是）</p>
<p>6，8，9，10四个点挣扎了一会还是弃疗了。</p>
<p>回去看测试点5……想到反正数据随机，写了一个稍微优化了一点的暴力。</p>
<p>然后改了改测试点2。一交发现什么变化都没有。</p>
<p><del>luogu又出锅了？这么想着</del>又交了一遍，然后还是什么变化都没有。</p>
<p>// 以上内容差不多是以回忆的形式写下来的。接下来差不多是边调题边写（</p>
<p>然后发现我测试点5的二维前缀和写错了（</p>
<p>仔细一推测试点2发现</p>
<script type="math/tex; mode=display">\begin{aligned}
\text{Ans}&=F_{n+1}^{2}-2\sum_{i=0}^{n}F_{i}^{2}+F_{n}^{2}\\
&=F_{n+1}^{2}-2F_{n+1}F_{n}+F_{n}^{2}\\
&=F_{n-1}^{2}
\end{aligned}</script><p>但是就算这样也不应该WA啊……写了个暴力发现是因为偷懒矩阵没清空……</p>
<p>然后再一交，10+10+10+10+10+0+0+1+2+5=58。</p>
<p>然后我突然有了一个想法，对于测试点10，我可以直接用一个<code>std::map</code>维护出源文件中的所有函数的值啊。</p>
<p>写了写一交……诶怎么还少了4分？</p>
<p>一检查发现只是计算了调用次数，忘了再乘以那个<code>___</code>。</p>
<p>于是再一交，10+10+10+10+10+0+0+1+2+10=63。</p>
<p>回去看了看测试点7，感觉没救了，于是想搞一搞测试点9。</p>
<p>看到第4问的答案只有3个字符，直接搜于是搜出来一个<script type="math/tex">_</script>。</p>
<p>再像这样搜了一下第5问发现是<code>we</code>。</p>
<p>考虑到后面都是英文单词了于是把枚举的范围压缩到了<code>a</code>~<code>z</code>。</p>
<p>然后搜出了第6问是<code>hold</code>，第7问是<code>these</code>。</p>
<p>然后上百度一查发现这句话是<code>we hold these truths to be self-evident</code>。</p>
<p>那么还剩第3问那个人名……这种问题无解吧，尤其是对于我这种咸鱼来说。</p>
<p>于是一交，10+10+10+10+10+0+0+1+9+10=70。</p>
<p>简单推了一下测试点7，发现指数非常有规律，于是把系数扔到OEIS搜了一波。</p>
<p>虽然是<a href="http://oeis.org/A137560">找到了</a>，但是公式也没有生成函数也没有什么也没有。</p>
<p>下面还给我来一行approved（</p>
<p>弃疗。告辞。</p>
]]></content>
      <categories>
        <category>瞎搞</category>
      </categories>
      <tags>
        <tag>提交答案</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5178」公约数</title>
    <url>/luogu-p5176-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5176">传送门</a></p>
<a id="more"></a>
<p>首先我们看到要求的这个式子……这什么鬼啊能做吗（</p>
<p>冷静分析一波，我们可以根据括号里的两个加号将原式拆分成三个三重$\sum$</p>
<script type="math/tex; mode=display">\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(i,j)}{(i,k)\cdot(j,k)}\\
+&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(i,k)}{(i,j)\cdot(j,k)}\\
+&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(j,k)}{(i,j)\cdot(i,k)}
\end{aligned}</script><p>首先我们单独考虑第一个</p>
<script type="math/tex; mode=display">\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,ik,jk)\cdot(i,j,k)\cdot\cfrac{(i,j)}{(i,k)\cdot(j,k)}\\
=&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{p}(ij,(i,j)k)\cdot((i,j),k)\cdot\cfrac{(i,j)}{(i,k)\cdot(j,k)}\\
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}(d^{2}xy,dk)\cdot(d,k)\cdot\cfrac{d}{(dx,k)\cdot(dy,k)}\\
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}d^{2}\cdot(d,k)\cdot\cfrac{(dxy,k)}{(dx,k)\cdot(dy,k)}\\
\end{aligned}</script><p>考虑将$d,x,y,k$写成唯一分解形式，然后对于第$i$小的质数$c_{i}$，它在四个数中的指数分别是$r_{d,i},r_{x,i},r_{y,i},r_{k,i}$，那么</p>
<script type="math/tex; mode=display">\begin{aligned}
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}d^{2}\prod_{i=1}c_{i}^{\min(r_{d,i},r_{k,i})+\min(r_{d,i}+r_{x,i}+r_{y,i},r_{k,i})-\min(r_{d,i}+r_{x,i},r_{k,i})-\min(r_{d,i}+r_{y,i},r_{k,i})}
\end{aligned}</script><p>因为$x\perp y$，$r_{x,i}$和$r_{y,i}$中必定有一个为$0$，带入整理后我们得到</p>
<script type="math/tex; mode=display">\begin{aligned}
=&\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\lfloor\tfrac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\tfrac{m}{d}\rfloor}[x\perp y]\sum_{k=1}^{p}d^{2}\\
=&p\sum_{i=1}^{n}\sum_{j=1}^{m}(i,j)^{2}
\end{aligned}</script><p>对剩下的两个三重$\sum$也进行类似的化简，最后我们得到答案就是</p>
<script type="math/tex; mode=display">p\sum_{i=1}^{n}\sum_{j=1}^{m}(i,j)^{2}+m\sum_{i=1}^{n}\sum_{j=1}^{p}(i,j)^{2}+n\sum_{i=1}^{m}\sum_{j=1}^{p}(i,j)^{2}</script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「JSOI2015」染色问题</title>
    <url>/bzoj4487-solution/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4487">传送门</a></p>
<p>sto <a href="https://www.cnblogs.com/asuldb/p/10775580.html">asuldb</a> orz</p>
<a id="more"></a>
<p>我们平时遇到的一维容斥大概长这样</p>
<script type="math/tex; mode=display">F_{i}=\sum_{x=i}^{n}C_{x}^{i}G_{x}\Leftrightarrow G_{i}=\sum_{x=i}^{n}(-1)^{x-i}C_{x}^{i}F_{x}</script><p>如果说遇到高维容斥，我们只需要一维一维地解决掉即可。</p>
<p>但实际上，我们是可以总结出一个$k$维容斥的式子的</p>
<script type="math/tex; mode=display">F_{i_{1},i_{2},\cdots,i_{k}}=\sum_{x_{1}=i_{1}}^{n_{1}}\sum_{x_{2}=i_{2}}^{n_{2}}\cdots\sum_{x_{k}=i_{k}}^{n_{k}}\left(\prod_{j=1}^{k}C_{x_{j}}^{i_{j}}\right)G_{x_{1},x_{2},\cdots,x_{k}}\Leftrightarrow G_{i_{1},i_{2},\cdots,i_{k}}=\sum_{x_{1}=i_{1}}^{n_{1}}\sum_{x_{2}=i_{2}}^{n_{2}}\cdots\sum_{x_{k}=i_{k}}^{n_{k}}\left(\prod_{j=1}^{k}(-1)^{x_{j}-i_{j}}C_{x_{j}}^{i_{j}}\right)F_{x_{1},x_{2},\cdots,x_{k}}</script><p>没错，这道题就是一个三维容斥的大板子。</p>
<p>我们令至少$i$行$j$列为空，至少$k$种颜色未出现的方案数为$F_{i,j,k}$，我们有</p>
<script type="math/tex; mode=display">F_{i,j,k}=C_{n}^{i}C_{m}^{j}C_{c}^{k}(c-k+1)^{(n-i)(m-j)}</script><p><del>话又说回来了这个东西应该是会算重啊（</del></p>
<p>恰有$i$行$j$列为空，恰有$k$种颜色未出现的方案数为$G_{i,j,k}$，自然</p>
<script type="math/tex; mode=display">F_{i,j,k}=\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}C_{x}^{i}C_{y}^{j}C_{z}^{k}G_{x,y,z}</script><script type="math/tex; mode=display">\begin{aligned}
G_{i,j,k}&=\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{x}^{i}C_{y}^{j}C_{z}^{k}F_{x,y,z}\\
&=\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{x}^{i}C_{y}^{j}C_{z}^{k}C_{n}^{x}C_{m}^{y}C_{c}^{z}(c-z+1)^{(n-x)(m-y)}\\
&=C_{n}^{i}C_{m}^{j}C_{c}^{k}\sum_{x=i}^{n}\sum_{y=j}^{m}\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{n-i}^{x-i}C_{m-j}^{y-j}C_{c-k}^{z-k}(c-z+1)^{(n-x)(m-y)}\\
&=C_{n}^{i}C_{m}^{j}C_{c}^{k}\sum_{x=0}^{n-i}\sum_{y=0}^{m-j}\sum_{z=0}^{c-k}(-1)^{x+y+z}C_{n-i}^{x}C_{m-j}^{y}C_{c-k}^{z}(c-k-z+1)^{(n-i-x)(m-j-y)}\
\end{aligned}</script><p>我们要求的答案就是$G_{0,0,0}$，简单整理一下就是</p>
<script type="math/tex; mode=display">\sum_{x=0}^{n}\sum_{y=0}^{m}\sum_{z=0}^{c}(-1)^{x+y+z}C_{n}^{x}C_{m}^{y}C_{c}^{z}(c-z+1)^{(n-x)(m-y)}</script><p>然后你问我为什么要写一篇blog？<del>闲得没事干（</del></p>
<p>代码瞎写的就不贴了（</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI2016」循环之美</title>
    <url>/luogu-p1587-solution/</url>
    <content><![CDATA[<p>突然被wzx安利的一道题。</p>
<p><a href="https://www.luogu.org/problemnew/show/P1587">传送门</a></p>
<p><a href="https://www.cnblogs.com/asuldb/p/10706088.html">wzx的题解</a></p>
<a id="more"></a>
<p><del>通过查阅fuge的题解，</del>我们发现我们要求的式子是</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]</script><p>$[i\perp j]$保证了这是一个最简分数从而不会算重，$[j\perp k]$保证了这是一个纯循环小数。</p>
<p>首先关于$[1,n]$中与某个常数$k$互质的数的数量，我们有一个结论</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}[i\perp k]=\sum_{i=1}^{n}\sum_{x|i,x|k}\mu(x)=\sum_{x|k}\lfloor\cfrac{n}{x}\rfloor\mu(x)</script><p>然后大力整理</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]&=\sum_{j=1}^{m}[j\perp k]\sum_{i=1}^{n}[i\perp j]\\
&=\sum_{j=1}^{m}[j\perp k]\sum_{x|j}\lfloor\cfrac{n}{x}\rfloor\mu(x)\\
&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{x|j}[j\perp k]\\
&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[jx\perp k]\\
&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[j\perp k]\\
&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{y|k}\lfloor\cfrac{m}{xy}\rfloor\mu(y)
\end{aligned}</script><p>这道题有一个突破口在于，$k$的范围很小，只有$2000$，从而$d(k)$的范围会更小，这就使得我们能够暴力枚举$k$的约数来计算第二个$\sum$。</p>
<p>观察第一个$\sum$，我们发现，套上一层整除分块之后，我们需要计算的是</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}f(i)</script><p>其中</p>
<script type="math/tex; mode=display">f(n)=[n\perp k]\mu(n)</script><p>考虑杜教筛，我们再找来一个函数</p>
<script type="math/tex; mode=display">g(n)=[n\perp k]</script><p>把它们卷积</p>
<script type="math/tex; mode=display">\begin{aligned}
(f\times g)(n)&=\sum_{d|n}f(d)g(\cfrac{n}{d})\\
&=\sum_{d|n}[d\perp k][\cfrac{n}{d}\perp k]\mu(d)\\
&=[n\perp k]\sum_{d|n}\mu(d)\\
&=\epsilon(n)
\end{aligned}</script><p>然后就差不多了。</p>
<p>不过有一个问题，像这种对$n$和$m$同时整除分块的情况，不能用类似min_25的trick（$N\leqslant\sqrt{n}$时存到<code>ans1[N]</code>，否则存到<code>ans2[n/N]</code>），只能通过unordered_map或者Hash来记忆化。</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">50</span>],f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],mu[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">T</span><span class="params">(re <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d[<span class="number">0</span>];++i)</span><br><span class="line">        res+=<span class="number">1L</span>L*(x/d[i])*mu[d[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=maxn)</span><br><span class="line">        <span class="keyword">return</span> F[N];</span><br><span class="line">    <span class="keyword">if</span>(ans.count(N))</span><br><span class="line">        <span class="keyword">return</span> ans[N];</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,lst=T(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=N;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=N/(N/l);</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> tmp=T(r);</span><br><span class="line">        res-=S(N/l)*(tmp-lst);</span><br><span class="line">        lst=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[N]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    cltstream::read(k);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">        <span class="keyword">if</span>(k%i==<span class="number">0</span>)</span><br><span class="line">            d[++d[<span class="number">0</span>]]=i;</span><br><span class="line">    mu[<span class="number">1</span>]=F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">            F[i]=-(k%i!=<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%g[j])&#123;</span><br><span class="line">                mu[i*g[j]]=mu[i]*mu[g[j]];</span><br><span class="line">                F[i*g[j]]=F[i]*F[g[j]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        F[i]+=F[i<span class="number">-1</span>];</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>,lst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n&amp;&amp;l&lt;=m;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> tmp=S(r);</span><br><span class="line">        res+=(n/l)*T(m/l)*(tmp-lst);</span><br><span class="line">        lst=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::write(res);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>FWT抄袭笔记</title>
    <url>/fwt-learning-notes/</url>
    <content><![CDATA[<p>看到坐在我左边的dalao在学FWT。</p>
<p>想着二轮前学一些很酷很炫<del>很失败</del>的算法，于是来<del>背一下</del>学一下吧。</p>
<p><a href="http://www.cnblogs.com/cjyyb/p/9065615.html">抄袭来源</a>。</p>
<a id="more"></a>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们利用FFT可以在$O(n\log n)$的时间复杂度内计算</p>
<script type="math/tex; mode=display">H[k]=(F\times G)[k]=\sum_{i+j=k}F[i]G[j]</script><p>假如说我们把这个式子变一变</p>
<script type="math/tex; mode=display">H[k]=(F\vee G)[k]=\sum_{i\vee j=k}F[i]G[j]</script><script type="math/tex; mode=display">H[k]=(F\wedge G)[k]=\sum_{i\wedge j=k}F[i]G[j]</script><script type="math/tex; mode=display">H[k]=(F\oplus G)[k]=\sum_{i\oplus j=k}F[i]G[j]</script><p>其中$\vee$指按位或，$\wedge$指按位与，$\oplus$指按位异或。</p>
<p>我们还是希望能够在$O(n\log n)$的时间复杂度内计算出答案。</p>
<p>这种时候我们就需要FWT（快速沃尔什变换，Fast Walsh–Hadamard Transformation）了。</p>
<p>在FFT中，我们先计算出了$F$和$G$的点值多项式，然后将对应位直接相乘得到了$F\times G$的点值多项式，最后还原回了$F\times G$。</p>
<p>类似地，我们可不可以试着计算出两个多项式$F^{\prime},G^{\prime}$，使得</p>
<script type="math/tex; mode=display">(F\times G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p><del>当然可以啊不然还怎么会有FWT（</del></p>
<h3 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h3><p>对于两个向量$A$和$B$，我们令</p>
<script type="math/tex; mode=display">(A,B)=(A[0],A[1],\cdots,B[0],B[1],\cdots)</script><p>设$F$的项数为$2^{t}$。为了方便，我们将其看做一个$2^{t}$维向量</p>
<script type="math/tex; mode=display">(F[0],F[1],\cdots,F[2^{t}-1])</script><p>然后我们定义</p>
<script type="math/tex; mode=display">F_{0}=(F[0],F[1],\cdots,F[2^{t-1}-1])</script><script type="math/tex; mode=display">F_{1}=(F[2^{t-1}],F[2^{t-1}+1],\cdots,F[2^{t}-1])</script><h3 id="正变换"><a href="#正变换" class="headerlink" title="正变换"></a>正变换</h3><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p>定义</p>
<script type="math/tex; mode=display">F^{\prime}=\begin{cases}
&(F_{0}^{\prime},F_{1}^{\prime}+F_{0}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\
&F&(t=0)
\end{cases}</script><p>我们发现</p>
<script type="math/tex; mode=display">F^{\prime}[i]=\sum_{j\vee i=i}F[j]</script><p>$t=0$时这十分显然，我们来考虑$t\gt 0$时的情况。</p>
<p>首先很明显的一点是$j\vee i=i\Leftrightarrow j\subseteq i$，也就是说$j$是$i$的子集。</p>
<p>对于$F_{1}$中的一个下标$i$，我们在$F_{1}$左边接上$F_{0}$后，这个$i$就多了一个$2^{t-1}$。</p>
<p>之前$i$的每一个子集$j$，也同样多了一个$2^{t-1}$，它们产生的贡献已经被统计在了$F_{1}^{\prime}[i]$内。</p>
<p>那么去掉这个$2^{t-1}$，我们还有$j\subseteq i+2^{t-1}$，这部分其实就是$F_{0}^{\prime}[i]$的值。</p>
<p>据此，我们就有</p>
<script type="math/tex; mode=display">\begin{aligned}
F^{\prime}\cdot G^{\prime}[i]&=\left(\sum_{j\subseteq i}F[j]\right)\left(\sum_{k\subseteq i}G[k]\right)\\
&=\sum_{j\vee k\subseteq i}F[j]G[k]\\
&=\sum_{l\subseteq i}\sum_{j\vee k=l}F[j]G[k]\\
&=\sum_{l\subseteq i}(F\vee G)[l]\\
&=(F\vee G)^{\prime}[i]
\end{aligned}</script><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><p>定义</p>
<script type="math/tex; mode=display">F^{\prime}=\begin{cases}
&(F_{0}^{\prime}+F_{1}^{\prime},F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\
&F&(t=0)
\end{cases}</script><p>它具有类似的性质</p>
<script type="math/tex; mode=display">F^{\prime}[i]=\sum_{j\wedge i=i}F[j]</script><script type="math/tex; mode=display">(F\wedge G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>证明略。</p>
<h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><p>定义</p>
<script type="math/tex; mode=display">F^{\prime}=\begin{cases}
&(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\
&F&(t=0)
\end{cases}</script><p>然后我们发现按位异或并没有像上面一样的和子集相关的性质。因此我们需要通过一些其他方式来证明它的正确性。</p>
<p>首先</p>
<script type="math/tex; mode=display">(F+G)^{\prime}=F^{\prime}+G^{\prime}</script><p>如果$F$和$G$都只有一项，这十分显然。</p>
<p>否则</p>
<script type="math/tex; mode=display">\begin{aligned}
F^{\prime}+G^{\prime}&=(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})+(G_{0}^{\prime}+G_{1}^{\prime},G_{0}^{\prime}-G_{1}^{\prime})\\
&=(F_{0}^{\prime}+G_{0}^{\prime}+F_{1}^{\prime}+G_{1}^{\prime},F_{0}^{\prime}+G_{0}^{\prime}-F_{1}^{\prime}-G_{1}^{\prime})\\
&=((F+G)_{0}^{\prime}+(F+G)_{1}^{\prime},(F+G)_{0}^{\prime}-(F+G)_{1}^{\prime})\\
&=(F+G)^{\prime}
\end{aligned}</script><script type="math/tex; mode=display">(F\oplus G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>这个不会证，告辞。</p>
<h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>就是把刚刚算出来的$F^{\prime}$变回$F$。</p>
<script type="math/tex; mode=display">F=\begin{cases}
&F^{\prime}&(t=0)\\
&\begin{cases}
&(F_{0},F_{1}-F_{0})&(\vee)\\
&(F_{0}-F_{1},F_{1})&(\wedge)\\
&(\cfrac{F_{0}+F_{1}}{2},\cfrac{F_{0}-F_{1}}{2})\;\;\;\;\;\;\;\;&(\oplus)
\end{cases}\;\;\;\;\;\;\;\;&(t\gt 0)
\end{cases}</script><p><del>啥意思啊看不懂啊（</del></p>
<p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P4717">板子题</a>了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>],G[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FWT(F,tp) &#123;\</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;n;p&lt;&lt;=<span class="number">1</span>)\</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)\</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;\</span><br><span class="line">                F[j+p][<span class="number">0</span>]=!tp?(F[j+p][<span class="number">0</span>]+F[j][<span class="number">0</span>])%mod:(F[j+p][<span class="number">0</span>]-F[j][<span class="number">0</span>]+mod)%mod;\</span><br><span class="line">                F[j][<span class="number">1</span>]=!tp?(F[j][<span class="number">1</span>]+F[j+p][<span class="number">1</span>])%mod:(F[j][<span class="number">1</span>]-F[j+p][<span class="number">1</span>]+mod)%mod;\</span><br><span class="line">                re <span class="keyword">int</span> x=F[j][<span class="number">2</span>],y=F[j+p][<span class="number">2</span>];\</span><br><span class="line">                F[j][<span class="number">2</span>]=(x+y)%mod;\</span><br><span class="line">                F[j+p][<span class="number">2</span>]=(x-y+mod)%mod;\</span><br><span class="line">                <span class="keyword">if</span>(tp)&#123;\</span><br><span class="line">                    F[j][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j][<span class="number">2</span>]%mod;\</span><br><span class="line">                    F[j+p][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j+p][<span class="number">2</span>]%mod;\</span><br><span class="line">                &#125;\</span><br><span class="line">            &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    n=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(F[i][<span class="number">0</span>]);</span><br><span class="line">        F[i][<span class="number">1</span>]=F[i][<span class="number">2</span>]=F[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(G[i][<span class="number">0</span>]);</span><br><span class="line">        G[i][<span class="number">1</span>]=G[i][<span class="number">2</span>]=G[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FWT(F,<span class="number">0</span>);</span><br><span class="line">    FWT(G,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            F[i][j]=<span class="number">1L</span>L*F[i][j]*G[i][j]%mod;</span><br><span class="line">    FWT(F,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            cltstream::write(F[i][j],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h3><p>我们知道FFT中的单位元多项式是$F(x)=1$，类似地，FWT是否也拥有这样的一个单位元呢？</p>
<p>当然是有的。</p>
<p>对于按位或和按位异或来说，它们的单位元是</p>
<script type="math/tex; mode=display">(1,0,\cdots,0,0)</script><p>对于按位与来说，它的单位元是</p>
<script type="math/tex; mode=display">(0,0,\cdots,0,1)</script><h3 id="求逆"><a href="#求逆" class="headerlink" title="求逆"></a>求逆</h3><p>既然有了单位元，我们就不禁会想……这东西能求逆吗？</p>
<p>大概……能吧。</p>
<p>以下所有运算在模$998244353$意义下进行。</p>
<h4 id="按位或-1"><a href="#按位或-1" class="headerlink" title="按位或"></a>按位或</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p>
<script type="math/tex; mode=display">F\vee G=(1,0,\cdots,0,0)</script><p>首先我们需要知道</p>
<script type="math/tex; mode=display">F\vee G=(F_{0}\vee G_{0},F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1})</script><p>注意到左半部分和右半部分的下标有一个重要区别就是从右往左第$t$位是否为$1$。</p>
<p>如果某个下标和右半部分的某个下标进行了按位或，它的第$t$位一定是$1$，那么它就跑到右半部分去了。</p>
<p>否则，即两个左半部分的下标进行了按位或，这种情况结果还是在左半部分。</p>
<p>然后我们就可以往下推了</p>
<script type="math/tex; mode=display">\begin{aligned}
F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1}&=0\\
(F_{0}+F_{1})\vee G_{1}&=-F_{1}\vee G_{0}\\
G_{1}&=-F_{1}\vee G_{0}\vee (F_{0}+F_{1})^{-1}
\end{aligned}</script><p>边界条件$G[0]=F[0]^{-1}$。</p>
<p>大致代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1[<span class="number">1</span>&lt;&lt;maxn],tmp2[<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line">        Inv(F,G,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            tmp1[i]=F[i]+F[(n&gt;&gt;<span class="number">1</span>)+i];</span><br><span class="line">        Inv(tmp1,tmp2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            tmp2[i]=<span class="number">1L</span>L*F[(n&gt;&gt;<span class="number">1</span>)+i]*G[i]%mod*tmp2[i]%mod;</span><br><span class="line">        FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            G[(n&gt;&gt;<span class="number">1</span>)+i]=(mod-tmp2[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度非常显然是$O(n^{2}2^{n})$。</p>
<h4 id="按位与-1"><a href="#按位与-1" class="headerlink" title="按位与"></a>按位与</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p>
<script type="math/tex; mode=display">F\wedge G=(0,0,\cdots,0,1)</script><p>我们可以用类似的过程得到如下结论</p>
<script type="math/tex; mode=display">F\wedge G=(F_{0}\wedge G_{0}+F_{0}\wedge G_{1}+F_{1}\wedge G_{0},F_{1}\wedge G_{1})</script><script type="math/tex; mode=display">G_{0}=-F_{0}\wedge G_{1}\wedge (F_{0}+F_{1})^{-1}</script><h4 id="按位异或-1"><a href="#按位异或-1" class="headerlink" title="按位异或"></a>按位异或</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p>
<script type="math/tex; mode=display">F\oplus G=(1,0,\cdots,0,0)</script><p>首先我们有</p>
<script type="math/tex; mode=display">F\oplus G=(F_{0}\oplus G_{0}+F_{1}\oplus G_{1},F_{0}\oplus G_{1}+F_{1}\oplus G_{0})</script><p>也就是说</p>
<script type="math/tex; mode=display">F_{0}\oplus G_{0}+F_{1}\oplus G_{1}=\epsilon</script><script type="math/tex; mode=display">F_{0}\oplus G_{1}+F_{1}\oplus G_{0}=0</script><p>将上面两个式子相加、相减，得到</p>
<script type="math/tex; mode=display">(F_{0}+F_{1})\oplus(G_{0}+G_{1})=\epsilon</script><script type="math/tex; mode=display">(F_{0}-F_{1})\oplus(G_{0}-G_{1})=\epsilon</script><p>于是</p>
<script type="math/tex; mode=display">G_{0}=\cfrac{(F_{0}+F_{1})^{-1}+(F_{0}-F_{1})^{-1}}{2}</script><script type="math/tex; mode=display">G_{1}=\cfrac{(F_{0}+F_{1})^{-1}-(F_{0}-F_{1})^{-1}}{2}</script><p>时间复杂度$O(n2^{n})$。</p>
<p>这就没了？并不是。</p>
<p>如果您按照上面的式子写好程序，然后往里面输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>
<p>这样一组数据，您会发现您的程序给出的结果并不正确。</p>
<p>那么原因是什么呢？是我们式子推错了吗？</p>
<p>输出一下中间的运算过程，我们发现，在中间有一步，我们计算$(2,2)^{-1}$时，需要用到$(0)^{-1}$。</p>
<p>显然它不存在，但是同样显然的是，如果$(2,2)^{-1}$存在，那么这个过程不应该出现这样的问题。</p>
<p>所以说原因就是，$(2,2)^{-1}$，或者更进一步地，$(1,2,3,4)^{-1}$<strong>不存在</strong>。</p>
<h3 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a><a href="https://loj.ac/problem/152">子集卷积</a></h3><p><del>让我来看看有没有点进去看完题面一脸懵逼地关闭标签页的。</del></p>
<p>这道题是让我们求这个东西</p>
<script type="math/tex; mode=display">h_{R}=\sum_{S\vee T=R,S\wedge T=\varnothing}f_{S}g_{T}</script><p>这比我们之前看到的卷积拥有更加严格的要求，$S\wedge T=\varnothing$，很明显，这是在提示我们抄题解。</p>
<p>我们定义</p>
<script type="math/tex; mode=display">F_{i,S}=\begin{cases}
&f_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\
&0&(|S|\neq i)
\end{cases}</script><script type="math/tex; mode=display">G_{i,S}=\begin{cases}
&g_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\
&0&(|S|\neq i)
\end{cases}</script><script type="math/tex; mode=display">H_{i,S}=\begin{cases}
&h_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\
&0&(|S|\neq i)
\end{cases}</script><p>然后我们从小到大枚举$i$，计算</p>
<script type="math/tex; mode=display">H_{i}=\sum_{j=0}^{i}F_{j}\vee G_{i-j}</script><p>为了理解这个式子，我们先将其展开</p>
<script type="math/tex; mode=display">H_{i,R}=\sum_{j=0}^{i}\sum_{S\vee T=R}F_{j,S}G_{i-j,T}</script><p>根据定义，$F_{i,S}$和$G_{i,S}$有值当且仅当$|S|=i$，因此这就相当于</p>
<script type="math/tex; mode=display">H_{i,R}=\sum_{S\vee T=R,|S|+|T|=i}F_{|S|,S}G_{|T|,T}</script><p>因为$S$和$T$可能会有交集，从而$i\gt |R|$时$H_{i,R}$也可能有值，这是不符合定义的，因此（如果有必要的话）我们需要手动清空。</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,N;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">1</span>&lt;&lt;maxn],F[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],G[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],H[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;N;p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)</span><br><span class="line">                F[j+p]=!tp?(F[j+p]+F[j])%mod:(F[j+p]-F[j]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    N=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">        cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::read(F[cnt[i]][i]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::read(G[cnt[i]][i]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        FWT(F[i],<span class="number">0</span>);</span><br><span class="line">        FWT(G[i],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">                H[i][S]=(H[i][S]+<span class="number">1L</span>L*F[j][S]*G[i-j][S]%mod)%mod;</span><br><span class="line">        FWT(H[i],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">            cnt[S]==i||(H[i][S]=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::write(H[cnt[i]][i],<span class="number">32</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/images/TIM图片20181011211750.jpg" alt=""></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2019R1游记」僕らは泥を這いつくばるもの</title>
    <url>/sdoi2019r1-notes/</url>
    <content><![CDATA[<p>被强大无比且随手吊打我的shzr催更了，于是诚惶诚恐赶来写这篇游记。</p>
<a id="more"></a>
<h3 id="Day-X"><a href="#Day-X" class="headerlink" title="Day -X"></a>Day -X</h3><p>经过讨论，我们机房研究出了以下两个堪称完美的战术，若能施加实际行动，定能令SLYZ省选大获全胜：</p>
<ol>
<li>让潮子分身，在每一位dalao（如rqy、ckw等）身边分别派一个，然后潮他们，他们就炸了。</li>
<li>让潮子在厕所蹲着，每看到有选手上厕所，等他上到一半跑到他背后，潮之曰「你稳了」，他就炸了。</li>
</ol>
<p><del>这都什么鬼东西（</del></p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h3><p>「省选快到了，我想回家休息休息。」</p>
<p>像这样理直气壮地请假回家颓废了。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><h4 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h4><p>12：30从学校坐车走，等到了济南已经是大概16：00了。</p>
<p>到了宾馆loli让我们自由组合。然后mhr学长主动邀请我住一个房间。</p>
<p>我直接就答应了。</p>
<h4 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h4><p>晚上出去吃饭的时候，潮子一直在潮。</p>
<p>就比如说钦定wzx的SAM没有了A，只剩下了一些奇怪的东西一道题都A不动了。</p>
<p>可惜绝大部分名言已经失传了。</p>
<p>这可真是糟糕，OI文学界的一大损失啊。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>就算没有解压密码也是可以看压缩包内部的文件有哪些的。</p>
<p>然后就看到了T3有16个样例有点方。</p>
<p>解压密码直接一坨乱码。龙虾选手表示解压体验(?)极差。</p>
<h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5283">T1</a></h4><p>诶怎么感觉有点像超级钢琴啊。</p>
<p>但是因为我超级钢琴只会ST表+堆，想了想发现这题不能这么做。</p>
<p>好吧，暴力60分先安排上。</p>
<p>出了考场发现人均A掉T1。</p>
<h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5284">T2</a></h4><p>字符串（</p>
<p>不难想到这么一个做法：对于这$n_{a}+n_{b}$个串每一个建一个点，如果$A$类串$x$支配$B$类串$y$，或者$B$类串$x$是$A$类串$y$的前缀，从$x$向$y$连边。最后整张图有环就是$-1$，没有D个P就出来了。</p>
<p>然后暴力建图。莫名其妙能有60分。</p>
<h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5285">T3</a></h4><p>写作传统题读作提交答案题。</p>
<p>考场上只想出来了<code>1_998244353</code>的12分。</p>
<p>然后出考场被各路dalao吊打。</p>
<p>关于测试点8-16，一开始我的想法是给出两个数$x,y$，有一个长度为$x$的区间从左向右扫过$[1,y]$这个区间。</p>
<p>但实际上是$[x,y]$这个区间内每个数的性质。想到这一点后面的一些数据范围比较小的点就没啥问题了。</p>
<p>但是数据范围比较大的点怎么办？</p>
<p>打一些比较小的表（</p>
<p>标程70KB了一下。</p>
<h4 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h4><p>首先是讲评。</p>
<p>没有抢到座位于是只能站着。</p>
<p>因为非常吵什么也听不清。</p>
<p>印象比较深的是讲到T3突然一阵掌声。</p>
<p>然后回到宾馆快乐地颓废。</p>
<h4 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h4><p>集体不想出去吃于是点了肯德基，然后……诶诶诶你们什么时候吃完的太快了吧（</p>
<h3 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h3><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5289">T1</a></h4><p>看到题目名我还以为是网络流。</p>
<p>然后我就在想有没有网络流计数这种操作。</p>
<p>大概是没有吧。</p>
<p>打了个爆搜结果还炸了。</p>
<h4 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5290">T2</a></h4><p>看上去好神仙啊。</p>
<p>考场上写了45分的状压枚举子集。</p>
<p>结果一出考场听说人均75，就我不会链的贪心和$O(n^{2})$的做法，自毙了。</p>
<h4 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5291">T3</a></h4><p>想写一写$L=n$或$k=1$的情况。</p>
<p>到最后发现什么也不会，只想到了$L=n$<strong>且</strong>$k=1$的情况。喜提8分。</p>
<p>但是最后测出来好像是12分来着？没仔细看。</p>
<h4 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h4><p>因为有人要回去所以讲评提前了半小时。</p>
<p>虽然说抢到了一个座位可是今天比昨天还吵真的什么也听不见了。</p>
<p>T3标程887行了解一下（</p>
<p><img src="/images/TIM图片20190409113807.jpg" alt=""></p>
<p>结果接我们回东营的车咕了大概有一个多小时吧，最后得有20：30才到家。</p>
<h4 id="晚上-2"><a href="#晚上-2" class="headerlink" title="晚上"></a>晚上</h4><p>当然是回家……啊什么明天就正常上课啦？咕了！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后60+60+12+0+45+12=189。</p>
<p>随便抓只猴子就比我考的高/kk</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>SDOI</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>伯努利数失败笔记</title>
    <url>/bernoulli-number-learning-notes/</url>
    <content><![CDATA[<blockquote>
<p>「クールでまばゆいばかりのアルゴリズムを学ばないでください、それはうまく検索することが最も重要です。」</p>
<p>——loli</p>
</blockquote>
<p><del>以上，我失败了（</del></p>
<p><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/guan-yu-bo-nu-li-shuo-zhuai-hua-zi-ran-shuo-mi-hu-gong-shi-di-zheng-mi">前半部分的抄袭来源</a>。</p>
<a id="more"></a>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>伯努利数$B_{n}$具有如下性质：</p>
<script type="math/tex; mode=display">\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><h3 id="自然数幂和"><a href="#自然数幂和" class="headerlink" title="自然数幂和"></a>自然数幂和</h3><p>我们定义</p>
<script type="math/tex; mode=display">S(n,k)=\sum_{i=0}^{n-1}i^{k}</script><script type="math/tex; mode=display">T(n,k)=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><p>我们希望证明$S(n,k)=T(n,k)$。</p>
<p>在这里，我们采用一种名为「强归纳法」（或者「完全归纳法」）的方法。具体来说，假设我们已经对于任意的$0\leqslant j\lt k$，证明了$S(n,j)=T(n,j)$成立，利用这个结论推出$S(n,k)=T(n,k)$成立。</p>
<p>当$k=0$时</p>
<script type="math/tex; mode=display">S(n,k)=n</script><script type="math/tex; mode=display">T(n,k)=C_{1}^{0}B_{0}n</script><p>因为我们有</p>
<script type="math/tex; mode=display">C_{1}^{0}B_{0}=[0=0]=1</script><p>从而$S(n,k)=T(n,k)$成立。</p>
<p>当$k\gt 0$时</p>
<script type="math/tex; mode=display">S(n,k+1)=\sum_{i=0}^{n-1}i^{k+1}</script><script type="math/tex; mode=display">\begin{aligned}
S(n,k+1)+n^{k+1}&=\sum_{i=0}^{n-1}(i+1)^{k+1}\\
&=\sum_{i=0}^{n-1}\sum_{j=0}^{k+1}C_{k+1}^{j}i^{j}\\
&=\sum_{j=0}^{k+1}C_{k+1}^{j}\sum_{i=0}^{n-1}i^{j}\\
&=\sum_{j=0}^{k+1}C_{k+1}^{j}S(n,j)\\
&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)+C_{k+1}^{k+1}S(n,k+1)
\end{aligned}</script><p>注意到$C_{k+1}^{k+1}=1$，我们就能得到</p>
<script type="math/tex; mode=display">n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)</script><p>因为我们已经对于任意的$0\leqslant j\lt k$，证明了$S(n,j)=T(n,j)$成立，我们就可以将上式进一步变形</p>
<script type="math/tex; mode=display">\begin{aligned}
n^{k+1}&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)\\
&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)\\
&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)+C_{k+1}^{k}T(n,k)-C_{k+1}^{k}T(n,k)\\
&=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)-C_{k+1}^{k}T(n,k)
\end{aligned}</script><p>接下来，如果我们能够证明</p>
<script type="math/tex; mode=display">n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)</script><p>自然就能得出$S(n,k)=T(n,k)$。</p>
<p>愉快地推式子</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i}B_{i}n^{j-i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{j-i}B_{j-i}n^{i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i+1}B_{j-i}n^{i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}\cfrac{j+1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\
&=\sum_{j=0}^{k}C_{k+1}^{j}\sum_{i=0}^{j}\cfrac{1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{j}C_{j}^{i}B_{j-i}n^{i+1}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{i}C_{k-i+1}^{j-i}B_{j-i}n^{i+1}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}
\end{aligned}</script><p>上面的第二个等号是将后面的那个$\sum$倒过来（$i\rightarrow j-i$）求和。</p>
<p><del>返回本页面最上端之后，</del>我们回想起伯努利数还有个这么个性质</p>
<script type="math/tex; mode=display">\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><p>于是</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}\\
&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}[i=k]\\
&=\cfrac{1}{k+1}C_{k+1}^{k}n^{k+1}\\
&=n^{k+1}
\end{aligned}</script><script type="math/tex; mode=display">\text{QED}</script><h3 id="诶刚才我干了些什么来着"><a href="#诶刚才我干了些什么来着" class="headerlink" title="诶刚才我干了些什么来着"></a>诶刚才我干了些什么来着</h3><p>哦我好像是证明了这么一个东西</p>
<script type="math/tex; mode=display">\sum_{i=0}^{n-1}i^{k}=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><h3 id="如何求伯努利数"><a href="#如何求伯努利数" class="headerlink" title="如何求伯努利数"></a>如何求伯努利数</h3><p><del>根据题解，</del>我们知道伯努利数的生成函数是</p>
<script type="math/tex; mode=display">\cfrac{x}{e^{x}-1}=\cfrac{x}{\sum\limits_{i=1}^{+\infty}\cfrac{x^{i}}{i!}}=\cfrac{1}{\sum\limits_{i=0}^{+\infty}\cfrac{x^{i}}{(i+1)!}}</script><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「Luogu-P3711」仓鼠的数学题"><a href="#「Luogu-P3711」仓鼠的数学题" class="headerlink" title="「Luogu-P3711」仓鼠的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3711">「Luogu-P3711」仓鼠的数学题</a></h4><script type="math/tex; mode=display">\begin{aligned}
\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x-1}j^{i}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{j}B_{j}x^{i-j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{i-j}B_{i-j}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}\cfrac{(i+1)!}{(i-j)!(j+1)!}B_{i-j}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}i!a_{i}\sum_{j=0}^{i}\cfrac{1}{(j+1)!}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}
\end{aligned}</script><p>定义</p>
<script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n}(n-i)!a_{n-i}x^{i}</script><script type="math/tex; mode=display">B(x)=\sum_{i=0}^{n}\cfrac{B_{i}}{i!}x^{i}</script><p>那么</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\
&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{FB[n-j]}{(j+1)!}x^{j+1}
\end{aligned}</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>伯努利数</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT987」高橋君</title>
    <url>/at987-solution/</url>
    <content><![CDATA[<p><a href="https://tenka1-2014-final.contest.atcoder.jp/tasks/tenka1_2014_final_d">传送门</a></p>
<p><a href="https://www.luogu.org/problemnew/show/AT987">Luogu</a></p>
<p>第一道AtCoder的题解。</p>
<p>联动一波<a href="https://www.cnblogs.com/asuldb/p/10623281.html">asuldb</a>。</p>
<a id="more"></a>
<p>「啊这题怎么做啊。看起来好难啊。不会啊。」</p>
<p>「我们来蒙一个做法吧。比如说就莫队了！」</p>
<script type="math/tex; mode=display">\sum_{i=0}^{m+1}C_{n}^{i}=\sum_{i=0}^{m}C_{n}^{i}+C_{n}^{m+1}</script><script type="math/tex; mode=display">\sum_{i=0}^{m}C_{n+1}^{i}=\sum_{i=0}^{m}(C_{n}^{i}+C_{n}^{i-1})=\sum_{i=0}^{m}C_{n}^{i}+\sum_{i=0}^{m-1}C_{n}^{i-1}=2\sum_{i=0}^{m}C_{n}^{i}-C_{n}^{m}</script><p>这是左右端点向右移动的情况。向左移动就反过来。</p>
<p>就这样。</p>
<p>但是不知道为什么奇偶性排序会WA。</p>
<p>好短啊QAQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(a) (a/sq+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(n,m) (1LL*fac[n]*inv[m]%mod*inv[n-m]%mod)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,sq;</span><br><span class="line"><span class="keyword">int</span> fac[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">Query q[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re Query p1,re Query p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> id(p1.l)==id(p2.l)?p1.r&lt;p2.r:p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        fac[i]=<span class="number">1L</span>L*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=<span class="number">1L</span>L*inv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    sq=maxn/<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        q[i].t=i;</span><br><span class="line">        cltstream::read(q[i].r);</span><br><span class="line">        cltstream::read(q[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">    re <span class="keyword">int</span> L=<span class="number">0</span>,R=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;R&lt;q[i].r;res=(<span class="number">2</span>*res-C(R,L)+mod)%mod,++R);</span><br><span class="line">        <span class="keyword">for</span>(;R&gt;q[i].r;--R,res=inv[<span class="number">2</span>]*(res+C(R,L))%mod);</span><br><span class="line">        <span class="keyword">for</span>(;L&lt;q[i].l;++L,res=(res+C(R,L))%mod);</span><br><span class="line">        <span class="keyword">for</span>(;L&gt;q[i].l;res=(res-C(R,L)+mod)%mod,--L);</span><br><span class="line">        ans[q[i].t]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::write(ans[i],<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>莫队</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组自闭笔记</title>
    <url>/suffix-array-learning-notes/</url>
    <content><![CDATA[<p>省选前最后两周。同时也是退役前最后两周。</p>
<p><del>在wzx的鼓动下</del>开了字符串。</p>
<p>然后自闭了。</p>
<a id="more"></a>
<p>以下，我们约定，$S_{l,r}$表示字符串$S$下标为$[l,r]$的子串，下标从$1$开始。超过串长的部分用小于其他所有字符的空字符填充。</p>
<h3 id="后缀排序"><a href="#后缀排序" class="headerlink" title="后缀排序"></a><a href="https://www.luogu.org/problemnew/show/P3809">后缀排序</a></h3><p><del><code>std::sort</code>（光速逃</del></p>
<p>不过<code>std::sort</code>也是可以做的（</p>
<p>我们发现，这种做法的瓶颈在于比较两个后缀的大小。我们可以二分+Hash求出它们的最长公共前缀的长度，然后比较这个前缀后一个字符的大小。这么做的时间复杂度是$O(n\log^{2}n)$的。</p>
<p><del>但是没什么用（</del></p>
<p>然后我们就需要用到后缀数组（Suffix Array）了。</p>
<p>SA一共有四种构建方式，分别是$O(n\log n)$的倍增，$O(n)$的DC3和SA-IS，以及$O(1)$的潮爷排序。<del>但是后三种太高端了我都不会（</del></p>
<p>假设对于每一个位置$i$，我们已经按照$S_{i,i+k-1}$的大小排好了序，并且有了一个排名。我们以$i$的排名为第一关键字，$i+k$的排名为第二关键字，排一遍序，整个字符串就被按照$S_{i,i+2k-1}$的大小排好了序。当所有位置的排名都不同时，说明整个过程可以结束了。</p>
<p><del>但是问题来了，排一遍序不是$O(n\log n)$的吗（</del></p>
<p><del>我们有基数排序啊（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[i]：原字符串</span></span><br><span class="line"><span class="comment">// fst[i]：后缀i的第一关键字</span></span><br><span class="line"><span class="comment">// snd[i]：第二关键字排名为i的后缀</span></span><br><span class="line"><span class="comment">// tak[i]：桶</span></span><br><span class="line"><span class="comment">// sa[i]：排名为i的后缀</span></span><br><span class="line"><span class="comment">// 一开始时以首字符为第一关键字，位置为第二关键字排序</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    ++tak[fst[i]=s[i]];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">122</span>;++i)</span><br><span class="line">    tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 处理桶内前缀和，用来求出第一关键字为i的后缀的最大可能排名</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    sa[tak[fst[i]]--]=i;</span><br><span class="line">    <span class="comment">// 第一关键字相同时，第二关键字排名越大总排名越大，因此倒序枚举</span></span><br><span class="line">    <span class="comment">// 因为第二关键字是位置，所以snd[i]=i</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> mx=<span class="number">122</span>,k=<span class="number">1</span>;;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    re <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        snd[++cnt]=i;</span><br><span class="line">        <span class="comment">// (n-k,n]的这些后缀没有第二关键字，因此排名最靠前</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(sa[i]&gt;k)</span><br><span class="line">            snd[++cnt]=sa[i]-k;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">        tak[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ++tak[fst[i]];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">        tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        sa[tak[fst[snd[i]]]--]=snd[i];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        snd[i]=fst[i];</span><br><span class="line">        <span class="comment">// 因为要生成下一轮排序时的第一关键字，把fst里的信息先扔到snd里</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        fst[sa[i]]=fst[sa[i<span class="number">-1</span>]]+(snd[sa[i]]!=snd[sa[i<span class="number">-1</span>]]||snd[sa[i]+k]!=snd[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">        <span class="comment">// 如果当前后缀与前一个后缀相同则共用排名，否则+1</span></span><br><span class="line">    <span class="keyword">if</span>(fst[sa[n]]==n)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mx=fst[sa[n]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去非常的绕（</p>
<p>最后直接输出<code>sa</code>数组即可。</p>
<h3 id="rnk数组"><a href="#rnk数组" class="headerlink" title="rnk数组"></a><code>rnk</code>数组</h3><p><code>rnk[i]</code>表示排名为$i$的后缀。</p>
<p>不难发现<code>rnk[sa[i]]=sa[rnk[i]]=i</code>。</p>
<h3 id="het数组"><a href="#het数组" class="headerlink" title="het数组"></a><code>het</code>数组</h3><p>大概算是SA的重点。</p>
<p>令<code>lcp(x,y)</code>表示$x,y$两个后缀的最长公共前缀（Longest Common Prefix）的长度。</p>
<p><code>het[i]</code>就被定义为<code>lcp(sa[i],sa[i-1])</code>。<code>het[1]=0</code>。</p>
<p>不难发现<code>lcp(x,z)=min(lcp(x,y),lcp(y,z))(x&lt;y&lt;z)</code>，<code>lcp(x,y)=min{lcp(i,i-1)}=min{het[i]}(rnk[x]&lt;i&lt;=rnk[y])</code>。</p>
<p><del>那么问题来了，怎么求呢（</del></p>
<p>首先我们是肯定不能暴力枚举的。</p>
<p>二分+Hash？太麻烦而且复杂度不够优秀（</p>
<p>SA的<code>het</code>数组有一个性质，就是<code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p>
<p>我们只考虑<code>het[rnk[i-1]]&gt;0</code>时的情况。</p>
<p>令<code>k=sa[rnk[i-1]-1]</code>，<code>lcp(i-1,k)=het[rnk[i-1]]</code>，又因为后缀$i$是后缀$i-1$删去首字符得到的，后缀$k+1$是后缀$k$删去首字符得到的，从而<code>lcp(i,k+1)=het[rnk[i-1]]-1</code>。</p>
<p>后缀$i-1$比后缀$k$大，删去首字符后，后缀$i$肯定也比后缀$k+1$大。根据<code>lcp</code>的性质我们有<code>lcp(i,sa[rnk[i]-1])&gt;=lcp(i,k+1)</code>，也即<code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p>
<p>利用这个性质，我们就可以在$O(n)$的时间复杂度内求出<code>het</code>数组了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(rnk[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        j-=!!j;</span><br><span class="line">        re <span class="keyword">int</span> pos=sa[rnk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(;i+j&lt;=n&amp;&amp;pos+j&lt;=n&amp;&amp;s[i+j]==s[pos+j];++j);</span><br><span class="line">        het[rnk[i]]=j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后SA就彻底建好了。没错就这么点东西（</p>
<h3 id="板子应用"><a href="#板子应用" class="headerlink" title="板子应用"></a><del>板子</del>应用</h3><h4 id="不同子串个数"><a href="#不同子串个数" class="headerlink" title="不同子串个数"></a>不同子串个数</h4><p>给定一个长度为$n$的字符串$S$，求其本质不同的子串的数量。</p>
<p>首先有一个很显然的结论是，如果一个字符串是$S$的子串，那么它一定是$S$的若干个排名连续的后缀的公共前缀。</p>
<p>对于排名为$1$和排名为$2$的两个后缀来说，它们一共有<code>het[2]</code>个公共前缀；排名为$2$和排名为$3$的两个后缀一共有<code>het[3]</code>个公共前缀……</p>
<p>因此，$S$的不同子串个数就是它的所有子串个数，$\cfrac{n(n+1)}{2}$，减去所有<code>het</code>的和。</p>
<h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>给定$n$个字符串$S_{1},S_{2},\cdots,S_{n}$，求它们的最长公共子串。</p>
<p>我们首先将这$n$个串拼在一起，中间插入特殊字符将相邻的两个串隔开。然后我们将每个串内部的字符染色，第$1$个串染成颜色$1$，第$2$个串染成颜色$2$，用尺取法找出<code>sa[l],sa[l+1],...,sa[r]</code>覆盖全部$n$种颜色的区间$[l,r]$，求出其中<code>min{het[i]}(l&lt;i&lt;=r)</code>的最大值即可。</p>
<h4 id="模式串出现次数"><a href="#模式串出现次数" class="headerlink" title="模式串出现次数"></a>模式串出现次数</h4><p>给定$n$个文本串和$m$个模式串，询问每个模式串在$n$个文本串中一共出现了多少次。</p>
<p>首先将所有文本串拼在一起。对于每一个模式串，如果我们能够找到这个长串的任意一个后缀$x$，使得其拥有这个模式串作为前缀，然后找到一个最小的$l$和一个最大的$r$，使得<code>min{het[i]}(l&lt;i&lt;=rnk[x])</code>和<code>min{het[i]}(rnk[x]&lt;i&lt;=r)</code>均大于等于该模式串长度，$r-l+1$就是答案。不难看出向两边取$\min$这个操作具有单调性，因此我们可以二分。</p>
<p>但是问题来了，我们该怎么找到这个后缀啊。</p>
<p>一想，把模式串也接到文本串后就可以了。</p>
<p>那如果说模式串出现了互相包含的情况呢？</p>
<p>我们可以再开一个数组<code>col</code>，<code>col[i]</code>表示<code>sa[i]</code>的首字符是否属于一个文本串。因为这个是静态的，直接一遍前缀和就行。</p>
<h4 id="母串数量"><a href="#母串数量" class="headerlink" title="母串数量"></a>母串数量</h4><p>给定$n$个文本串和$m$个模式串，询问每个模式串在多少个文本串中出现过。也就是说，在同一个文本串中出现多次只记一次。</p>
<p>和上面一样，只不过是最后一步<code>col[i]</code>表示<code>sa[i]</code>的首字符所属的文本串的编号，对于每一个模式串，二分出区间后数一下颜色种类数。</p>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p>自己找去吧（</p>
<p>然后您就会发现字符串的题一道比一道神仙（</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>「Ynoi2014D2T2」人人本着正义之名</title>
    <url>/luogu-p5066-solution-not/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5066">传送门</a></p>
<p><del>一人血书放大常数Splay一条生路。</del></p>
<a id="more"></a>
<p>之前Ynoi2014唯一一道没公开的题。</p>
<p>写个$O(nm)$的暴力就有30了。</p>
<p>我们来分析一下操作$3,4,5,6$都在干些啥。</p>
<p>以操作$3$为例，如果在操作前，有一个位置的数字是$1$，它左边是一个$0$，操作完之后那个$0$就会变成$1$。除此之外不会再有其它改变。</p>
<p>仔细想象一下这个过程，我们发现这实际上是将操作区间内所有极长连续$1$的左端点向左扩展了$1$位，所有极长连续$0$的右端点向左收缩了$1$位。</p>
<p>操作$4,5,6$也是类似的。</p>
<p>那么我们写一棵珂朵莉树就可以获得50分了。</p>
<p>但实际上emmmmm……我的珂朵莉树可能和别人不一样（</p>
<p>别人的珂朵莉树：</p>
<p><img src="/images/TIM截图20190319161404.png" alt=""></p>
<p>我的珂朵莉树：</p>
<p><img src="/images/TIM截图20190319161900.png" alt=""></p>
<p>那么满分做法？</p>
<p>手写平衡树。没了。</p>
<p><del>虽然这么说，但是lxl都写了将近10KB（</del></p>
<p>总体思路就是，手写平衡树维护所有极长连续段的长度，并不需要维护端点因为可以算出来，单独维护还麻烦。每个节点维护子树内极长连续$0$和$1$的数量、长度最小值，以及连续段的长度变化量（标记）。修改时判断一下如果最小值变成了$0$，那么就暴力重构。<del>反正lxl说因为有前两个操作的存在这么做时间复杂度是对的。</del></p>
<p>首先有一个问题就是，这样做每个节点维护的必须要是<strong>极长连续段</strong>。想象一下，如果有两个相邻的节点值都是$1$，我们进行一次操作$3$或$4$，会发生什么？</p>
<p>两个节点的长度都加了$1$。然后整个序列莫名其妙多出来$1$个数。再然后您就WA了。</p>
<p>然后就是各种各样乱七八糟的细节。虽然这么说但好像没什么可列举的了。</p>
<p>然后您按照上面的思路打完四五百行的代码之后交上去一看：</p>
<p><img src="/images/TIM截图20190319171721.png" alt=""></p>
<p>虽然说暴力重构的时间复杂度<del>应该</del>是对的，但是不难发现它常数大啊。</p>
<p>但是如果不重构，合并相邻的连续段就会变得非常麻烦。</p>
<p>结论就是这题不可写，散了吧散了吧。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>珂朵莉树</tag>
        <tag>毒瘤</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>来扯点多项式？</title>
    <url>/polynomial-triangle-function/</url>
    <content><![CDATA[<p>在luogu上看到了多项式三角函数/反三角函数的板子。</p>
<p>不过还没加进公共题库，没人交，于是不敢交（</p>
<p>于是来口胡一波吧。</p>
<a id="more"></a>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>总之就是求$\sin F(x)$，$\cos F(x)$，其他的三角函数都可以用这两个凑出来因此不需要单独讨论。</p>
<p>虽然说我们也有$\cos x=\sin(x+\cfrac{\pi}{2})$，但是问题来了，模意义下怎么表示$\pi$（</p>
<p>首先我们有欧拉公式</p>
<script type="math/tex; mode=display">e^{ix}=\cos x+i\sin x</script><p>于是</p>
<script type="math/tex; mode=display">e^{iF}=\cos F+i\sin F</script><p>根据定义，$i^{2}\equiv -1\equiv 998244352\pmod{998244353}$。而$998244352$是模$998244353$的二次剩余，说人话就是这样的$i$是存在的。</p>
<p>但是问题来了，我们该怎么分离$\sin$和$\cos$？</p>
<p>我们还需要有</p>
<script type="math/tex; mode=display">e^{i(-F)}=\cos F-i\sin F</script><p>很明显地</p>
<script type="math/tex; mode=display">\sin F=\cfrac{e^{iF}-e^{i(-F)}}{2i}</script><script type="math/tex; mode=display">\cos F=\cfrac{e^{iF}+e^{i(-F)}}{2}</script><h3 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h3><p>求$\arcsin F(x)$，$\arccos F(x)$。</p>
<p>我们令答案的多项式为$G(x)$。</p>
<p>我们都知道</p>
<script type="math/tex; mode=display">\sin^{2}x+\cos^{2}x=1</script><p>于是知道了$\sin G$或者是$\cos G$，我们就可以推出另一项，然后再根据</p>
<script type="math/tex; mode=display">e^{iG}=\cos G+i\sin G</script><script type="math/tex; mode=display">G=\cfrac{\ln(\cos G+i\sin G)}{i}</script><p>就可以算出$G$了。</p>
<p>那么$\arctan F(x)$？</p>
<script type="math/tex; mode=display">\sin^{2}G+\cos^{2}G=1</script><p>因为$\tan G$有意义，所以$\cos G\neq0$。</p>
<script type="math/tex; mode=display">\tan^{2}G+1=\sec^{2}G</script><script type="math/tex; mode=display">\cos G=\cfrac{1}{\sqrt{\tan^{2}G+1}}</script><p>但是看着就麻烦（</p>
<blockquote>
<p>Updated on 2019-03-18</p>
<p>上面这种做法大概不是正解，因为这样需要对一个常数项不是$1$，最低次非零系数也不是$1$的多项式求平方根，很明显这需要二次剩余<del>，而且我不会</del>。</p>
<p>考虑倍增。</p>
<script type="math/tex; mode=display">\sin G_{0}-F\equiv 0\pmod{x^{t}}</script><script type="math/tex; mode=display">\sin G-F\equiv 0\pmod{x^{2t}}</script><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\sin G_{0}-F}{(\sin G_{0}-F)^{\prime}}\equiv G_{0}-\cfrac{\sin G_{0}-F}{\cos G_{0}}\pmod{x^{2t}}</script><p>然后是$\arccos$。</p>
<script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\cos G_{0}-F}{(\cos G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\cos G_{0}-F}{\sin G_{0}}\pmod{x^{2t}}</script><p>然后是$\arctan$。不过我不怎么会求导$\tan$（</p>
<script type="math/tex; mode=display">\begin{aligned}
(\tan x)^{\prime}&=(\cfrac{\sin x}{\cos x})^{\prime}\\
&=\cfrac{(\sin x)^{\prime}}{\cos x}+\sin x(\cfrac{1}{\cos x})^{\prime}\\
&=1+\tan^{2}x
\end{aligned}</script><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\tan G_{0}-F}{(\tan G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\tan G_{0}-F}{1+\tan^{2} G_{0}}\pmod{x^{2t}}</script><p>这大概不能写（</p>
</blockquote>
<h3 id="多项式GCD-LCM"><a href="#多项式GCD-LCM" class="headerlink" title="多项式GCD/LCM"></a>多项式GCD/LCM</h3><p>既然多项式能够整除和取模，那么GCD和LCM一定也是可以算的吧！</p>
<p>……应该可以吧（</p>
]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>三角函数</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数学习笔记</title>
    <url>/generating-function-learning-notes/</url>
    <content><![CDATA[<p>又被wzx吊打了QAQ</p>
<p>来写一篇生成函数吧QAQ</p>
<p><del>本文全部内容抄袭自<a href="https://www.cnblogs.com/asuldb/p/10533453.html">这篇blog</a>和<a href="https://www.cnblogs.com/asuldb/p/10534860.html">这篇blog</a></del></p>
<a id="more"></a>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个数列${a_{0},a_{1},\cdots,a_{n}}$的生成函数$f(x)$被定义为</p>
<script type="math/tex; mode=display">f(x)=\sum_{i=0}^{n}a_{i}x^{i}</script><p>就这样（</p>
<h3 id="封闭表达式"><a href="#封闭表达式" class="headerlink" title="封闭表达式"></a>封闭表达式</h3><p>但是这个形式比较玄乎，不便于我们推式子。特别是当我们需要求一个无穷数列的生成函数时。于是我们希望能够进一步化简。</p>
<p>比如说，当$a_{n}=c^{n}$，即这个数列是${1,c,c^{2},\cdots}$时，它的生成函数是</p>
<script type="math/tex; mode=display">f(x)=\sum_{i=0}^{n}c^{i}x^{i}=\cfrac{1-(cx)^{n+1}}{1-cx}</script><p>就是一个简单地等比数列求和。很明显，当$x\in(-1,1)$时，如果$n$趋向于正无穷大，则上式等于$\cfrac{1}{1-cx}$。</p>
<p>我们现在来分析一下斐波那契数列的生成函数。</p>
<script type="math/tex; mode=display">\begin{aligned}
F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\
&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}
\end{aligned}</script><p>为了方便，我们定义当$n\lt 0$时，$F_{n}=0$。</p>
<p>然后我们发现$F_{1}=F_{0}+F_{-1}=0+0=0$，于是我们再加上一项$[i=1]$。</p>
<script type="math/tex; mode=display">\begin{aligned}
F(x)&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2}+[i=1])x^{i}\\
&=x+\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}\\
&=x+x\sum_{i=0}^{n}F_{i-1}x^{i-1}+x^{2}\sum_{i=0}^{n}F_{i-2}x^{i-2}\\
&=x+xF(x)+x^{2}F(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">F(x)=\cfrac{x}{1-x-x^{2}}</script><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><p>那么问题来了，我们闲着没事求这个生成函数有什么用啊。</p>
<p>求通项公式。</p>
<p>我们知道形如$a_{n}=c^{n}$的数列的生成函数等于$\cfrac{1}{1-cx}$，我们可以试着将$\cfrac{x}{1-x-x^{2}}$分解成两个类似形式的分式的和。</p>
<p>设</p>
<script type="math/tex; mode=display">1-x-x^{2}=(1-ax)(1-bx)</script><script type="math/tex; mode=display">\begin{cases}
&a+b=1\\
&ab=-1
\end{cases}
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
\begin{cases}
&a=\cfrac{1+\sqrt{5}}{2}\\
&b=\cfrac{1-\sqrt{5}}{2}
\end{cases}</script><p>再设</p>
<script type="math/tex; mode=display">\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{x}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><script type="math/tex; mode=display">\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><p>于是</p>
<script type="math/tex; mode=display">c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx=x</script><p>等式右边没有常数项，因此$c+d$应当是$0$。再继续接下去，我们得到</p>
<script type="math/tex; mode=display">
\begin{cases}
&c=\cfrac{1}{\sqrt{5}}\\
&d=-\cfrac{1}{\sqrt{5}}
\end{cases}</script><p>于是</p>
<script type="math/tex; mode=display">\begin{aligned}
F(x)&=\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1+\sqrt{5}}{2}x}-\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1-\sqrt{5}}{2}x}\\
&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}x^{i}-\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}x^{i}\\
&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}\right)x^{i}
\end{aligned}</script><p>结论就是</p>
<script type="math/tex; mode=display">F_{n}=\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{n}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{n}\right)</script><h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><script type="math/tex; mode=display">\begin{aligned}
F(x)&=\sum_{i=0}^{n}C_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}+[i=0]\right)x^{i}\\
&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i}\\
&=1+x\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i-1}\\
&=1+xF^{2}(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">xF^{2}(x)-F(x)+1=0</script><script type="math/tex; mode=display">F(x)=\cfrac{1\pm\sqrt{1-4x}}{2x}</script><script type="math/tex; mode=display">2xF(x)=1\pm\sqrt{1-4x}</script><p>当$x=0$时</p>
<script type="math/tex; mode=display">2\times 0\times 1=1\pm1</script><p>因此根号前应该取负。至此我们得到</p>
<script type="math/tex; mode=display">F(x)=\cfrac{1-\sqrt{1-4x}}{2x}</script><p>那么通项公式呢？</p>
<p>根据<del>一个我抄过来的</del>广义二项式定理，我们有</p>
<script type="math/tex; mode=display">\begin{aligned}
\sqrt{1-4x}&=1+\sum_{i=1}^{n}\cfrac{(-1)^{i-1}}{i2^{2i-1}}C_{2i-2}^{i-1}(-4x)^{i}\\
&=1+2\sum_{i=1}^{n}\cfrac{(-1)^{2i-1}}{i}C_{2i-2}^{i-1}x^{i}\\
&=1-2\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i}
\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}
F(x)&=\cfrac{1-\sqrt{1-4x}}{2x}\\
&=\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i-1}\\
&=\sum_{i=0}^{n}\cfrac{1}{i+1}C_{2i}^{i}x^{i}
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">C_{n}=\cfrac{1}{n+1}C_{2n}^{n}</script><h4 id="默慈金数"><a href="#默慈金数" class="headerlink" title="默慈金数"></a>默慈金数</h4><p><del>等会默慈金数是个什么鬼？（</del></p>
<p>默慈金数一般记为$M_{n}$，被定义为在均匀分布在一个圆上的$n$个有编号的点之间连出彼此不相交的弦的方案数。一根弦也不连也是一种方案。</p>
<script type="math/tex; mode=display">M_{0}=1</script><script type="math/tex; mode=display">M_{n}=M_{n-1}+\sum_{i=0}^{n-2}M_{i}M_{n-i-2}</script><script type="math/tex; mode=display">\begin{aligned}
F(x)&=\sum_{i=0}^{n}M_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}+[i=0]\right)x^{i}\\
&=1+\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}\right)x^{i}\\
&=1+xF(x)+x^{2}F^{2}(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">x^{2}F^{2}(x)+(x-1)F(x)+1=0</script><script type="math/tex; mode=display">F(x)=\cfrac{1-x\pm\sqrt{1-2x-3x^{2}}}{2x^{2}}</script><p>总之根号前应该取负（</p>
<script type="math/tex; mode=display">\begin{aligned}
F(x)&=\cfrac{1-x-\sqrt{1-2x-3x^{2}}}{2x^{2}}\\
&=\cfrac{2-2x-2\sqrt{1-2x-3x^{2}}}{4x^{2}}\\
&=\cfrac{(1+x)-2\sqrt{(1+x)(1-3x)}+(1-3x)}{4x^{2}}\\
&=\cfrac{(\sqrt{1+x}-\sqrt{1-3x})^{2}}{4x^{2}}
\end{aligned}</script><p>woc这什么鬼东西溜了溜了。</p>
<p><del>留作课后习题，哪位dalao推出来了让我%一%（</del></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「TJOI2015」概率论"><a href="#「TJOI2015」概率论" class="headerlink" title="「TJOI2015」概率论"></a><a href="https://www.luogu.org/problemnew/show/P3978">「TJOI2015」概率论</a></h4><p>首先很明显，互不同构的二叉树一共$C_{n}$棵，其中$C_{n}$是卡特兰数。现在我们希望求出这些二叉树的叶子结点总数，我们记为$F_{n}$。不难发现</p>
<script type="math/tex; mode=display">F_{0}=0</script><script type="math/tex; mode=display">F_{1}=1</script><script type="math/tex; mode=display">F_{n}=2\sum_{i=0}^{n-1}C_{i}F_{n-i-1}+[i=1]</script><script type="math/tex; mode=display">\begin{aligned}
F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(2\sum_{j=0}^{i-1}C_{j}F_{i-j-1}+[i=1]\right)x^{i}\\
&=x+2\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}F_{i-j-1}\right)x^{i}\\
&=x+2xCF(x)
\end{aligned}</script><p>于是</p>
<script type="math/tex; mode=display">F(x)=\cfrac{x}{1-2xC(x)}</script><p>其中$C(x)$是卡特兰数的生成函数，我们知道它的值是$\cfrac{1-\sqrt{1-4x}}{2x}$，所以说</p>
<script type="math/tex; mode=display">F(x)=\cfrac{x}{\sqrt{1-4x}}</script><p><del>然后我又不会了（</del></p>
<script type="math/tex; mode=display">(xC(x))^{\prime}=\cfrac{1}{\sqrt{1-4x}}=\cfrac{F(x)}{x}</script><script type="math/tex; mode=display">(xC(x))^{\prime}=\sum_{i=0}^{n}(i+1)C_{i}x^{i}</script><script type="math/tex; mode=display">\cfrac{F(x)}{x}=\sum_{i=0}^{n}F_{i}x^{i-1}=\sum_{i=-1}^{n}F_{i+1}x^{i}</script><p>我们就得到</p>
<script type="math/tex; mode=display">iC_{i-1}=F_{i}</script><p>于是</p>
<script type="math/tex; mode=display">\begin{aligned}
\text{Ans}&=\cfrac{F_{n}}{C_{n}}\\
&=\cfrac{nC_{n-1}}{C_{n}}\\
&=\cfrac{C_{2n-2}^{n-1}}{\cfrac{1}{n+1}C_{2n}^{n}}\\
&=\cfrac{\cfrac{(2n-2)!}{(n-1)!(n-1)!}}{\cfrac{(2n)!}{n!(n+1)!}}\\
&=\cfrac{(2n-2)!n!(n+1)!}{(n-1)!(n-1)!(2n)!}\\
&=\cfrac{n(n+1)}{2(2n-1)}
\end{aligned}</script><h4 id="「国家集训队」整数的lqp拆分"><a href="#「国家集训队」整数的lqp拆分" class="headerlink" title="「国家集训队」整数的lqp拆分"></a><a href="https://www.luogu.org/problemnew/show/P4451">「国家集训队」整数的lqp拆分</a></h4><p>其实这道题我几个月前推出来了一个$O(n^{2})$的式子（</p>
<p>如果记答案为$G_{n}$，我们有</p>
<script type="math/tex; mode=display">G_{n}=\sum_{i=0}^{n}F_{i}G_{n-i}</script><p>其中$F_{n}$是斐波那契数。为了方便，我们强行定义$G_{0}=1$。</p>
<script type="math/tex; mode=display">\begin{aligned}
G(x)&=\sum_{i=0}^{n}G_{i}x^{i}\\
&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}+[i=0]\right)x^{i}\\
&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}\right)x^{i}\\
&=1+FG(x)
\end{aligned}</script><p>其中$F(x)$是斐波那契数的生成函数。于是</p>
<script type="math/tex; mode=display">G(x)=\cfrac{1}{1-F(x)}=\cfrac{1-x-x^{2}}{1-2x-x^{2}}=1+\cfrac{x}{1-2x-x^{2}}</script><p>多出来的那个$1$是$G_{0}$，可以无视掉。</p>
<p>设</p>
<script type="math/tex; mode=display">(1-ax)(1-bx)=1-2x-x^{2}</script><p>（中间过程略）</p>
<script type="math/tex; mode=display">\begin{cases}
&a=1+\sqrt{2}\\
&b=1-\sqrt{2}
\end{cases}</script><p>再设</p>
<script type="math/tex; mode=display">\cfrac{c}{1-(1+\sqrt{2})x}+\cfrac{d}{1-(1-\sqrt{2})x}=\cfrac{x}{1-2x-x^{2}}</script><p>（中间过程略$\times 2$）</p>
<script type="math/tex; mode=display">\begin{cases}
&c=\cfrac{1}{2\sqrt{2}}\\
&d=-\cfrac{1}{2\sqrt{2}}
\end{cases}</script><p>于是</p>
<script type="math/tex; mode=display">\begin{aligned}
G(x)&=1+\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1+\sqrt{2})x}-\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1-\sqrt{2})x}\\
&=1+\sum_{i=0}^{n}\cfrac{1}{2\sqrt{2}}\left((1+\sqrt{2})^{i}-(1-\sqrt{2})^{i}\right)x^{i}
\end{aligned}</script><p>最终结论就是</p>
<script type="math/tex; mode=display">G_{n}=\cfrac{(1+\sqrt{2})^{n}-(1-\sqrt{2})^{n}}{2\sqrt{2}}</script><p>根据暴力枚举，我们得出$\sqrt{2}\equiv 59713600\pmod{10^{9}+7}$。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P4705」Van♂游戏</title>
    <url>/luogu-p4705-solution/</url>
    <content><![CDATA[<p>下个月就要省选了我还在颓怕不是要凉</p>
<p>然后再一翻wzx的blog发现他更新频率快到爆炸</p>
<p>大概这就是神吧</p>
<p>啊啊我好菜啊，不过还是来抄篇题解吧</p>
<p><a href="https://www.luogu.org/problemnew/show/P4705">传送门</a></p>
<a id="more"></a>
<p>令$\text{Ans}[t]$表示$t$次价值：</p>
<script type="math/tex; mode=display">\begin{aligned}
\text{Ans}[t]&=\sum_{i=1}^{n}\sum_{j=1}^{m}(a_{i}+b_{j})^{t}\\
&=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=0}^{t}C_{t}^{k}a_{i}^{k}b_{j}^{t-k}\\
&=t!\sum_{k=0}^{t}\cfrac{\sum a_{i}^{k}}{k!}\cfrac{\sum b_{j}^{t-k}}{(t-k)!}
\end{aligned}</script><p>然后我们看到了$\sum a_{i}^{k}$这种东西，要算的话时间复杂度至少要是$O(nt)$的（</p>
<p>从这里往下是抄的题解。</p>
<p>定义</p>
<script type="math/tex; mode=display">F(x)=\prod_{i=1}^{n}(a_{i}x+1)</script><script type="math/tex; mode=display">\begin{aligned}
G(x)&=\ln F(x)\\
&=\ln\prod_{i=1}^{n}(a_{i}x+1)\\
&=\sum_{i=1}^{n}\ln(a_{i}x+1)
\end{aligned}</script><p>我们先来考虑如何求出$F$。定义$Q_{i}$为从${a_{n}}$中选出$i$个数相乘，这样的所有方案结果的总和，且$Q_{0}=1$。我们有</p>
<script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n}Q_{i}x^{i}</script><p>然后分治。假设我们现在已经求出了$[l,mid]$上的$Q_{L,0},Q_{L,1},\cdots,Q_{L,mid-l+1}$和$(mid,r]$上的$Q_{R,0},Q_{R,1},\cdots,Q_{R,r-mid}$，不难发现</p>
<script type="math/tex; mode=display">Q_{i}=\sum_{j=0}^{i}Q_{L,j}Q_{R,i-j}</script><p>这部分的时间复杂度为$O(n\log^{2}n)$。</p>
<p>然后我们将$G$在$1$这个位置泰勒展开。先回忆一下<a href="/polynomial-learning-notes-pt2/">泰勒展开</a>的式子</p>
<script type="math/tex; mode=display">g(x)=\sum\limits_{i=1}^{+\infty}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><script type="math/tex; mode=display">\ln^{(n)}(x)=(-1)^{n-1}(n-1)!x^{-n}</script><script type="math/tex; mode=display">\begin{aligned}
G(x)&=\sum_{i=1}^{n}\ln(a_{i}x+1)\\
&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{\ln^{(j)}(1)}{j!}a_{i}^{j}x^{j}\\
&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}(j-1)!1^{-j}}{j!}a_{i}^{j}x^{j}\\
&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}a_{i}^{j}x^{j}\\
&=\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}\left(\sum_{i=1}^{n}a_{i}^{j}\right)x^{j}
\end{aligned}</script><p><img src="/images/TIM图片20190123161752.jpg" alt=""></p>
<p>令人窒息（</p>
<p>然后这道题就做出来了（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">            tmp1[k]=F[k];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            tmp1[k]=<span class="number">0</span>;</span><br><span class="line">        NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            G[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">    G[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    Inv(F,tmp2,n);</span><br><span class="line">    NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">    NTT(G,N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(re <span class="keyword">int</span>* P,re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        re <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,N=<span class="number">1</span>;</span><br><span class="line">        calc(P,l,mid);</span><br><span class="line">        calc(P,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">for</span>(;N&lt;r-l+<span class="number">2</span>;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">        F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mid-l+<span class="number">1</span>;++i)</span><br><span class="line">            F[i]=P[l+i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=mid-l+<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">            F[i]=<span class="number">0</span>;</span><br><span class="line">        NTT(F,N,<span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-mid;++i)</span><br><span class="line">            G[i]=P[mid+i];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=r-mid+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">            G[i]=<span class="number">0</span>;</span><br><span class="line">        NTT(G,N,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">            F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">        NTT(F,N,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-l+<span class="number">1</span>;++i)</span><br><span class="line">            P[l+i<span class="number">-1</span>]=F[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::read(A[i]);</span><br><span class="line">    B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        cltstream::read(B[i]);</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    calc(A,<span class="number">1</span>,n);</span><br><span class="line">    calc(B,<span class="number">1</span>,m);</span><br><span class="line">    Ln(A,F,t+<span class="number">1</span>);</span><br><span class="line">    Ln(B,G,t+<span class="number">1</span>);</span><br><span class="line">    F[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*j%mod;</span><br><span class="line">    G[<span class="number">0</span>]=m;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*j%mod;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=t+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">        F[i]=G[i]=<span class="number">0</span>;</span><br><span class="line">    NTT(F,N,<span class="number">0</span>);</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">    NTT(F,N,<span class="number">1</span>);</span><br><span class="line">    N=cltpow(<span class="number">1L</span>L*n*m%mod,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=N;i&lt;=t;++i,j=<span class="number">1L</span>L*j*i%mod)</span><br><span class="line">        cltstream::write(<span class="number">1L</span>L*F[i]*j%mod,<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流学习笔记Part II」总之XJB写点啥（</title>
    <url>/network-flow-learning-notes-pt2/</url>
    <content><![CDATA[<p>Part I大概是<a href="/something-about-network-flow-learning-notes/">这篇</a>。</p>
<p>去郑州的时候讲的网络流部分。</p>
<p>什么你说游记？咕咕咕。</p>
<a id="more"></a>
<h3 id="一种似乎没有名字的二元组模型"><a href="#一种似乎没有名字的二元组模型" class="headerlink" title="一种似乎没有名字的二元组模型"></a>一种似乎没有名字的二元组模型</h3><h4 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h4><p>你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个三元组<del>（虽然说不是标题说的二元组不过不要在意这些细节）</del>，每一个三元组形如$(x,y,c)$，意思是如果$x$和$y$两个任务在不同的机器上完成需要额外付出$c$的代价。你需要完成这$n$个任务，并最小化代价和。</p>
<p>我们都知道最小割=最大流。因此在一些题目中，如果无法将问题抽象成最大流问题，我们可以试着抽象成最小割问题。</p>
<p>对于任务$i$，连边$(S,i,a_{i}),(i,T,b_{i})$。对于一个三元组$(x,y,c)$，连边$(x,y,c),(y,x,c)$。</p>
<p>割断$(S,i,a_{i})$意味着任务$i$在第一台机器上完成，割断$(i,T,b_{i})$意味着任务$i$在第二台机器上完成。</p>
<p>首先很明显的是，同时割断$(S,i,a_{i})$和$(i,T,b_{i})$一定不是最优的决策。因此一个任务只会在一台机器上被完成。</p>
<p>对于一个三元组$(x,y,c)$，如果我们同时割断$(S,x,a_{x})$和$(S,y,a_{y})$，$S$与$T$直接就断开了，这样我们的代价是$a_{x}+a_{y}$。同时割断$(x,T,b_{x})$和$(y,T,b_{y})$也是类似的。</p>
<p>如果说我们同时割断$(S,x,a_{x})$和$(y,T,b_{y})$，图上仍存在${(S,y,a_{y}),(y,x,c),(x,T,b_{x})}$这样一条路径，我们还需要割断$(y,x,c)$，这样我们的代价是$a_{x}+b_{y}+c$。同时割断$(x,T,b_{x})$和$(S,y,a_{y})$也是类似的。</p>
<h4 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h4><p>你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个六元组，每一个六元组形如$(x,y,c_{1},c_{2},c_{3},c_{4})$，意思是你需要为$x$和$y$这两个任务付出一些额外代价：</p>
<ul>
<li>如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{1}$。</li>
<li>如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{2}$。</li>
<li>如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{3}$。</li>
<li>如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{4}$。</li>
</ul>
<p>你需要完成这$n$个任务，并最小化代价和。</p>
<p>首先仍然是连边$(S,i,a_{i}),(i,T,b_{i})$。对于每一个六元组，连边$(S,x,A),(S,y,B),(x,T,C),(y,T,D),(x,y,E),(y,x,F)$。我们发现</p>
<ul>
<li>如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,x,A),(S,y,B)$，付出$A+B$的代价。</li>
<li>如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(x,T,C),(y,T,D)$，付出$C+D$的代价。</li>
<li>如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(S,x,A),(y,T,D),(y,x,F)$，付出$A+D+F$的代价。</li>
<li>如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,y,B),(x,T,C),(x,y,E)$，付出$B+C+E$的代价。</li>
</ul>
<p>因此我们列出如下的方程组</p>
<script type="math/tex; mode=display">\begin{cases}
&A+B=c_{1}&(1)\\
&C+D=c_{2}&(2)\\
&A+D+F=c_{3}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;&(3)\\
&B+C+E=c_{4}&(4)
\end{cases}</script><p>因为我们要将问题转化成最大流问题，首先想到，我们要有$A,B,C,D,E,F\geqslant 0$。注意到，$(S,x,A)$和$(x,T,C)$中有且仅有一条边会出现在最小割集中，因此我们可以将$A$和$C$同时加上一个数，求出最小割后在答案中减去。$B$和$D$也可以类似处理。</p>
<p>需要注意的是，$E$和$F$不能被这样处理，因为我们不能确定它们在答案中产生了几次贡献。</p>
<p>$(3)+(4)-(1)-(2)$，我们得到</p>
<script type="math/tex; mode=display">E+F=c_{3}+c_{4}-c_{1}-c_{2}</script><p>定义$K=c_{3}+c_{4}-c_{1}-c_{2}$，当$K\geqslant 0$时它有意义，我们直接令$E=F=\cfrac{K}{2}$即可。</p>
<p>剩下的四个量随便给几个值，好算就行。</p>
<p>其实就算$K\lt 0$有时也是可以做的，但是我太菜了不会（</p>
<p>因为太菜了所以没有图（</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="「国家集训队」happiness"><a href="#「国家集训队」happiness" class="headerlink" title="「国家集训队」happiness"></a><a href="https://www.luogu.org/problemnew/show/P1646">「国家集训队」happiness</a></h5><p>题目要求最大化总收益，我们可以先将所有数取相反数，然后最小化总代价。</p>
<p>令位置$i$选文的单独收益是$a_{i}$，选理的单独收益是$b_{i}$，连边$(S,i,-a_{i}),(i,T,-b_{i})$。</p>
<p>考虑一对相邻的位置，他们都选文的额外收益是$v_{1}$，都选理的额外收益是$v_{2}$，列出方程组</p>
<script type="math/tex; mode=display">\begin{cases}
&A+B=-v_{1}\\
&C+D=-v_{2}\\
&A+D+E=0\\
&B+C+E=0
\end{cases}
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
\begin{cases}
&A=-\cfrac{v_{1}}{2}\\
&B=-\cfrac{v_{1}}{2}\\
&C=-\cfrac{v_{2}}{2}\\
&D=-\cfrac{v_{2}}{2}\\
&E=\cfrac{v_{1}+v_{2}}{2}
\end{cases}</script><p>为了避免浮点数，我们把上面所有边的容量乘以$2$，包括$(S,i,-a_{i}),(i,T,-b_{i})$，最后再除回来。</p>
<p>然后，为了避免负数，我们将$A,B,C,D$加上$v_{1}+v_{2}$，把边$(S,i,-2a_{i}),(i,T,-2b_{i})$的容量加上$2a_{i}+2b_{i}$，最后再减回来。</p>
<p>总结一下就是，对于一个位置$i$，连边$(S,i,2b_{i}),(i,T,2a_{i})$。对于一对相邻位置$x,y$，连边$(S,x,v_{2}),(S,y,v_{2}),(x,T,v_{1}),(y,T,v_{1}),(x,y,v_{1}+v_{2}),(y,x,v_{1}+v_{2})$。</p>
<script type="math/tex; mode=display">\text{Ans}=\sum(a_{i}+b_{i})+\sum(v_{1}+v_{2})-\cfrac{\text{MinCut}(S,T)}{2}</script><p>但是我的<a href="https://www.luogu.org/recordnew/show/16563258">代码</a>不知道为什么写炸了（</p>
<p>反正这个式子应该是没问题的（</p>
<p>那么告辞吧（</p>
<h3 id="闭合子图"><a href="#闭合子图" class="headerlink" title="闭合子图"></a>闭合子图</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于一个有向图$G$，它的一个闭合子图指的是一个顶点集合$V$，满足$V\subset G$，且</p>
<script type="math/tex; mode=display">\forall u\in V\wedge(u,v)\in G,v\in V</script><p>其中$|V|$最大的$V$被称为$G$的最大闭合子图。</p>
<p>如果$G$中的点有点权，$\sum_{u\in V}w(u)$最大的$V$被称为$G$的最大权闭合子图。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首先，我们还是需要将所有点权取相反数，转为求最小权闭合子图。</p>
<p>对于$G$中的一个点$x$，割断与$S$之间的边表示$x\notin V$，割断与$T$之间的边表示$x\in V$。对于$G$中的一条边$(x,y)$，如果$x\in V$，那么一定有$y\in V$。我们可以认为，如果令$x\in V$，$y\notin V$，需要付出$+\infty$的代价。由此列出方程组</p>
<script type="math/tex; mode=display">\begin{cases}
&A+B=0\\
&C+D=-w(x)-w(y)\\
&A+D+F=-w(x)\\
&B+C+E=-w(y)+\infty
\end{cases}
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
\begin{cases}
&A=0\\
&B=0\\
&C=-w(x)\\
&D=-w(y)\\
&E=+\infty\\
&F=0
\end{cases}</script><p>于是，去掉所有容量为$0$的边，我们得到$(x,T,-w(x)),(y,T,-w(y)),(x,y,+\infty)$这三条边。如果$w(x)\geqslant 0$，我们需要把边$(S,x,0),(x,T,-w(x))$的容量都加上$w(x)$，相当于是把$(x,T,-w(x))$换成了$(S,x,w(x))$。</p>
<p>总结一下就是，对于原图中的一个正权点$x$，连边$(S,x,w(x))$，对于原图中的一个负权点$x$，连边$(x,T,-w(x))$。对于原图中的一条边$(x,y)$，连边$(x,y,+\infty)$。</p>
<script type="math/tex; mode=display">\text{Ans}=\sum_{w(x)\geqslant 0}w(x)-\text{MinCut}(S,T)</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P3613」睡觉困难综合征</title>
    <url>/luogu-p3613-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3613">传送门</a></p>
<a id="more"></a>
<h3 id="xjb扯"><a href="#xjb扯" class="headerlink" title="xjb扯"></a>xjb扯</h3><p>以前刚学树剖时看到这题感觉好神仙啊没法做啊。</p>
<p>然后现在学了LCT过来一看<del>，这不就一水题（</del></p>
<p>xjb写了棵LCT一交。</p>
<p><img src="/images/TIM截图20190215193107.png" alt=""></p>
<p>emmmmmm……</p>
<p>然后改的时候才发现全是细节错误，LCT的部分动都没动一下（</p>
<p>就比如说，下面是我第一次交的程序的主程序部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> opt,x,y;</span><br><span class="line">    cltstream::read(opt);</span><br><span class="line">    cltstream::read(x);</span><br><span class="line">    cltstream::read(y);</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="comment">//我都不知道我当时是怎么想的（</span></span><br><span class="line">        cltstream::read(z);</span><br><span class="line">        split(mempool+x,mempool+y);</span><br><span class="line">        re <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans0=(mempool+y)-&gt;ans0,ans1=(mempool+y)-&gt;ans1,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=k<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(((ans0&gt;&gt;j)&amp;<span class="number">1</span>)&gt;=((ans1&gt;&gt;j)&amp;<span class="number">1</span>)||z&lt;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">            <span class="comment">//甚至忘了用1ULL（</span></span><br><span class="line">                ans^=ans0&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                z-=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                ans^=ans1&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        cltstream::write(ans,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> z;</span><br><span class="line">        cltstream::read(z);</span><br><span class="line">        access(mempool+x);</span><br><span class="line">        (mempool+x)-&gt;tp=y;</span><br><span class="line">        (mempool+x)-&gt;val=z;</span><br><span class="line">        (mempool+y)-&gt;pushUp();</span><br><span class="line">        <span class="comment">//？？？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我Splay节点的内部信息甚至开成了<code>unsigned</code>，excuse me？？？</p>
<p><del>不这个东西这不是我写的（</del></p>
<h3 id="真正的题解"><a href="#真正的题解" class="headerlink" title="真正的题解"></a>真正的题解</h3><p>首先LCT。</p>
<p>不过首先的首先您还是要先做了<a href="https://www.luogu.org/problemnew/show/P2114">这道题</a>。</p>
<p>每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。</p>
<p>我们记这两个值为<code>ans0</code>和<code>ans1</code>。</p>
<p>左子树和节点本身的信息很好维护。</p>
<p>而关于右子树，看上去我们没办法迅速求出把到现在为止的<code>ans0</code>和<code>ans1</code>扔进去跑一遍的结果。</p>
<p>但是注意到这些都是按位运算，位与位之间不互相影响。</p>
<p>我们可以对于<code>ans0</code>中是$1$的那些位，提取出<code>rc-&gt;ans1</code>的对应位，对于<code>ans0</code>中是$0$的那些位，提取出<code>rc-&gt;ans0</code>的对应位。</p>
<p>然后<code>ans1</code>也类似处理就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">    SplayNode *ftr,*lc,*rc;</span><br><span class="line">    <span class="keyword">int</span> tp,rev;</span><br><span class="line">    <span class="keyword">unsigned</span> val,ans0,ans1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">apply</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tp==<span class="number">1</span>?(x&amp;val):tp==<span class="number">2</span>?(x|val):(x^val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ans0=<span class="number">0</span>,ans1=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans0=lc-&gt;ans0;</span><br><span class="line">            ans1=lc-&gt;ans1;</span><br><span class="line">        &#125;</span><br><span class="line">        ans0=apply(ans0),ans1=apply(ans1);</span><br><span class="line">        <span class="keyword">if</span>(rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans0=(ans0&amp;rc-&gt;ans1)|((~ans0)&amp;rc-&gt;ans0);</span><br><span class="line">            ans1=(ans1&amp;rc-&gt;ans1)|((~ans1)&amp;rc-&gt;ans0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是还有一个问题是，LCT在连边和提取路径时需要<code>makeRoot</code>，也就是说需要区间翻转。</p>
<p>但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。</p>
<p>那么提前维护好就行了。提前维护好<code>sna0</code>和<code>sna1</code>，表示把$0$和$-1$反过来跑一遍的结果。</p>
<p>然后就没了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>「年轻人，你渴望力量吗？」</title>
    <url>/min-25-sieve-learning-notes/</url>
    <content><![CDATA[<p>标题来自某学长安利min_25筛的方式（</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，<a href="/number-theory-learning-notes/">杜教筛</a>可以在$O(n^{\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。</p>
<p>但是现在我们希望更快。于是我们有了min_25筛（</p>
<p>以下，我们约定$p$是一个质数。$\mathbb{P}_{i}$表示第$i$小的质数，$\mathbb{P}_{0}=0$。$\text{minp}(n)$表示$n$最小的质因数，$\text{minp}(1)=0$。</p>
<p>现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质：</p>
<ol>
<li>$f(p)$是一个<strong>可以快速求前缀和的完全积性函数</strong>，或者能用多个这样的函数运算得到。</li>
<li>$f(p^{k})$可以快速求，大概$O(k)$以内就可以。</li>
</ol>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>我们要对每一个$x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，求出</p>
<script type="math/tex; mode=display">\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>定义</p>
<script type="math/tex; mode=display">F(x,y)=\sum_{i=1}^{x}[i\in\mathbb{P}\vee\text{minp}(i)\gt\mathbb{P}_{y}]f^{\prime}(i)</script><p>也就是把所有质数和最小质因数大于$\mathbb{P}_y$的合数全部当成质数代入$f^{\prime}$求值并求和。不难发现</p>
<script type="math/tex; mode=display">F(x,+\infty)=\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>我们回忆一下埃式筛法的运行过程。</p>
<p>筛完$k$次后，我们除去了最小质因数小于等于$\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\mathbb{P}_k$的合数。</p>
<p>可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\prime}$的值的和。</p>
<p>首先，第$y$次筛掉的最小的数很明显是$\mathbb{P}_{y}^{2}$，如果$\mathbb{P}_{y}^{2}\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。</p>
<p>也因此，筛质数筛到$\sqrt{n}$即可。</p>
<p>否则，即$\mathbb{P}_{y}^{2}\leqslant x$，我们将所有数除以$\mathbb{P}_{y}$，之前所有最小质因数等于$\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\mathbb{P}_{y}$的数。</p>
<p>又因为$f^{\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\prime}(\cfrac{z}{\mathbb{P}_{y}})f^{\prime}(\mathbb{P}_{y})$计算$f^{\prime}(z)$。</p>
<p>那么看起来</p>
<script type="math/tex; mode=display">F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)</script><p>$F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)$包含了三类数的$f^{\prime}$的值：</p>
<ol>
<li>大于等于$\mathbb{P}_{y}$的质数。</li>
<li>最小质因数大于等于$\mathbb{P}_{y}$（大于$\mathbb{P}_{y-1}$）的合数。</li>
<li>小于$\mathbb{P}_{y}$的质数。</li>
</ol>
<p>但是很明显第三类数不能被除去，因此实际上</p>
<script type="math/tex; mode=display">F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)</script><p>综上所述</p>
<script type="math/tex; mode=display">F(x,y)=\begin{cases}
&F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum\limits_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)\;\;&(\mathbb{P}_{y}^{2}\leqslant x)\\
&F(x,y-1)&(\mathbb{P}_{y}^{2}\gt x)
\end{cases}</script><p>初值为</p>
<script type="math/tex; mode=display">F(x,0)=\sum_{i=2}^{x}f^{\prime}(i)</script><p>注意到第二维只与$y-1$有关，我们可以滚掉。</p>
<p>还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。</p>
<p>因为$x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，这样的$x$最多只有$2\sqrt{n}$个，我们可以离散化存储。</p>
<p>具体实现细节我说不清，看代码吧（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cltstream::read(n);</span><br><span class="line">sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sq;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">        g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">        fsum[g[<span class="number">0</span>]]=fsum[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="comment">/**/</span>;</span><br><span class="line">        <span class="comment">//注释处应填f`(i)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=sq;++j)&#123;</span><br><span class="line">        f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    w[++m]=n/l;</span><br><span class="line">    <span class="comment">//编号对应的离散化前的值</span></span><br><span class="line">    F[m]=<span class="comment">/**/</span>;</span><br><span class="line">    <span class="comment">//注释处应填\sum_&#123;t=2&#125;^&#123;w[m]&#125;f`(t)</span></span><br><span class="line">    <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">        id1[w[m]]=m;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        id2[n/w[m]]=m;</span><br><span class="line">    <span class="comment">//分段存储值对应的编号，这样数组只需要开到sqrt&#123;n&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=g[j]*g[j];++i)&#123;</span><br><span class="line">    <span class="comment">//w[i]&gt;=g[j]*g[j]，所以w[i]/g[j]&gt;=g[j]</span></span><br><span class="line">        re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">        F[i]-=<span class="comment">/**/</span>*(F[id]-fsum[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//注释处应填f`(g[j])</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一部分的时间复杂度已被证明是$O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>然而看上去很奇怪（</del></p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。</p>
<p>定义</p>
<script type="math/tex; mode=display">S(x,y)=\sum_{i=1}^{x}[\text{minp}(i)\geqslant\mathbb{P}_{y}]f(i)</script><p>也就是所有最小质因数大于等于$\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。</p>
<p>首先我们需要统计所有质数的贡献，也就是$F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})$。</p>
<p>关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。</p>
<script type="math/tex; mode=display">\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)</script><p>但是还有一个问题是$S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)$中不包括$f(1)$，因此$f(\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来</p>
<script type="math/tex; mode=display">\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>于是</p>
<script type="math/tex; mode=display">S(x,y)=F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})+\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>然后暴力搜，记忆化都不需要，时间复杂度还是$O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>就很神奇（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">int</span> res=F[id]-fsum[y<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=<span class="comment">/*1*/</span>*S(x/p,i+<span class="number">1</span>)+<span class="comment">/*2*/</span>;</span><br><span class="line">                <span class="comment">//1处应填f(p)，2处应填f(p*g[i])</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="「Luogu-P4213」「模板」杜教筛（Sum）"><a href="#「Luogu-P4213」「模板」杜教筛（Sum）" class="headerlink" title="「Luogu-P4213」「模板」杜教筛（Sum）"></a><a href="https://www.luogu.org/problemnew/show/P4213">「Luogu-P4213」「模板」杜教筛（Sum）</a></h3><p>首先我们有</p>
<script type="math/tex; mode=display">\varphi(p)=\text{id}(p)-1</script><script type="math/tex; mode=display">\mu(p)=-1</script><p>然后$\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。</p>
<p>说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,sq,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],w[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],id1[maxn+<span class="number">1</span>],id2[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> prmcnt[maxn+<span class="number">1</span>],prmCnt[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prmsum[maxn+<span class="number">1</span>],prmSum[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getPhi</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> res=(prmSum[id]-prmCnt[id])-(prmsum[y<span class="number">-1</span>]-prmcnt[y<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];<span class="number">1L</span>L*p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=<span class="number">1L</span>L*p/g[i]*(g[i]<span class="number">-1</span>)*getPhi(x/p,i+<span class="number">1</span>)+<span class="number">1L</span>L*p*(g[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">int</span> res=prmcnt[y<span class="number">-1</span>]-prmCnt[id];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            res-=getMu(x/g[i],i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">            prmcnt[g[<span class="number">0</span>]]=prmcnt[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            prmsum[g[<span class="number">0</span>]]=prmsum[g[<span class="number">0</span>]<span class="number">-1</span>]+i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">        cltstream::read(n);</span><br><span class="line">        sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">            w[++m]=n/l;</span><br><span class="line">            prmCnt[m]=w[m]<span class="number">-1</span>;</span><br><span class="line">            prmSum[m]=<span class="number">1L</span>L*(w[m]<span class="number">-1</span>)*(w[m]+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">                id1[w[m]]=m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                id2[n/w[m]]=m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=<span class="number">1L</span>L*g[j]*g[j];++i)&#123;</span><br><span class="line">                re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">                prmCnt[i]-=prmCnt[id]-prmcnt[j<span class="number">-1</span>];</span><br><span class="line">                prmSum[i]-=<span class="number">1L</span>L*g[j]*(prmSum[id]-prmsum[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        cltstream::write(getPhi(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(getMu(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/TIM截图20190214152934.png" alt=""></p>
<p>上为min_25筛，下为杜教筛。</p>
<p>min_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说</p>
<h3 id="「LOJ6053」简单的函数"><a href="#「LOJ6053」简单的函数" class="headerlink" title="「LOJ6053」简单的函数"></a><a href="https://loj.ac/problem/6053">「LOJ6053」简单的函数</a></h3><p>总结一下这个函数：</p>
<script type="math/tex; mode=display">f(1)=1</script><script type="math/tex; mode=display">f\left(\prod_{i=1}^{N}p_{i}^{r_{i}}\right)=\prod_{i=1}^{N}(p_{i}\otimes r_{i})</script><p>其中$\otimes$表示按位异或。</p>
<p><img src="/images/TIM图片20190103092627.png" alt=""></p>
<p>按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（</p>
<p>注意到</p>
<script type="math/tex; mode=display">f(p)=p\otimes 1=\begin{cases}
&p+1\;\;&(p=2)\\
&p-1\;\;&(p\gt 2)
\end{cases}</script><p>我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。</p>
<p>然后还是要用min_25筛的前半部分筛出$\text{id}$和$1$，其实和上面的$\varphi$没多大区别就是加了点细节（</p>
<p><a href="https://loj.ac/submission/336101">好像这种能随便看代码的OJ可以直接扔个提交记录</a>。</p>
<h3 id="「UOJ188」Sanrd"><a href="#「UOJ188」Sanrd" class="headerlink" title="「UOJ188」Sanrd"></a><a href="http://uoj.ac/problem/188">「UOJ188」Sanrd</a></h3><p>次大质因数和。</p>
<p>其实这个题面有点考阅读的。</p>
<p>但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。<del>说好的只能筛积性函数呢（</del></p>
<p>我们来分析一下min_25筛的运行过程。</p>
<p>调用到$S(x,y)$时，剩下的最小质因数大于等于$\mathbb{P}_{y}$的数中，只有质数与$\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\mathbb{P}_{y-1}$的数。这部分可以直接算。</p>
<p>关于次大质因数大于$\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\mathbb{P}_{i}^{j})$，手动加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">long</span> <span class="keyword">long</span> n,re <span class="keyword">long</span> <span class="keyword">long</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> k=id[x&lt;=sq?x:n/x+sq];</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> res=(y&gt;<span class="number">1</span>?g[y<span class="number">-1</span>]:<span class="number">0</span>)*(prmCnt[k]-y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">long</span> <span class="keyword">long</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=S(n,x/p,i+<span class="number">1</span>)+g[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://uoj.ac/submission/324057">提交记录</a>。</p>
<p><del>一道比一道神仙，像我这种菜鸡只能抄题解了（</del></p>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><ul>
<li><a href="https://loj.ac/problem/572">「LOJ572」「LibreOJ Round #11」Misaka Network与求和</a></li>
<li><a href="https://www.spoj.com/problems/DIVCNTK/">「SP34096」DIVCNTK - Counting Divisors (general)</a></li>
<li><a href="https://www.spoj.com/problems/GCDEX2/">「SP19985」GCDEX2 - GCD Extreme (hard)</a></li>
<li><a href="https://www.spoj.com/problems/APS2/">「SP19975」APS2 - Amazing Prime Sequence (hard)</a></li>
</ul>
<h3 id="其它文献"><a href="#其它文献" class="headerlink" title="其它文献"></a>其它文献</h3><ul>
<li><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096">https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096</a></li>
<li><a href="https://www.cnblogs.com/zhoushuyu/p/9187319.html">https://www.cnblogs.com/zhoushuyu/p/9187319.html</a></li>
<li><a href="https://www.cnblogs.com/cjyyb/p/10169190.html">https://www.cnblogs.com/cjyyb/p/10169190.html</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>动态树学习笔记</title>
    <url>/link-cut-tree-learning-notes/</url>
    <content><![CDATA[<p>24号要出去学习，趁现在先自己xjb学点啥。</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先我们有一道<a href="https://www.luogu.org/problemnew/show/P3690">模板题</a>。</p>
<p>我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。</p>
<p>这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\log^{2}n)$。</p>
<p>但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。</p>
<p>很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。</p>
<p>实链剖分一般被称为LCT，全称<del>Link-Cat Tree</del> <del>Linear Challestend Transformation</del> Link-Cut Tree，也就是动态树。</p>
<p>与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。</p>
<p>为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质：</p>
<ol>
<li>每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。</li>
<li>每个节点属于且仅属于一棵Splay。</li>
<li>如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。</li>
<li>不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。</li>
</ol>
<p>以下图片来自<a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。">https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。</a></p>
<p>我们来看这样一棵树</p>
<p><img src="/images/1309909-20180123095924037-1618037447.png" alt=""></p>
<p>其中粗线表示实边，虚线表示虚边。</p>
<p>它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。</p>
<p><img src="/images/1309909-20180123095955350-1680422636.png" alt=""></p>
<p>当然这并不是唯一的。</p>
<p>为了方便，我先放出我Splay的代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">    SplayNode *ftr,*ls,*rs;</span><br><span class="line">    <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//判断一个节点是否是原森林中的一棵树的树根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">        rev^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                ls-&gt;reverse();</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                rs-&gt;reverse();</span><br><span class="line">            rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sum=val;</span><br><span class="line">        <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">            sum^=ls-&gt;sum;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">            sum^=rs-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    re SplayNode* q=p-&gt;ftr;</span><br><span class="line">    q-&gt;pushDown();</span><br><span class="line">    p-&gt;pushDown();</span><br><span class="line">    p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">            p-&gt;ftr-&gt;ls=p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">            p-&gt;ftr-&gt;rs=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">        q-&gt;rs=p-&gt;ls;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;rs-&gt;ftr=q;</span><br><span class="line">        p-&gt;ls=q;</span><br><span class="line">        q-&gt;ftr=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;ls=p-&gt;rs;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;ls-&gt;ftr=q;</span><br><span class="line">        p-&gt;rs=q;</span><br><span class="line">        q-&gt;ftr=p;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;pushUp();</span><br><span class="line">    p-&gt;pushUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line"><span class="comment">//不同于我们以前写的Splay，现在我们只需要将一个节点旋转到根即可</span></span><br><span class="line">    <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">            rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><p>首先我们有一个基本操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>首先有一个问题是，这个单词怎么读？</p>
<p><code>/ək&#39;ses/</code>？不不不应该是<code>/&#39;ækses/</code>。</p>
<p>如果您有兴趣，可以在<a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation">这里</a>看看自己以前都读错了多少单词（</p>
<p>这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。</p>
<p>我们来看看这个函数的具体过程。还是上面的例子，现在我们调用<code>access(N)</code>，整棵树会变成这样</p>
<p><img src="/images/1309909-20180123101901740-2118178734.png" alt=""></p>
<p><del>虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（</del></p>
<p>首先我们调用<code>splay(N)</code>，令$\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。</p>
<p><img src="/images/1309909-20180123110136115-1112016464.png" alt=""></p>
<p>向上找到$\text{N}$的父亲$\text{I}$，调用<code>splay(I)</code>，回收$\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\text{N}$，然后$\text{N}$就成了$\text{I}$的实儿子了。</p>
<p><img src="/images/1309909-20180123110156272-1242463729.png" alt=""></p>
<p>然后继续向上，找到$\text{I}$的父亲$\text{H}$，调用<code>splay(H)</code>，并令$\text{H}$的右儿子指针指向$\text{I}$。</p>
<p><img src="/images/1309909-20180123110209772-2057141058.png" alt=""></p>
<p>最后一步，找到$\text{H}$的父亲$\text{A}$，调用<code>splay(A)</code>，并令$\text{A}$的右儿子指针指向$\text{H}$。</p>
<p><img src="/images/1309909-20180123110213709-49169640.png" alt=""></p>
<p>然后我们看到，$\text{N}$和$\text{A}$到了同一颗Splay中，完成任务，返回。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    splay(p);</span><br><span class="line">    p-&gt;pushDown();</span><br><span class="line">    p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;pushUp();</span><br><span class="line">    <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">        splay(q-&gt;ftr);</span><br><span class="line">        q-&gt;ftr-&gt;pushDown();</span><br><span class="line">        q-&gt;ftr-&gt;rs=q;</span><br><span class="line">        q-&gt;ftr-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">    splay(p);</span><br><span class="line">    <span class="comment">//据说闲着没事瞎转转有利于摊开时间复杂度（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="findRoot"><a href="#findRoot" class="headerlink" title="findRoot"></a>findRoot</h3><p>有了<code>access</code>，我们就可以随心所欲的瞎搞了。比如说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayNode* <span class="title">findRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>返回给定节点所在的树的树根，也就是调用完<code>access</code>后它所在的实链上深度最小的节点。</p>
<p>因为<code>access</code>的最后自带了一个<code>splay</code>，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">    splay(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="makeRoot-amp-amp-split"><a href="#makeRoot-amp-amp-split" class="headerlink" title="makeRoot &amp;&amp; split"></a>makeRoot &amp;&amp; split</h3><p>现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。</p>
<p>不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用<code>access(x)</code>，然后考虑翻转$x$的子树之后会发生什么。</p>
<p><code>access</code>结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。</p>
<p>那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次<code>access(y)</code>就可以把它抽出来。</p>
<p>我们实现下面两个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>令给定节点成为树根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    p-&gt;reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    access(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p>我们需要实现函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。</p>
<p>思路很简单。假设我们指定$x$和$y$两个节点，首先调用<code>makeRoot(x)</code>，然后检查<code>findRoot(y)</code>的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即<code>findRoot(y)==x</code>，说明两个节点联通，直接返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">        p-&gt;ftr=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>我们需要实现函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>
<p>切断给定的两个节点之间的边。不存在就什么也不做。</p>
<p>需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用<code>makeRoot(x)</code>，此时$y$应该是$x$的右儿子，并且它不能有左儿子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。</p>
<p>完整板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">        _tp z=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkCutTree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">        SplayNode *ftr,*ls,*rs;</span><br><span class="line">        <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">            rev^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                    ls-&gt;reverse();</span><br><span class="line">                <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                    rs-&gt;reverse();</span><br><span class="line">                rev=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            sum=val;</span><br><span class="line">            <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                sum^=ls-&gt;sum;</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                sum^=rs-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        re SplayNode* q=p-&gt;ftr;</span><br><span class="line">        q-&gt;pushDown();</span><br><span class="line">        p-&gt;pushDown();</span><br><span class="line">        p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">                p-&gt;ftr-&gt;ls=p;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">                p-&gt;ftr-&gt;rs=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">            q-&gt;rs=p-&gt;ls;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">                q-&gt;rs-&gt;ftr=q;</span><br><span class="line">            p-&gt;ls=q;</span><br><span class="line">            q-&gt;ftr=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;ls=p-&gt;rs;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">                q-&gt;ls-&gt;ftr=q;</span><br><span class="line">            p-&gt;rs=q;</span><br><span class="line">            q-&gt;ftr=p;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;pushUp();</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">                rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            re SplayNode* p=mempool+i;</span><br><span class="line">            p-&gt;ftr=p-&gt;ls=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">            cltstream::read(p-&gt;val);</span><br><span class="line">            p-&gt;sum=p-&gt;val;</span><br><span class="line">            p-&gt;rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        splay(p);</span><br><span class="line">        p-&gt;pushDown();</span><br><span class="line">        p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">        <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">            splay(q-&gt;ftr);</span><br><span class="line">            q-&gt;ftr-&gt;pushDown();</span><br><span class="line">            q-&gt;ftr-&gt;rs=q;</span><br><span class="line">            q-&gt;ftr-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">        splay(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        access(p);</span><br><span class="line">        <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">        splay(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        access(p);</span><br><span class="line">        p-&gt;reverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        access(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">            p-&gt;ftr=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryPathXorSum</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        split(mempool+x,mempool+y);</span><br><span class="line">        <span class="keyword">return</span> (mempool+y)-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">createEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        link(mempool+x,mempool+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destoryEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        cut(mempool+x,mempool+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyVertice</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        splay(mempool+x);</span><br><span class="line">        (mempool+x)-&gt;val=y;</span><br><span class="line">        (mempool+x)-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;pushDown();</span><br><span class="line">            printTree(p-&gt;ls);</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">"%d(%d,%d,%d)\n"</span>,</span><br><span class="line">                p-mempool,</span><br><span class="line">                p-&gt;ftr!=<span class="literal">NULL</span>?p-&gt;ftr-mempool:<span class="number">-1</span>,</span><br><span class="line">                p-&gt;ls!=<span class="literal">NULL</span>?p-&gt;ls-mempool:<span class="number">-1</span>,</span><br><span class="line">                p-&gt;rs!=<span class="literal">NULL</span>?p-&gt;rs-mempool:<span class="number">-1</span></span><br><span class="line">            );</span><br><span class="line">            printTree(p-&gt;rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LinkCutTree QAQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;\</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    QAQ.build(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,x,y;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(x);</span><br><span class="line">        cltstream::read(y);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cltstream::write(QAQ.queryPathXorSum(x,y),<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                QAQ.createEdge(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                QAQ.destoryEdge(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                QAQ.modifyVertice(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>是不是感觉很好写呢（</del></p>
<h3 id="用LCT维护子树信息"><a href="#用LCT维护子树信息" class="headerlink" title="用LCT维护子树信息"></a>用LCT维护子树信息</h3><p>咕咕咕。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Splay</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-01-20：loli的两场模拟赛的题解</title>
    <url>/lolioi-2019-01-20-solutions/</url>
    <content><![CDATA[<p>今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。</p>
<p>上午记为D1，下午记为D2。</p>
<a id="more"></a>
<h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><h4 id="T1-简-simple"><a href="#T1-简-simple" class="headerlink" title="T1 简 - simple"></a>T1 简 - simple</h4><p>给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。</p>
<p>$n\leqslant 100000$。</p>
<p>不予置评。</p>
<h4 id="T2-单-single"><a href="#T2-单-single" class="headerlink" title="T2 单 - single"></a>T2 单 - single</h4><p>给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义</p>
<script type="math/tex; mode=display">b_{u}=\sum_{i=1}^{n}dist(u,i)a_{i}</script><p>还会给你一个$\text{tp}$，$\text{tp}=0$时给你${a_{n}}$让你求${b_{n}}$，$\text{tp}=1$时给你${b_{n}}$让你求${a_{n}}$。多组数据。</p>
<p>$n\leqslant 100000,T\leqslant 5$。</p>
<p>$\text{tp}=0$时就是一个简单的树形DP。</p>
<p>$\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（</p>
<p>他给的题解我也没看懂（</p>
<p>我就打了$\text{tp}=0$的$30$分。</p>
<h4 id="T3-题-problem"><a href="#T3-题-problem" class="headerlink" title="T3 题 - problem"></a>T3 题 - problem</h4><p>有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。</p>
<p>关于$S$，首先会给你一个$\text{tp}$，然后$S$如下定义</p>
<script type="math/tex; mode=display">S=\begin{cases}
&\{(x,y)\mid x,y\in\mathbb{Z}\}\;\;&(\text{tp}=0)\\
&\{(x,y)\mid x\in\mathbb{N},y=0\}&(\text{tp}=1)\\
&\{(x,y)\mid xy=0\}&(\text{tp}=2)\\
&\{(x,y)\mid x,y\in\mathbb{N}\}&(\text{tp}=3)
\end{cases}</script><p>$n\leqslant 100000$，$n\equiv 0\pmod{2}$，$\text{tp}\in{0,1,2,3}$。特殊地，当$\text{tp}=2$时$n\leqslant 1000$。</p>
<p>四合一数论提答（</p>
<p>很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。</p>
<p>$\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。<br>我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此</p>
<script type="math/tex; mode=display">\text{Ans}=(2n)!\sum_{i=0}^{n}\cfrac{1}{i!i!(n-i)!(n-i)!}</script><p>$\text{tp}=1$直接卡特兰数。</p>
<p>$\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。</p>
<p>如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP</p>
<script type="math/tex; mode=display">f[x]=\sum_{i=1}^{x}f[x-i]\cfrac{(2i)!}{i!i!}</script><p>其实如果改一下模数的话这个东西可以用NTT优化到$O(n\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（</p>
<p>$\text{tp}=3$大概是$\text{tp}=0$与$\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是</p>
<script type="math/tex; mode=display">\begin{aligned}
\text{Ans}&=\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\
&=\sum_{i=0}^{n}\cfrac{(2n)!}{(2i)!(2(n-i))!}\left(\cfrac{(2i)!}{i!i!}-\cfrac{(2i)!}{(i+1)!(i-1)!}\right)\left(\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\right)\\
&=(2n)!\sum_{i=0}^{n}\left(\cfrac{1}{i!i!}-\cfrac{1}{(i+1)!(i-1)!}\right)\left(\cfrac{1}{(n-i)!(n-i)!}-\cfrac{1}{(n-i+1)!(n-i-1)!}\right)
\end{aligned}</script><p>于是愉快地$230$直接rank1（</p>
<p>话说wzx打了$240$分的啊……然而炸成$210$（</p>
<h3 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h3><h4 id="T1-印章-seal"><a href="#T1-印章-seal" class="headerlink" title="T1 印章 - seal"></a>T1 印章 - seal</h4><p>给你一张$n\times m$的纸，上面有些格子要印墨水。你有一个$r\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。</p>
<p>$n,m,r,c\leqslant 1000,T\leqslant 10$。</p>
<p>首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个<code>bitset</code>瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（</p>
<p>拿了$60$就跑（</p>
<h4 id="T2-多边形-polygon"><a href="#T2-多边形-polygon" class="headerlink" title="T2 多边形 - polygon"></a>T2 多边形 - polygon</h4><p>一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。</p>
<p>这是一个$0-4$边形</p>
<p><img src="/images/图片1.png" alt=""></p>
<p>这是一个$1-4$边形</p>
<p><img src="/images/图片2.png" alt=""></p>
<p>这是一个$2-4$边形</p>
<p><img src="/images/图片3.png" alt=""></p>
<p>给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。</p>
<p>$0\leqslant k\leqslant 10^{6},3\leqslant n\leqslant 10^{9}$。</p>
<p><img src="/images/TIM图片20181023195537.jpg" alt=""></p>
<p>告辞（</p>
<p>彻底放弃治疗（</p>
<h4 id="T3-扔球-ball"><a href="#T3-扔球-ball" class="headerlink" title="T3 扔球 - ball"></a>T3 扔球 - ball</h4><p>给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。</p>
<p>所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你${a_{n}}$的期望逆序对数量。四舍五入保留两位小数。</p>
<p>如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。</p>
<p>$n\leqslant 500000,0.4\leqslant p\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\Sigma|S_{i}|\leqslant 500000$。</p>
<p>从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。</p>
<p>套个树状数组就行。</p>
<p>但是等会，$a_{x}=y$的概率怎么算啊。</p>
<p>首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim_{n\rightarrow+\infty}\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\
&=\cfrac{p}{1-(1-p)^{|S_{x}|}}
\end{aligned}</script><p>那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为</p>
<script type="math/tex; mode=display">\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}</script><p>最后总分只有$160$，被$190$分的wzx吊着打（</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>loli</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>「HEOI2016/TJOI2016」求和</title>
    <url>/luogu-p4091-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4091">传送门</a></p>
<p>感觉最近意志消沉啥也不想干，于是继续来颓blog（</p>
<a id="more"></a>
<p>仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（</p>
<p>首先我们知道如果$n\gt m$，$S(n,m)=0$。于是我们将原式写成</p>
<script type="math/tex; mode=display">\sum_{i=0}^{n}\sum_{j=0}^{n}2^{j}j!S(i,j)=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)</script><p>第二类斯特林数有一个通项公式，它长这样</p>
<script type="math/tex; mode=display">S(n,m)=\cfrac{1}{m!}\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现</p>
<script type="math/tex; mode=display">F(n,m,k)=C(m,k)(m-k)^{n}</script><p>然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现</p>
<script type="math/tex; mode=display">G(n,m)=\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。</p>
<p>然后我们继续推式子</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\
&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\
&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\
&=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}
\end{aligned}</script><p>我们看到右边就是一个等比数列求和，于是</p>
<script type="math/tex; mode=display">\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}</script><p>定义</p>
<script type="math/tex; mode=display">F[i]=\cfrac{(-1)^{i}}{i!}</script><p>右边的等比数列求和比较麻烦，我们需要一些特判。</p>
<script type="math/tex; mode=display">G[i]=\begin{cases}
&1&(i=0)\\
&n+1&(i=1)\\
&\cfrac{i^{n+1}-1}{i!(i-1)}\;\;&(i>1)
\end{cases}</script><p>然后我们就有</p>
<script type="math/tex; mode=display">\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\sum_{j=0}^{n}2^{j}j!(F\times G)[j]</script><p>这么一想前几天的我还只会暴力二项式定理展开（</p>
<p><img src="/images/TIM图片20181209192946.jpg" alt=""></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>HEOI</tag>
        <tag>TJOI</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>有上下界的网络流问题与预留推进学习笔记</title>
    <url>/something-about-network-flow-learning-notes/</url>
    <content><![CDATA[<p>感觉最近好颓啊（</p>
<p>这是一篇正在咕咕咕的blog。<br><a id="more"></a></p>
<h3 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a><a href="https://loj.ac/problem/115">无源汇有上下界可行流</a></h3><p>我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\text{upper}(e)-\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令</p>
<script type="math/tex; mode=display">w(u)=\sum_{v\in V,(v,u)\in E}\text{lower}((v,u))-\sum_{v\in V,(u,v)\in E}\text{lower}((u,v))</script><ul>
<li>如果$w(u)=0$，说明我们不需要对点$u$做出调整。</li>
<li>如果$w(u)\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。</li>
<li>如果$w(u)\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。</li>
</ul>
<p>然后直接跑一边从源点到汇点的最大流即可。</p>
<p>需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。</p>
<p>否则，我们就已经构造出了一组可行解。</p>
<h3 id="有源汇有上下界最大流"><a href="#有源汇有上下界最大流" class="headerlink" title="有源汇有上下界最大流"></a><a href="https://loj.ac/problem/116">有源汇有上下界最大流</a></h3><p>这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。</p>
<p>我们可以从汇点到源点连一条流量上界为$+\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。</p>
<p>需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。</p>
<p>当然，求解可行流时无解的话，整个问题无解。</p>
<h3 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a><a href="https://loj.ac/problem/117">有源汇有上下界最小流</a></h3><p>还没看懂，先咕着。</p>
<h3 id="最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）"><a href="#最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）" class="headerlink" title="最高标号预流推进（HLPP-Highest Label Preflow Pushing？）"></a><a href="https://loj.ac/problem/127">最高标号预流推进（HLPP-Highest Label Preflow Pushing？）</a></h3><p>还没看懂，先咕着。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>预留推进</tag>
      </tags>
  </entry>
  <entry>
    <title>类欧几里得算法学习笔记</title>
    <url>/similar-euclid-algorithm-learning-notes/</url>
    <content><![CDATA[<p>其实我也不知道这个算法的英文名是啥（</p>
<p>我就yy出来一个「Similar Euclid Algorithm」（</p>
<a id="more"></a>
<p>给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出</p>
<script type="math/tex; mode=display">\sum_{i=0}^{n}i^{k_{1}}\lfloor\cfrac{ai+b}{c}\rfloor^{k_{2}}\pmod{1000000007}</script><p>$n,a,b,c\leqslant 10^{9}$，$k_{1}+k_{2}\leqslant 10$。</p>
<p><img src="https://i.loli.net/2019/01/10/5c36dbda14c92.jpg" alt=""></p>
<p>太难了，告辞（</p>
<p>所以我们现在来研究简单一点的。</p>
<p>给你四个非负整数$n,a,b,c$，你需要求出</p>
<script type="math/tex; mode=display">\begin{aligned}
f(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\
g(n,a,b,c)&\equiv\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\
h(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\pmod{998244353}
\end{aligned}</script><p>$n,a,b,c\leqslant 10^{9}$，$10^{5}$组询问。</p>
<p><a href="https://www.luogu.org/problemnew/show/P5170">传送门</a></p>
<p>于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。</p>
<p>首先考虑$f(n,a,b,c)$，假设$a\geqslant c\vee b\geqslant c$</p>
<script type="math/tex; mode=display">\begin{aligned}
f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)\\
&=\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\\
&=f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor
\end{aligned}</script><p>也就是说，我们只需要重点关注$a\lt c\wedge b\lt c$时的情况即可。我们令$m=\lfloor\cfrac{an+b}{c}\rfloor$，然后继续往下推</p>
<script type="math/tex; mode=display">\begin{aligned}
f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\sum_{j=1}^{m}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\leqslant ai+b\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\geqslant cj+c-b\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\geqslant\cfrac{cj+c-b}{a}\right]\\
\end{aligned}</script><p>然后我们发现，我们可能需要在$\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。</p>
<p>考虑转换一下思路。既然$cj+c\leqslant ai+b$，我们就有$cj+c\lt ai+b+1$，然后再往下</p>
<script type="math/tex; mode=display">\begin{aligned}
f(n,a,b,c)&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\lt ai+b+1\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\gt cj+c-b-1\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]\\
&=\sum_{j=0}^{m-1}\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\
&=mn-\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\
&=mn-f(m-1,c,c-b-1,a)
\end{aligned}</script><p>然后我们看到，这个函数它递归了！</p>
<p>注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\log a$次，时间复杂度就是$O(\log a)$了。</p>
<p>然后考虑$g(n,a,b,c)$。</p>
<p>$a\geqslant c\vee b\geqslant c$：</p>
<script type="math/tex; mode=display">\begin{aligned}
g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\left(i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i^{2}\lfloor\cfrac{a}{c}\rfloor+i\lfloor\cfrac{b}{c}\rfloor\right)\\
&=\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\\
&=g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor
\end{aligned}</script><p>$a\lt c\wedge b\lt c$，当然$m$还是$\lfloor\cfrac{an+b}{c}\rfloor$：</p>
<script type="math/tex; mode=display">\begin{aligned}
g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\
&=\sum_{i=0}^{n}\sum_{j=1}^{m}i\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}i\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]
\end{aligned}</script><p>我们可以把上面这个式子理解成$\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor$且$\leqslant n$的所有自然数之和，于是差分一下我们得到</p>
<script type="math/tex; mode=display">\begin{aligned}
g(n,a,b,c)&=\sum_{j=0}^{m-1}\left(\cfrac{n(n+1)}{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\
&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\
&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)
\end{aligned}</script><p>我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。</p>
<p>$a\geqslant c\vee b\geqslant c$：</p>
<script type="math/tex; mode=display">\begin{aligned}
h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\
&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)^{2}\\
&=\sum_{i=0}^{n}\left(
\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}
+i^{2}\lfloor\cfrac{a}{c}\rfloor^{2}
+\lfloor\cfrac{b}{c}\rfloor^{2}
+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+2\lfloor\cfrac{b}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor
\right)\\
&=
\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}
+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}
+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}\\&
+2\lfloor\cfrac{a}{c}\rfloor\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+2\lfloor\cfrac{b}{c}\rfloor\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor
+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor
\\
&=
h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&
+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}
+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}
+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor
\end{aligned}</script><p>您绝对想象不到上面这一坨子东西的$\TeX$源码长什么样（</p>
<p>$a\lt c\wedge b\lt c$：</p>
<script type="math/tex; mode=display">\begin{aligned}
h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\
&=\sum_{i=0}^{n}\sum_{j=1}^{m^{2}}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor^{2}\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[c^{2}j+c^{2}\lt a^{2}i^{2}+2abi+b^{2}+1\right]\\
&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[i\gt\sqrt{\lfloor\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\rfloor}\right]
\end{aligned}</script><p><img src="https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg" alt=""></p>
<p>然后我们发现推不下去了。</p>
<p>不过办法总是有的。首先我们有一个看起来没啥用的式子</p>
<script type="math/tex; mode=display">x^{2}=2\sum_{i=1}^{n}i-x</script><p>套进去</p>
<script type="math/tex; mode=display">\begin{aligned}
h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\
&=\sum_{i=0}^{n}\left(2\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\lfloor\cfrac{ai+b}{c}\rfloor\right)\\
&=2\sum_{i=0}^{n}\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\
&=2\sum_{j=1}^{m}j\sum_{i=0}^{n}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]-f(n,a,b,c)\\
&=2\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^{n}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]-f(n,a,b,c)\\
&=2\sum_{j=0}^{m-1}(j+1)\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)-f(n,a,b,c)\\
&=m(m+1)n-2\sum_{j=0}^{m-1}j\lfloor\cfrac{cj+c-b-1}{a}\rfloor-2\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor-f(n,a,b,c)\\
&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\
\end{aligned}</script><p>然后我们看到它奇迹般地递归了！</p>
<p>我们来总结一下。</p>
<script type="math/tex; mode=display">f(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}
&f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\
&mn-f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)
\end{cases}</script><script type="math/tex; mode=display">g(n,a,b,c)=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}
&g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\
&\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)
\end{cases}</script><script type="math/tex; mode=display">h(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}=\begin{cases}
&h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)
+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&
+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}
+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}
+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\;\;
&(a\geqslant c\vee b\geqslant c)\\
&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\lt c\wedge b\lt c)
\end{cases}</script><p>但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样：</p>
<script type="math/tex; mode=display">f(n,a,b,c)=\begin{cases}
&\lfloor\cfrac{b}{c}\rfloor\;\;&(n=0)\\
&(n+1)\lfloor\cfrac{b}{c}\rfloor&(a=0)
\end{cases}</script><script type="math/tex; mode=display">g(n,a,b,c)=\begin{cases}
&0\;\;&(n=0)\\
&\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor&(a=0)
\end{cases}</script><script type="math/tex; mode=display">h(n,a,b,c)=\begin{cases}
&\lfloor\cfrac{b}{c}\rfloor^{2}&(n=0)\\
&(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}&(a=0)
\end{cases}</script><p>另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,a,b,c,n,I2=<span class="number">499122177</span>,I6=<span class="number">166374059</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,h;</span><br><span class="line"></span><br><span class="line">    Query(re <span class="keyword">int</span> _f,re <span class="keyword">int</span> _g,re <span class="keyword">int</span> _h)&#123;</span><br><span class="line">        f=_f;</span><br><span class="line">        g=_g;</span><br><span class="line">        h=_h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Query <span class="title">query</span><span class="params">(re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(b,<span class="number">0</span>,<span class="number">1L</span>L*b*b%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a)&#123;</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod,<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod,<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">        re Query res=query(a%c,b%c,c,n);</span><br><span class="line">        a/=c,</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(</span><br><span class="line">            (res.f+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*a%mod+<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod)%mod,</span><br><span class="line">            (res.g+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod)%mod,</span><br><span class="line">            (res.h+<span class="number">2L</span>L*a*res.g%mod+<span class="number">2L</span>L*b*res.f%mod</span><br><span class="line">                  +<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod*a%mod</span><br><span class="line">                  +<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*a%mod*b%mod)%mod</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> m=(<span class="number">1L</span>L*a*n+b)/c;</span><br><span class="line">        re Query res=query(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>);</span><br><span class="line">        re <span class="keyword">int</span> tmp=((<span class="number">1L</span>L*m*n%mod-res.f)%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> Query(</span><br><span class="line">            tmp,</span><br><span class="line">            ((<span class="number">1L</span>L*m*n%mod*(n+<span class="number">1</span>)%mod-res.h-res.f)%mod+mod)*I2%mod,</span><br><span class="line">            ((<span class="number">1L</span>L*m*(m+<span class="number">1</span>)%mod*n%mod<span class="number">-2L</span>L*res.g%mod<span class="number">-2L</span>L*res.f%mod-tmp)%mod+mod)%mod</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">        cltstream::read(n);</span><br><span class="line">        cltstream::read(a);</span><br><span class="line">        cltstream::read(b);</span><br><span class="line">        cltstream::read(c);</span><br><span class="line">        Query ans=query(a,b,c,n);</span><br><span class="line">        cltstream::write(ans.f,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(ans.h,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(ans.g,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，这个东西有什么用啊。</p>
<p><del>没啥用（</del></p>
<p>其他的模板题我就不举了，我们来看一下<a href="https://www.luogu.org/problemnew/show/P4433">这样一道题</a>。</p>
<p>看到推平操作我们可以直接往珂朵莉树上想了。</p>
<p>那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息<code>l,r,L,R,a,b</code>，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\sum_{i=L}^{R}ai\operatorname{mod}b$颗石头。注意这里的<code>l,r,L,R</code>一定不要搞混<del>，我就是因为这样WA了整整四遍（</del>。</p>
<p><del>这三个样例一定是故意的。</del></p>
<p>然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：</p>
<script type="math/tex; mode=display">\sum_{i=L}^{R}ai\operatorname{mod}b=\sum_{i=L}^{R}\left(ai-\lfloor\cfrac{ai}{b}\rfloor b\right)=\cfrac{(R+L)(R-L+1)}{2}-\sum_{i=0}^{R}\lfloor\cfrac{ai}{b}\rfloor b+\sum_{i=0}^{L-1}\lfloor\cfrac{ai}{b}\rfloor b</script><p>直接一波板子套上去。</p>
<p>还有就是，这么算的话中间量会爆<code>long long</code>，我们可以考虑用<code>__int128_t</code>来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后把一些没必要用或者是不能用<code>__int128_t</code>的改成<code>signed</code>即可。</p>
<p>代码还是有必要贴一下的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">signed</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">signed</span> digit[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">simEuc</span><span class="params">(re <span class="keyword">int</span> n,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)</span><br><span class="line">        <span class="keyword">return</span> b/c;</span><br><span class="line">    <span class="keyword">if</span>(!a)</span><br><span class="line">        <span class="keyword">return</span> (n+<span class="number">1</span>)*(b/c);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">        re <span class="keyword">int</span> res=simEuc(n,a%c,b%c,c);</span><br><span class="line">        <span class="keyword">return</span> res+n*(n+<span class="number">1</span>)*(a/c)/<span class="number">2</span>+(n+<span class="number">1</span>)*(b/c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> m=(a*n+b)/c;</span><br><span class="line">        <span class="keyword">return</span> m*n-simEuc(m<span class="number">-1</span>,c,c-b<span class="number">-1</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,L,R,a,b,sum;</span><br><span class="line"></span><br><span class="line">    node(re <span class="keyword">int</span> _l,re <span class="keyword">int</span> _r,re <span class="keyword">int</span> _L,re <span class="keyword">int</span> _R,re <span class="keyword">int</span> _a,re <span class="keyword">int</span> _b)&#123;</span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        L=_L;</span><br><span class="line">        R=_R;</span><br><span class="line">        a=_a;</span><br><span class="line">        b=_b;</span><br><span class="line">        sum=(R+L)*(R-L+<span class="number">1</span>)*a/<span class="number">2</span>-simEuc(R,a,<span class="number">0</span>,b)*b+simEuc(L<span class="number">-1</span>,a,<span class="number">0</span>,b)*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re node p1,re node p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _it <span class="title">split</span><span class="params">(re <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    re _it it=s.lower_bound(node(pos,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        --it;</span><br><span class="line">        re <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r,L=it-&gt;L,R=it-&gt;R,a=it-&gt;a,b=it-&gt;b;</span><br><span class="line">        s.erase(it);</span><br><span class="line">        s.insert(node(l,pos<span class="number">-1</span>,L,L+pos-l<span class="number">-1</span>,a,b));</span><br><span class="line">        <span class="keyword">return</span> s.insert(node(pos,r,L+pos-l,R,a,b)).first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    s.insert(node(l,r,<span class="number">1</span>,r-l+<span class="number">1</span>,a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;res+=itl-&gt;sum,++itl);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    s.insert(node(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        re <span class="keyword">int</span> opt,l,r,a,b;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(l);</span><br><span class="line">        cltstream::read(r);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            cltstream::read(a);</span><br><span class="line">            cltstream::read(b);</span><br><span class="line">            modifyStone(l,r,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cltstream::write(queryStone(l,r),<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>类欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>「HEOI2012」采花</title>
    <url>/luogu-p4113-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4113">传送门</a></p>
<p><a href="https://dftyem.github.io/2019/01/07/HEOI2012-采花/">Taduro的题解</a></p>
<p>sto <strong>Taduro</strong> orz</p>
<a id="more"></a>
<p>首先，读完题一定有人要跳出来喊「莫队！」。</p>
<p><del>莫队！</del></p>
<p>然后再一看数据范围</p>
<blockquote>
<p>对于$100\%$的数据，$1\leqslant c\leqslant n,m\leqslant 2\times 10^{6}$。</p>
</blockquote>
<p><del>笑容逐渐消失。</del></p>
<p>然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了<del>，树状数组什么时候有这种操作了</del>。</p>
<p>首先这个样例比较菜，我们手造一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 6 2 4 2 3 6 2</span><br></pre></td></tr></table></figure>
<p>首先我们维护一个<code>nxt</code>数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的<code>nxt</code>差不多长这样：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>nxt[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$8$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<p>然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。</p>
<p>然后我们还需要一个数组<code>ans</code>，对于每一种颜色，我们令<strong>其在指针所在位置及其之后的部分中第二次出现的位置</strong>的<code>ans</code>为$1$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<p>因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。</p>
<p>不难发现，此时$\sum_{i=1}^{x}ans[i]$就是询问<code>1 x</code>的答案。</p>
<p>需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的<code>ans</code>置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。</p>
<p>这个时候<code>nxt</code>数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。</p>
<p>让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$\underline{1}$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$\underline{2}$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$\underline{3}$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">${\color{red}6}$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">${\color{red}6}$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">${\color{red}0}$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>i</code></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$\underline{4}$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>c[i]</code></td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">${\color{red}2}$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">${\color{red}2}$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">${\color{red}2}$</td>
</tr>
<tr>
<td style="text-align:center"><code>ans[i]</code></td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">${\color{red}0}$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">${\color{red}1}$</td>
</tr>
</tbody>
</table>
</div>
<p>对于一次询问<code>l r</code>，我们将指针移动到<code>l</code>这个位置之后查询$\sum_{i=l}^{r}ans[i]$即可。</p>
<p>代码就不贴了<del>，其实我还没写（</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>分块</tag>
        <tag>HEOI</tag>
        <tag>2012</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>「AHOI2017/HNOI2017」礼物</title>
    <url>/luogu-p3723-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3723">传送门</a></p>
<a id="more"></a>
<p>首先我们要有一个简单粗暴的暴力。</p>
<script type="math/tex; mode=display">\min\limits_{x=0}^{n-1}\min\limits_{c_{1}=0,c_{2}=0}^{m}\sum\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\%n}-c_{2})^{2}</script><p>因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。</p>
<script type="math/tex; mode=display">\min\limits_{x=0}^{n-1}\min\limits_{c=-m}^{m}\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}</script><p>我们仔细观察一下那个$\Sigma$。</p>
<script type="math/tex; mode=display">\begin{aligned}
&\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}\\
=&\sum\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\%n}+2cA_{i}-2cB_{(i+x)\%n})\\
=&\sum\limits_{i=0}^{n-1}A_{i}^{2}+\sum\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\sum\limits_{i=0}^{n-1}A_{i}-\sum\limits_{i=0}^{n-1}B_{i})-2\sum\limits_{i=0}^{n-1}A_{i}B_{(i+x)\%n}
\end{aligned}</script><p>首先$\Sigma A_{i}^{2}$和$\Sigma B_{i}^{2}$可以看成是常数项。</p>
<p>$nc^{2}+2c(\Sigma A_{i}-\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\Sigma A_{i}-\Sigma B_{i})$，我们知道它在$c=-\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\lfloor -\cfrac{k}{n}\rfloor$和$c=\lceil -\cfrac{k}{n}\rceil$两者都代入原式，然后取较小值。</p>
<p>然后我们想要求出$\Sigma A_{i}B_{(i+x)\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。</p>
<script type="math/tex; mode=display">\sum\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\sum\limits_{i=0}^{x-1}A_{i-x+n}B_{i}</script><p>然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。</p>
<p>然后一想，我们可以倒过来搞啊。</p>
<p>定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成</p>
<script type="math/tex; mode=display">\begin{aligned}
&\sum\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\sum\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\
=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}
\end{aligned}</script><p>然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。</p>
<p>以下是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 131072</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans,k,mx;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],C[maxn+<span class="number">1</span>],D[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(A[i]);</span><br><span class="line">        ans+=A[i]*A[i];</span><br><span class="line">        k+=A[i];</span><br><span class="line">        C[n<span class="number">-1</span>-i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(B[i]);</span><br><span class="line">        ans+=B[i]*B[i];</span><br><span class="line">        k-=B[i];</span><br><span class="line">        D[n<span class="number">-1</span>-i]=B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=min(n*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n),n*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n));</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">1</span>;m&lt;n;m&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    m&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(m&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    NTT(A,m,<span class="number">0</span>);</span><br><span class="line">    NTT(B,m,<span class="number">0</span>);</span><br><span class="line">    NTT(C,m,<span class="number">0</span>);</span><br><span class="line">    NTT(D,m,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        A[i]=<span class="number">1L</span>L*A[i]*D[i]%mod;</span><br><span class="line">        B[i]=<span class="number">1L</span>L*B[i]*C[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    NTT(A,m,<span class="number">1</span>);</span><br><span class="line">    NTT(B,m,<span class="number">1</span>);</span><br><span class="line">    mx=A[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        mx=max(mx,A[n<span class="number">-1</span>-i]+B[i<span class="number">-1</span>]);</span><br><span class="line">    cltstream::write(ans-=<span class="number">2</span>*mx);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>AHOI</tag>
        <tag>HNOI</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5162」WD与积木</title>
    <url>/luogu-p5162-solution/</url>
    <content><![CDATA[<p>9102年的第一篇blog。</p>
<p><a href="https://www.luogu.org/problemnew/show/P5162">传送门</a></p>
<a id="more"></a>
<p>大概算是我用NTT切的第一道非模板题。</p>
<p>其实本来应该是<a href="http://codeforces.com/contest/438/problem/E">这道</a>。不过调不出来了弃了。</p>
<p>首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。</p>
<p>首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程：</p>
<script type="math/tex; mode=display">G[n]=\sum\limits_{i=0}^{n}C_{n}^{i}G[n-i]</script><p>但是这样对吗？</p>
<p>代入$n=0$我们发现</p>
<script type="math/tex; mode=display">G[0]=C_{0}^{0}G[0]=G[0]</script><p><img src="https://i.loli.net/2019/01/02/5c2c7c9a52fe9.jpg" alt=""></p>
<p>注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。</p>
<p>那然后$G[0]$应该等于几？</p>
<script type="math/tex; mode=display">G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1</script><p>所以说$G[0]=1$。</p>
<p>如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。</p>
<p>再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开</p>
<script type="math/tex; mode=display">G[n]=n!\sum\limits_{i=0}^{n}\cfrac{1}{i!}\times\cfrac{G[n-i]}{(n-i)!}</script><p>定义</p>
<script type="math/tex; mode=display">H[n]=\begin{cases}
&0&(n=0)\\
&\cfrac{1}{n!}\;\;&(n>1)
\end{cases}</script><script type="math/tex; mode=display">G[n]=n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{G[n-i]}{(n-i)!}</script><p>注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义</p>
<script type="math/tex; mode=display">G^{\prime}[n]=\cfrac{G[n]}{n!}</script><p>就可以得到</p>
<script type="math/tex; mode=display">\begin{aligned}
G^{\prime}[n]&=\sum\limits_{i=0}^{n}H[i]\times G^{\prime}[n-i]\\
G^{\prime}&=G^{\prime}H+1
\end{aligned}</script><p>注意不要忘了$+1$。因为很明显地$G^{\prime}H[0]=0$，而$G^{\prime}[0]=1$。</p>
<p>然后我们就有</p>
<script type="math/tex; mode=display">G^{\prime}=\cfrac{1}{1-H}</script><p>然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。</p>
<p>首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此</p>
<script type="math/tex; mode=display">F[n]=G[n]+\sum\limits_{i=0}^{n}C_{n}^{i}F[n-i]</script><p>然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（</p>
<script type="math/tex; mode=display">
\begin{aligned}
F[n]&=G[n]+n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{F[n-i]}{(n-i)!}\\
&=n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\
F^{\prime}[n]&=\cfrac{F[n]}{n!}\\
&=\sum\limits_{i=0}^{n}H[i]\times(F^{\prime}[n-i]+G^{\prime}[n-i])\\
F^{\prime}&=H(F^{\prime}+G^{\prime})
\end{aligned}</script><p>不过这次我们就不需要$+1$了。</p>
<p>解上面的方程，我们得到</p>
<script type="math/tex; mode=display">F^{\prime}=\cfrac{HG^{\prime}}{1-H}=\cfrac{G^{\prime}}{(1-H)^{2}}</script><p>然后我们总结一下</p>
<script type="math/tex; mode=display">H[n]=\begin{cases}
&0&(n=0)\\
&\cfrac{1}{n!}\;\;&(n>1)
\end{cases}</script><script type="math/tex; mode=display">G^{\prime}=\cfrac{1}{1-H}</script><script type="math/tex; mode=display">F^{\prime}=\cfrac{G^{\prime}}{(1-H)^{2}}</script><p>最后的答案，也就是$n$块积木的期望层数，就是$\cfrac{F[n]}{G[n]}$。然后不难发现$\cfrac{F^{\prime}[n]}{G^{\prime}[n]}=\cfrac{F[n]}{G[n]}$。</p>
<p>我就是不贴代码（</p>
<p><del>反正会的应该都能写出来了吧（</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>题目组试题选讲</title>
    <url>/timuzu-solutions/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2dd6a073ce060181f6cd51069ce323e81141edff4cefa985ed9cd96a4b7ddb31">39c32e27a93b45abda723b50a96178dff13d54f3e6a396d6ce96140a006d6cad17d6dfff6507efae5a5bf041a25f046793e6e6509a451f93fe04fc87bc2c4332662b80c89907c65dd3356e18d4d0485f8ac63cb4dc10f759faeb9d4352bb31a2b984fbbacf4df0ff579a754841f1a651c51f0c8f20b24336eb9dadbf7c637aebc27b01af560bb6bd596f9eab7c94c28e81c53a2a39811081dd7e8136866c8e1033da4046266d761416ea9c1fdd2c634f5c9e9154ab12483232c794f7fee7d4ca1e4ba3289198cf974b205259cdd879e83d8b142ca8208dd8e1fd564669800c9c29e896ae16ce6d5337895620e2569eca3beb31ebf996a570ba8ff214bef0cbb521a69b60aac910a0d38ab9613006c5b9f4d48938e38901d4a0ad3164a0e984333227e6350f047692304e9abac419c338188a7298da99f6346d33e51cfad0f310545e89c22d204465fb657d39fb3d18983b62ef31427566fd06dea02804e9294bb0e81f527a2cff6e7286eb4fc6da9713906876d2166965831eb398b39d1acf75fa9bfa4cebc5eb5164c2e2d89b76e5204a243354879ec8e51d272af36f1116ac94cd505c9f0f3825075d314c6a73f7563e349f4bf6ec68a2dc9bc7ea239aa5a10b859df62b2e89dcc80d2a021663f227a6743253646a8e120525b5a08dedc4534a81164dd5d72bbf44db2c9583e9d99673eab3cd763a837fb298ecad3e0a8c9f0b3fb51f88d89de6ec7182d1d0b811b998a2ebb4aa83c2902539c5352af669be7cf54684d211062431bf84fe99a5cd8a91ee55656da62f5642fb29c439a0a1b91cd92cda8c80a946d55ed7f3214139299277c57ad83d14d58be495a59fddd03e23a7df43d62cc53a8a586f3c5ae74f28580200d8da2bed2a79a3f86f29d254f5598b90d67583c9d9a7db1f803da31b9db995f93449256ce59cc144e165b849c52590c0e8d4d990afc378a581aacf2a2a6c5e7f098aef98b20981a26f3f01728a67a4a78098f6204604a80d4b2b6efda40912219843364a10c334adce9a724964900c1579f1babababae2f73665669c8dfa8981ce51fe95b03a0b1a4c77c2c71e9f04544d1e2b62ec88745aa750e1ebf34c1e2694da25e702dde398e7bbba7d67ff3738a0444d3d411c33d049c07ba7a0f4a274f3cdd8213580fd63adcae84c5da0c3a2ac4711a15f30afce2249f118dba705100fce568f77447be077b0e454bba67970b567e95702800e00e95fe3e072c77900e43d19b724027fd9ee68a706f3c249abb20784ce4302a5535a8440d14027f38bf19b1701a3935f79b624369b0f50b7773ca38fe0d7636890d1c8d2220c98d3a561a7e12d4fbdff7d13c6fd162432aa63f9d71f36ffccaaa6189fd356d68a7fdc6a1a6a4e5181cd5b10ade679e5293bf1b109afff6d0707aaddda869ccdeb688a65b750558df79ffad8d61383e139d8e28360097be68105c7bbb5a167baae4335b5feeb9cbf8837530379d1bb2613fe1c4c3e07e5d2265fb1f411143871ce4db50d53bc30ea0089fdcd9c23c19186ab2e35a4deec9161f5093b4f6edc2efdbf66774cb8cfa0cdfe6b8512edbb0824ae0b8ca6b1198e10580adc6cfb204955b0b91d1aab61ee81a240ec75ddef76a3505964ad8f60684bd55f09b15b82a59c42e59d1940edd7ae8309fa3c19fa45423420c97c34f4d0734abbfd6ccf89bd453ea649685c1a7104f004521ae70241a8e4e9312aea64631528fe05154bfc6b20c5bf3dfc0d017d60825d62ef5ecb1f94d2d44df6f00de103c1cb66e31957d858b959226fbe4cd59aea1807b80304468f6378da99834009a26bf259b75cf1e00eac9934a396b3bafd30676f83339ac66926b19a278850fd609e31f645fb99c9cf427f3a19526bc5c473c971b7deb50d2a8e03df4f5eef2cd9887d4e505334293ceac22850a97318d3db49e6a567367372b2e2c1bac3a30a942ade68610881567171fb0d7e37878b3e96c4a0eb251086b59f725fe1a8591baacbdc6391488732f680e895173eb04cf8da54adc16870c1bb6c36e869fc28980f1d7f39940f001ff991c5257363d8088a41ed65435d9084acb15a807ad62f7740299b3142ac6b15c5d6fa93a2075bf8713343969d965d63248ba80f4b0205f4aa7b5d41544c1ab77b016be2ad02a668507fb58e18f5f55f13b30eabfc98e6b5e5a27b3596038253a9bc10ccb2203ffc47f4ca80e2aa7005016cc52fafd0cc5e44cefa0c038ca034d2045d971bdf148574e9604b7a7f314384f1edb9d4055517afedab186da018065aca86fdd33722434345af68bbe7f8ff986a67e7fd7fbe580fad7254ef6760057f579ec282ee6cae66b4eb8aef82d63269aa1dc10325fb3df4965cc865b05c4a7a1daf7bd8b15e3951aac407d64b3abba47769af257b4cd8d012ebf1dad4c6d2f7e4c119b12cbef3923bef2537bc6078b678dfbcc53408aeae8866843a0919c3873c5bcac89c19cf9badb830923275361fb6675b3d2f55409a09257ea5a5cafb708816c91d269dd65a77c74bae917aedaeb0d033ad5efaf431839d0c1490be8bcafd9e33e7e8be03a60f8ad97f3a2f687fbdc7cd7b3f98ade1ebe8d9879940b38217d396d54e33598962ff766ce94f61c0f0ecd0686cea469086fb23fab07cee7bdc87195de59047a8584d1c4460a033d94c2b0c90ed2b15d6abfc74c97feddcf99289f4cb454b9469fee3c15c171ac1905d4b8c035d00322fde5450f44c3b900eb20e0cba32ce1ec0dbfd66764725dd8ffdaac91fcfd3c6e49b6d4543334678f4dcb48604cf02e8462d804f01d9defd1562d7266120b7983a2a212296a2d453c18c95059f7770258a95ceb77371daa6092eff8c14475323b8031ac13dd6ad920c02fc42f44b468924eade1d2d26890d6df365aa2617c0fdf097beb0aabe61f974ac3005c6e4ea285fb1f62251d0c8fcfb22abde43c482e39cc8de403626be18fdffd4c60b7e5f9a5a8981f04a4386dd43143593f1c24831004302a175e5cf0dd751910be2b8313e5a840acc34b1121c3c5e6f8aaa7e9afba9c4d530f6af90b95e447c0eb57c8d26e87b32e102c9a2f81c0660f6fdd43bfdbafcc5b31234b6c2019e91528ebffac1f00ba63d8f00b9d5eec9c3914b139915ab08c53a3f1b93dd658bf5a5fd5204ce141dca39875f228d42c702c82019304fe17e9d5b2808af3e382ea0f3ecb74da17812e9c6b9fab57300a8269f8a6478a7131b10b2f8029ddf895bd9e8a986225c59365d4b3e2941f1fe1d1c9692867f0ccb213d633b59e301d6890b80eac123de0f0ff5c0c77b51935e639678907de447e9bdc28564485cf7beec522c623b0f9fd157d935cbc361632256acee1c783a2ac7b824f8dd6a9719ffc68d82f8f23bb8b83a44df3cb85eaca5559e9ed88fd6491ba73d1fdd67b9b2adbda6bb34c1932198538c54cdd3e1753f7e2bac647cc1b19a411b66c033a9a3660007886339bdd5a63429d7a01300dac9ffc1fc637896cb5cce3eed7a3d7bccb5d220ddaa6c2e278eff3c7c5e7a83fbe26ce4fbf22d963268eb20f8cfacff791ae886925d2e7942fa197952e67b60fe160320d624906d5c35c4eac778b4e7aec0845c9917ba6e6f9dfbb883dcde8c131adea4ab60265c72bfc4c265b64fde270cd63a904f239d05ec890c882880a5324e0c7141a49a34808f60b530d5eeed036bf4d476682170ec9e4bd0fcad2ad7ff3fcef4e2822948df0c885c0978842e1fdf4742ac2456d3157b9b9b41a43a28a98650640f5aecb8aa09d7c5087014d6f8ca0acdfaa0be36fb6750e2d7af458ee3bed15fb2ca9ef62a8fd22f368ef12724d9159d516e4cfe155a96326739b274b68e54b4e53017dd8e247542ad4f7f9240d18ca694248233e730d95b1e31a11294930380032d6d76327b55d74d89a9ac3a787ddeae2051e7e588d777e9c52812846c77f4c1e6d8caec6c141dd54f533aac193d63d9756bc37548712fa91b7300c15c125e8b3f485c7d33a0bcf5f577163241735c55c4a2f5cdf2af0a6047f82fe3d391a7f94a9640e1a3abe1b597b0e973d7fd2cbcfbfd85c26687080833210b407220e3058aca62d191c188361a0a127eaac9725bfb54d6396d6877726a1b4dcb8b89994e27f8d9c79e874a4e68aff12b3f4b223c02ccd564b33020dab08f25626a3a5c6b20bf700cd10bbf50ca527e3d0ab01cf22217990e4ebd48ae4702ad67f8df3a659438a3a88dd99ec45829c8aadc0f188c0908817798a2991491a3d643058c0a3377d37c4754ee1da79659feea21e32f157dce0f568e81e2033b1f7cafd3e1fbff2c49458eb6f49182ef28e346931a1f96f653a34c99cece7f795ec602140c9ac3545df735d48ac1c0da67f7f35b5cccfa00024d7fc509719a8a149fc52a86128b8964ad5d1dd8873fdd30d04c60f1722e5008c53d7e0b9e2adaf408af20d04dd6bb9a77f409a5efe116ff599d5ff2627b9a20ac10ff2fb1b38486d8c078f7e4b2557caf4635d011ae1d815f9c3a3e7b6656af32bfbcab0a66624c5672a1aeafda8e138ff16004aa9356c0150ee86c0f345a8ae051e54c0b794cbc7ad56046bc18920f5bc61011e91b751b2fe5a35bf1b64af85a5351bdc1f3a7571aa29d09f4ef95e313ebca6d281a21f30565020b118b840b7f5a3fd3001a86c940d501be942f3d70249701892826a86f93c7dd6cba1d344e143930d9346b21950f20fbbfd009e54be41db1208f9ed22ba3241d59c46359589145294487488266d96d87ebb819a16496796fb429aa80729b5bc338a4a90d7c83646ada8f650022c5e982e773268005daa43e801bcaaf1172479074888f4f46dd245a5c84cd8178e62e26fc18b52ed51e669bf5c31076aff9e649e77d7f77405abad4487409d0a3a42c292a8038eeefe70d4a4a578e60fca4b497c5dc78fe23ccedab96754c48e1b75b02bea0a689829e1444f85faa613c2d3439bc1b98b969ba916159db780a05ab1c0e87cb8e2a8368206d9300a3d9c41e55119a177226d836b1fccdb7eb2993fc4a442251f93d0cf87d63fdd3bc0b600bc81e26396ea1cb09c26d1972fc99d52df4154fcc4e6dffe5080b422786db90dfb3a791d6ed095e59c3add1d36c793f75da4c91ff6ea304d37d79d8c4529010b9f1bb3857074c543388890ac4137cecf5e221495c17a466f3651be9db129eadf39a9854dc0731bb4d85767eba98dfd74cfcaeb11c939c998618dc03f879c360ecd27987b5500e574eda9aef90a387f47f0f1b37d21410b0293ee92a1f578b652011a8c5eb707809831eec5944cf77e7082aa542d040789d5f45f8dd5c64b46ce6f76966a0617a5c888df2506cf8459807494f0d1f2d78b823ec28729a20dadf5c71694cc4ed2f882e41551dd6a0b0e025c94441158893a08ace0fda92606e67c8b46199001e1e74ba9d08f111e74b8f8aeafdc5c556f0156ba4acd7cb3ee5a02c33d885b6db7908670f44d2b52124111179f5941fde1e686d95f3635c75249f87f01d41da25f16bac9596ee9286f063521a66a1dcfb0695055d15013eb7a7292726bb109b12dad5f6a288d37b3652e1d4dd9adef4fc9f86efe2b9a9b20f092ed5785bb13963fe430ef247afe10a505a74fe5988eb9be185db9dcaf0f5b09eca213882da2a42b25c712ce4a977fbaa124275a8b0eec61dc5f53eeb00518bde3c82078d8083b86416c0b0a39341781c125dd7e6fa93af0f65cb25297d1d2080f0d5f06a643f9f68dd01442d5b9472872c62186ffdbb8a4a15870897502e3174596eb010f607ced13f66ace669f1bf10986252368549e7abe69c5de4d9733625acd0f0e4c20026d214ae436a66ab42400283d12d6b55a34bfb3b5b7888e2c81c1458c9d71946835d350cb8ed8640bddd35d362761a889dcb63d3cadf73e962bf90a973bc0f1dc2a5bdadb09841b6a7816602f6df6753ed1c0153d2355fa0681cc2aa1b04e16e30d342d08a718b9990b955cce66b7fe35304e0a3a10e2b27800ce542a59000e46972fc88c95546ebc7379d46e564be964c4df7630be20df833a6cf5825a0a95d95ff4486a894d5869496ba2069d5d01b949bd06aa82cfd50017c019b60580af9d874bf9e76a497b6b1d6aee3e4856f79cfb88d107637af3f9956187e48e93dbb1cdf168846aeb3d863567852e7333bf7ff70513607f2e67c07d31d8d01c59d21ce72f4e030a2065d59d507c9876930430dc13d94b1f74599478dd6305b85048b00039877cdd9afec26631ec25b8da65c32b174d3d00ae38a3d27eafb6c039f97bc7025c27f80fcc963afbea0c102653effb81e9cb39960e13d22c39d3379ed9af3fbca47cca2fdfb88633b25a4d6839f125924b99dff3206adc2379b409e1acc047e065492be362e22d420e51cb2377f3bb3d0673ab231c23a485c9ea2b90b824687ebc6f37bf0148f14b300534895e2641dec057374e7a654f1c37e6b8997ac43d7fc800e4bd3e698438ceaea9340b1389efc67b85654e2260de97132f77713f5fe9a9c51cc5bfc1882d6ffa6e777765407e4e86ebf7e4529b8883744dc9fc5beb7141a848fdfbf4a1368e36506005dc7c215927f82a79541017c5af35e91269ba3ba3d33d05c0b2f2207d623a7e3b9f96907d2aae53a1255fb1427447fafa0b668ee6ce14e12b55b706c56d94e55e15de9557fd6c2415c2fd062b0887e7d9d74dbf3202f6bda7f4f964de385364320931cd29d6d97fcac46cf35f375150223d9552b19855405de40e029cd90299a60a71f8985131721760dac3bb83b059e79122fa3d985b0ec0344202ebf9fc076482bd27dc50a30076ccf69825ee672a146cc8412cfe7f74e28ccc9c9a85634ca4142eaea0852ebf822ac7133804d2f9ffb066c600614d9d113633507e694450f5855649f08857e8e7fab99d2feaae05c63709f8ddb710beea4df7ed942b94ab11d43331fe971095b408eb9ea02bfd03fbf59bbabcfd914f3e29f49022a356e7a981f5c6dfd8c8f33c315674c8c2c212c77ded43e82a6c406fab0b90b3d1bf9b210c7a983d02a62b23b663322c9e9353e051d82d029127635b8c63feca16f63a8ea01ba74fe71127b702ba3b4727468c179af4b0b5c0b291796e0563294b8dfe854940faaa7ef1086f117b993c1cdd3cdf6b51a826b43231b639be73995849ea3dc64392598d91253025b5d1d80d5bd60f407d24e1e4fed9b954edfe666ad040520679331ae04ff0fee930e46406008995daef8dc5865b13498cedb98fe2b49d9a753b0cbe80cf4ae98fbdc4f8c92f144b6b10ff7948d1b0b4e0d0c5f089bc513c43b8e3695ec3fe85d44608da5d46a958e89fd1d14a5d04904bdd2627616c600bf8108e30932a83d262656821cba57456339baa67e71441351b25b54a4f2d746662fb8ea99f5801fd64dbf12e174714e4ad9c10e9843100f07082821119cb71dede379085ae28f10f8efdc352e8118229218b71ee7080ce26d826c8091bf56afd121454e0ff613311bac1dc2a5d2b1f19c188af084c82dc1193bf5b8c3f81061e0780f524c0daeeeeb0d1842782b65877d590273539ba629ff76a9a2b91d317c5a1b55c769fc6298e611b6235296694beccba11d42de487ad092af73cd7d89c73d6eabc987069bc509f1743a079bb7af43ea3a23f2a814b7409119e9f1a392ed8336deec946e68bbcc2b921bf2127512b89a2fecfece08df465ad5374a8fae0e671c84c3f23fad916c442bdce8b8f3f79849e7b477d14e3b39b7ae34bccd7b1c8b19ff7f040db8721e6bb9eaf08799acf4b4d5f32537e8f86c40740ba0e221a9c67d9b3533b067efb2a4fd09851212f88a8e7da8d27f463b33b13f9a818a01bdb6103855bb1d9aea29b143e3f162a8493039dbd25396d42441b19707c7b240f13136cdae55eced9bb79484955682083195da123ad26e3d78672e9a6c81e71525a218285a8ad0007eb90f746e47866e972727f0a4bdd8c5cb5d0b0555bd70c1f9e4570774f6d59f26ff14e8690b0da640ae462b00171b8dde44070f689e9e8261c52b118c6529b763186ac2ef10c140662c07f5d9f1927057504cca96641cdb3b35ba407c5c1be73aa580b7a2ef61767f3ab6e5fa6fb75ffc1085e5e58436de3e94c3014bc87300c4df4b94fbde7ec7d6d61ea8606367038111644dd494961a1619ad802ed0e1b21728e6390b0b9603f04c7bff3c35f8a00e5747058511074fcc9966e9f60e66abcf0fd7bda8a4b143f36f454c58ae41b8b392fc0e47c9ba5802b43de31a8074e3b632c913c53e728e302e0832a5eb04207dcc33ff04ffb558ec99ba4d7840ca9e7523cd53743d79db1d46d25220c88d5b63339e0924aeee4e4787584504e589034352eebb24d5ee8b0277bb8409284a8ae48df795088cef7b560e6abab0b91c52f3f186138ed2cf98c1f8e64388979549e85f50b062f79468a93b9b0bc76608b23d1554d3edbcfa021d09be7b66102837d1acbfb4493a67185b024a88c6797511353a857e64876d89ac7ea52d7f95f634bf5c8e4267ec11e9d8b0261ea24f2392adf829a526a638bb7af425cec742188c366426848e5a0cbab4b973265ce7e3a3855e9073f71a27e9bbbf8fc31c67e0db5c9b3a48c61ff6d674c638f8c8d64bd61d8428dd1acc98198f238c3cb0fab83990d3ce580d523527520d80fced690b3b56260a025c805af3b813d184292dde54e20e1104a090ce9cd2a0bde65fcc65271ed3544f61fbce094d113deca5caef471db62a3f350f56d852b650dd5ed6b572c240b4b8e17495c404e5cefb3d70e22140a076c94b4840d5ba97eff8ed1a0d4f231331d6a41ef3ef0b228d04b334f6dd68857316103427f31f3bb76a7275762bcf5d910e9bd3f0b3816fd3d3283fbdd23f774732bed3b103a238bb65832691b9ae99f223091b8194e29948c8593397f78d81d3ffa8eb002ae7df0d91e2185f43b5af4ba80db723e470aa014765c830f2a12ac4b20d480499274ac74014fb93b6cb18acb6412cb3fcf109b6d916962251bc40d6b60570e837d35d61b0a58820c3748a12f8b174c315b9ba846151f53169c85022b7ee227675c5a2ea08c6b907b795d27846bb2455a54aaa09bf34a9f01181275bd8aca9a6935382390c5b8b8521861c5a39c30e90245d4655b383b462b41889e9c8d30fb319937b33857f214507da159e5350d385462dd6f649bec2370be204b789ece51a97596373aa1af57af017e95c2ee527cfac2d06a998214298e7ada2110341e9874a1bf05ece9e73fb8a305cf170341d1abe2b71f9c8d38528e322d81a3bc22fb8a01c88556b54d6770a0f49723ccd14a171cf9f2c0082c326e7f91a16c2f6fd2589eea1e0018ce735f937db723eb2d8fb91119ca6d500990d230c91ae5d8677d0653816e0fe8e00574f340b60d41613a9c158786a6a3dc80883f1dfc24f044981aa4c9561d5ff890390b38b431c7ba1ca882a7f90079d0ff5b52388d989afad490a09525115340e2ed28e4d1562b117e1ce433bfac34c5abd3ce9fa2903488686c69da5b9d225a86447cf6f3200b8860405314098c14ae89b79d421224775de4316d611f9f9d75bbd2572c2601e1884e7ff053529eb703dbfef4ae09346f07f720191971acb8d8444283604f4d5c6327acad120829e77076d16ee8704a2297bce21d6669da2d61b8c854f6c6a1cbb5564a8871e424b131dafc27efe32dbcf162257b42593ef624037f8a3b7ecf2c5fe0ab5cb23ee7e710603315eddbd1a4cea052d97b5542af679a103b41d6ce60118d4934ae624428809618bfd278fd33b62d05b2192a987819c2ee08d025be8963bc878f0ca5dc4dcce7d3f5379a75528684732deabf7930aa9d198d75d7822db8a9972a1ec441e0f6e6f67bb74f5868870c9f0982a9aaac067995273e438cea8031539ceb30493377306cef0b6326d15dd3dfa053d246f0dfd6fdfb3f4b506202d71dbd1fbd34d772805aa4feff09210e937a040c0118c5b70c3fe2ed0e01433e330d9bfcae49a45ee35b03840bbd892e1665334dbd897e021d9819984d6a3143728a6194f1b160e88ecd21e9e1e7765b85f551a246094afce57f5dc3d3eab5b81c6e13c0af3795eca323a75386ddb2c471f68ed9c9d55b453474c0af3a5ce8c52f2e6903008030958c484b832b9000b74ca35b446e49f6ca8413c3ea9291d69039c1c1e6e66d2ea151678fc651efb1805f58ae7e1b31c0c7d1aff40be61fbd7fe2bf30d2ec17e59556a69e0ecd7fd78ac22724f3350e78dc079a45376c41928943ebee4dbe818b8e58c29e273f4f270ec1fcf3b18541e7183813386321091d4f358ca333590c940861d3401e8ee4f18dfdd991fd66113ddbb4736414b647ff9d3057b1e394f09d1bc45a9d3de253c9c895dcd8d9aae456ebad361cbd32741ee5ffe71025a8722b55619498b31f3a5e89b4fc33ae989e67609634fe2d93db5d2fe0d6bd50e3ef7ea4304b2a20042e26391d4f8800ea8a5af2d9b6f3f62abe729682052f32f1b4dffb0c30bf2d7be41d6484ff2fe37fe9a758622b69b2a3d6fbe8a8309bd65edbeac7ff64d068bae74e43e8c4203d4511ca09328b569e06a37150cae4ec99fc4a1ecb3caa3b5d397265c649956aaecfaa589d8fa31e4fee77751a6e84463e6fbe59de3f29573a3c4d1dbedb482c924d276f6df5b99bec8a92bbfe97290c669ba5b12074cf1ab107f1fd77c5ebcd1ae37f326c78a870b179c7f5cfa6e94ea7fd943f7add9d165bb0d3d4a1d963342d1d622c1b6497c8bcf93fa16fcde1c1e1740187d4c0a036b8909b3527cf75b987948689a74ed38ae8c562cee0b945927188a80f661caf878963521aa315f76c07fa554e532bfb93d09d0d01aba32a7652ff5deeee2b0cac1f4516531dd7d0e0ef3e5d9dcb1050eeeee43180fb53453d250ecd71a70ce483c36736bb49004809a973283efa7c6729211bed707a85f153fac92d7a1b4fcbe2035e1f081cf9e3a152e0c32efe823ed2a148809d10beae86ee6551cb9f98670ca3402a4c678e6d863cfefbbb8f09b7faef23bcd98180da0e06b8e89ff2ed988db97e9e75223d3e4330833f482b85b51ffb433ba9d95b86e5e8f21b904b3d9136d378e693299a2fe4eab325177ba74e1fbdcd3142b9905ad6c4748049df46f88612475aa139be52bf009609bbee4a2bb4f168c468d0a0c8eabebd9608ca8499fd92caad006f18313b3cfd755cc80d116b0c16c644691e3d47e74de9c7cd0d83f3ddd238af938e71f22592edd17e62292ff64c58a0b18bb7998f53b138be8124a940a85f47ffa0024b931486ffad4ff412d87ef37023e2fb935939bba89205d36e595df59da01ce53acb7796133b347ef1a9c3b22a5cf61042f28e0394469faa00df5ef681cfa2ab23fbc629699c741ad818c70ab5384c8233221c8a16257fb74acd7448021b20dea7a2f3c621d6f46efd4578d3c33106b13a41b86de0b087154c55a0471b1c9d5b6c29322f8f6fd980c46c3bc29f2339a18530fdc6656afbe6a16fb72afd025ad0c2f4f36374bed67723fe01288511051633723bdcce65135e3dea5c2eb5ae0545206c3a57eddab47acf661243e894321faf872d1d61d744a824bf515527efe46135341eebb8b1abbb892052c6ac8fdd118250cc3271b3c0f7a887ee347974a2c0f7e001eeffd19e4dab1208de66dfcd91d775efcf5a89d9555669c86dce33cd6733a118e773709fc341697e45c93358809d2e63e791ad853f29b8e7dc06730f9e27ae5ef423bd57ad7c9288ec9fd5949eed439af03a8d79d6c5f8dc45279b37e20d2635a5d6beacc7b7218f0b7514e0b4c155dd7917b15fbb22a88dd28e0e232ba0bbb524291331b5905359157e730f86f90f1cb1c0127729a26bfddf518ccdac18b3430b8c076767a79dd00671cbe8e0bf695721072f537033a02b182593ab6bc285243ee059e46c4e670b81ffad3c50c055b86ec9996057dacdc308919f484ade7a18b7de33bfd496dea4e7c59057ba412124968a5d82b4deda834bd0512e19ddac0653ff8a239428137c4a8cbd8c4a2dc5bca548468c51ea37ea6c6a771ae0023e67a3949aa3e78f411b8056506fb2f10bc094b43589fa919577a8d5624897e2f522e6311cc3427ad007314642f71e8a86dbe83c384d81b15f0d1c134042f8b32c32bb4bbfa493af6a1c2a44113c01e374a8f8c3df6f74e91379e1c08a28e7be13b5b4af24435ae431b0ace25d00a5a4eb9bf4b017c654597024221a0eb438d9d630530674b63e916fb5bd545be39a1c5024830c20b55789f1261dfa1928fb125ba9e06353fefb1b9fa42974ff125b184766678f58597f318b90a66cbbe9461fe076e703ec3dbd723baec4b19909a4bc1e3818002c18e733769cb2d29dfa2372b0387ac9512ce7c08ee31a05718f29e1e5d27e6c492fa771fb51965faecfe44495d3457351b7d01cf116a116c0c891010c93d8fe2d7151b94e81634898579cb8c98fc896f66d1ce80d53a34f2095b0689448e18d5efeaf2c3bc1dd5415887bb7d4a749d333bad389d61e24263d50e006546c4e5a611ddf43ffab6b49ed6d096125ab8a64530166724b9479e2f63cfdbf6ac611fe1718218649afd09895410a51eacc5e7dffc942f2fb4b0a92f012879cc9061ea76e7cf263c177978c59d6ebfe1c1d4cffa466df2f20aca0e57b60a7901c575b23e1cf4f1a2970aacd32701debf0f5cbe3e1559856e6951045b8e43c02e1505c68df255481ad5984cc018739c2af897ae651a8315ad617197d0e34a9f67c02c5070ce328a1a0c8f96e7b88aa351b3f359eed29fcc052f6ac6d21ca1492b8d4cd4b7a6aeaac39a1c34317194b8de5736ef861fbc17583edf4b541888f128d068bdd43db13f03ccb1b89bc733fc1753eaddf6e4fb35bc649e409bac810f1967007617e5e78f707f2d935840d35e113a02098d1bb0eb3567b12e3fab8b701f14e63dc12f8096e9dd0ce373d5ba70d1eff5289ba2123903ab607b12e823bdefdc764d990e93a78d8ff8605d0e9c59e126b1c348be1601a08db7e858834c169f71f4886a3eee00eb340250748b7320c9d3f7b686dbb72a455228665e2617f10deef57904b99e1935404c21099d7f42676d6a6f1cacb6d72c6442f88f7866adf9c1800991af0882051eeaff1d074bfdc528180b385e991e26c5b6737df6931c0c104e9250a72f20ab8174ea1a2a62af7b76f927b9fb923744f278bcdade708baef32dd6c93502955a16bea7b12d6411f9804cc1b29f9cbfa604410f07f20bc35c6fa4d2cb8a82e48f0f0ebc1fc71501477e5d9dba20d2582bad8bf660daf776d695fe9912bb27a2ab66e91dcb6a6e20a1e847a9f449b79838e101c0febd118b4c8366b68606e1a5d16c155c277c5af75061854b9871ac5f4f4690428ead9646fb23e4d4e831dfc54d992a9ff87958d359fc1a9be5d47ba1115fbd6dbb217c5ce2174dfb52b202e47e4349bdd81bdca9cc1b94d7bae125923e7acf337d62079fc4721d653642257e80247d25a95295510e2c4c0aa23fda78305d0643c5d2383b7c58c562f52bbeaca6c7cfb6d9f9b3659e4b837211d63a0122b8fcedbbdc4d0eac5bb1cdecfd2c48ad2403c9f8ca8137910948f89bd2b6f5b2fa99a7ff1bf0cb0beca16d5dc3b09e09a039297603158e536fb0b776391b458c942c566398ae6e94e9cf87f78f26d469634eeccf22ab5cace71c7cce076fa6a5a08e9aaf4a2e005b8063c15c2afb6fe5495062cdda7ecdf43b644b3cffd2e714dba89421456cc95e87b29e58c9826e521c3d06d853b784238b7a211d73135db39d7ef83c4ed08708ab866f239028ec5e0c33f27680073d063446b116d23bda190f7b59c807389bbc6f9a3108c41b05987eaf212f7cef799cb804ab27c89f28622bd6fb4b24b7ef5756daf67972dbfbee1ff25cd8077f5cb621f12d54a37b3055ef50fd66c7b5ec4562691ce7d500a5ad9cf3238859a7eb0972e9c944a98fc7fc1f2e409ad8361d90a099c3474f2dc03870b2c0abf6ec1a410d250bf869ed725ab472171c2874e500e7272e981843c7d21f6d6f46fd5ac539545a5c63f62807473c80a4d8b42f9e1f87f7651ea908d7f9276da2ca4dcf0cc0b2819db463ec34097b2a51cfb28c1062d90d92a5f292981170925ceb8fc741fcfc337b91ef43642f9ef0ebee1d928af2023c0dcfb05c75f5b6d1ad916259d01f1c84072b64b69dfa8ac2963a8bb05e839e7f83baa6a9cf55dd38314b38db3f4ff850558c156661f85bfa2790efc707e30afd10c4494b14d5c76b0cc742f822e3df512e6d7e98be886337f0348ee24899e9f047fed25fd120883be18c3f1096e7c90084ed1a9012d6efc180dce4c797b302ad7e616be82d27e5696b5852b40d0a928167fc834535b9c67a3e2ef1b5d9b0ffef51eab61542b8c0ffd03bb099449bcbc50f6743bf7675fd56213e33af6822135f05386642b9a68763f2b1ffeac056c3e9c25658ad536752eef2bfcb8a0f24ec81308487a35f8600d23d94b86a805cad64bd47c9e426d322df8e3f16648579ddb55d46e2f6b6a1f4ccf8b276ea745c623680c34a9e47eefbec0b77300d8e89d13924aa147caeef558ead4b4c1da205d2abebfcffdfd7a09f759d077544bed590d5b0c4ba91a03ccb7a8f20f4e6dc6bf77ad50cee68f8c55a59f2a7adbc4eb1dbf9cdfa4853e7f4ef4ace0b6e12854d331b65f5f48202a352cc3160871b7beae0b09870cb39793aeae05d9d24594488c9a7bfa4978024fe09f22f6292fc21eaa5230391d651dd97dfe6fc8a79d30f5cbe71335aae1d8d7dd6b202da52492c16d7f32292a2d2be1d99a29200ccae34d08272bae3608213c8642c16de3f1c785d44ef57e6ee8578f68201545bd7a234996fbfc7a6547492d43889984a70e5492ece735917e97f4743ad6b44f5387c9b5e69d5ec4fcb62004f066e24a8a41535c0b5cccb317d5c252f51311f22cda4af7a2caedecb5beee472e008f028b8d508eb9058122d8d13ccf320a8d2d63d0e43aaa5d8d32dbcbfb0828ed293c4f12bb54485a19092f44bd57c7a2aa2112a4cdcaac77515927ae5b274bc1b3cc59e20dbfaece68a6e0594b58b264907fc8e8c802c7a7796de6a5df421452d1f68ee0a6f54c7eadfc75307a4d8c4d420089f93ef54059e947d914688e2bcf7f7ee8407c8d074697646b11b5353565ddcc4afc03e99073f079a8f9516e4defa7ca05fdca8403fc4d6fa7dec91ddfea33fd803e62bdb7872275968b37dd69e87d70262b714ad7887bb0cc5ffa14ec81aa4fb1d8fa06edff81b2d2394fa11b61c85f1cb2d389d42a97523ac8cb874103e8076cc5e9c0c116599121193cd131dc7689deb7697a63e65b5caffebf60143e1ea345d06cb4f6d9a10f7ae2e4162ad8cd6fd42ea40a5c8ab300731015d4cd822cc1a8bfd62d78dae326f89a90f87e604f1a3b2e516978d6ec29e441185a08fbec2fc7219149da6bec262228b4c138c4b1169b9d953ccc749e181cae9322fb4c7286ca7967c2e65357098d8d892a6f2c2292f508e2e692c9613c96df01a0fdbea63a17698e0d93fd7dca48f5775359e6308fec19bf03b362addcbfb318d95f5a1c004935891d74d8c5d72cacc130d3b92dab2e1420ad925c756cfbe161c4cbfe4dab6696c0f427abffda47227e9bc76f0e5ccfefc958a5caead2bd60ba6e90a20f45a7e7ad55c9dd6e137751ea5267d295b4c29a4648e4a1493ca64ea066a999a664f3915eb22a6578eef523cdde544932f636f3c16df57753a409771bc6408af0acaebd1c83650428868ce9f0e9a8784588aff9619f579e8003f2f7c68b09b57b2936e8639f100170ba577b671ed01100c0492181c1ff7afefa9ed5d8cd43753ae9fa7f4fcd017d7aa71081890a807b49634af99b7328ab29041542841e0ce717d10cf9ba89626c50cc8a5ef17a047e630a14009701d7a702de0423de3af029d244aee0fda31514a511eada7369ad5e5ccf45a125c31876591e8556415b23a2c9f1208bd45c3f65ef9c76da0495157d717e62c4e04c6fc1a16f92d540483a39facf6b88e24c03152d71b23fe787be16e53d367527157008116b68a7aa65b39d9c271992331982ff427a37ecf67edcb361c6295c067eff4a7d0e707791e649bea40c913d4848e6fa5ded9bba95495e1050cc758cd2b71b361ddde082bcff879cd2c0ea3a61f6c2552ae1a7ae207bc6f97dfca5c7456bf3c6e21d476fa027f66da5198c80e9c0a04b557c070f69b0899ee49bcf8198919e9e795c3c152a2e78708615d285a5192e1faba4095e734d9a926ee6d0dac110baa37ce0209b48eac7b47f505c081b890d8f5385e258d76485a844c6ae45f969add62d1de964507c87d971991cdd7265fc538ef15faca3dae9e1f835924d9034633ca938f350e9738123aaa00531ae8fa259b4df52891554052d1cc2eb0f30dde3b315a04af8e12aee192bd4933d6728b5f1386830c327a07b155d0415198fe059dfb2ef801064f51ac906b011cca2d247112a5759b584da6d1b1e55efc3f280de83262cbf70a1de8a68b546585dcdd008146e47b3fe905ab4a05bbac80ddacb03bf48e398c360aad9c0935d30ab5afac4c4451cf8e2cfcb186a110459598508964b49cd3e0ab670d6e189c870567d2ad8cece9a821fb725262343e44abff112fe111c6e5efe2f229b44acec805fb45257be7ba11053996f447d7cb93b9d562db2ac1f55a00d51e1bc612eae01007df3668fe9c765fd18381a6fb593e79cf0d36592b103c30ee410518d941463850e79ff7498ba19e8c6af1d2cd4724c4558e4c363ec23c324959e1ca28a97374c5126ab34c4f08b2c2539d359a59c2fc1902f3fd2b41d8532533c1d55f54a1db2e5a22652f1f942711ce6f8d5625ec0a3838b37f0888e615add519650bd2d6fd676e0f8c6e334f1f2e4e8ab5942ecab90cdf83ba37892bacc5549410637029020c828999c1dd1b3ebfd7dfa52d33da65df65a22ae0661e7856fdec497af7dfc789551276e02301a3cf33570186accd4d6aa6aaaa5a565fb1e5335ca356b0fd99daba595d67301d3649c8741aa34d503e8e74af738e6393484b45f9fc19ac6b4c74afe6ba6bceff8347a2b0a22ad5060d2c31f6e9be009e529a7c72ec4c12eb7dc9fe327656c2f9dde012f90c77eea14cca913bd21e4b8b6d3d2aa59b76753ac5b102dd0a238a6aadf724933eb346f3b294fc8622e5ba83a26a8fc659bd81d70f17424aa8f43296aa31b6e5d666c16b909a7d06807d3479086c717809d7cf5f00f3544b2d3827db0bf1f0ce6b1c0bf344bf6ac6021e85cff6a9a03e52dc5e1721cea3694f06c7326d2341e4f25d7d0a4070f7b4f327e38f645f9810690ae016df352934d2d95dccaf95c30a41f37fb05fec71e0075fcff5107b8d0db8b179e4d289cb4a55850026a6330c9eebd7d7c786b621a362fc52f7d23dfae153d63287d4c7a45e08323e95192c029fd800922bb3c7fbf70bd6e0ea2bbe8e1b04edc1a5c88b9b4ce17e5e586d580a2565a6fa41b8b8d25d8c45b0080c654658df732f54440e47f2aed905ff547ec4dbb38b70d417f09a010fef1d1f712d8945dbd33d260026dbd6daecd302834c63fde55ed54a568e3a7970f07c72de70491e839bebf9576dfb258f675d291d8f0ac7fb6ce85a175a723867154690c3ecc99ce3ae9f9d40f3dc113b1ae01525b0108b02c5f7b34254b681073434c687eb10b69327efa3bdc8fe5b3f0c72646ecaaeb37b322fdab346e3b5b5fb73534dbe621dcb2d043d979e98eca28723c214de8c7efa5542e0fcb2832208a5456433130cbe5d3c96f29b6d8456e35edf9076cc41c5a0c6bec19951afc3edba65af00c206a7af3e50cd02a4fe67a86185d10533a692c3a2f7a38f6f9f880efddd5b9af0bec271e6b6acacef66e614d72614ed57dafed585ca4af9cd2cd86dd89a64df91382dea3cfa51b4394042694682a72fe0c0884c3a544fac70247b3713e5ee311fa5a4d1f850dc3b693fce82d70d7df607371e647cd8255e085587bc35c4dee8e9e0afb1459ad2c1a66ddf26fda82fca64e49c818664aba36e65955ff2f6817837f5e6f9b5751384e1e4370a0aaa7a87c0d0439680b68b249d69b274d14153810dec07aeb36d8beeb6ebec13c171ef335250d2ee0ef6d223d317b56b849700bd601c4556a90196aaf005251e176c9452556838ca527d949c128dce9817a633e6620f9dc35af5f8364ff76497d47ef6982f66fe763844e9fc83019e713410899b26aa174ad6527df02de61e296af41e39e6528f9267a2af5153652af8a26190d4a454b2caef3b46985f4e3403e819f5e02ebbd659d2da693ffdadb273055bde47499390c0b4c644b8661a0aeebd3677861fe3a616a885ea5295b4ea5adf787cd1cc459ec8a5a7a03e38ab3d68ff581ba22f2c2dc8a1a46e51aa2468f65a8b4bb19bdf2bfd13fb325897a6bfa2f19d220b7ec35f9a5fa7a2fc297186293fbcf0939cc01b8391a3f53d04c5f0d2476312b8a4d81f7b842f1a220d05f90e2c3cbab83f32f7f962f65378bf66397a57091756282602bdf8fd8ba394a8efb734252f5633cdb0ccecfdbf25f044cd3a4746e98a54711228f8390b80b41d200cbac883ec5505a7f836066f4a67ef52d7ffc928fa3866619d8f4078adb7d709a45b7c0a158819251c6717ab77abb7b11b144dde70b8c1e8c4a030ca63409a9c6d710bfdf34da51fba855b80ff95d54f93e5d9464e1d96f6e09d8c1a0e4448130b10661effe304af62286f207d3bbd30f21f553861c3af6b293546474b9a567bbf93ba265210d7bf016bae7426c093e75d757a58d2d54840e31e1fe034abe40881f98b9a94e502035c5ffb6ec806b76f94d0473342ec7da4d91e9eae41d6edd2128c2625cf093738066bedefca9b998799eccd4381d6ab6ba8ff53ae7146c4aec5ce72f6c88aaef07177ac8af1ba761959dd5d963ed1d5b5b78b61bf65dece566ff9893bc8ff686bf41f1899bfffceab875f0b2888f9edae5a85049cdfd6c570e153556d79b060abde5a8e180ac0ddde0df686475b4df9b92ee78b9721000bc50c7a336ff0510b1d3715f58eec5748402d5befc470f7a3fb3dab36af046535bb8f1057289c6a95adf46bc132dc5243af233d63e9c8baa730ab3529688e9f02b0433db305e4bb084783935439b3c31af4f8afb02299dbb1564626e4372e5063809704485be0ad702d1a68d06267b7b47c7de11222259eb4f87eb0779c00dac4c0f82d1d752043eff7741ea822203387c13ea7b3ce46f7efcce09f6b2900c6fa7b4bf6606cba944de5a15c569b77e1dfc3643abd53663fbf9a2d98b28d9cb8b615fa04fb2b08fbb69ae20c1e186a83dbeaa45ea028ad802be73c05e2f16a12c0304594dba8e69ef301b4c4e691aa3a16074f1145a6d2a22b8d444f925e243b0fdda35f72010a2da829726e3e138ea7a863dc137cdd855d574903db2cc9b6d9afe8639902d921635050d185ae1fbe98c4d877260499ed31aaa58a32e1988b78f4d22b4c295f89c5698d2fa33dc45bd03c3300296287b15a85bdcdd0f6d4af69e758de68014345993d70eb6b208c33d62533192b75aa1351dd6fc2c81476ffaa5ff0c92a55af54e2f9526564b78685ba48f4cb43ee666d130b656a69df97f0c652d0d2d386b8d83d00d7be2048f0430bd00aad7900151407bdf3a34aadee3fcf6833491fa661468dd7e34300f82dfda40887f49f6752b87f61aa1525bc718fa86d0c9d1bd5716eab5833d23931e09252462435d4780593e2570f389ad1a4847aa63e5d5d7a5bcc3968f93e0a6cc59b9bdcb2315def782e2cc2406aaf1c979cba3701c9025d6e1d8edb217ed7be85b10d74c0a6a068a3ae5040875fa577939727cf21da2b4f542338c412f0f116555a30212757f8d2f94b8dfca5f9f5e1f5df1d16dc1c6efef6ad1424d89754769344802f180d1f4cea7779cdcab3b5bd97060179a826b3236b5f983f7e4b488f3a9c8d7baadf10caeca9f616cc2bb6af3b1c5d6e2cfe0b4632e0add8eed4c55d2b05459c0930f814b14bd7bd9771e97226cc33426d7697ac88bde34774dc1b764e3076cc56bb3ce08e5d070a535a15d0b91d80eb19f4b3d73dc97d3ea2ccdeb0d5c3f242b927dac89ea26b98d2ed3134c7f91aae390d34461aa1e41b447716728ec96627996522d803e961a62f44b70fce269b79fc375b8ac83a4ccad36d47a5dd6e1e3d87e65b64131ed69dbe518a74e297aaf2c0b7ac78bccd67cfc536e7a2e0c336dac0ac71836d098d627b46a8c34041e6ed467d643bf46f369ae24a3fff5b1c58a464da4274761904f4b7118eda44e2c314b8fa59ad20c400639e82c0efbc4e29afca1159ada57c0da064ab92a03b372326d5b55a9069513a38875808d7ae1ae25ba830e42a07c2b95b272e4733b24fefeb2b6de0d39b4132407a75a479e8bfb7959692e85e279879af0b643ea02dec518fdf4dea63ed491bd0f158447e67849f418ec4942cf0846b5da4ffe49a297ef849f392d4704a34e6e36c6dea64e1fad8767eac4ad2e3141f3e40e8df2a9303ae934e7f1793cef138c59c429e0a2c7d6b41d5c03eca2bf4c39dcc40d8475758a3b57a746c91c01ba26ad6929f2fbf68ccc92e36d4514609024cd201457aaaeb3e46145ba313c083f06c6ddf32d8989744b89e7fad74e3f105d3309f43bdf10f3b0214805e0fba0200aedc200b09379d9554c957e2c26dbf3a8291c663b8c8610c96e992b482d9ca5d8e0bd3f2d276b6a8fc926023f8d85d5e1439da625d65a31592ef45294d4c9772959a8b00e6a23ca9ded984c4b4279d6d6cd14337260c72bddad9206088737450c628798c0432d166551a8dc304f5c7a77df6093fef9eaad53314ed5f15d23c06489546cb6be27e687b50b1356f842ec5de875d7a0fc4b50e9af128cd704e6b552b07fe49f28d3661e46802da45f7972fd9adaf28727d8166ccde351b2c8cc3b26cb3fe5628c48c094d44c79eea049b8f7c73fa32121b66d4bf8ca8c5c9db3abda788a11ad6ef9deb1d486d5c95dd4552eea089fb766de408df53bb1a4540115ddd46f76d4dd22b4895a8e4364370aa0a84f381c22aef75130d34a67b8d5c83a059efea9702631bcbb097969f479db6c77b4c6c9dc11972e13b074979928d144ed688a646e8427424317240dbc0ebf09929c2cb934989b937470b66265ebb4680b719bb5e08c30d0418e4d3449267b765bd616c15994284f775422e2323fb09ece50f47337832ceed30b4980e0689089cd6b2e3275592869a8b919325af8ba0fc958c2c8db67391fc94f7b8edf2c782d2d56b498949d75dec9bafdb8d151655ed90dfa80434fd2c3d9ce33b50ccf8100eecc0e9af08b5120bde84d7f4874184428fb761405ed364c6b91cb79571efc2094f94180c2717a2373582390354f21fa600c243c8ff262abedf417ecbd69add9904fd4ada4ac82812977a47f1723ee454a7b4d39024799bafd96d375dc47b83a71c26e0dccd88d00158b0bb5630573fee12da00d46c03b17d05ef0577c65a449c7f82c25d114356253d1c7bc6f7844be6bc37879250b1f956f77450970bc692cd13290b9bd7490cda419ad225ab554c92097916943ddeb73385b876f74d29c0da5c6305d92eff8db60a4075afcc15a426efd2324f11cc48ec30e27ee311bd1a638f9e5653d8ae386f549a5499268738b673d59775713130e845ec827ffca94d445ab9cbb5c87a0b61002c824aaa7e87912190df1dbc1c21201a8899af4d457ff00d0f37aa3f61dc9b4d4a1e8f8a61fcc133a82b15117eb1e7e3cb17f0bb5ed18da354082dd99c1ad74b3e946382b795df7fd5b39239de38ea6f340ea26ab07656cf3fd222bea40ca90890635fd9045b7c26b2886c713ce41e649af38603a3bb76c669c8515ee759fe912564cc358db52ff58586ee0f5740bc83f47310c72dd293723138d0499e89de57050b1159fa020e89c3b18c4069053cb49c4abfabb7aa22bb7347c3c194f666336f7c5f5479f6d0462d0157a7a92731bb5bc454bb033db31ac3339dbebb5bab83a020686282973d2e0c6f725d95a4d31b450b28a4224fa32f18b8ca866291ee7d7ff697b4588161047a9c31f2492443092da494a0be54c94cec2a2df08657c2f40e4f34be4da6e49646977625dda0aa85d16d68d0b19cd222bd5a8659900801149b50d910e8a9f1c95090ec97387d4e3cd9fe0c85f19520891ebc890aec4b9afe525eb743aa22c8df0b64c08e1792802f1b90f0b55df4689b0dfa0b4984e6f642c8d38c698dd442208e98cb2492e19f068590ed47d91a25ea6495481261f0ebe60d8b14a0f3de09d73c4394f568863f28f3d965a0377767e8b932cb7c5d4172a634ab4cb36cb326f2027c5b0a27c50c1a1b011fcee2d6c7af2b68146402e0093e682198a3b6474362ca66febc7640a06bbccd10373feb9baa6d2fbf6590b0403656d2ae73b0934c909edb2a6ce735b1cfc58d07bb5ea0e28bad628f1bcdc83dac6af24e5e837884384625f6b01a48ee2b90ecff6aa00eb9bcca02c969272772d830117490919881a3f032657ee26a785f39d603871df4ee4442085d0ca6e970b94927a40c4ac9010cf032c9e40c5ae8a1253a1361c67c139e60c4ea3c908123cbf75659720fd9a957f8ec0642730f7475e5b017f46bbbca339275f396e5494d3d9b755ebfacac16b1792fc05c08728d1f75bd9b08356cc7c9219bdcddca947e2cd18363493472c331520e55464f0bb0b651eddc254e0609e9cae203e26b0286b8fa8be00a8c7258d674abf9d13589daf344f75872633d75d4d1665bf29fabe470a07e5680de1a7bc7fe5fddc542efddc19b79e41af29c0ab846e2b50c1ef92253221444fcf8c76c96e5dab575a93d4e8dc7a0445661e7ed365e87255843c308a79c57353a18d143ac6e43f32104e1d0aa28d2c1c8c5376b3dbba7f68d04efe20e010b1c91e1eb45f41b044ec03c1ceb06d601efd3806c2fb4e222fc7d5cec22746b02faef60975ff3a87cef7bf746a82057fdc023683167c267e018d8ee50806ea10eef524966df69d0a500cbae4f1a8aced3bbf57d8f8e40814f4b1183fe5929194ff8b1dde9f2c56d4018d75fafb0e93111dc9cca56a8fca27b44aed72c054d5bd3d3540741ab5d456fea95bad9a93c2744a07e7e0168d0da1ee5619d438fcfd58a34d42cb902b6137eda8c71ed7fe08876e40e046d2a63d47d81116b279d56577c08a77a55b3682cfade4058ce39d34c1550d9e36addfd1faa5aae8de58fef98bf5cd7a38aecd668d94257aac9a7e6e9c76b9299b2caf1ea2370b4440e0503c46fb8bd0f4d3617bb733229bcb346a10d9f711a27cc214c8b8ea57a6453a00a2adc3ab12c914e9de35d50b25b44afd4d2b60e778985e9dd92d95c1c23f5e286d6f1c5748b6dc002c9d92a253532e8b96472bfa56ac5438c7e6e10dc139b5af6ede49adb1c1b058fdbe5ceb2d5bf20ae4c499b1339bee771558f8f8cd43999c5f2fc4b56771a5dcccd12f1ffcb3d9773b9503b5052cab48476b09e44dbddcc84c9eac5c0e11d0b9676f7892ca9b86826b899984c3064613d7ed2d6b5a02e0230b1609ad77baa56199718733f7b4cf316c33e2de13523ca329befd2a2e3c3dbf83c60a131c7b94c04335ca7ea4b6390646d07639ecb6108116158d3dd8eef6f7f89d93dd673beb0522a58cd1e9a1378e00dfc5efd775290471818303f77a5293aa9466bdb11c974632c05dd87b68cd2b1c37dfc3a1bc2923297eb4decc5d12cbf856927fd3f3e705aea38dbc170198bd9c5caf53d8891fffab496d2a1dcfc8fa5c0dfc1be76ab675c2827bc265ca76259bec1ccc9aa7721dee50a7644137c1413d98b9ff3b76c90e2e094ed9f69a4375d052375ccfd3f09be231ce41132758606154e0350f3d331e2648b534679ca75f487d82839cf3b47cc526237c6a007af3f71617747da2ceb9ee42d3f77718ef6e9dc894232708bfb509445fa93270d72278e472edb43d86a6b691a6011998078e8d2211721dc3ad427bc34502bc0df8b77e5d38971238c499271ea7fa551e8a5542c6fe137b2c055645b0804820c217a1ef5a275228eee4c00e2ea724a46d33e2f92e2963632446ba289bf4017794c621bc280f59d95825844d293be8769e8f982b8de6144b4d0c84385ab5f4312fc100e52a757fe456c7c0a66cede9966dd1b46a2588a2b1db26b3d992fff661ca2cbd9af310e06b235eac37d1135e53bae1248a66e7ac22a91a2aaf4fbc101ad0aacb7805b6a8ba33cf68bd790a8b7da2c8b820e77b0a0d55da2c756947a9ff54c4d3fc83689da36430622e56558cbad931e9af2f7ab51f686450327b81cb67643631a339388791084bdacd68259a0212564fe76e9fc02797a1239e3d5f9af019179a8fe6cc8228b9c82611141570a6572e263a2dcc9bfcfec3bdc37a481bc12d8f63058229d807d6e39116b0e4a992976715999de09693cd29d9207be3d946df4ba64a4e9a73f23e5a46d0557ad7b538ed488bd5d62975c99e86911fc64dd15d0ca06fabd76e149e1885f5ab68cd1b8781db130aff9c9c57b4c9d798458507721a5d43fb43076fcb4fcb4bc73b2e0df2899bc76608df379fd95ca388fc00cfbaf5fe4f236230d45915d5c29879ea15f5bb5cca8c2afc5eac8644e61ef9f58b7f4878baa1e8cc39f8c68dcab67ff7a4a890b328c2d3ca948515862aeb10623f4a9c1641253e1295ed04be94e4cc94f81ba23dbb6511e78f0dea65ff4f1834bda280c0a61013f554769f695c840f5001e486993571c462a711e8e4818b54c9c5896a120099f2cb4d355bf051b0c22cad454a4ab216632b18ac1223515cc5efb1a8099d403ea62cf55623bbdccbb4fab1eaf3e84f5507ab4991c509f6c75a2d9dfe6f10e93f6d219be75fc715eb6992948edb77e211448591f6c6032474b9e863985b6d42813ab0be0f78df67f34cfe98dd874102fa81126fa8cfe883131418afa68d4c370162f0b2dd7568969c1f38658f98a6699384cd1b99bf3559064114cb12ad0a9ed94f3f0b4b1c5efd900fb384f85012092a9415315ffccdef5c84789bae95495ce5f9c26a1d59a662de0eea26e135495a440efec8a9f565d2e737c04e22b737456eeda880eac50e7b890a6b9395da9d533149a08029ea7de0174eedbda44d18e91dd82e6ef49ab9440e65ab98b4d2f43cab7fbf4844e6c4c0056c5e01c2c87c5b62df4dd541efcf6f08c673f83b9c9ca0bf8e6fbae0dc2fc16ca866ec778c184d15ae757de3120ce2e8f30807d8e1ca38f71c5ddb1346c4933aeb3606e35460d8f9fbb2ea03e87ab200fd23317403f71ee8d64a2f1765ce452920b7416d06a9e7b54d402ce21372ef5b7eb00a08e334b01ba6a03820891ffcbb0abb4aa9e2c3f05cfc8eba3e342687376dcf0d052ebb6326c0253846d597481fc76a3f5ca8a836b020c9d10231a51ed8e43b182b0cb82ee54094cbb2d6dc7cc202c446c3fd3fcdad515128013a459255d882de6aa2ab42291e04f42c27cffe12d0c177aa4d9f8afe5ff775e83de46bb6d9b7807bb433bebed1d1200bdbcfb826095d595055b00c77a5763c9cacd575025a59f991a02fee7c5e4bce13316cf6e9d60b83af287393ec26c7ab0d81e6a2dbd520485511567e4563945d98a66b4f52c01a6b74d75436b06c7439beb70f2351ee2a756cf4f7b319231010991fa1134e9d8bbad43cae4b4f43139ea0c221e2f56f92c9bb139b47011142df4739dcdf67718b9f876fb3e16ef06637ffb5e927183f916a013c81fb9c426d3dfee540b1dde333991e26186e80db49b6f1c5d966bfc5139d46d4079ec917580774bcffc8f13b725a42dd44d5090075f7401c97ce0d64bc00e5418155f6e1f1ede91c119f8c335190dcabc39158a1eee7e4bddcf32902fc45f53d66683868f3728c90af644fc2b994569aa680decd9211ba1e11b1f2bbc9727a88238374c3f6ad053d16d350e25f292a2f126e7c55ab1b02d0b72418623c9bcb0ba4b3a7a006588601a971be46f830df187f1fba059e024da559a71d4c3114a8b466dcc827934fb2f332716aaf09a17606b1b8c3c18ddcacacbd6bc349bc93f9a72e7cd0757787c66cd55d55e9b81724f100148aad8a2dca9d5bf3acb5b11eb18469e91e68f240485551ec407165de04c3facbb5a2f05795c7845ffc79fec67aa44e7ef4dbcb6c5a094cc980e22b3761de5eb77b8a3cf4b4630e5210fe34e3bf1605508241360c269a7d83032e64694c6571945a21873b663b48264b76e29c99c9d2237336f6afcaa0304ae5b6e99b39e7cc1877f06513fe1e272ebd25d408073a329732bbedbbaf4148f650e58cce10ff5cd78034437c273a61b2089e07c79e4a947469763e9ba0d6970783c76299214641fdce927296d9747cb167e45de19cbb5f432d5f2830fa6dcea3b84e98ad8676f242c3006eab8e144771fea5d627efb7f780c303ec25f875758b440ee6099381fcd2ecde2a50998a705891d17f08c5329391de7b7b7fc34fb8c7292dc5ff104feb1a6dfc3c5149b7c3bd2c8e501709e74e39de42b136cad33d06660aa9ebd4621cbc7e1a6ca3a0f47f2ee25f7e04c16350260905a1a24d6ca381d82ed130e7134736da9f0f3d667cb45c3affb7bbda47fc1f7d4284be486e02a2031ee8dd018a7c0812b5a34c3ab387c573b7714d74ed8c35e4a3e2ca971a51e74525de8005a1b0ab0d0e633807102b67c885a93131f2a278cf275adcdd1e3645a355e72e112a0cf05df6cd2b4b406b360ffce6c5ffd46e3368d6bfdfd1d2ba55bebaf959befd02a4a29fe55dfe526d62e90c52308375dcefe1bdf7565f6d74c14a9aac6db32f91761c6230f5d904f2d961865f43cf5e1a328f1f3b37f58259f553abee82d3835c9fe96f8fb8833b41eb3d34e6294ae9a9772dc96fd5545d15eadfe5397216ab3ce7ef209226c3ceb2e3992a9d9b9b74c6bef8a18bffdcdb90f916d457f619c073ab1c6e9b2100ad7d24796d9f7ceea9b7e237bf856d74da2010ca927552b4328673e0376168d7e6aec9010ac6151fec4a9d5b2fcf6fbae73003e3511fa6df6d466402b363676a1b05e0d897e39e089d850c02bfc259234e4d4f635e5ec4b4017613e860a1be5be294b74218dd76ca5406c441b1608d6f6dbb6c5d18cb645455e5f83f5254123b67482cc43867e952d6728fea7eb242a50f1d40bd96388cb004222a74db884ea492aa403392bcc5a5294722b6776474c7a25b0b6386e91ed11f4211f2bf14b349382d2387c31fe92339a570709fc1240f19444ed603c9917c5225566c5ce17f5cb9e23bb6a2dec4440b284a65918ed0b74a63e7222ff099ffa0ac6ad6ebdc2e1246840c0696b84cd176dfa53ed34028a01abce63bdcd7ef1fbdaf9fb7411b5df0153f432eaed6b8329d076ef64c487c7a60dede2e6c2cb03884461d1d16844931733b1fdcb811cc4e1b5f29d8b5b835ba425887453b107e8ae2f6bd7de15820653c0b972cf2b266b22d4893187e05e9da0e6bda737b12cbb3b691ec1dff281f50356454548687fdfb931429e52a9cfac4d4e929acdbd132197eea3b8e38afe8bac49e40a296bb99d99fb5eb23d6a8cd54047c0d7e79886b9655d4c1f236c75b88b710533ef65ce5182cc88ad76816990f27522b68cb00a52d4c7dabdb111ca486974f1a381426d18dc1675a380549a507c03e243562255ed6bb043e77028a4670a7b8a33517e47358886b34c463e0afb7503ddb6eb17e242a0444d099aadbe0dc64419b1522a40f26030b7de8910e4655ebfc6eb80570ddfb67299abcbfdb50eff119be19965194ba17eb8a04c0bce13cf5a38edd5f08bae696a0972f23081586c33b7cd5cd81cd7e7acbbe3520d8034b66ccd78a226f418c803162dfead58d5dc06d000205092a388772a237da5800cb3f4b75788aae86d3cd532139bdb5152849a6fb9a77d8a1ab901a096af1b0f0911fcc551244d8f53816a39c5200a8f9088d79d22d89f64dcacf3e9c07da169167681cf865e4410b7633c88d17446e6901cccca386fd26f3a3454f4fe6197d01088569d8620fa42f44d2495b26a3657b5e78825d9ebbcd2e5bea96be7f4cfcc43f9822332979bebbf1a03f76abf31aa53eb540c0ebfb16cc0190539606e0660ff45be3b4d681aaa0f07dee15b40298a2cf8cda9794f2cc71dd1b331d758691455963645fb5785a5d59aeba9b7908b9ee8863e54f39a35645cd20fd2b9f18333d2766153c879cc1beb5325682925cc4d0dd8ce0abd51ddabf4c04506bb1eef774d4ee2483a9a168a72b80c8c3a46dc947d748bd0d533764d235e13bea4900ac192255e7a586811514ef44061d9ecc2748133a02f75512e285f17fc5cd7b9d063d4668b30c342c92e8ec1db8cdd7f97c845f82cc906e6ad53301cd2d58771566c2b522006fa1cdf93ccfceb08defdcb660d5ead0c22b3774058f448079a5164cb9e7788bfe5c46010013c7086d7c8fa810cd6aca35254f3a0917368be90c4771c89c54914100e47d844d1899c99d143cd40403a3190d765717879c202443df5449c9a90de21f7c922dc35d3b090b093cc1f4680002acea5142648a60306f6bef2299f3c22412596eefe6aba969014af69aad2fce216b1c2aeef482b7f481333564a19749d5753bde3fd8c1e22101b9214bf729a91734e8834864af22959738f6c772f5afafb03977485a50da34710917fde14ea6bd2e0d5893fa9fe7a74e1bf13b4a9c407d9feb30293d1cc89a12bb074db88f6947b85809631d1a2cc10362620e3a33b87d87c2edb7dcc1baac079e510743836b073bbee45b72b445fd08acef67d17d875f87d301be7b4b8c9c7fd1f24e474f8f6573d8552a01aefde79915dace200a94d50e8de9a8989020bf6c6ef82e8bfeba46e48195e81b51da3ad31147e8970af28726d87d37d84e6c2643f9dec7f4af11828d6e2ad857bcc6d70eaba494e98dd8c4db83a7c719214810a871e47dd0013dcb3d439e37f34f589d7be89392c9123c9eb33f37e6ce0604b76f138a890e15b8ea65b46afa455c86cbc32a3789d44de868b11165875d88b59f6a2f6d0bdfdba8989d5ca70023964c2bc8704be9d5b9d67a9b280666ad5c162e23d1f771a07b4d4833df9075db1b8ed35826004d11296fea4f5a258f503ea73c4baf817684a921a7fa364dc734a2a9d151230410d37b6aca90888d8ee26674b198870fb5f070d2607ba9d704f229d77824b85260e41b69e4f5a95aa347aaba3496cdcfeb301ac7de2e535a0e4e8f871d25a39af69be6e9483a778ed3a80d22aa10a5556b43eb4c0efe1289b68704562495686a39db7ed92fffb75227d2b5d6061921507f6566fcda26f5c6493e3837557e8085fd31c251b0b85614e4b3bfdb3f3b39af2634aa88a5965843f79452b220051fe2ff4fbd175a2a5c98738d8e20d378f94775c9faa7fd6da65369a330372c8b71211190dd5b2873a99d2a4f6373a60b9e5322dfa3b53cd56a1cc35e9e0d76e6a53b15e83de46d9571c6e275cf3d5ca38dfba18e01d79512befe7c49468a26964dda8c649490946dc469a0a0e682eba4da1c6bc00f83a3b773e1c8cbba222775a1652ab0fd1ef65ef114575844357cd62e13e8adcc1344a6f88fdf9153a0bf11fc443c9029164015dd4411bc65065c1e1e8f40a398fe94135b6f3f5b69057f058761e5644a9a9f2bab15449644345e09580b824b26eeb0f0efd9b0c0a0bd13c60a356336abb46ea6fb27fa427e7c17e3866a56336ea56d392249b3db53ddd2268e66eb9dfb3ffa02332086b1c79e6b56b975de006e5e1069d8efc07745d92edf15b61b2b69267fe3253ed79e80991d20c05a110fb0f08ca0cf91e4e1c21ab436b8720a6115031f711fc5c21e04879faa4b9eb11d87e7a47b8776f251fabd50a8ad85bbd9a99b917a5d07af40ef8e8a915552eb5a44de9c2e73f80c4605b03e7538c337ebde368ed791049624149fd7239833b12ab2fe10d2476152a15c2b4de08c94bc5d415b92a217f89f74fdbb7b8b11a6af7812430dabcf15f00a0dec9f6b4d8ea81ae0bea1486ee7a1c042d96ce58be766c24ba1834e959c3be35c13b57a95677d3f0535030814355178abdd1e99e04fb6e0ac5baf8179827f4b4c5db803b198b398f3fb77eec293de2a765030fb024db00936e3db335ba9f38e07776cda147a5742990e426e7c79ad668c2eab0e8f35e2a4e2a1cbf89dbcafa9f7728bac462654cd1374f9909aafcb03fb9f7b802ef2e16101ca9a6523ca02167071921bb23b8f060c1d88fcb9ffb5945262071b41c88c08784cfb99f494f879a25318250463945f25c5fedc04cd36dc84b5a4d1a1b068996ec9e7ade26511619f00b13e0cade4787d289cc7f3303b6197076dc124449700314bbbaa76caa55e3d928425a20b925b1d9383550eb5bc95542237757a75b273aa3b1ada35ef23b37c7312da6dfba36fe143b109bb953dd94c86f60378c41ea003f08354fcf836e0251fa646eafbba63f457116b74ce3ea84df40f918349f6356817e66806686f0ffa10488baa11a273c9877bf2ea08818b4ab2b8ba8d540b526ce3c4c07412bd0118550c080a97fb53ff69c1359298b12513262d00938fa51882e63b3fece755b4f7fe37778050a9f10a00a57c01cbbc6ebdec04a1f550419c452215ff65ffc24f5762a43dc12865883984e6bce642146244454b330535fc5656cb45ad2807d5029e9dee20a52d31d32b07e9e92d54e0ae84aae89199cb21a3f01da4e613b1b5c9e1a16e71f3bffdb4d75a3d81a429aec32b7501743ac802ce80b0e691536923de020b18fe129d8d16487f615a1ee7b0f3d39c690fcac0ebd31a91d8bec90b2d6cc19d7261c3f8aa9e3142a67726cb78e8736ede6a5b540c9379c568173763e1a446260a5d6c906cb4352809e90514d760610063226d5ff559f3383591e8784741b5a9158970f993e188a489cf41c34cf96905a163386209c5f0e5293cd6ad8a816cd558de645cc6eaf72c7e60f46db203e878fb4ec985f173c19fbbf4c7254b5e3cacc477d079e3b949688ac558643707df2429ac60f49fae4a41e0ec06a20c4bffc74d31a7b54fcbc4ead6ce1aaa6ab411034cda4fe141e5ee628cea5a0a8700093ddee7a3a2b6a7c642a7089aae5c0a430ace38c9ffbc1d7d898270b29c05c9796db499007071a1157f8e88affff52b764357723f4d91c1b1e7304a61983ea5601b61d6a748881f7d1aa03bd4114a644a337a83f1d01c170291716334081189026ef45b2a4530a9350dfab0eac8ca0ac6d6fd4f68b6a96824c9358655096ff18a81bc14f2b64d332ffe9528d76bd1804d2b7e630767960d1dce63054d30c5253990a8da043c2be8588e0ff91c1b7977998ca3ca88e1d5cba7b02012d353e98a6a8b97923a0cee9e900b779fe1bfd6734f772aae8046a76196b8f5fec02cf6f2af43d76755adbcaeedf03e04168c3637f9c6e32a512510b42fd48c308338213a8c2f8dc092e7bbd0aff1b18ab63be88e5578c2980e698beb13eadb0f5902bdb1dd923425c08e1f7c12bf27750d1a906b9212ba03eb197b10a0cb8367be7fe3942b85bc57b1bbc38c73fc032a8963fc5de15007c345d14d3b9001deeeac8853b31708cb0fedb64bfc83ae3519e19339278b2df1c6d12612e803001a83a1c532353e652da0d9677df89e689ddae99fda3b3523de7f98066b2bbaaad1436e9e28e54eae2509176b437982b5245238b877c8f0235c46751cd17c69b7fed957a9870d9d455e7021fcb5285e17e61e759b978ec7e7ead5e3f520bcd508cbcee1523384b8caa1bedf195830c27a219c5e4b44dfa8d5788dd263fd60f3187c753e89eb56e8298f49ad54b8521c9b078f45b3dec38a6cd1bcfc9a127ba1c235b72c2cab6a5941b00304d062c9715263e32017b5352f15918961baf9fea519372e92161bba47569eca8792661ce42cc80ba97518781796088a2618049b3ba432b78f8f75ffcdf347ecd232906e92b6f9006782fad3480e65964e3e06dd262e5976a0232360c2cc2bc0f1930ca26833f6661d555dc5575803d8b0b3c5f3ab28ae1dada5ad3c352f1faa90856f63c12b25ed225c19ecb5ba21143b234602891d065f70874fe16408f51bb86d123825df2f30a982d991d14cc5d3fd643b33cb637056f3c02f9d3dc53389ed1ce3ba8bf873cd8619b79971ee63668ba7692a224940a74e066fc040a300b1cda62bbccfe1b8c11c7547f2b2f3caecc74c498e26417c23aba75f59a0f43e1480515df2e80b7d688687904f8cc692f0544ee9addccd3f4e0d60cfd606e9d171d08b65ed85cdee95a220183123754c058c2485f8878b5df2e340d85a4191a508c4fcedc22cb5046bace160075df6f41d8304260be32e1900bb135369d9eb5da9dc060fab5dc871940c684018f0032cd7fdce69c1075ff4a4376dfb53057877d43bf0946c503111c5cb43d1cf2d1071fe147ddc3ea4942ad4e5304f24b6c93fac68462683cacc28f23a9d7c979a721d83ebe3a9d8e8c1ba54945c29c7b22803d7a446e9681a472192698cf95c08d53414b12bbc119220fa3cedcb2c52d90a20263442e60b9e10d06493756292cfb8b249f2c90a564459ca71a8f5df17a195d7f09688a8adda7f2cdbc2c46d78eb94808c3b6775f56b5e2714da7c8441c213628e5f0e382ba575ec9aeed64d1e1a0f444103992ab3d37f22c6f26172ecdd9b8f8ae4e1ff8184634f23798adeb37445c3369487e75a3895e602c945ca6a235e4b0de7da4bd66cdc3b4a08eb9c03db8aa81a353a13b393b73848c310834dc51795dfce9cdfbe8119e4450d0c36aae544b1220c26d9af492e3608f9a1bcdca7e04384e57e1607340a6866b7b55a37af08cf9850103d3b79956299323250ab8b4d7bebdfe6fa3c6f6788113f6d301ead27d8d2135becd24baa4fc63352609f76d3067c889071035d20d88f30f0c537a08dc8b84dade0b636404ea02be14899f5e72e75246641e0576346738f61eba1a6ea6c147cabe8b8cc2d802f5d297661188a7657d50add8cd3babdb7c660282b78e881800214af2e31b22acc438d559eab5579dd7149fd8041d6ee640f91e0d5bb15f7cc12d3b24922909870b9f2c4a91f81c4a9968643e5bbeeca5781f9d3714b7f835c9524ab53e12b9344f65d78872fd172cf8a02447a4f1ebc2b8de338132825555a44eff7b52fcf23c6a6c7896982f01724875737c4d0263a497e981f5db231fcea14eed896e1465130089c37c489265d882cc2fbbd4d1f66613184586a8126f4cf2871f9b0e84b1457c534717a0b82f27ec3f322b596fc4f56acab20f0e6df42150473031297b4396e3da1d1b26c5d8666695aaa4c0f7e178816a5609e08a8e6f7573693d41e9a2b38c35d27c23227eab67b4c04bc66f7bfc731bd065cc31620d0f82220b97dd293184dfae0247af596283bd102d02052487e3e578d95b5003c2d43b29229f4711f5bc3076e18732b274e40725c022ce29d1c54130398d464fed9e74268117a425dad32144c940902637cd0c5ca427558e17ad28d398fe75a49e1237b4bc1aafea9e9f0e9e3e47dd3249b25a3d12b32f5708f0b3bb6928e27497d6200731463e90092dfbceea4d1043ec380a6ae16ac19d78a4dd57707b869c14ded5db475a5b469d3d16ca66034877359f6626b6b4850672ec7eaa3d6ad155ba495182998fbf9be9f88ab87eff454a28459c108fe91a74b678efe7ab96f7af70f57cfeaf801fd333c2b928f970ddc0392775e68d9b137cea237226788bca0cac6e9f036b83bedce2fbd9d1bb2416718c183d1ca2b2269194a8829ca60358094ca7597795edc454525ec9f7035b61ef46ce580eb5b0e9a9fc1995e3331604dd62d944922bbd0b795fe34a054fc48de53323070222b1cbf821c91e686795a33adb467324b17330d8b19fa6f20c68ff5f3c624c5edfabd31c55d496b22b0beabff9e2a0e03d9e04c80e0d6a7365fcf67a79853c3132c3cc2fa824f0f4e29547d3b62339fa885c28acfe540f6dba157820136ea715e4ad6e17f9c77be6174c600136a7d53067d080780d71003099c63123c4ef86f46c4fb1fb35a0062f0b02edf4aadaea24af4be4fc5bce12883f6780f1dba7e4c42a2e7905595b6bd3a5f9da002cfadeadf1cb498b16d2edcc77211d71396ab03a446ead31c68fe0281f0d521abbdfe9235f8bac5790f9332b7ac39d263bbb669f0cc280b55c8fbf2bbe98cca2f3eadb724e051c54a966f837b467b1274e88a46ef3f1a2a8992ff768a7628c27dec0a98083cbff1d4e4b2c7a129c4bc403875873cf07ea687d350be0b211788c1d07bb4d8cacb95e038b2cfb7cb2c62ac35fcaa7a856ebbceff3c87fb5dac39d689be0ecef3263017c7286819d72f13465addd73cb1d860e545c18f3ac8b808c357270e164094aa9cd938eefe29152a96fc53a56c9b8b7a10eca7f57badd6d4ca98b2de6a42c591eb17987d6c95c94d154bbb1a816498691dbc19547c444c92cf049def2063446bccc20249d11f90bb8637da247dd1965aec054bb906ae5bf582c341d28930d3671911f2465ce64f3b8ea2c550d48ac5c5da4e2b8262b05f15f9aec0ee8179565c0b727eafc259c3e78d40964ddf2eaa0a4fa9e2c05dec85a7b3af8de8500799292305532aefbcb214faa115b48a6aa2e68d8bf790e467c391d7efde44322adc6d75b0081abc2df31fb96f8f9b1bd362c7b2c9389ca373e76c16fdc8a7defdcc785613e53b0b5f59cae5c117c31c16f6f8f7c660061d5e533db9546da6e270333f790e4936c6a6d6cd1ff2165735340ae5409f5bb215a41d8bd7da23cd00d05282ca819838501bb5798d7c1d2ffd08963bb08a55d0fcac6dac214a4e9eb9d762d5b9a637c36b96735d6e10a7a5af2b0b64954214b8b2bb0e5b37398a421f3be00d042aa95bbe799a62173e89abbc019f79361841074ae440bccf00eb893187f234a7dbd531f2826ed0814c74ff913ae97b29580b747b98f9e3d53c301498d241a4bd5c4afaf564276717205088a1059ea36418bc015aed8f288d60d9d76e9b62ade306765f1d5cf070941b43035a3580d4f8a40abc059b64b6d1a258fb20210f37b37e12ee191a533b311f5e79f15cf1f3ce09143035a2a4aa197e7b023a9f65405bb2618c02620e7dd1773e6ad303e83ef355af8daff91bc058a207f4bfeaa3a97f5ebe732341213d05ddd04afb0e63e173e7e9882af233dd21702701bfcfd1171fa87f251aaeab8b0090da353fb08ad1559b81c843bcb69b7d43b52ff1fdcfbaba30a069a0ed36f8207902178b9a064eeb362f82dfac8ffc5a1f1eeda6eab0d2eafe4ba6c85e626fd52504e090bf2b1666de7fa63204675eff8e1db34ab051b1bf6bba640396efbf3f360d9d6dd5549a74852db122a4e21c3d9d0283ca3f5759b616477443c4c80bbba04a17e9ee1fc76c59f9ac46922df0a695eece01ae03b7b5b2458c10625f1b201c2052947ff72206e92fe3f37d01b5db8c959a5d555d2521a8a8395a2071ad64de9d8d81cf8861fe1bff875e3c6effa5d1c76e4cf75d649d09eb0afc264c4f6376f1e34d77668b19dd8809d0aa8af58f92365ff1dc7d59791b3a44b9252f56a6c3bd50bfcae0aaafb173b132090ad42551016e4f72827b9d84529ef89138417a9b095cd6f3264441d9cbcdb4a65a800149bf29f5e0e1924ae3593f44ff2639ae0a6c080e4fbd3e1d4e797f1a3a2c2435dc174cc33986816e276f28920059be3a73f92db8e51c7507cde00cf5978418da98b6661f251ef0c8a1c2dd9bc631d72b51fd98e382b4d64ea785917880e74d5d9dd31911778c5d83391a5ee764e97e7861207d0ccb76af10daa9590da6460b74c8df606a98785a7e33757a6297e9c498047dda8288e955468a740f60904ffdaf6b2b1c8cd1695ea4f35abe6ac29d166e2bcc7b596dec7a7250525d0c2a4773fc5d56701f5fe7b75ae993dbafdd8624fcbc4b1c6aad319b66a89e9f6c5b362536e6ec8d26c9634b5cd4888ca4567afa0a6a35bf34b785bf76b8d0ab504f647660a066b1d0454debb3a63d9998edda642c1e1c3bd3a0b7e690813223fab9c39df1414729f1b85ffe6ab5e983553ca6f7092be7ce14254470904b82fb3001700a3048c36df7a705190fb6ccccecee0623049ba77958a56c582fed4fd3fc9f77bda50c35d925f5c599c555686ee60d9a44e7954b8493d2a3dcf3e4688aeab274c7a95a8ff7600b325a273010ef6d2416098d85358e0902845c9cdf53af0b9058473655f6fa277ef9561cf71cc695fe1d6c93d4b00ac291677d74c5d936b7e35d7b5b0d5a4966a3e0f69e99e22d9c244caecce706ae55beb4513a5acb341500958d08eb2a71d4c0e65ae1cb1eaa5fd1efed42c5a9789481499a2fa69e05637c38b709cf89d091c13e6986dbeb8499c064143df50faccc2d980fbb48410367a2112ba489a225cd789b8fd061d64add0947dcd01f70c3041948fe84b1dee48b2e212400b74bd3d947467d42057baec2f8c63b470c03328891f0eb5438b3fb816b0ff4d9f9510f1542ac38c69282c54275fca9bcc2b835d7f67828e90c3c6bf8fd6c991c7b45529021f1f6eb97dfc7b104f1f946a005f1d3870f103c1c1a87910f50d351dc6db6b3a1852acfa8c5f438faaf597dac7e347bd1bf51da89060bf6e1653f67f9b2a0b3f11010e95c7c7cb2df51451d2820d23b1bef094d95aa438e4b63b2fd7eb4c5089349cb59a02553beda11b8d53f323bfa05dcd90f3828bde6130d06dbaff5a7a79a7fb83d8305f678225728507dc24c77e3306a3bf994a9d918bb267cee9cc39b56b4bb54a1205605e2afd73f8c196e48f0a9e09b57dbe27f56504560422f2fbbb0c035a6d90b162cd81b9aa5e4677099c9d0ca1b8226866891b9f2e237237e9cb3ef6bb8a4a4952f11ed89016c73008562cf3d39bc6a472f1151c3c2b1860b7477ac6d25fe1f3d510e26ef7ca0f0015b8b3d6d74b7ad4d4e5195bad3697c0c9df672551fbd7061a686e6519cc0687bb01c86cb9f4fe5c0c58ee32930e54ea7c2be770009ac8bf4a7a14c8bd2997fc6aacdb5ccc6e912b5a2b44bdd55fe1ef2d6d6966a59a09dd4a563691593340ad4888df0d18cb8df471bd47ba59ab59de0205637229242dd6724e88c87bb161cefe6b604f240cdafe37fdd36bbfae5322e39831ec9483d80f66a498ce56c92ca1addd2406a1d94b4ab43d9e27d1d1c9f9539dcbb29d7b8ae2db95c873dfdbd99bd21ce2063472600fb0539cccb6364c91d4bf549c7cfa96c91ab7af556f3eee0d54c3be6ebd1d6c95a90e833be4b92e2105322f22e98a7c5a349f0805badb5dbcdc33b920593313796d0a627f9787037fcea40ef0a1d97b84feb59372d550cf5ff2a6c773931614d98230753e39feb1bab5266457bd427433db37f1cdc80b5a53802786229812b4296edfcdb6a27413a755d90a6d1ce902aa0474c0c64c11f5eaf889d01584e89860a484c11ef1ce8c26dd99c46a67926e49355d4bc9ad350acb3f37118e53ccb230afaf9cbf75c4bbee9ae74533b6fc77c94e9da00e0ea3b634cd69351f2f190fa294aa65091035becb176d4233751ece30381e3de6dbbe7fb0d61b40b29342b8b1664fbd003472189f687178fc7e91cd0bb644cf3671485c05ae83ff617fedcb7be92148a3e196a958185eba6919a29267a27194d3fcc86be3ef2d6dfa3e5dad669793473f534bc8edd1f2f04b6c1d980cdf7b1ff394fca36425426914f4ff9723c087eb4bdf2a1f2f2b9099843ed3cb3d5ec6a7098b67cf3c4e051809f567dc4938b4bed6fa8b7bf386f68331d3f1bc83f1f8479309bb969acebea633a20fe9b1f76823152659467abb653a6f714e0562124e26a0b60ed2f1f8ab717c338a7d303f21448256926af1efaba50c55ab4dfdf6618b783a5ca47d6573725552af53c899a6e7a27e30c1c48e7d877cab618fd16a7e85952e5cb1e414e59924089dc0cadca4f7c83dc5aa782685f6e83be65b204dafa03c2b47ee4ec92d8d72ff3870f3bdf58852bafb3b2e98507a0bfe5669053abca4dafacd21f3b45c4db56fca985ea42b63a674e498b4597b267ebfe8a440d3ae586e29ff4e0f8ae361a11d143b5e2965147361e423613be8425c268e717f8aa63bac28fb76ccc0d627943319670ae934feaaaf80a78e7b4b723bd359afb4c7c8e6fd3e6fdb27e935e864c8b9207c71a6ac9e316f11d2e8ca16c6ff2d4fa8f4fd4a6948fd337099349c3d20f16f62a40ffac8685649c6cabed6c948004d7b86fc20361f5b53b369d3a13e5300fe55699944c596b9887cfb3fb20256f541293d8555d4c717a1e8122e82464bdc0f243dd77595c7676b51ffb7d7368b4e7dc373f3315af30878be4e8216433001c918ac3ef376e855f05d96489b9a4e5fa3ee11e0c68d3a6c3a2e3bb45ced548e7d2f2357d09eacc7b7883b57d89392c52ee5626fb354414d1feea77a58503b345eccbd19e43e05cbdba31b0d21e5037fc5e426231f725dbc10acef521eea893e52c5ee9f6b3ac391e60f21cb5253c6c8e47c396fde339aef48191b9cd31436d9a96e2ecfcd6c2ae0421e0d47c0d695edef42a6b0fd16cba71ef8971f0ae0c44398a41d3c97346580b7fdf186229562e8b0a3f900d1f46332e1fe6aaee7f267efd5e6036f42d4f8cfb93e00fe5345fef5978dfb8baf5ac943f59967d1ddfc6023d7215d5a47513333d16d4842d6fa41cee1126ef97bfee8a4757f67392214cef699af3b291f6665eb88cbbff374019a4017a7a24ea40f658b69decaa1edecc535ea45765c91614137cf6f463e556764fe9bd192d3c3069b486804b79cb82c8f787b5c4f1244b78c35b81c071b192ad95ad6a2f9404bbdc9aca3392798647a3675e88af445130fe770b5172d13c8a1b871d45ecf28f4bfc9eecd89259bf7192ca085c3a6b02a61f64bf2800ae501e2768f1048df5b3be76828f65bf873e7be7776cbb168d3faa49b9ef3cf430ab9560acc38f715517c4e5dc99629d245b022a7f08a27c0deceb5ffb212d4b1540ecf6dfdabbd356596f3699dd7e9f7e894192d2be31ddffb009c2520405e5ae71462d6a983be93320c07ca20f654e3340b4de5e2438a0187de00a84b9d155f59a9a6867f080614b118c4b72342788939c28638047d423f9ebb7615cb8be931b521ea0904a6b8c55d78c69cd0ea147e56db45d7494035f9e417ad0ddf7c688baac6fbdad5f7a2f2da17bbc6e29a1c2a4d67fdadd474a1d8c2143fc678f1b0cc60d8023c4052de8f8d96636f40b88c30059e351f29c5187c31456e2987d5d6523472b28b8324d6c3bda5c32fb7c6e6fb6830e38b0a22f416bbacd1af40c5b839bc86b974525388b018f2c7d64b9abc71b29cb53c28ae1de3dbc86e87268d4da467a7a6053343ec605c9cb621e19e6607e0cc6303abaed90117fa9863185511b84921d9b1ee485b1ceba2718abb75013607bbc58fb95aa8c270fbc7023824d98b552e85131a94d041f3b61025f35be9a5568a0cbaaed687a47b3d2ff7c120c26b89c4179d0c0d4524aad5976a94d1089a5402364ea87c7c5f6cf012f57693d3530dc29cbc44e408767e6affff6a10b5c46d822eaf370309738ef0d53b699b85239303cc02c16457190b588b89527e344eec1a4e978ebf2a1fc259a3f654c2374bd07a70bcddab73a9cfc36794e0bb058cec2c327cc8032dc584b7d62ae42cf32dc8c57d862d31a674e3e2bf9d7221715be0ba87ab2910b4d2fa87871c608ce7361b18a1dc5df14a971932b79108692c27e853cfcf1548e858f3e1a72fd3a51017fe6715928a82b3f7e1a946534a14ee0855630fb63d2b2f24f236627f0edd27d47e41e6498d06fcc3b976de338716652410e21e5dd2eb8b38dfc09a2c6d67c40e7fa739a062d75db98d221e560bd62fa00e0dba11ffbc86f6591429709cc2e326958673aa1bdf52149c2e93b7fbb9173c43a7738bc5d069cf5329b9726701ce7e014a70fda24d990397fdc9a5d88c10943944c6c1cfc6a24bc0c63f57be7445e628f2dd7c61b5ca323ced25c853c6445223c96b9d2e5991e99dc0079d309be55840a311628f88391bc33fcca5f9efc92ce65da7156adb46c8dce9276bc873a885d51ef228f0e347df9f429c1575c4d45f0d02a636a7697ab5744777d43b60fdb86f63a45fa23d0be5c27176619a41afa6a162d148547535b58e58ccaffcc8248b90ec1e13d05f7eac6c8a9313edb18f62024cc93616b534f7e961a2e1feb67b27421b813b3908f1476e97a7ec14193152a3d38f5685ac59902e7245dc777ba5d6ece3b594d89f793f76c3879d71d48e8458bac9326fc3ce1f51ea7ac383533739b123377c55e7e8e2edfe4f034c724e322a3aff2ba66d86cd57d172cab57d039f8598f377d2d4f8fd1fd2477ddc8ee1fa5ad6f2e18511531f256f07ca5d235409ccc7bdfd493c85df0000ea0700dbe97274d4d461f2b12895e731ca641c089e134ee6345bed8cc06ce70fed143e043f2fe2d3ef9f09a7ad71af280643808eb075bdbbd97f2f55b241ee9cf06f2dd3abfee2c27042932b3acb6ae489b498eb70082b52801353d9925c54fa74ef03b86a610fdc1608996013de4365f6948c9954700a5b93ac27fbdd2a30e0a69670ca7fde432df42ab4e0dadb0df6bf88c75bacbe18825b09e488d82aa405bc6f1310a40389c6f749bcd49d7d9b71fbc2649d32793f08ceb0739cbd31428a53a520505c93ba8bd4feee689e6fa8cabf091982251a1c7c4698d63e1097f198640e3ba4eaf2fc0a2b676ede16c431fc0f0c1591f97e0b8dd2079126bfe7c6a24563bab2791e54f9360104ec3c6baf64f18bd68222fe121050a2a10e579afbd754b16da7c5cf40c81c7b4385e26a7ba3a847e24339b8bb3d59dc064fd192f105302e1f681c5417bcc927b86fd862eb11fcf201b3842c9ac5c7c8cba5bcf157bf39cc2bc62ea4059b6ec2bf2cc9adf62f6f6a4ecaeb2687b5655bb7761dcbf3df5ed2f70cd29e474e2bc4a55cc4c28148bd093efb34cf2f79e574d5d7585cd2aab12fc2840de9c6a4ce1969a60ec67d7f490ba94ca1d7832a6a5c30320ec83d2e33b18cec1d0d0bf73355da0244371b7485c1072cc6b0b48ea42a3f231caf1dfe6586d4c2d1f6b7e8099ef037637bebcfbb492d6ceb7874d04bc9f76feaf1f0aeab62acb37fc953f2e9ec7cad3da8496cd5b1cfcbadd4da813153dfbf8cb3e74f3879a9193b0e30899e254cec0a31f7868cbb0a36962a1c5a6e67990d036bf3971d0f4d53ac60a884fe3be31f8b0d843fa073e65799e29d5ce5e266fc5a400d2ce170bf51f6b475fd475d3818d82cf985942cc17961c76dcc7c662f7746484807e4e77865de7796739f9eaa263a4cd3815fc9446ec7620e7ffd4bc72184364e2c3faa844bc4e096189b73456536ed99db409e8b1547282c7a9baeb497ed4de2f8a328173be0734e5767c39d3fc99f4871cc901c952996c2ed42463aaf47c6383672d665a407057629252267771c378beac1f776bb549743eda285b8c5a8a8d2f4655d8d0b8b374bd6ef0db95ac167e60c4d260759357323e5c2d763c78ce9700e9d8e2bc51d8b51eaf90d08a1a7ad76d6325b68e37a8ef9cdbde72adca5d68d84b8827501d00e689d1ee8914d595ac4ba96e844ff0857fa530d752d6afacff7a9eeb5cea82303c9f1b893a0cd7d331c5410f8285f2b77f38c9588bd02616363d62296dd4cfde64916cac235d123fcfed434db200d15a8514f619326efb0e9fa190f13e25028a614597fecd24151e2e774ff5973479443f9b6751442c4810ef4319217ca0c129a60d33a8c1aee9aa849d43f017b3b13352ee7ceb92eb439f3130a244097dc52a442fcf88fd5f7c7b2d6258dc0f52d013ef165ca8b8627c843551bf2d47a3867d84774f6287d2868c107bb7edfa67fe0da59c52b614f3895f8d0d04b0a9fa92c5093ca9c3a2d10797049ad4ec453e82a34ca446415a368f5791bd2ff3992abe8ed6e0be43d9a832f0e008b8a8266be7d2ed9d7429d4526ea752d2b03e06e19f48aee7e674b1d67fc0918b4d165f4245b6d8cccfdde2907fa9deb733899b2e85b642a5981c442ee7b856da652afe8c8b410660e377dd43bb67265ba222182017fbcbd6a9cd16ce4d511a07fa82821c769dca5bd4244778124ff330a5f2d6eec30c0833d5e4e60ba03b4a4b1b1d459bacf08760d33813635c1b77132f684e58bae421448f8403cb0f977ad280bd6c661db9fe804c4920190ed111286d838b51b9546e3f11bbbe9eb9d87b683eb0c1a349e973d26ee0bd4a357fba5d2acbf96a0a7aea0dadc29044e2507ca4fa29182bcfe30c0f836d4944c78af33c1b11feed981572ff827012a2083f2c15ead69b36d5b93b2e9551e789d83afb7611bea9cf4c4a441161bb7539fb2b5e2dc40a32166279ee002ae74aec884056325117f4263483dc22df3498de27a02ede1eee797f071f97dcb5307a69d42d5d450de8ebdbb9b1046baf818f341ff4fb60f8b2dd6fc6218996f0eaaca889232d222bf7eee909628ad11b86c18e3e3113cdbf84d354a65c5f0dceb8630bd3d3bc1bbb02f94b666cace42c1d7cad78d04d8b8c3fd9b1df397489d8682b115fd4df3ef753c7d28d036620c8cd6ba1f0f5d0dd6e890b255c954213d8b9e15ba52818a1cd4410125f2332ff3df1600f27b3e98e42218dc0397e926fb3a6f8926822fd84c030302670b040e6d1f615c4fd93ad6492eeceb3a2733ff901bdcc5a81a6a9c193177c15f5bf400e10ea8ef7be30347c6bf26a058de49233199eca40d0c6a09c2c4de8341a71dfe813a70ed4b6e08f46911fe8a072bffa6b639ba7c4af6603c30d949241a24c7cda0b7f4b51c8b1465e9853cdd1287d4321d14888e1438aeec7191ec456421134765bbcc56981a14cd8e8c86c4df87a1e3f06605cd272e396431dafa10c5b9c681e26db8f074d3c6adac3c627cbe267e696f8f2402ecf733a2eb75413c8cf74228ae115d469349454b98c57a0c5bb20e4f9473a31f288b9c9cb94cc4b77a5e4571df696333fe91387d359beac92effab94f887d450072adeb88a4f1a4ad8fef54b2a9aa24f9eb38d603be3457afbc4414139d7386cddca457364fa8d80948a8825b0be7e98a2c1a06b53d5b5b535e51d0f67ff1df9229d046015a1e52c93399b288da9eee118a5ce0e958b2f4e3eaa5380207676ed931885b149796ce99b1945086c33b8b7c201c21d55b9760b4ba43401e8d8c75823e340ed19b654368d922fcc18c5bcd57d23c4e22ea08367163860d57dd7324f3f22839b649c8b6672565e7bbe2b6317e852c5cbd13e7becac93ba3de8760bf54107cdb3bec2c85866cb54bc4a7d60de9e23c295b68654d3c83f35b430128137e84280b2f6cf75b52104b82bde7f99b3328534748e8d80ec7db574c446f92e1fa94282b4e9236b1bd79575b0159417cc159207acec4664a26a48ad5ed30610c7dad8dc1a13f268073e4ede0eecf3f8a6e45caca0d7616a1354e5907207463a03569a6f7f0104b12fa769d9338501c40acff5aeb111fb1f545228edfdb12e70ac076e0f6d05b207825a68ea1f682acc44bbb8f6a1428ee2d13bd2c66a73af669951dd838d2dd4dd7cfb074aaab16141441e02491968b331b81a58e7bf44303c11a357d012268c4f7efd57b5e3ca9f54fc13adb894ad6d9ab637a30e2f9ac30433271d8b7b24029fcf6ced97e969edfe5b37c2b82222a0e91d65a6bc08f4af919ef998142de9371a950045412557c92c2547a52c5ab5300811db9543845eea86fa917c48a05f67d3f3a54edd2c683cbb98b7c737c4a1319642da9ad13fa29c25b8aa826351ca42b9129dd91535529e70f2fd6f556b0b0c2cd68930880ccc3d59125c96de34e6aadd9b346ce842f9fee2fbe841c498ff16873db15015439fcc647164396cae598e7356d12835d4203ccb7f6fd0c5aa40af2a52bd0552b879d4fa0c339578a6855d2efd9547bf506dfe0888705998e927d3d223a774312cfc31bb072dc4708bc129765622bf591ef6aee865ca003eac66b5a6d3f9245d63e99daf41631c9990948832066625aa8959b817c21412c5e26f0d31ddb5b0b3bfba0eccf804a37ca7bffc4723cb372bf2f282a5aeee645d73f6bbc48f595122e82624b366d768909846540e36300502776e86ae441dc6c6f05ebd5908afe329ea9ab03946878e7cf41064a1dce53d7cded22e0354a85f3c597c02596f9f8ea5e00a0fb0703398e8e049d474b0e43b852f850f4b5f4d142b19ab4fb7296d202b6b235fc69bb6c50cf391661d93ca9e22b1fd6b549f65ce789ebf585588a178f4f034a40e95c72309130ca412796e2408989dabe9d6bb1a0a81c5b364f18779fb54c4fc0df3abd2af3797bd53e39d449145cc51505702cb5fac6613f2e34a56bfd73d5d0d094382025cbe4e890647e96468fc5c15e82daad59482fbaeb22abe24a356872bb505c28220964f23f443f10e94029ad0afb5ee6a46b3d19563754b186a5401e13b5e3ab325cae3da87f3a9b05080e02478c3d2865cc8c5f35626170b80d7a761bbcf40e71c588f2aae5916d86bae6664e7160f40b484f54931f301df828d2b26fa16549d44d546143382de8c142d09cef64759b2e7811d9e09e8443d1672621a30a507880b9c3234d0cc3ec4cffd9c4988ffd52bf2646a58e4ce947a5bbb97496bc7083794a3849c5ddbfff5b762f47bed047ec6558106e55882cc6757fe048e2954d52c51ace7f2a8f1aa3fb99b1a4c3a5b7d5e418361cc62081634f2ff66a74a15d162f3c8038db13bb2ecb28de3fd0ebdb827eb12718efdb479cd6d6d0487b604292331bd5f79ef77c1400d6bb0b0eed849bbec480b562126f94cc5878e01bc447dda5bd1d9d93c06cba57f9dca77448a54eb32b165870434de4725e2804f60188129f82a229208752dbacb9f563843530f231fd59d90abb120c625e62548deb36377dbef8f7521c750d6049e5ea21999479727ba26b1a548630b93a68e093a70ee9221058093940c113ee2f129be21688eed5c3d88e8239ddf8fe13a8e8c59af71ab719270107ac3ba8d2832a68bc98dbb6d961f2bd2a0d330ed796a0a96419a05a2ed322f98512351d272b0032ddf7303afe66b3ee2553941daa462648057f9c20a1688d8efff77a25ee5e8d996a06d0cfe8f63044b3166ba32fdfd13deda35f9ffa14f31da5566984530765b50f0b5fa34dcd49fbdaeffbbe070d3da614d9ed6f390d4937b923e46343cd35079ede055a64e6fa42d90600a54e89a538013a6c65dd64f0ea538ed8f98e4af718f0f0c741388fe4440422860e7666b716cab99ced0e0e2b8112cc3ac8da563c21534588e844900af08f43dcf7f746799da0a79e760fb767295971e6a5f8c325ebd9461ccecf4c6993651a500dda2d74fcd893f9903e23cdbcbc6baf0ac440b8b39cbc195d36af46bb7f4becc728e3aa2a02d51775fb553d969a03ad7f98e4e991cd881f7764a314ffd507cbe220fa0909364b8d9ae2c6fec69a3c443279368313843a43af4e4b1f92c4be8d473987cad52b0e91064bbb3569ee7376aa9186ede93bd6e083fadccd94b54562d6c26d78a7039ec8955530de9c6a5ba141972337b0715c23ffb2deedbfadfd597716d5fa6d5c24b02d4ccecca054d0514bcd311f42037e8414c5a9dd0e9f003d7398704e257517274ea0a7dc4479560b674d0c9f4c80931da3c0e223b9b5cac79bf6542a46bdadaa06ee8ea4e6f1fb748610e48406211a64ca68241ef100278a373a859a761401c5b677f193c53460285381981dae99f1a7043c00af9045ca8b24de2d62f161b6aeed3b92d267e4c00d4ae09b32869e209aafcb99aa56d3e69b3b916b5c7e6a72e9deb0fd32cec7ef5eafe56759b627da5452bb42f8d2b060ca7938c040203521632db52643bee12bdc7d03e8918007e3ac8f43e2de1bce66ea4f82b6686729198f1241d76df05492cff340491630957387c45433d4b08160e1745b6fdc89a31600a1d0a865bce7b5c3feb50692cdd25523d6c1ec1c49cb1cc83b93361da1e46438538d40922513686f1c638f132ff53bf302483ae8da35006311eb1b01beba5c84ed3f3528b319fe61954162c8a61d610dbd51912a1dd25b3ced0d5f3053c556ff66344862436b99a731422e0ef26ab0ecaf63565c45d6d5f0fbea3f4028b7fab568f53b565d02c5b777fce7c6dd09e3494420351162d77c1d81efa4b1c61b1b4d6462be0bbbe9860205addd5dd5f477ffdb599f670daecabc9fecc3e3420cdc1c4c5761fe5f54bad83d2ee7c2657f1f24243c1f1eaff4a5dd6f552207691db77f73b0c53abbca21b95f23188363af58ce243e715524f7cb864144b62e6a5f3b6ceebedd306ffba39679fa90878fdc6b92fd6f4c438fd6d51e1db734863a94c44bfce979bff9f27efb2d1be5e1b8455f85c2946134fef6ff59c657cfeaa6c6b903f5b86e3d78c2b38956094c3dddbed41479a11a2dbed2717fccc9a9c9031a6f4b0eff036c21496e58f6210c619755e7937aff7d67ac748b6b4c296a4d6ff7b2d1bd348a83f6fb549202f83d671a7d12450d1a6b7452556dcb303284aa49789754f5b2fee141ee18b395b7949318eeafbd7bb0604b201febc11368c0cf11a3642ca7f7bbee63e43e5ef0f4e45a1ce50f7a2830ee4268cdf54299a18bcd7e20a2e8f032d40dfd7f4fe8b6cf86984ace7c841a630a197cf896b6802207b5cb95eda1b576b945f3c8764a87a5be980d078d1673b9c984e8ef8b36b9e817d941e5819c5da1868633f4af1c37331a9de7d0fe3c7d5c99771d70b952225de4eea69aaa4c1069713841dd7473cbca7f6def82d347737f2571cb2d1723f91b746b1be0c3559de74d5af7498cbfe8338ad73517b5d6a33a8c2edb4a8bd6d9b5b94caf3a5ce2572f52bf9846d014e45abb7368301bfe3daead8a6ed33a78b7eb1e569142b2096091f71775b9a56288579bcedf250bd1f7dcce766f8edddfc7cee984c2dc5420cfe255eea37aa87765d47e37a3e943f95a9c709c022aa583b84f1134b0e72f0ecaf5f8c960b9167d45ff4ad41f7eff6feb8ce5eb770e5976118d043bb4b79e5de06487f641fdceb9bde90225c64976fc6b4cde428ea0b7169dfb50c4587555f08ad6eee21fdf595bf40ae66f1d0da90520458b82c47e2a164d6cef05b74d8fb216469592fb694af8e9f88bab3cf20d795edb5859cd526eebe67dffd7ae71a1a13cf0bf7a9428ee37a39e2c53faafccb2528d127098c1c921be6237b33d79084c3cf0b1081adea0fcea09764cee70e813f9efe0ea87eb4c5ed9353f6de4c8c711896fefbfe3b8ca2cbb2a8014972598b02e614939fe7d7609991ff053cfba8c5aed57b544a4a3d0eb6207e4635f4889a8dacb61b61f9928862b7c8387dc8daea551d60d23f56e23d3c312f22843766924fd05861ac82db9cc800ec85eb0fc821d7b577ca13c3887792e6fc4647c2c2936e4e7b2b02b7639c99ceeecaa82fc181728d22288d05a4b4d3b0a2fa389aafd46df9393fb84bc2f14c4db6752e205a7a34e60cae4d02fef5f268cab55e2fb181ed4184936a52dc5df832ce468630d9c76dc04a50d66058dc0b418b1045a360a57c9977a056cb1b25095071314f8d2727ab7b270ae3c0a18eb2717a911d1897e7fa14e8a3c0703e8b45e4860853349b25de253a1a8beb921169b1736dd0dce42d1dc472b0899e72bfcc09ddfec34567f515dd73764a2c76adc65201f5ce3f32502a420b887806980412d26796d198b0e725f32976befa0e0ec843ddadef3550ec7373fab85a9e9c327d3cf6a566458cade14f0c76764eff98c26540fb8141cd4f47320c4eed090963646aa8a439f4fb456827152c487b06016a0f669b21dd8a40a562b42806c947f33d6a4fc9d96a5cbd2408b51feb8a892392318dd42ebef213b93e1008943e122a8b2e6b35ccf625b90149a6fceb47fd9e7ab5d0adb348456ac16a11f8f9e946911f085c0cb48dd7668d685efbe6e5350fe2b31b94d94e405ac93b39fc89823bac6c40515893a8e34b3dc0bdfd2a9921299cdfda86824420d4c00e398c6f0656837803909a36285bce105929f61b15856243605880a335c72b07cadf769cede90d4fa4431bc76db1cbed4f49315391f8ae178e467aeec678f4e77542c7828452baa6f18d4ef23de1a3bd0aef14ab956877164d71d4e512eeb3b6d2725fc5242243b8ad6eaefeec4d426f8c3d7a324dea34addf31809ad6eb45657f658bf6e595e9c7e8431f0f8da0f7c9fb57936ddcbcb4eca2bf0439e9b5c37a8811e9017fa7e77949152eb122960124f82aa9456b8028ec67911f819f81995f9926dc4227904b58aaa0282c760bbe40c3c55415928c9e84c40e221f0d542570ddc7f4f1e021b59485e420ea677b348a889bf5831820bb712eda86783ba0679421b5f4014cac0f84a27d21651bf5745c85dd3aa7a24aec6e4866a5cecad1d7e0abeecd8bc748485b4b46cb981472e6675d3994dc360ddebc51627c314374b24bd9b7226bc0f598bacda112ce7aa409bb2139bcab8c232d0ef6b2eb9785d4fd6129b2f06d0ccf5b1d0fe8e3db9e19fb5be9ae54c9499bad7c4fa716844d9e52e175d3b679110cd562b599fb599928818739663e66534615f6e70e394fff77fd6bfd4291e219b0a6ff3a7a1841b79705ab75d69b358cada01a2fff30affdada13c24584575b6fef51623e469c021a6a8813cc9bab98446825d2d2a061bd51f6e0905a6e89fd2de1fd7b42c7f5eb36e5e4a216f48f250a838ceef8f5b37dd5a6777669e0b99e91f1aab14eb7559059e14fcb3b5efa25d0023f033dd792fa7a8ce448d0a4ee56c7e64d34e677a29d9af50dfce64cf4f2a1d573ab0afc629f7f1d9f538d69a7d77665234268e7bc9651eddef3d0238b31949684c1a2e802b664a0888cc830f827c054dacefaf50a54061bc24a957c1b3e0e50840107d01ed1764b57ce4f6fa07ef8dc983b16feaacd2888df92f0ebdff521205ea7838a0249359eb659160164e6671f624e68348a8954d6cef1d9259f4218da463708450c9a7cafa0f849e1b4e6a4d45f665d41b69ff4b36d9530d5d3b5feb1b6dd0f9010ede86acde0fdfbe394ba5091366a2a54339b6a520acb36d04d466f546deebb280d55729c6d871c1030dd3c46606a73a639226eeed501b9dabd98a26149fa32ed342df66272726317bb6d7b8d902846043cc6fb22a46c034eb303644b48d980416b5882e79178404818c665f443012a0d2c3bbec33c692ac9279bf92f72d991bb8a4050499f8c78979c51deabf4deda7b81befe89f1a2a55c6ced8f741a02d9a46d8d18349b274933336f095b5da1b5387de717caccd850957413ccd074b5c4128c8c9c1f102260a214d3f09fd1760fdecd0c891f961d56bb7fa75da3c4ab627d5f794cbb62ddc54ad6f6481830819fdeb33f9c92fd216e53c332ef396d49cce838ac5b4dd66773022dc4f812517288c7e551d5cc17431f19626abab7a7d7a10f04c2bb026f8597cdb74618ad8c27d197e3177615ffd7568aed27f15f5abeb6c277cb58bf289c74bd530003d6cd61d4ac0d5f46a87b74263316bfd90560161984fadc0a3f9f2e8e310b2d6e9ffbd2e7526ae1043c73175713b4d1d0308d6206c77138f641da77157c9184abe140284172f858f3c1fedef685296f48101f6b933dc69385312119b331783e297f1c45d7132deb6fc2552a93ae6ae5a474c345a36e095c10c8607efe6cfcedafc857bfa2ed6c62b7183f84ec98a09789ce6937cf25b81f1b1d89e3f143e40f555ff75e18e4a16fc75b48cd80ef2b69182b0c2dcf50eb1ce3bf09fb47e76e5ae1d616c9de418b89cef3d7572044ac13d8045166161ee54d99ff9dab7d037be8ebe8dd41f766d43a0a650df5e6bac4c7760d0500a251c07837876dc762f0cceace279c7ea33790e3a045500d583d504f4e306e560fea0d043c178cf6b3039dbe6eacb8481e216a030dd8e14b7b345620e3be8473e7bd6a0676600f78bec3443f371d628a5b6612c170c84b04672a0ef88e228aba592088a6783fc856d106d75b0252f0e64e2743f368055cb706f4fc14b6c34616e03b7842f03200b9ad99b1474ced5dfee60c42038de8f4fe515c22e23b59e5ea1c4daaaf61f874f87041bd1a5590f9f83e6aae14d71ea07cf3f3f27a09d90ec2093ac0e427fee2dc655a13efb97ed4cb02fa35ac4b5e5f33e9cdb26ccf15f2dbc5d13672abc10b7e22d6fab0da56992849f0c851f8f6742efac5d7adb04d3b213eeab4d2c0c075ade69a373810110024d63944da13160b58d3ef14af3adeaee9361279f20eea3ad9b424c38052cf411a5061f56543208314256b8392fe6dc359d697e4312bd1018ae456523ec5736c2dd8c72e650ab09df012bae0dfb398296703a3d0917fa1c6d4ce70be9053fb5b1366c948aa51cf0ac35bd1a786cb6e6996d9c1dd377e36644145f6dab21ff452c7bc4803217803c31814cab1da412de0c2cbcea981a0d84c70f004c2227763b17d1a81bbe1da6157029eac2791dec9fc73766c9ce4fe6a099f6fb7a736782c586f2d5d423667ca4ce6342fa424c4db848093138a7d4d06d62322ce1f0c39072fcb38d1b6147b2e4cf8d54ab851cde673b3d3d2f14ea4a5a1a2612eee67cb83e767acc56ca68a55a22070e789fd21849df09f3e118a99cbbf0b7a93bf5248efa897c99d4603b6c3fc7888af94f47a0effa5f688e74a963686124d54ad585e8f3125664a13e1555c4c161e0e7c79fd3dae7eb61a9a3dffaeb9fb8f56d011b4a9f286642cb89cd3fa97321d57d187542a9e8aa40d822ffbd1f1585bd13a383f45ae02122bb80ed306d2edc6620ff6770e51b9683f31c2e506b95111045d3d154389e64e895737677916d563e149b630d162e3e6f4ebd5c92a7de9be58208cabfd2864e2beca8c6cb941e24b9ee8cdeec2eea3dc43fecc1a809dd371fe13de7a2bce2063d024996fbabd14d38021422deba9fd0bd4f63d31af23ab698ffd0d205da987a1d8fb439afd4a5b2f494a1166d0e5a5d7dedc95d460762553d6d626d3e4869412b5680e5ecb99f4ed0dd7338abf98c3012eb8607b82191f01c5f80e53fba2ae129c070795f6998d70fa1bd770d6752ec373afddbebdd30b58d9b338c0c56198359618f0137f5bd4cc04994f7bae248c199ff2bf5906b315404bfa0fa9e708e8174f259e4f36681dce1749fb8c2b23a0e1b6a06a0f290f4fa1815b9fd106dfdd71b59005427a517527aee0c38add65ed5db6ea06ad04f4b519a7697e847c73e63e85b9f7250f01c64ccd64ef66464fa12f8e23afb0ea83cd03cd619f78913e3557368bb8c3e6b0d62a0083500139e8abfe40e51079a6b1146f4f1965569c4bdfbf3cf3fe97425f1708082e97c67ed6e5dcb69b9e72b38f159a5a3d3246a066206bda053667a41829562301e9d8a1f75e1cea02790e87bb1458143d09e5d94d0cb5b9f71d9bcbb86ea954c73f4da898f2bdc5aa51bc57fc5440e4301c47664521cece663a72ca953ae166cb7b72c45fb61a2f09b5a809f3667776fbe0bdff4f0424ff60ac977430ce001bb0dd375f3f20141d4c0c066e0dae1ca53ccd6111fcd46e506c5fb64841b0af90fcb65869a832e82507340aa6fa714bab314aae9616dd22cc44b1b254b0df624e0be21a7487d8ac08870a5ff1406474ba072ccc3ab12b7a000e0ed2c32bdfc518d3e2625d3be5004505846e3646e8812519d7da42320b23361a954df0695fdf22e5a45d0ffd70fc1b7bb6cac79c1dbb1078a213e8ee5d4cd19f0825b858b61476e76dff6c61090a50cb0190681ecbb99eab97f689e2c26b706e3cacff467bd22143339d128dc5b2b594beaefc1090dbe0ab9ebd3b93ceddaab145c6de9e26ba14c07996a2b0211fe43c49fe814fde8d3dd54be289826f30dfe6215a6f1d625ada583c25a496498a830f7f2b372c53d00175d51dc7e08efbdc0b8cbc7574a13b4e0b3ac2f59ffa7b3ebe7d79a6d7811d0b5c6768886d44b2f23c50e07791d40531293654b5f1d751bb40bc3b9fca9068dc5a1c636e92d9485ea50ba7e3b20fbe4b463763ab99cd4b6acbfd772cf51f74113a80779660786e5eedc4c4d766ffefe6fb865ab26ba229b6388099bc336ae54e091d5ffc6c6edc2e8ce682b2c8396f92fd414828734bf4108388cac575d72d156b9c2e7561223f02468ad5dabd906b356bee292befbd9023ecd9d1386e71b55638561708e0d60911dd75197d31322f1a8d465101c320cb949ab7567ac8adf99f1fdb532b3b11c755bc2f503c0443fada8563a16616f67d8185906feae287ea2e2db4464392e27289c619c9ea6b99fe46c0667ddba4b51bf29bdff2d3c663f6f31c4e2c3c2be336b3b2b6e6d2568e44f0b7c3813434fa46d9e4516cb7f031670388ea0914664414d53e2e960e007c1e8af150ea7c319eef6bfdd7d0b9f479058b100fece907e77cea4c6e5cc21fb9b48fa9f15f97035053d94c221c8cf467483902af4b5963db64ae3b161f4637944fd3c2b9b8777f1316905599273242c7e26892603c473042e7512772ac171968265b439ec396ca9d27031fc7349e3585fbf2e0c7d81939aedb953cd2ccca21f91365618ea21314c1d23610cced966ee7a886caadd694fd289411bd8d650e5a753b7154a195ea019251e153c9e528f86ff28165fc4ae450f7b60737a6cebf071b94ef3c431f32ea2c2a528ebeb40e335b8d9436ab509d2c4150268a879ad4028c263a0954e159a2c63e0e01f00dfd18c8cc47c13e5f7b04cef22af8fe4d4e4b058219f9e91624d93f19f5aed164fb6185d60e278e0065b00b19d5745c519ad1d9a79aea8e8a47a10a043ec10ac1b0064cf314eb0e515319c8f6f3ca9ad16809a0ce731a6da63aa3bfd5dff1178d7118c291cb3eb4220e13d64f60fc1a61915d8015b6879178c40b6df08ed546f25d7b4ece60236d7e6b052cf675deb7e7d8ff7b6db54ae5ec4a78cef5b3d2f16ded414e52a4daffa20179dc104f5e78aaedcfe30cbb95258bcd24c3415378cbe0c0dc3996b969de24c8d7dd90db2f713b20263453932e5adac4aae4e50a242b488a7ad5857461853423adf7e1605b9f2d83b84ac39a014927fb0d667f6fc30697a7a4da1181fbea814ee16a5001e3b33a0140e64082bfe34c33512f1a02f42076e60a07a70270381488d965af8fcf446e9f5c2842a7dc5eb04d505e338b3e1e0cc58070087d98d517d340768647944c00c6ed3a64fb588bcc7eaa5a37b299a756787a2ec81371a25938d4a9e7783906fd027eb8bbd531c5529b9f1b4c8c23b087e3c02984001941bf92439fb7ce2d2a285e32a18376ebc68e0bb2b320ecfcc0ab54f146f2a2bf2357a298d4c101950780439aa024e29c621520cd736d260fcdb285c3bbdd4421b9f8d59fb34c905baf134655b38aa397cfabbb2e6d07f5d8e20dfc152eebd1e98ef7bf36815f50d8d9218096ccfcbea73859b7ea105209dc17e00134a0376741cc43573a7392167f6dc99230ff0bca69fd4d28c05281276406f2fff0818caffc4ca5f6c8fbd8d6458b0bf5afd0e94cf9e7ea872a8295dfa8890f34fabbbd04a637c539a237df92e9bfcaddd90c27096549afda7ef6a12670d21c5e192dfe567ff8e95b12747cd243bafd9d898a0924f89155f9fc726462e58deedf11c839e9fe4fcb1526ca2affc4989dece336a55966efdaa4b61125ae479da4ab2d7f8fe820d07bd0d79a7b9cd2d4fe016b9e55d8ed16834366d598a041b850f7fedc202c5ae6c84724c333653c7701d2c29ac84281f993fa091171dc8af8c3401e9088b004301bfb6c0ccc967af37e3fe3edbe257b376979b1a777191cf52a5ac2dca292b1d2d8b11463a169844d8de9ab9a107ec856d1b6f6f2de2ad93dec6500b8d9e4655826b1b72da991368278fb7f6141645556e68c679b52341e59629b69c794e1d2a554bde0415808680546401df05f0ef4fe3884a400b6f666f5952c027b8c574ee10b34db9e35efe356c01b2505aa0f85dbf82931d4243266b94b9d807d47258cbf1c1dc3d1807841cdc170c36d42607c5c29bc7f15e93f425f8b3139cebbd3ca3e8900b40975d378d103efac3e92ef341861afb411d04c0ccb2d721067480c9d3bffcbcb3a28f22b2adddc405736458089fc52e36606d43410e34b7a480603a353bc0def7ec17ee4854fb718101bd11ecc411eaf2c7203e4f35bd31b0354084d2cff2bc0bd7a21056bf0e735dc2bd493ba72eaf746dd9d3be577ad31fe7a1a2d2d7ef6056715ec7cc9af31aec74468b53a3fcf5462bac70dddd86ca044e9f8a4998204d8808e8b54d529e9ed0a3b5f895589761d11cafb3c94c8afcde924ad8a9d0633a0805def985a9d76b11ecc81b14f80dda222eaa2965208ea4aba0f7b23f8949617537610e7d7c6c3fcef837cf50ceaba70b1659d7db4f2efa6097ce178e7694ddfbe3089faf2859afc201af0b654b2d455f34043d75e3367ae626f8d187c3647c5b17bda4f40894660b30676233a3026c5cd98db16c9e80ddd047ca22ee78cb1e40dc326fead77b346746e275667d5c5f56a8d366c0a41f0d66c4945c10fbb4db75c4c9aa8df3d6b84ee9dc3a591f77d03c0cf4a4d6b88b075a9b918961953dcd158b642af525e2038359bf423f54ca3c80c95e7ecdd7bfcb3e667dd6b99bf9e14981dfa1a43b48be634a3f4769f1a511f6b31eabc0ae90eabc1668ddff019b1091d2fb4b97f69fe48a5fed21c1e94bf3ab7012d09a4f985347acd59ede53e37f9da2b2c3930f164e3446d6637cc829fb88944710eb48054550899190a589e7fec653ddd6e3e1c1402ef071d0aa0f68e63b61c4ffef15531ea5875a03e0ec4bc30ec0f7f07ee699c0afb81961c76a9228099aa0bba0807b9a13d3deeefea5e272b12f5bdff1fb37037b3bdc379bb30492b0f71db8e5a0ccd6da5a33118db6044a18dc7f4c7c4bc695f77390dc7e1b56f23efa399704cbd8397850e70c3b8e2987a673d870b99afb10914d2325730a921b81f7687ac03bc6c959af8bdcd1d20f3bb29b32572136405bf0417824384b24a5d890bb7d239a86639a1ace5af73a6c40c0cd23027054f3737faf6461bb2ead72bf4a99b41718285a40bf2403cd3b676d1b1855e31cd04f5e6f194b1592ea074e63f41537cdbd42b87a91f681941edc2412c62e8d2e766b53f0f2110eed81968808f50565f840c3432dae9259eebcdf99b95698eea6bf4803c094df5deef36b98250b88cfc13478c7c5a8e56eeade458700b4c8dc888a6dd50027be2a72801ab1021fddecf40b4d9606d628f10b464ba29c7df795de32a91ab618d44a1776c13052dfeb233fd48641e8a32ee62dfcaf14954a9ad49086f9b0700098d98df4985f1a179fb74f0d713615bef60846a1ada8b224daa1f6bb4f47ac4e87a9cb98bd749a6bfdad898a97413142c1ca1026acedf4aef7121a2a0079478f35e88a61bfeea31a14e1b9fe58e763df8086837ab7d9b6b0d0ca0153432138155015d6f79d0a9fb68cc8124a992674f0781b1276535a1203c828141551706fbf7efa1a2081662c71b536b9dfdc4ebab2671e2311f8fcc1208515e8ce053ae10173c03c79932528e614547b6549e05c690bf529f29337a228c97eb28641fa346b359452c56c5d795c7dc29514c5b4c4c3a5d4a0edb7d19295ba10c1b4ca131e311a4a294fa1b7f57cdcf316351aa9bf72fbca3cc4266b07f7fc3e33f478990c98579aa4bc71801b40e45256489a5027cb2e6ff267444b3967b1d4cdd44efe6b52ae3735fe78a1940e2f5f9315c19604ac6ae4f4cc418285ff7f9c3ffc27150d91db2ae017bba47fe533fd60e3da7b6d56985099b612176ca3d44731c473fe274cd8da22c55301f41eb2e415505f2c70324a5334b9982b7cb93bc8b51ac8331a54f1546fc30c08e8c4d1aef0190b00622fab62d6f86eaa49e75be8ec270a9f3e6b6caee8033d4d114c4015bfbb0036f4075a6f4c1ed2200a5ece0b89228654af690d3c7537d3b7bc688675805d2d236cfc8169e6072b84b3b4830fb8144f8aaf37e3e5eed7e4696b68277bbfa96420747eda7ef1d0527cd98084e98745d5c4af4469c67fcad383a2786610feb143fd569b4d92f7e07a034b2c519e57bde3ff7b7c5958846435faa0945077b48ea5b19ec40872fcaae02ffeb56a47bbe29120925f2e9de19d99fb09ebf778d8d6c3ac46b2f18f1a58209353c1df5765a83bbb9e129723aadfa95ac0b77aa7684d70516ceff036496071dbfaf25b92ed1f115d39204249dd126162f780d0bdf1738d6d3abe55ff82b9c670eafa5743f7e36bc2e7b96d07a9023cf678b1beadc34f867cbacebf54de74fdfbadf0ac1dadabf2e422a34df3c7c7a61e731dc7c312be3e382088316274e5f66080242e1cb1d7763a5c4daeba96ae695a9d25187c9a20314f2da659a6b3b5b016ad94fa38647c4359017f524a820c43f5cd86d22004b47ced445de15410fbc3f2aecf3f508b581afcaf6f1aba0c5becdca5d1601d883870ac2af266a2a975ca305f12f4c4359899884fbdfe4af5cfc75e98abca86e28e1cfb36f8abe6d969de54140ed74aca19647d52751abea0f55a055b83a52dfb0cfd96dfb2e3698d87050e888921d29ae9ff3d164bc9b9f48049436b39f2ddebe5a1b0de6b4f2448d6278e08ad31757b6af3c3163f39f879e4307de30244f84df7f23574f5d685ae992e27f66f40b791f0be97b0bb08517356609b074b4aadf6e8aa93f19c809960a020581db7fc8bd512fa834959830982667ac11aa9ab6b2fab6a1e81ba04fabe1506fc5cde46c5f94f1686340fff3b554c6f88108bdb7ef8f9f6961cf4c414699a5327814df0f2433e98ef5ce0d68eb4d937e97119630a79eca4727649ed07ec46903cace992438ec33377a6a027255dd551298ac0433ab33ce96b64916c120881a2db77423e47a5eae321b46e84dc2de483d14e52749163838b7b921bbb4a5c764ca759fc07fc69bf27bd8ea954082b175afc60bea64fff5b7b04515dec55402522044f8aa787bc4851a5f7b3f66187f8879093076b3f75a50ff90a6ef0606a1847d5f9a3ac9382cd54bdbfaabf8b8e6ad9795c1144f80213785f1d2c2dc585c5286b0dc71c2984f0f9028b46513fe6af98e60214a71dcc10036cf44f1a5635d89844107658b086e646eac007a1da751736905042302c0ad14bb3e5cd667306c9286b334891950f35f085cd2b0887bf16708bc84feb87dcaf10601c4f674c8bb87977978fc01dc4f4f942478dc40c2d4aaa75c31dddcc142aca3fd6ed9ece577dfcad867e0fd54cdf43e00cca1eda311db4335dba98044aa34e9dc382f7a4a4de024f1223888f20bdc0d1c5897c510ec943aa2f7f36ae28b00f3c36af57bb85d6acd19c631293041c44d31951923e0f17816e03d6850618c10b86e496b8c100f08e6ac9100c77c6d10078567e1650da33af0ce946d77d3ab5bd16775f1154eb0613db37ba5af8320981814262a4e6e290f471b7b5b5e3362b7e3cfd3b0420113d671feafaa9f21d23bc5d04fe4cb3ad957ba86862afe6bfb953dc943c49fa42b76ff335455ae0e3d73e25ea4049c96a6e9c42d459c41fae0b5d24dd1e43ed3f8c0c401f875db1e26987d2380f11f432f48c1855095e505baac7b8fceb39f49eeeb2482e41908a696ea4185d16086367efd7599686e5cd7e1d11b2c42410efa8c89511d71fa1a9554e9989428a0bb868e5b82568845d8a7c92108c63adbc87606c3167a2e89144a1f286a0d75ddacff3b75a25de9873e464d6324361dad86ec812be0ea55e86b51d97578c738530cad5f5d751e6b47a74a86f3a732da6c64c43320652c30cfbd1227cf8b3665789085bb985a1ac46e70dda9a0eb3f3d2a059fdc6b7ac5ad163dee2335d2a6e4b4a534522ac06164396b3c57a4b3f06301d7b4b0453ddb3110395f5d1c7811698da06ab464100c18b982526e5a227cf8ed35baa3186dcc40425681fb30daf2a22e7f98350f495dde89080963e62844f6992acfb34e5647a0105f2d5968fba890fe06588d7bf6a88f9f1ab1c79567c70200eda1eb303de64737edb4fdc2ef44229cc1c596f9953e49a36e6d9be88b108bbf88558dcb8eccc84be5ba59365b4ac536480a3a1e3a7466cf9762a3e8c49c11ea170a99f6138d719784bc3cee387a3f5bde4abb6a4555c047542377854399a722d2e1eaf7f60ff781c0ca72c017fcf9edf1bc4d06093ca1349c74627c3bfd98828d7a97098aa694934712c1369f6f7426248964cf481f0752bc390bf16cb5c594f63339f348c2ad91cf0661fb37ae5dd021c65965bdd5db1f78db8132cbc04af9b3b693efd17e45fafe7cf0277cf49dda4a327f2fca5de023955c2aaa0780ce5dcf19aaab35449cf6661fc2935c42a28cb3025514444e582d409630a5c7f1ea38f75b3434eb83a74102f31750a43737a9a1ff92aeb75fd70ad7c0f700cb65e8046be77f3c10fdcaa668ac752ec982ac06106c88194917b2e83a1b016bbe5a536f35faef862785a14003188183f5374bf3e1fd4424fe9171cad0e3271dce1b054fd82c983700476dfa089b169cc25f8dd5fcb03246493b5fba2a978cffc30459149d2c40f6df60a97d09e35a5204349f5d84f7b2c3e17060c7476bcb9c21b211b5ca4917bd2c954134b0d9a7febd4f903ee8bda92dae660e36b4c51132a7355a11bc543bf78196023ea6282552f4975063ede733ed3b8e897dde34cef308db2a36fcedb4e8897a38de9e1396e1039e60acde4ca991c60cbec71ac3a3e0dfdeba5cac7efa3ed9f853d95b1c311fe743cd9d698898e73bffd750a702c5146f5aa872d7a4d9ba701cf70f3913f206ab0e8b7e870ab9fc7ad51693322894316e80ef0b318c2e6735cc9fa31010428ac979b5590a7c4e56195dd5db003203ae007235a95876756172069c667ca1c601e14ef78e84da9f4bdcefd01181aea8c0efb1dc7dc7f2e9f4629e5f1c310cae1d14ab2e10fcb60a6a773eb83fbabd150bc9b17d43b6d0df48e5fd9a7a1e0633b78552eb36b90e6e13ac8d120bbd8079c70fe993bbc5046f1ad3027f6e64555dbeeb180487f744d695b69388bca914805f80e1d28088220e180b6243480eaf6ff4308be571fd166b89ef487fec6b6683efb36f3a6f53b90f9e019dca56d37dcaee29d8a6ca79e4045452d67b411e541a0a4c5f1d4b919dc987ae6bf8e63a2fd8df5fb736b47673683d465fdc00c322a3774aa0b2672ccfbdc7f1ddbc36db599096f9fddda8410b5d71791c7204b4f8d1fd8b57b03b71980fa50462826ef2cedcc8045a4c93cbeb641eb1a40876d8ed328811b8bb746db9ae9681f412321cba0944bd651786060bb79572641bffb4bf6bbd65494e1c82734506a8f89888aef5434270a9312f2217fca1634d9060709b430d227031d2a879988757d948a0327d06fcbdb06331e857c2f19c0597207839ef81f903ea5520b6c77a2f3aa6272c6f168b3e820f79152ea5a5895b51d6a48d3111d70a46ecd950d318d0c8e6ef6f4d693457db6d771574e112573f81e4a2cfe5a6cacc6d92b7265675b777ac1d5734f29841a916e684d14ef07cc8ed070e71070cdb4a2404a76974c64b0b05392ac20fc9260baf0032b354c5d9c21992e13d699d11337559de45f7a273502f359f8be7e61d3772796f8f20def3a26dd89f0d2433fe0f1861310bc9cb01119784c07f2928da7ca1dcf7b9aac76837aa50c848d806725a99b01c54e7a270f5e0a6851f576daaf0bd0ca67bf85e0832862d87f3d1a228383f0b6022452d9f4610a87682c92bf30c8a93270cfe6b54f08f7c65ba1a951016f37340a484540f7fa17c8b531968a8b74da7364763ea521d3bd6b081c1dafd524a8cbced7afc6f06f9b562bbf1cf1760175f2297545edfc2aadb06b16440a83b1e306eb1c1bf251f54503927cbce3d0d1ff236d928272004b4cc0b9df75c7c40b908e451b9022b8b9cd7d490248bfd6c2ae1eb03f1837df8c024d516d7b2929e7ff2e55cc2e80f455ba2baf7cdd79ed0f1c41b70a8a06761c85905a77a31cb302be823eab27945ec975e210ea4e149d287c21e1557c3010b2fbcb604334b5f4c59e38a2f460e92b13a8d17a2a46e2874365bc9c36a67e8674182dfa56065d6be227c2fdbbe05b693fb8b788834d074f329360cb6a61bcf839806305a06841259a2563b56d3c5eb45c1c3ae2e3bec89beb497cb335add2bdc68c3cb451ed6925e1708c60049ff03a75dd152cc7c36dfba581eaf9dea84b7a63d6e55f529c7bc142b119126a2d7da78e835b5b17c33cb7747274b995ef6536678100d9e4367a57f1d151b5f5a67e2df9f42d539df3c63e0284a74e1588b73d13afb2a9abd5b07d48d55626277b335bbe9ce89648c2c9306cf79fad391f3a257647e9eda88f5f38a9eaa504754f487973e0b33a01afc9dec2096eecf2fd53f7303a8e4fce83368caa6fae7bcbb0555fdf010b0be585028f0d34d36e20b2cd71ddd4a184b202c5eb8662b278371daaf76ca4d3698bc8473eda265e185bd3e2c00198c5f4ce1a7fa7490ec22c4ab10c5a66cbed97feeb42f0db6cdeae07dd2146c392caa3cb66e930cb76a27ec76d43810783c3639bc6c083f69b38058b26bca527088b2e8021334c1c5fe322505a17ba65da99c8f62127b76934c4fb73fbaa400ec389cdedcd4bb94e84208e7f39f5357e921733d4a433c53a2f969a38d11608997f032453156b84015d95a05a0f84fb68b91d102042e4aabd0e085c07d98ebdcd29cf0e95f87b6b73aab61b601bbdc6947b39d133085391aaeb9d2f64d0831f7218aefc581d781873bc7a819e7b3cde914bbd2e604dff82a2b20a3bde72370254d7d4ac55c93736c20b149bd7924c4b5412227af0d14fd472968d522b9bf0bb8797c99b647f2142313a18075c057bfdd2de24b0edac3e915a00d083d0f3ef9bf9ff3040fe98bfb1e96eabe9659630c989cd4109768df4f4d7303fd305e7a7aecd97cfbb915ff48172128478d1818a3cca625721a4a9d32da4936ca7efee81aa9782a228e9c5eb81331e78a8db1b9e5edf2f7ad62a0eb541652bddab6f136d9772995c63743dc32da286ec63457e3c277055ae889c3fd2e22ba48c40fe9f2a7a5da10e9714755d7e7f920580775a3761c3d2901db9d8f0bd30879d8665c35fd0c155cadf413c417f11ec838aaf887c5625c5dac823ecbf90cf6579b2556ef5490f2655333b09564f8aab68badad1c301f909632f8d2ee2cc3508804c25c5620c1c148146149f62ccdc2ab00bc9e1d5ef86bd3237b68b2ad22a57116449b66f7ae46e31fc79937666af6a012809fa4472355cbf961626f28babbc8632a9edd0425dd596f5419b3a58de66973baea6b51061030b4ac36a05a510b15d5e7df9215ec816d67122daf810557f6134bc57bf68a3e700b4ad7448bc7240dd1be194d7fddadce0ed66363b75b2f90124f3d6bf2e8ee50f138edba3058ff61e3a3f6ecb871efb1097285a28b8c66981e624d1a69a86791cbd796b715c018a01d0d4dcc3086b523e3df40d1e9617f06b38823445914743fefe1c599fd39eb77f8dea462be4b8663394e6ced366c387a3a1de3a87999caab4d221ed604f362c41ca50a6ad05e95dede8fb7cfab3b248cd5f978bf68642dd9dcd7bf3629f13507a3a65c7becfb34dc241287af7dbe6f4e7ea52254c39b1619613f70e8ad66774948ae659bf643fcbd90898194b9d96eba333ca9698a1a66afddc34542042678995a7b9e51e0f98c52a8123f29abad2b49868e57f1a3461fb7b1a8d2d781606073c39ba34a3ac224e83553bf14528fd6baaa9af42b6c22af6e63a5eeb879b6f55f20bcbcb91c16ef7c439068ed9e58bc1e82ee5f67f9cdd4620c5d9b24bcfac24c1efe711202734a745ff4adace8d5dabb8c1df69015ee3956ea33223c1be7382eaaaac857f5bb2608800b04b8625a2b61062a3f349903f077cef894eeec31ddcb3341847ee75323dd9c35b41a68121fcc714a1b07b85278f855af19cc515ddb7de5d6f5825dd850764980c927520ab67ca3a229402c6e8ab4d89d28808aa2e3fe967b70518c94d963fd269f72e58144f0a7ef580703f01d5f0e2a265edd2553505f6f137737adac4e11ceec5cb5a1804a3f392cb8e5a09fdee5a97c348e3ac42bc80d94db698b92a06cfa1a74d54082a3b46a5b206756fc290cc6557f6f35c7d033c6b261fa1968a9856d2c87448e76314a4716e4b69dec5deff8c9612e4d4ae99b62b7149949f14b8da4942a1672db420ef16339178a7116fa4000f13d284e60a81edb72d653fb65af3e0f6f01636a4f6affa2944596be0cb1da99f323ea39b442596877c57a1e0660efe14635b8eaf60afbbed98dd8d9cdb318de2c085da9fcc15bfd13596abd3a9ec2fc4e0a486b738930b75261a084ebc0c0b303377d41ac8bff11e2bcf5474ca8f8f8a65b6042839590f3c4206da61ca0411a62c982f79b0eced59bd255d69ff3e9cb96aebc0bf6a9f49f74b40a2c00967921e97f147dd04bb1a47d781a6282764dbff1aad95d597ef84d667a74caad54f8a0c4e5cf48c7344fc3d8438155e7c59602820d739892eb2afd7f294b68af314375d56b68ddca3cc5b4f440d3a72fb133806e1312e29ae70afad54f85b8854655b92940dc521f5a4f85f0edd06d85a4e43aa3c9890a2dd9fbab71daa47cee6de6aaa96eb071e127c254f6cafbe98cef009b77ff431cd3852bb6fcaa20445647a0b4c22962e05990cbad31b5f45f8f15494668119623ee3459ff8e9066601747b08bdaa54f67ef06ef42758e6c2e0c762bb3948f3215f51c9c6cd0c47758f57c2f89148cd75991660f4475fef7ac83ba51a6ad59918bd3928c968c8bd7e07e10639b94fd6f5a2deb3a961360cd8309ba21123b753049550c327f5ab845ec8b4ef865b1776d995d27ec9cc6b45e3fe34cbebeddced08ae86a41b929896f7c495645c9afbfc3dd226abc82b361a40146b4870a5509a9e224e97f6be5e65bd4994fca34d5c0cd2a3d926c4648088a858d439b0d351e7b424961f72c38d9ac23ae6a0a98e12a68b8c1424b4bd9c9ddf8054e63316e96988aa93039d90fc5751ecfa2358b34f897660f7674ab8067b5464271f8118b58d7deda3c054dd28486ff200b95cbd05f5d1ab6c10287024554682009328b16dbfa7f89a6f5b6864f8d469a54576053a672b7f3491fe9fad26f658d489af7fb9c0cf8fb10af89b10f92b4a493a4ff4d4f658f2c188bc9b680c77cff10440952c2e5a10e92f5bf353e949e28ed934571754802fefdef41ffd147f02a11e25ce090a59b3ac665769779097e18feba82bca93a2df5f66eb5f364a5061d8b071048144a6ca65294a600aa6b8e54a792bb37cff6fe3a4ea279316fa20542e20cf1713ac0b491afd26ba71e7583ebb0a46de6735a6ad997c01aee4c56ccc5c31fd2cc3a9b72ef4dba6e4a172dbb9b885b10ea394d847829e6c310565c00cdc612eda3c2ba015eeae723130c79376555fc1120a352bdc99e9fffcb6f38032a8648df14f18aa696a163ea51f63ef47e3064bd0bb74817ffc2c4f9e8bac5d82510ccbece606f02794996532c9e1658453821bc2c0e3b42de0d2ba6a24fb999cc3cc247215da37b9f524d44cf5e8e99938338d097ff2a0c470e50923ce0a9fc51a2dd5ae682fc099e87c1a64e1ca6bfd9a36c692f484fe6678ea0e4280e3aed18e2026aad6bef08b3177cecac8b4a763abef4d32fd4f7774af41506ee35ed5a797f8a3054df542adab993832ecb832d530fb34d5f77d7b65b3beab5014725c78c99368f691e234979ce915f4f033a6eb5814e48366c59ac64f7992b3983e79e81ae8587349b8c6db61ce1b863cd5bdfff54bfe4d543a91e03fb34eccc68d135be6c1fc1d2de9836681d7f1bf2435b12ac44aaa1675fda2c6beb4f70b39995a2996502a211e6aa55aca55fe813522cbd8b1ca7e5703408299e57264298e28aafabfc29aeba6c2766dd8c31cf29e4f17632183530bb4458772ca19b5b4978ba1d1d173bd3da2b5dc836213689716765e8616ad299edb58dd28f0b1ee3517cdd3f5b65ac5b30e2a242597c89a076ca0f3e8c0a8e8e67124b073926f2ba9570a3b22637afc6034ed14dca5bc5cf2e4fb8c5b58454da25d3007980d5038f0131ac97b9db0bf81861ceb3a5c06a75d89b7ec42e3d27556ab68bddb29fb463f6828fc91a9ba120a3c0822b1345ad6b0e67e1edf7b140199010ea41060251b72f0114fe82756d96829fff25b0994cc83601c7cfca216e9793ab64769206199baf6026db325095d79b1ea8ba00988d87e2e97dbba9666e857e193d6a84a9bd61706baf92c7af5aaf5c178b1a8fc635d6b5c01b5014562d66405e83ea860383bcd0e73064ef86ddf18db2bfc5d5e4ed862070e02c4eb46151ba03bcbb2bd82949bb3f5db2eca2c1c7f393197925e36f9ab78510d671f8fc86534f048570a5c16ca50eb06aa4a5dbc4d9965ed1dee9707bdcf73947d5f33de65a1b92bbf16e4ea8d92ad324c3e90302db13ac20532fcf2cca7253f3f352f01cdfa6bbc3d9894869c8d35c4292f78963d1da7017e0d11953d47336fffd2312b3ffbb20eaef647185034dda138a388265a00e6f4f7f2c2b6f368b858b0fdcca115f2321d0ebd3fed0c30eaff9fcf9efcfd0ef08def4a05b449532a509f17583621ed8f4422bcd3afbd3391b53d3ad30c49357efa38fa8c703cce2d78c20ec3528b99790be12dc8ef72084132ed072d8e0ecb781471586b2d74a96167d368b3f6b14adda5232d29f2d118f63aec33692b2ce525d7f66ba7cdfed9ec750117469744536751ffec6964674c1152c4216473c579e3c45277ff13ea7d3949fb454eec8d71b3958787b36b02a78dadf691a91550f47c2ad7199861e5bea2ca38e0c108a41980cea598dfe0f1e5442c29034b2abd2845df70022950ca127ba73cca374d128586a8e45f5e972be036a8782558a20c8b8747d5fb77fdf6eb601ca4824c0847a1d21f3d9e470fccd61c51e1b4d8623b1912aa38024cb762c6a7e6fc48152f256e8a2e41278ff086f1c4adc926dc394398bcf3b1540f53fd81d94aa12cbcdc2ba5a627d9bf37</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码继续阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题目组</tag>
        <tag>毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title>关于块状分块的研究报告</title>
    <url>/block-decomposition/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2b6d0d8dc06f030d0e768c44a670458ba911a7c1cf1fc512500c17089f3ab80b">db88ea21dde1523cc6d4f97d6db5a895331a20ae7c4b3e1920a46894d67c16158b8748430d3e479e2f382bde45c84473a4260a618622b3ba92370399f561cf3fbc452ed39122bd7c3b6c208a6af237caf522c9e4ebc12f3d079cdad60cc0bb172da3827cab3a174918a0aaf3fa7b8f28f3f22714e65b0de09795f1747f6c421e1e5efb57ed2618bce8145a16277110a4f83b75242d75bf01c7afcf6f2992f0ded31e1782efd7f917e1539531734198a3208bf349aaa7805d7f7102c66ef7b8f37a56a48e559835a4e45e39d05a3fe27e4479296a346f8ed861e20f8f984a2f00a067d37e5df033d0e7371b03c7d5f9d5740ccdd3bc5937aa9fd55bc31e9fd37bde00d3a075fca0cd268a383ea7daf7761d1f88fc2206b7bf1ab20beb062aea20509cb83868af50cd2e6ade15a91cf44e5fade0b2b132826397b4ae947ba4a147bfcbbf7725d8caf0e43b0991701aa38df70b84c2fbc0569b48797324e614a72d61cb9ab8be82e2503e9400e854c4fa4e7eb0bc76c0ccd52d97a251ee6da05529460f291c5bb0cf4ae62090667b8b0daa104d67475c576823f4ca7beaf0cab3ce1978e2de67c619a13b509368424064feaa5435194fbb7bee75cc3d6bc2e4d314b6a021a30d5dc43a54d5443ba73a06a4a88df90f8044fc42767a2ca015ca5577e3a720ac97394fb26b49830eb68c09de21adce45cdc69465de977c569c9307a29a2d51e4a029e71d492feafb26840495e6debc7f3d4dd2cd3ed3ec10ffb658e561976939833295493105598584713f3206840f6a40e47f94bc9dea9323dd54e60f30e603a550e54f0bf3515035061ece1d9dde05ac0ebb7caf69b3ee9c48606d444def797353545fb307c880fea1e5080d7af45e16369bc575a139f1362ce89aafefa0c5a2ae701adb8fb3d4394aebd98ca8721eca63a75daaab383851bdb5e592b452a77d0e191eae3dfc8a860fac7593587ff7923280b6a3350a0080e1d3e5b6a7b6c6c3ae1092db6a9653bac9ae67c44df44d8c4669f0289234a86ad72b30974b02d375b877a7592b9c8b5517596b2f7be2262a7826987bc9f6dbd5a9c06db4cfb8bbedb42f30972846cab74fb8e7b3303d3824365541323d50512117cd6dea7a0aa53a2c9a070507b69a019745d495cc8c124d49516fca44693a720869da9bf573a904f2c232fe883193cbd8a4c8bbc46cc661b1b6690922543f9c1cfe654ac0a0232cd47ee8cda7d8e4559258093df0d3a348630d7c2b945d2ff2db786d1232f227ce4a35d519b69ff4aae14c066fd942b7cf83df76a4b910d985801c62f35c4113eeff1f27c6a35c8c84d192b717decced96ee283303705cc1663b604c201de4eb09f8b22e12c22f74fcf5c1659199a8bdca027ac98672fb41d8774c3f0e5cde15bed1bc83d9aa7adb4c3faf184731185e3228be8fb896aaf2cc9d60b01174179c40649b5d2428e051b472b30e097a9ce4a3381d0ccf6ef14581c41e4fd121aae249af859893049732aade2371351dd172d67c047ffac199e7b7f1036c2d0fef5abcdedb364fd6d8d46cddf94abeae160e79cbd720f073fa1cb6515af1565cb918b08bcc3bf457af28cb4f3e442c7b054e5894ea388d90ebae45c90f0fe5f521f64c7e4416919f7e7fcf7ccaee4f8a82eefcb844ce2fc66427963d73f002869fe4af3d5d548cc86c1bfc798aa073ca0c4b632a2aecfb274a7b8705f49d36390cb58d3aec1f1efdba949b66222b931dcf4575fa62fbd49a44784a01ce5a452278bd8adcb0e7968bcf017a42a23faf0452a421f382a2c158d2cc82286c462b3b0366660b9708e7ee67837318671ab2d8b9daae3d40fbeb2510f2ee4ecc13ef51244d3b27989f0579046c30d459f2600be9f43f3ed8f258a7a93e2b2da8f48fc2e3d3dde25d1e9d204619cffed2a8b001e69318e21233973491bf8564e48e7da16832813a4a67df9b9b1b9b65df89292d2844ab827869de42b61f8aef458fff5cc20a0ba8e7553257105783f2e945ba433383507c7b8a39609a8c5b19b81d1641e83d41a5cff1bbdeaf6e42ff9821f23b2b1d5de7e2a8385bd9a39d92cb85cb6c4a0c0d4a0d9ace0447794d55ea72b710676fa597ad4a5711a00c8d4bc760a9cefe34abaae643b8f7c50f78d5bbccdd35298db5fdcea399fe68248b6d437dc8dac99e7121a4a0dd7fddb3311adac857b646a87520d6fe7f64c10c4c6ebf9ecd265770de0853f0af3ff89ea298603211d65e49e8e8218e8844d28ddc1b41bc1186d19c6031574772c47e18f6db4bebefe04cc960ad72e54e2cfd6404d5e4f267524572e6f15a24d8983f067ee8def3a2f46c328f5dc603f4f6681a7f83e4c1bbedcfa33c736e36e848129d21ab19b6cc143a554cf60ab62164a1ac95d2dcc6dd59963b3c16e0e62caf93a63d225624dd21a05f7c549a560198eeb92216bdc49fd04495424c0c62f65958cb09f43d144cfb6d661b10773f885891eabdaf4ec492c322f5b36a0c95325606f7c8e95d0940557ebb5928d51b257b313d2e5461f759b4486c073ce73acc20c13e1cbb5994fc3a1927636819ae4f8c794bc20bbecf006399e69fb0865dfa58c0e14ebc0ce36a24b65969079452890d48e512f98ff778430e08b86dc3cb04c0580aa4b675e5c63fc2710aac4cbb0d8e974b6a08225014030187e8e8b50b1ae32221bff7ce4d53e2de1a073c5be091c941fb0fe224b1a3fa63773c687e785bdea297777bf3a5c6259a8f2be92ede5ab6287a005594230ddb9e887a071659fa0ad6c0a4153c0a68752da129eeafd8e8ebfec11d0c727edc31d824e54c6c2727928d847ab53d53d0b3c988691999aa9b94e33e99cbbd1c1ea750c82ca01933558d1f8ba035589ae8228282323e9ef6c6fd07a4b9604b35d87d1c1befc9afd35466c41bf99fc418c1c70968ea64a3d48e34ccc3023be01628d7ab4838f25ff32d6594b01c622f1e9113a4923815691d956db1e39ab37e8a82e5b55a224a021498a50027caf184970afeb0f3a91d585868e0d979dc6866c61e3c2e50ed5613369e798554ff8a75c8d8e5b065bc929263f8575eb2d9300577bb73e04221a01aa44d4a475ed390bb5c4e6fab61d6853ad9e5ab203efe9dd1d9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码继续阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>研究报告</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>块状分块</tag>
      </tags>
  </entry>
  <entry>
    <title>「多项式学习笔记Part II」多项式的进阶操作</title>
    <url>/polynomial-learning-notes-pt2/</url>
    <content><![CDATA[<p>以下，如果不特别声明，则所有运算在模$998244353$意义下进行。</p>
<a id="more"></a>
<h3 id="接下来的前置知识"><a href="#接下来的前置知识" class="headerlink" title="接下来的前置知识"></a>接下来的前置知识</h3><h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><p>说实话，其实我也不是很能理解这个东西（</p>
<p>我就凭感觉xjb扯了（</p>
<p>现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。</p>
<p>我们令</p>
<script type="math/tex; mode=display">g(x)=\sum\limits_{i=0}^{n}g[i](x-x_{0})^{i}</script><p>我们想要让$x\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。</p>
<p>我们先考虑$0$阶，也就是原函数。因为$x\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有</p>
<script type="math/tex; mode=display">g[0]=f(x_{0})</script><p>然后是$1$阶</p>
<script type="math/tex; mode=display">g^{\prime}(x)=\sum\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\prime}(x_{0})</script><p>再然后是$2$阶</p>
<script type="math/tex; mode=display">g^{\prime\prime}(x)=\sum\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\prime\prime}(x_{0})</script><p>最后是$3$阶</p>
<script type="math/tex; mode=display">g^{\prime\prime\prime}(x)=\sum\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\prime\prime\prime}(x_{0})</script><p>我们发现$g[n]$有如下的规律</p>
<script type="math/tex; mode=display">g[n]=\cfrac{f^{(n)}(x_{0})}{n!}</script><p>综上所述</p>
<script type="math/tex; mode=display">g(x)=\sum\limits_{i=0}^{n}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><p><del>应该吧（</del></p>
<h4 id="多项式牛顿迭代"><a href="#多项式牛顿迭代" class="headerlink" title="多项式牛顿迭代"></a>多项式牛顿迭代</h4><p>考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得</p>
<script type="math/tex; mode=display">F(G(x))\equiv 0\pmod{x^{n}}</script><p>我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得</p>
<script type="math/tex; mode=display">F(G_{0})\equiv 0\pmod{x^{t}}</script><p>我们希望求出一个$G$使得</p>
<script type="math/tex; mode=display">F(G)\equiv 0\pmod{x^{2t}}</script><p>我们将$F$在$G_{0}$这里进行泰勒展开：</p>
<script type="math/tex; mode=display">\begin{aligned}
F(G)&=F(G_{0})\\
&+F^{\prime}(G_{0})(G-G_{0})\\
&+\cfrac{F^{\prime\prime}(G_{0})}{2}(G-G_{0})^{2}\\
&+\cdots\end{aligned}</script><p>注意到</p>
<script type="math/tex; mode=display">\begin{aligned}
F(G)-F(G_{0})&\equiv 0\pmod{x^{t}}\\
G-G_{0}&\equiv 0\pmod{x^{t}}
\end{aligned}</script><p>也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有</p>
<script type="math/tex; mode=display">\begin{aligned}
F(G)&\equiv F(G_{0})+F^{\prime}(G_{0})(G-G_{0})\pmod{x^{2t}}\\
F^{\prime}(G_{0})G&\equiv F^{\prime}(G_{0})G_{0}-F(G_{0})\pmod{x^{2t}}\\
G&\equiv G_{0}-\cfrac{F(G_{0})}{F^{\prime}(G_{0})}\pmod{x^{2t}}
\end{aligned}</script><p>然后我们就一直倍增，倍增到$t\geqslant n$为止，此时$G_{0}$即为所求多项式。</p>
<h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a><a href="https://www.luogu.org/problemnew/show/P4238">多项式求逆</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>
<script type="math/tex; mode=display">F(x)\times G(x)\equiv 1\pmod{x^{n}}</script><p>假设我们已经求出了$G_{0}$使得</p>
<script type="math/tex; mode=display">F\times G_{0}\equiv 1\pmod{x^{t}}</script><p>我们希望找到一个$G$使得</p>
<script type="math/tex; mode=display">F\times G\equiv 1\pmod{x^{2t}}</script><p>据说能用牛顿迭代推，然而我不会（</p>
<p>考虑正常一点的方式<del>，虽然说还是倍增</del>。</p>
<script type="math/tex; mode=display">\begin{aligned}
F\times G-F\times G_{0}&\equiv 0\pmod{x^{t}}\\
G-G_{0}&\equiv 0\pmod{x^{t}}\\
(G-G_{0})^{2}&\equiv 0\pmod{x^{2t}}\\
G^{2}-2GG_{0}+G_{0}^{2}&\equiv 0\pmod{x^{2t}}
\end{aligned}</script><p>两边同时乘$F$</p>
<script type="math/tex; mode=display">\begin{aligned}
G-2G_{0}+FG_{0}^{2}&\equiv 0\pmod{x^{2t}}\\
G&\equiv 2G_{0}-FG_{0}^{2}\pmod{x^{2t}}
\end{aligned}</script><p>边界条件也很明显，就是当$t=1$时，$G[0]\equiv F[0]^{-1}$。</p>
<p>说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（</p>
<p>关于代码……现在还不是时候（</p>
<p>后面有一道超级综合题在等着我们（</p>
<h3 id="多项式对数函数"><a href="#多项式对数函数" class="headerlink" title="多项式对数函数"></a><a href="https://www.luogu.org/problemnew/show/P4725">多项式对数函数</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>
<script type="math/tex; mode=display">G(x)\equiv\ln F(x)\pmod{x^{n}}</script><p>对上式两边求导</p>
<script type="math/tex; mode=display">G^{\prime}\equiv F^{\prime}\ln^{\prime}F\pmod{x^{n}}</script><p>又因为</p>
<script type="math/tex; mode=display">\ln^{\prime}x=\frac{1}{x}</script><p>我们就得到</p>
<script type="math/tex; mode=display">G^{\prime}\equiv\cfrac{F^{\prime}}{F}\pmod{x^{n}}</script><p>求导+求逆+不定积分即可。</p>
<h3 id="多项式指数函数"><a href="#多项式指数函数" class="headerlink" title="多项式指数函数"></a><a href="https://www.luogu.org/problemnew/show/P4726">多项式指数函数</a></h3><p>超级综合题来了。</p>
<p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>
<script type="math/tex; mode=display">G(x)\equiv e^{F(x)}\pmod{x^{n}}</script><p>首先</p>
<script type="math/tex; mode=display">\ln G-F\equiv 0\pmod{x^{n}}</script><p>我们把$F$看成是常数项，定义函数</p>
<script type="math/tex; mode=display">A(G)=\ln G-F</script><script type="math/tex; mode=display">A^{\prime}(G)=\ln^{\prime}G=\cfrac{1}{G}</script><p>套牛顿迭代</p>
<script type="math/tex; mode=display">\begin{aligned}
G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\
&\equiv G_{0}(1-\ln G_{0}+F)\pmod{x^{2t}}
\end{aligned}</script><p>然后把以上提到的所有板子全都复制过来就行了（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>],tmp3[maxn+<span class="number">1</span>],tmp4[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">            tmp1[k]=F[k];</span><br><span class="line">        NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            G[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            tmp1[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">    Inv(F,tmp2,n);</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">    NTT(G,N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        tmp2[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        Ln(G,tmp3,i);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">            tmp4[k]=F[k];</span><br><span class="line">        NTT(tmp3,j,<span class="number">0</span>);</span><br><span class="line">        NTT(tmp4,j,<span class="number">0</span>);</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=((<span class="number">1L</span>L-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            tmp3[k]=tmp4[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        cltstream::read(F[i]);</span><br><span class="line">    Exp(F,G,n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        cltstream::write(G[i],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式开平方根"><a href="#多项式开平方根" class="headerlink" title="多项式开平方根"></a>多项式开平方根</h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>
<script type="math/tex; mode=display">G^{2}(x)\equiv F(x)\pmod{x^{n}}</script><p>牛顿迭代吼啊！</p>
<script type="math/tex; mode=display">A(G)=G^{2}-F</script><script type="math/tex; mode=display">A^{\prime}(G)=2G</script><script type="math/tex; mode=display">\begin{aligned}
G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\
&\equiv G_{0}-\cfrac{G_{0}^{2}-F}{2G_{0}}\\
&\equiv\cfrac{G_{0}^{2}+F}{2G_{0}}\\
&=\cfrac{1}{2}(G_{0}+\cfrac{F}{G_{0}})\pmod{x^{2t}}
\end{aligned}</script><p><del>复制粘贴吼啊！</del></p>
<h3 id="我刚才都学了些啥破玩意"><a href="#我刚才都学了些啥破玩意" class="headerlink" title="我刚才都学了些啥破玩意"></a>我刚才都学了些啥破玩意</h3><p><a href="http://codeforces.com/contest/438/problem/E">一道例题</a>。</p>
<p><a href="https://www.luogu.org/problemnew/show/CF438E">Remote Judge</a>。</p>
<p>这是读题前的我：</p>
<p><img src="https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif" alt=""></p>
<p>这是读题后的我：</p>
<p><img src="https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg" alt=""></p>
<p>这是知道了这题正解是多项式开平方根后的我：</p>
<p><img src="https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg" alt=""></p>
<p>我……我怕不是学了个假的多项式哦（</p>
<p>厚颜无耻地抄题解（</p>
<p>首先我们搞出生成函数（然而并不是很懂）</p>
<script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{m}G[i]x^{i}</script><p>其中</p>
<script type="math/tex; mode=display">G[i]=[i\in\{c_{1},c_{2},\cdots,c_{n}\}]</script><p>定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有</p>
<script type="math/tex; mode=display">F[0]=1</script><script type="math/tex; mode=display">F[x]=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]</script><p>就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。</p>
<p>然后是一些神仙操作</p>
<script type="math/tex; mode=display">\begin{aligned}
F[x]&=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]\\
&=\sum\limits_{i=0}^{x}G[i]F^{2}[x-i]\\
&=(GF^{2})[x]
\end{aligned}</script><p>令人窒息（</p>
<p>然后我们就有</p>
<script type="math/tex; mode=display">GF^{2}+1=F</script><p>但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。</p>
<p>于是解上面这个一元二次方程，我们得到</p>
<script type="math/tex; mode=display">F=\cfrac{1\pm\sqrt{1-4G}}{2G}</script><p>但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\mp\sqrt{1-4G})$，然后化简一波</p>
<script type="math/tex; mode=display">F=\cfrac{2}{1\mp\sqrt{1-4G}}</script><p>如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\cfrac{2}{2}=1$。综上所述</p>
<script type="math/tex; mode=display">F=\cfrac{2}{1+\sqrt{1-4G}}</script><p>本来接下来应该有代码实现的，但是<del>我拒绝</del>咕咕咕。</p>
<p><del>其实是调不出来了（</del></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「多项式学习笔记Part I」最基本的多项式乘法</title>
    <url>/polynomial-learning-notes-pt1/</url>
    <content><![CDATA[<p>最近正好月考，然而并不想去月考，于是来颓blog吧。</p>
<a id="more"></a>
<p>给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\times G)(x)$的各项系数。$n,m\leqslant 10^{6}$。</p>
<p>我们不妨将$F(x)$的$i$次项系数记为$F[i]$</p>
<script type="math/tex; mode=display">F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{m-1}G[i]x^{i}</script><script type="math/tex; mode=display">(F\times G)(x)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}</script><script type="math/tex; mode=display">(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>不难发现直接暴力算是$O(n^{2})$的，因此我们需要优化。</p>
<p>不过为了优化，我们得先扯远点。</p>
<h1 id="点值表达"><a href="#点值表达" class="headerlink" title="点值表达"></a>点值表达</h1><p>如果我们选取$n$个点$(x_{0},y_{0}),(x_{1},y_{1}),\cdots,(x_{n-1},y_{n-1})$，并且其中$x_{i}$两两不同，我们就可以唯一地确定出一个$n-1$次多项式。</p>
<p>就比如说</p>
<script type="math/tex; mode=display">(0,2),(1,7),(2,4)</script><p><del>瞎写的（</del></p>
<p>我们可以列出如下的三元一次方程组：</p>
<script type="math/tex; mode=display">\begin{cases}
&\text{C}=2\\
&\text{A}+\text{B}+\text{C}=7\\
&4\text{A}+2\text{B}+\text{C}=4
\end{cases}</script><p>解得</p>
<script type="math/tex; mode=display">\begin{cases}
&\text{A}=-4\\
&\text{B}=9\\
&\text{C}=2
\end{cases}</script><p>注意到$(F\times G)(x)=F(x)G(x)$<del>（废话）</del>，我们只要知道了$F(x)$和$G(x)$的点值表达，就可以$O(n)$的计算出$(F\times G)(x)$的点值表达了。因为$(F\times G)(x)$的次数是$n+m-2$，我们选出前$n+m-1$个自然数即可。</p>
<p>但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要$O(n^{2})$转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（</p>
<p>于是我们还需要优化，于是我们还需要再扯远一点。</p>
<h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>对，你没看错，扯到复数了。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说</p>
<script type="math/tex; mode=display">x^{2}+1=0</script><p>我们知道，它的判别式是$\Delta=b^{2}-4ac=-4\lt 0$，因此它没有实数根。</p>
<p>于是我们就定义了虚数单位$i$，并规定$i^{2}=-1$。形如$x+yi$这样的数被称为复数。它的模长被定义为它到原点的距离，即$\sqrt{x^{2}+y^{2}}$；幅角被定义为与$x$轴正半轴的夹角，即$\operatorname{tan}^{-1}\cfrac{y}{x}$。</p>
<p>因为$i$不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$就是实轴，$y$轴就是虚轴，$x+yi$就对应了点$(x,y)$。</p>
<p><img src="https://i.loli.net/2018/12/19/5c1a46b4d785b.png" alt=""></p>
<p>上图展示了$4+i$和$3+4i$。</p>
<p>复数的运算其实没什么出乎意料的：</p>
<script type="math/tex; mode=display">(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i</script><script type="math/tex; mode=display">(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i</script><script type="math/tex; mode=display">(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i</script><script type="math/tex; mode=display">\begin{aligned}
\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\
&=\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\
&=\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i
\end{aligned}</script><p>我们来单独考虑一下复数相乘的几何意义。</p>
<p>假设我们有两个复数$c_{1}$，$c_{2}$，它们的模长分别是$r_{1}$，$r_{2}$，幅角分别是$\alpha_{1}$，$\alpha_{2}$。不难发现我们有</p>
<script type="math/tex; mode=display">c_{1}=r_{1}(\operatorname{cos}\alpha_{1}+i\operatorname{sin}\alpha_{1})</script><script type="math/tex; mode=display">c_{2}=r_{2}(\operatorname{cos}\alpha_{2}+i\operatorname{sin}\alpha_{2})</script><script type="math/tex; mode=display">\begin{aligned}
c_{1}c_{2}&=r_{1}r_{2}(\cos\alpha_{1}+i\sin\alpha_{1})(\cos\alpha_{2}+i\sin\alpha_{2})\\
&=r_{1}r_{2}(\cos\alpha_{1}\cos\alpha_{2}+i\cos\alpha_{1}\sin\alpha_{2}+i\sin\alpha_{1}\cos\alpha_{2}-\sin\alpha_{1}\sin\alpha_{2})\\
&=r_{1}r_{2}[\cos(\alpha_{1}+\alpha_{2})+i\sin(\alpha_{1}+\alpha_{2})]
\end{aligned}</script><p>总结成一句话，就是「模长相乘，幅角相加」。</p>
<h2 id="单位圆与单位根"><a href="#单位圆与单位根" class="headerlink" title="单位圆与单位根"></a>单位圆与单位根</h2><p>单位圆就是指半径为$1$的圆。不过一般我们都是把它画在原点的。</p>
<p><img src="https://i.loli.net/2018/12/20/5c1b06e5602fa.png" alt=""></p>
<p>考虑这么一个方程</p>
<script type="math/tex; mode=display">x^{n}=1</script><p>它的所有复数根。</p>
<p>因为复数相乘意味着模长相乘，如果一个复数的$n$次方等于$1$，它自身的模长也应该是$1$。如果它的幅角是$a$，我们应该有</p>
<script type="math/tex; mode=display">2\pi\mid na</script><script type="math/tex; mode=display">\cfrac{2\pi}{n}\mid a</script><p>不难想象出我们有$n$个这样的复数，它们的幅角通式是$\cfrac{2k\pi}{n}(k\in[0,n)\cap\mathbb{Z})$。我们称其中幅角等于$\cfrac{2\pi}{n}$的复数，即$\cos\cfrac{2\pi}{n}+i\sin\cfrac{2\pi}{n}$为$n$次单位根$\omega_{n}$，我们就可以把这$n$个复数表示为$\omega_{n}^{k}(k\in[0,n)\cap\mathbb{Z})$。</p>
<p>它有如下的一些性质</p>
<script type="math/tex; mode=display">\omega_{2n}^{2k}=\omega_{n}^{k}</script><p>因为它们的模长都是$1$，幅角相等就相等了。</p>
<p>然后就没了，读者自证不难（</p>
<script type="math/tex; mode=display">\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}</script><p>因为$\omega_{n}^{\frac{n}{2}}$的幅角是$\cfrac{2\times\frac{n}{2}\pi}{n}=\pi$，不难发现它就是$-1$了。</p>
<h1 id="快速傅里叶变换（Fast-Fourier-Transformation）"><a href="#快速傅里叶变换（Fast-Fourier-Transformation）" class="headerlink" title="快速傅里叶变换（Fast Fourier Transformation）"></a>快速傅里叶变换（Fast Fourier Transformation）</h1><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>那么问题来了，我们刚才扯了这么些，有什么用呢？</p>
<p>就是说，有个叫「让·巴普蒂斯·约瑟夫·傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出$n$次单位根想要求点值表达。</p>
<p>首先，我们通过在高次补$0$的方式，将这个多项式的项数（也就是次数$+1$）补到$2$的非负整数次幂。</p>
<p>然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：</p>
<script type="math/tex; mode=display">\begin{aligned}
F_{1}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i]x^{i}\\
&=F[0]x^{0}+F[2]x^{1}+\cdots+F[n-2]x^{\frac{n}{2}-1}
\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}
F_{2}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i+1]x^{i}\\
&=F[1]x^{0}+F[3]x^{1}+\cdots+F[n-1]x^{\frac{n}{2}-1}
\end{aligned}</script><p>于是我们有</p>
<script type="math/tex; mode=display">F(x)=F_{1}(x^{2})+xF_{2}(x^{2})</script><p>现在我们假设$0\leqslant k&lt;\cfrac{n}{2}$，将$x=\omega_{n}^{k}$和$x=\omega_{n}^{k+\frac{n}{2}}$代入</p>
<script type="math/tex; mode=display">\begin{aligned}
F(\omega_{n}^{k})&=F_{1}(\omega_{n}^{2k})+\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\
&=F_{1}(\omega_{\frac{n}{2}}^{k})+\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})
\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}
F(\omega_{n}^{k+\frac{n}{2}})&=F_{1}(\omega_{n}^{2k+n})+\omega_{n}^{k+\frac{n}{2}}F_{2}(\omega_{n}^{2k+n})\\
&=F_{1}(\omega_{n}^{2k})-\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\
&=F_{1}(\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})
\end{aligned}</script><p>我们注意到，如果说我们求出了$F_{1}(x)$和$F_{2}(x)$的点值表达，我们就能够$O(n)$地求出$F(x)$的点值表达了。至此，我们不难想到分治，边界条件就是$n=1$，这时什么也不用做直接返回即可。</p>
<p>简单地贴一下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="built_in">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">complex</span> F1[n&gt;&gt;<span class="number">1</span>],F2[n&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">    	F1[i]=F[<span class="number">2</span>*i];</span><br><span class="line">        F2[i]=F[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    work(F1,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    work(F2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    complex unit(cos(2*Pi/n),sin(2*Pi/n)),tmp=1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i,tmp=tmp*unit)&#123;</span><br><span class="line">    	<span class="built_in">complex</span> w=F2[i+(n&gt;&gt;<span class="number">1</span>)]*tmp;</span><br><span class="line">        F[i]=F1[i]+w;</span><br><span class="line">        F[i+(n&gt;&gt;<span class="number">1</span>)]=F1[i]-w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，以上代码是我现写出来的，<del>保证其不正确性</del>不保证其正确性。</p>
<p>不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，<code>F</code>数组的每一个位置上实际存的是几次项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7</span><br><span class="line">0 2 4 6|1 3 5 7</span><br><span class="line">0 4|2 6|1 5|3 7</span><br><span class="line">0|4|2|6|1|5|3|7</span><br></pre></td></tr></table></figure>
<p>写成二进制看看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">位置（十进制）</th>
<th style="text-align:center">位置（二进制）</th>
<th style="text-align:center">次数（十进制）</th>
<th style="text-align:center">次数（二进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$000$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$000$</td>
</tr>
<tr>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$001$</td>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$100$</td>
</tr>
<tr>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$010$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$010$</td>
</tr>
<tr>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$011$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$110$</td>
</tr>
<tr>
<td style="text-align:center">$4$</td>
<td style="text-align:center">$100$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$001$</td>
</tr>
<tr>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$101$</td>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$101$</td>
</tr>
<tr>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$110$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$011$</td>
</tr>
<tr>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$111$</td>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$111$</td>
</tr>
</tbody>
</table>
</div>
<p>注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后$\operatorname{log}n$位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。</p>
<p>我们可以$O(n)$地处理处每个数的镜像：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是$i$这个数除了最后一位以外的所有位的镜像；右边特判了一下$i$的最后一位是否为$1$，如果是的话，就在最高位补一个$1$。</p>
<p>接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="built_in">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function"><span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                <span class="built_in">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                F[j+p]=F[j]-tmp;</span><br><span class="line">                F[j]=F[j]+tmp;</span><br><span class="line">                cur=cur*unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么现在还差最后一步，将点值表达转回系数表达。我们将$F(\omega_{n}^{0}),F(\omega_{n}^{1}),\cdots,F(\omega_{n}^{n-1})$分别记为$y_{0},y_{1},\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
&(\omega_{n}^{0})^{0}&(\omega_{n}^{0})^{1}&\cdots&(\omega_{n}^{0})^{n-1}&\\
&(\omega_{n}^{1})^{0}&(\omega_{n}^{1})^{1}&\cdots&(\omega_{n}^{1})^{n-1}\\
&\vdots&\vdots&\ddots&\vdots\\
&(\omega_{n}^{n-1})^{0}&(\omega_{n}^{n-1})^{1}&\cdots&(\omega_{n}^{n-1})^{n-1}\\
\end{bmatrix}
\begin{bmatrix}
&F[0]&\\
&F[1]\\
&\vdots\\
&F[n-1]
\end{bmatrix}
=\begin{bmatrix}
&y_{0}&\\
&y_{1}\\
&\vdots\\
&y_{n-1}
\end{bmatrix}</script><p>我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
&\frac{1}{n}(\omega_{n}^{0})^{0}&\frac{1}{n}(\omega_{n}^{0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{0})^{n-1}&\\
&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\
&\vdots&\vdots&\ddots&\vdots\\
&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\
\end{bmatrix}</script><p>现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为$A$，第二个矩阵为$B$，$A\times B=C$。不难发现$A[i][j]=\omega_{n}^{ij}$，$B[i][j]=\cfrac{1}{n}\omega_{n}^{-ij}$，我们有</p>
<script type="math/tex; mode=display">\begin{aligned}
C[i][j]&=\sum\limits_{k=0}^{n-1}A[i][k]B[k][j]\\
&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{ik-kj}
\end{aligned}</script><p>若$i=j$，不难发现此时$C[i][j]=1$。</p>
<p>否则，即$i\neq j$，设$i-j=l$，我们有</p>
<script type="math/tex; mode=display">\begin{aligned}
C[i][j]&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{lk}\\
&=\cfrac{\omega_{n}^{ln}-1}{n(\omega_{n}^{l}-1)}\\
&=\cfrac{1-1}{n(\omega_{n}^{l}-1)}\\
&=0
\end{aligned}</script><p>综上所述，矩阵$C$是单位矩阵，因此矩阵$B$是矩阵$A$的逆矩阵。</p>
<p>因此我们有</p>
<script type="math/tex; mode=display">\begin{bmatrix}&\frac{1}{n}(\omega_{n}^{-0})^{0}&\frac{1}{n}(\omega_{n}^{-0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-0})^{n-1}&\\&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\\end{bmatrix}\begin{bmatrix}&y_{0}&\\&y_{1}\\&\vdots\\&y_{n-1}\end{bmatrix}=\begin{bmatrix}&F[0]&\\&F[1]\\&\vdots\\&F[n-1]\end{bmatrix}</script><p>注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的$\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$换成$\omega_{n}^{0},\omega_{n}^{-1},\cdots,\omega_{n}^{-n+1}$，然后对着点值表达来一遍FFT，然后再除以$n$，就得到了原多项式的系数了。</p>
<p>注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),tp*<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后调用时再传一个参数<code>tp</code>进去。<code>tp=1</code>表示是系数转点值，<code>tp=-1</code>表示是点值转系数。</p>
<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">        r=_r;</span><br><span class="line">        c=_c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">complex</span> F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">    _tp tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="built_in">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),tp*<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="built_in">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                F[j+p]=F[j]-tmp;</span><br><span class="line">                F[j]=F[j]+tmp;</span><br><span class="line">                cur=cur*unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;F[i].r);</span><br><span class="line">    ++m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[i].r);</span><br><span class="line">    <span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    FAQ(F,<span class="number">1</span>);</span><br><span class="line">    FAQ(G,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=F[i]*G[i];</span><br><span class="line">    FAQ(F,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0.0lf "</span>,F[i].r/n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>不要问我<code>cltstream</code>哪去了（</del></p>
<p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P3803">板子题</a>了。</p>
<p>其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（</p>
<p>最好还是自己写吧（</p>
<p>什么？想知道是哪道题？往下看（</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="「ZJOI2014」力"><a href="#「ZJOI2014」力" class="headerlink" title="「ZJOI2014」力"></a><a href="https://www.luogu.org/problemnew/show/P3338">「ZJOI2014」力</a></h3><p>这是一道裸的卷积题。</p>
<p>考虑两个长度为$n$的数组$F$和$G$，现在我们想求一个数组$H$，它满足</p>
<script type="math/tex; mode=display">H[i]=\sum\limits_{j=0}^{i}F[j]G[i-j]=\sum\limits_{0\leqslant j<n,0\leqslant k<n,j+k=i}F[j]G[k]</script><p>在本页面往上翻，翻到这个式子：</p>
<script type="math/tex; mode=display">(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>发现了吗？这两个过程其实是一样的。</p>
<p>于是，我们如下构造两个多项式</p>
<script type="math/tex; mode=display">F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{n-1}G[i]x^{i}</script><p>然后直接一波FFT套上去，输出次数最低的$n$项的系数就好。</p>
<p>那么这题呢？首先我们把$j\lt i$和$j\gt i$分开计算。</p>
<p>先考虑$j\lt i$，令$F[i]=q_{i}$，$G[i]=\begin{cases}&amp;\cfrac{1}{i^{2}}\;\;&amp;(i\gt 0)\&amp;0&amp;(i=0)\end{cases}$，那么</p>
<script type="math/tex; mode=display">\begin{aligned}
E_{i}&=\sum_{j=0}^{i-1}F[j]G[i-j]\\
&=\sum_{j=0}^{i}F[j]G[i-j]
\end{aligned}</script><p>直接套板子就行。</p>
<p>对于$j&gt;i$的情况，我们将数组$F$左右翻转，然后继续套板子就行（</p>
<p>具体还是看代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>\lt cstdio&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">        r=_r;</span><br><span class="line">        c=_c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">complex</span> F1[maxn+<span class="number">1</span>],F2[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="built_in">complex</span>&amp; a,<span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">    _tp tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="built_in">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(Pi/p),tp*<span class="built_in">sin</span>(Pi/p))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">register</span> <span class="built_in">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="built_in">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                F[j+p]=F[j]-tmp;</span><br><span class="line">                F[j]=F[j]+tmp;</span><br><span class="line">                cur=cur*unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;F1[i].r);</span><br><span class="line">        F2[n-i<span class="number">-1</span>].r=F1[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        G[i]=<span class="number">1.0</span>/i/i;</span><br><span class="line">    <span class="keyword">for</span>(m=n,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    FAQ(G,<span class="number">1</span>);</span><br><span class="line">    FAQ(F1,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F1[i]=F1[i]*G[i];</span><br><span class="line">    FAQ(F1,<span class="number">-1</span>);</span><br><span class="line">    FAQ(F2,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F2[i]=F2[i]*G[i];</span><br><span class="line">    FAQ(F2,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,(F1[i].r-F2[m-i<span class="number">-1</span>].r)/n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数论变换（Number-Theoretic-Transformation）"><a href="#数论变换（Number-Theoretic-Transformation）" class="headerlink" title="数论变换（Number-Theoretic Transformation）"></a>数论变换（Number-Theoretic Transformation）</h1><p>注意到朴素的FFT使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用<code>double</code>存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完FFT却会出现小数。</p>
<p>这就启示我们，能不能用其他的什么东西替换掉单位复根。</p>
<p>设有两个互质的正整数$a$和$p$，最小的使得$a^{k}\equiv 1\pmod{p}$的$k$被称为$a$模$p$的阶，记作$\delta_{p}(a)$。</p>
<p>如果说$\delta_{p}(a)=\varphi(p)$，我们就称$a$是模$p$的一个原根。</p>
<p>现在我们找一个质数$p=an+1$，其中$a$是一个正整数，$n$是$2$的非负整数次幂。然后我们找到它的原根$g$，并定义$\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：</p>
<p>$\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$互不相同。这是为了保证点值表达的合法。</p>
<p>虽然我不会证，不过我们的确有$g^{0},g^{1},\cdots,g^{n-1}$在模$p$意义下互不相同，$a$次幂自然也一样。</p>
<blockquote>
<p>Updated on 2019-03-17</p>
<p>似乎这么证明有些问题？</p>
<p>原根的这个性质实际上是$g^{0},g^{1},\cdots,g^{p-2}$在模$p$意义下互不相同。因此如果$(n-1)a&lt;p-1$，那么上面的结论就是正确的。</p>
<script type="math/tex; mode=display">\begin{aligned}
(n-1)a&=na-a\\
&=p-1-\cfrac{p-1}{n}\\
&\lt p-1
\end{aligned}</script><p>以上。</p>
</blockquote>
<p>$\omega_{2n}^{2k}=\omega_{n}^{k}$。这是为了让我们可以分治。</p>
<p>根据定义，$\omega_{2n}=g^{\frac{a}{2}}$，就是将现在的$p$进一步拆成$\cfrac{a}{2}\cdot2n+1$。不难发现</p>
<script type="math/tex; mode=display">\omega_{2n}^{2k}=g^{\frac{a}{2}\cdot{2}k}=g^{ak}=\omega_{n}^{k}</script><p>因而原根有上述性质。</p>
<p>$\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}$，或者说$\omega_{n}^{\frac{n}{2}}=-1$。这同样是为了让我们可以分治。</p>
<p>因为$p=an+1$，根据费马小定理，我们有</p>
<script type="math/tex; mode=display">\omega_{n}^{n}\equiv g^{an}\equiv g^{p-1}\equiv 1\pmod{p}</script><p>因而$\omega_{n}^{\frac{n}{2}}\equiv\pm 1\pmod{p}$。又因为$\omega_{n}^{0}=1$，而$\omega_{n}^{\frac{n}{2}}\not\equiv\omega_{n}^{0}\pmod{p}$，我们就得到$\omega_{n}^{\frac{n}{2}}\equiv -1\pmod{p}$。</p>
<p>若$k\neq 0$，$\sum_{i=0}^{n-1}(\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。</p>
<p>以上，我们成功地用原根取代了单位复根。一般情况下，我们会取$p=998244353=7\times 17\times 2^{23}+1$，它的原根是$3$。</p>
<p>需要注意的是，我们还有一个可以优化的小细节。注意到$\omega_{n}=g^{a}=g^{\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于$998244353$来说，我们需要预处理$\omega_{2},\omega_{4},\cdots,\omega_{2^{23}}$。注意到</p>
<script type="math/tex; mode=display">\omega_{2^{23}}=3^{7\times 17}=3^{119}</script><script type="math/tex; mode=display">\omega_{2^{k}}=\omega_{2^{k+1}}^{2}</script><p>我们一遍快速幂算出$\omega_{2^{23}}$然后倒着推出剩下的即可。</p>
<p>关于$\omega_{n}^{-k}$，注意到它就是$\omega_{n}^{k}$在模$998244353$意义下的逆元。那么我们把上面两个式子中的$3$换成它在模$998244353$意义下的逆元即可，这个数是$332748118$。</p>
<p>然后我们把FFT板子里的单位复根全部换成原根，运算换成模意义下的就行了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        cltstream::read(F[i]);</span><br><span class="line">    ++m;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        cltstream::read(G[i]);</span><br><span class="line">    <span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    NTT(F,<span class="number">0</span>);</span><br><span class="line">    NTT(G,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">    NTT(F,<span class="number">1</span>);</span><br><span class="line">    n=cltpow(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        cltstream::write(<span class="number">1L</span>L*F[i]*n%mod,i&lt;m<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>关于最优化分块时间复杂度的研究报告</title>
    <url>/sqrt-decomposition-complexity-optimization/</url>
    <content><![CDATA[<p>最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。</p>
<a id="more"></a>
<p>假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\text{A}x+\text{B}y$。根据均值不等式</p>
<script type="math/tex; mode=display">\cfrac{1}{2}(x+y)\geqslant\sqrt{xy}</script><p>我们有</p>
<script type="math/tex; mode=display">\text{A}x+\text{B}y\geqslant2\sqrt{\text{AB}n}</script><p>当且仅当$x=\sqrt{\cfrac{\text{B}}{\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\sqrt{\text{AB}n})$。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>研究报告</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>「未来算法Episode I」严格根号分块实现树套树</title>
    <url>/future-algorithm-ep1/</url>
    <content><![CDATA[<p>分块天下第一！！！！！！！！！</p>
<a id="more"></a>
<p>我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。</p>
<p><a href="https://www.luogu.org/record/show?rid=14518116"><img src="https://i.loli.net/2018/12/08/5c0bb272768cf.png" alt=""></a></p>
<p><img src="https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg" alt=""></p>
<p>我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。</p>
<p>先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。</p>
<p>然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\operatorname{log}n)$的。</p>
<p>那我们就在外层套个树状数组，把修改$O(n\operatorname{log}n)$查询$O(\operatorname{log}n)$均摊成全部$O(\operatorname{log}^{2}n)$。</p>
<p>然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。</p>
<p>考虑<del>无敌的</del>分块。</p>
<p>一般我们想到的分块就是在块内维护<code>std::set</code>。这样操作$3$可以做到$O(\operatorname{log}\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\sqrt{n}\operatorname{log}\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\operatorname{log}10^{9}\sqrt{n}\operatorname{log}\sqrt{n})$。</p>
<p>然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。</p>
<p>我们来看一下<a href="https://www.luogu.org/space/show?uid=56384"><strong>Shadowice1984</strong></a>dalao在他的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119">另一篇题解</a>中做出的评价：</p>
<blockquote>
<p>这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\text{log}$之内。</p>
<p>但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\sqrt{n})$而不是$O(\operatorname{log}n)$，这意味着分块其实和$\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\text{log}$来，这在强调常数的根号算法中绝对是致命的。</p>
</blockquote>
<p>我也是从这位dalao的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380">blog</a>里看到了严格根号分块实现树套树这种未来算法。</p>
<p>主要思想其实不难理解，既然分块和$\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。</p>
<p>定义<code>cnt1[i][j]</code>表示前$i$个块内有多少个元素的值在第$j$个块内，<code>cnt2[i][j]</code>表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\sqrt{n})$的。</p>
<p>然后我们来分析每个操作该怎么实现：</p>
<ol>
<li>首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。</li>
<li>还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组<code>tmp1</code>和<code>tmp2</code>来保存边角块的信息。</li>
<li>直接$O(\sqrt{n})$暴力重构两个<code>cnt</code>就好。</li>
<li>需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内<strong>从后往前扫</strong>，找到答案直接退出。否则还是<strong>从后往前扫所有值域块</strong>，找到第一个非空的块然后进去找。</li>
<li>操作$4$换个方向即可。</li>
</ol>
<p>综上所述，该算法的时间复杂度为$O((n+m)\sqrt{n}+m\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\operatorname{log}^{2}n)\approx 12183043$。看起来好像比不过树套树，实际上开个$\text{O}2$跑得比谁都快，正如一开始那张图所示。</p>
<p>不过代码写出来有点长的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxs 230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(a) ((a)&amp;(-(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,sq1,sq2;</span><br><span class="line"><span class="keyword">int</span> id1[maxn+<span class="number">1</span>],id2[maxn+maxm+<span class="number">1</span>],p[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">1</span>],opt[maxm+<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> cnt1[maxs+<span class="number">1</span>][(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],cnt2[maxs+<span class="number">1</span>][maxn+maxm+<span class="number">1</span>],tmp1[(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],tmp2[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(;(sq1+<span class="number">1</span>)*(sq1+<span class="number">1</span>)&lt;=n;++sq1);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        id1[i]=(i<span class="number">-1</span>)/sq1+<span class="number">1</span>;</span><br><span class="line">        cltstream::read(a[i]);</span><br><span class="line">        p[++p[<span class="number">0</span>]]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        cltstream::read(opt[i][<span class="number">0</span>]);</span><br><span class="line">        cltstream::read(opt[i][<span class="number">1</span>]);</span><br><span class="line">        cltstream::read(opt[i][<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(opt[i][<span class="number">0</span>]!=<span class="number">3</span>)</span><br><span class="line">            cltstream::read(opt[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[++p[<span class="number">0</span>]]=opt[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="built_in">std</span>::unique(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>)-p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;(sq2+<span class="number">1</span>)*(sq2+<span class="number">1</span>)&lt;=p[<span class="number">0</span>];++sq2);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p[<span class="number">0</span>];++i)</span><br><span class="line">        id2[i]=(i<span class="number">-1</span>)/sq2+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i]=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,a[i])-p;</span><br><span class="line">        ++cnt1[id1[i]][id2[a[i]]];</span><br><span class="line">        ++cnt2[id1[i]][a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=id1[n];++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]];++j)</span><br><span class="line">            cnt1[i][j]+=cnt1[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[<span class="number">0</span>];++j)</span><br><span class="line">            cnt2[i][j]+=cnt2[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        re <span class="keyword">int</span> l,r,x,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(opt[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)</span><br><span class="line">                        ans+=(a[j]&lt;x);</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)</span><br><span class="line">                        ans+=(a[j]&lt;x);</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;id2[x];++j)</span><br><span class="line">                        ans+=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j];</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>;j&lt;x;++j)</span><br><span class="line">                        ans+=cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)</span><br><span class="line">                        ans+=(a[j]&lt;x);</span><br><span class="line">                cltstream::write(ans+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=opt[i][<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                            x-=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j];</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line">                                <span class="keyword">if</span>(x&gt;cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                    x-=cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k];</span><br><span class="line">                                <span class="keyword">else</span>&#123;</span><br><span class="line">                                    cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;tmp1[j])</span><br><span class="line">                            x-=tmp1[j];</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line">                                <span class="keyword">if</span>(x&gt;tmp2[k])</span><br><span class="line">                                    x-=tmp2[k];</span><br><span class="line">                                <span class="keyword">else</span>&#123;</span><br><span class="line">                                    cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">2</span>])-p;</span><br><span class="line">                <span class="keyword">for</span>(re <span class="keyword">int</span> j=id1[l];j&lt;=id1[n];++j)&#123;</span><br><span class="line">                    --cnt1[j][id2[a[l]]];</span><br><span class="line">                    ++cnt1[j][id2[x]];</span><br><span class="line">                    --cnt2[j][a[l]];</span><br><span class="line">                    ++cnt2[j][x];</span><br><span class="line">                &#125;</span><br><span class="line">                a[l]=x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line">                                <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line">                                <span class="keyword">if</span>(tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cltstream::write(ans?p[ans]:<span class="number">-2147483647</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::upper_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line">                                <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line">                                <span class="keyword">if</span>(tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cltstream::write(ans?p[ans]:<span class="number">2147483647</span>,<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我还没写啥呢咋就$12\text{KB}$了（</p>
<p>这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（</p>
]]></content>
      <categories>
        <category>未来算法</category>
      </categories>
      <tags>
        <tag>树套树</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>一些乱七八糟的数论</title>
    <url>/number-theory-learning-notes/</url>
    <content><![CDATA[<p>最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。</p>
<p><del>抄袭来源</del>参考文献：</p>
<ul>
<li><a href="https://lx-2003.blog.luogu.org/mobius-inversion">铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演</a></li>
<li><a href="https://www.luogu.org/blog/54745/dls-tql">浅谈杜教筛</a></li>
<li><a href="https://lx-2003.blog.luogu.org/dujiao-sieve">铃悬的数学小讲堂——杜教筛</a></li>
</ul>
<a id="more"></a>
<h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><h2 id="定义与相关性质"><a href="#定义与相关性质" class="headerlink" title="定义与相关性质"></a>定义与相关性质</h2><p>数论函数就是定义域为$\mathbb{N}^{+}$的函数。</p>
<p>两个数论函数相加，就是简单地把函数值相加。</p>
<script type="math/tex; mode=display">(f+g)(n)=f(n)+g(n)</script><p>数乘也是类似的。</p>
<script type="math/tex; mode=display">(\alpha f)(n)=\alpha f(n)</script><p>点积也是类似的。</p>
<script type="math/tex; mode=display">(f\cdot g)(n)=f(n)g(n)</script><p><del>好像没啥用。</del></p>
<p>在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：</p>
<script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})</script><p>或者说：</p>
<script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{ij=n}f(i)g(j)</script><p>它具有以下的一些性质：</p>
<p>交换律，即$f\times g=g\times f$。</p>
<p>这很明显。</p>
<p>结合律，即$(f\times g)\times h=f\times(g\times h)$。</p>
<script type="math/tex; mode=display">\begin{aligned}
((f\times g)\times h)(n)&=\sum\limits_{ij=n}(\sum\limits_{kl=i}f(k)g(l))h(j)\\
&=\sum\limits_{ijk=n}f(i)g(j)h(k)
\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}
(f\times(g\times h))(n)&=\sum\limits_{ij=n}f(i)(\sum\limits_{kl=j}g(k)h(l))\\
&=\sum\limits_{ijk=n}f(i)g(j)h(k)
\end{aligned}</script><p>分配率，即$(f+g)\times h=f\times h+g\times h$。</p>
<script type="math/tex; mode=display">\begin{aligned}
((f+g)\times h)(n)&=\sum\limits_{ij=n}(f+g)(i)h(j)\\
&=\sum\limits_{ij=n}f(i)h(j)+g(i)h(j)\\
&=(f\times h)(n)+(g\times h)(n)
\end{aligned}</script><p>单位元为$\epsilon(n)=[n=1]$，$f\times\epsilon =f$。</p>
<p>这也很明显。</p>
<p>对于任意一个满足$f(1)\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\times g=\epsilon$。这时我们称$g$是$f$的逆。</p>
<p>我们可以这样定义一个函数的逆：</p>
<script type="math/tex; mode=display">g(n)=\cfrac{\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})}{f(1)}</script><p>这样我们就有</p>
<script type="math/tex; mode=display">\begin{aligned}
(f\times g)(n)&=\sum_{i\mid n}f(i)g(\cfrac{n}{i})\\
&=f(1)g(n)+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\
&=\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\
&=\epsilon(n)
\end{aligned}</script><h2 id="积性函数与完全积性函数"><a href="#积性函数与完全积性函数" class="headerlink" title="积性函数与完全积性函数"></a>积性函数与完全积性函数</h2><p>如果一个数论函数$f$满足</p>
<script type="math/tex; mode=display">\forall x,y\in\mathbb{N}^{+}\wedge x\perp y\;\;f(xy)=f(x)f(y)</script><p>我们就说$f$是一个积性函数。</p>
<p>特别的，如果上式去掉$x\perp y$仍成立，则称$f$是一个完全积性函数。</p>
<p>很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\times n)=f(1)\times f(n)=f(n)$。</p>
<p>常见的完全积性函数有$\epsilon,id^{k}$。$\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。</p>
<p>常见的积性函数有$\varphi,d,\sigma$。$\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\sigma(n)$的值分别等于$n$的约数个数和约数和。</p>
<p>关于$\varphi$的积性，我并不会证（</p>
<p>我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设</p>
<script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有</p>
<script type="math/tex; mode=display">d(n)=\prod\limits_{i=1}^{N}(r_{i}+1)</script><p>我们再假设有一个$m$，且</p>
<script type="math/tex; mode=display">m=\prod\limits_{i=1}^{M}q_{i}^{s_{i}}</script><p>如果说$n\perp m$，肯定有</p>
<script type="math/tex; mode=display">\forall i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z}\;\;p_{i}\neq q_{j}</script><p>于是我们就有</p>
<script type="math/tex; mode=display">nm=(\prod\limits_{i=1}^{N}p_{i}^{r_{i}})(\prod\limits_{j=1}^{M}q_{j}^{s_{j}})</script><script type="math/tex; mode=display">\begin{aligned}
d(nm)&=(\prod\limits_{i=1}^{N}(r_{i}+1))(\prod\limits_{j=1}^{M}(s_{j}+1))\\
&=d(n)d(m)
\end{aligned}</script><p>不妨再反过来考虑。如果说$n\not\perp m$，那么一定存在一对$(i,j)(i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\neq d(n)d(m)$。</p>
<p>我们再来分析$\sigma$的积性。还是设</p>
<script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\in [0,r_{i}]\cap\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是</p>
<script type="math/tex; mode=display">\prod\limits_{i=1}^{N}\sum\limits_{j=0}^{r_{i}}p_{i}^{j}</script><p>这正是$\sigma(n)$的值。</p>
<p>接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。</p>
<p>现在我们来分析，两个积性函数的卷积是否也是积性函数。<del>虽然说都这么问了肯定就是了。</del></p>
<script type="math/tex; mode=display">\begin{aligned}
(f\times g)(n)(f\times g)(m)&=(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\
&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(i)g(\cfrac{n}{i})f(j)g(\cfrac{m}{j})\\
&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(ij)g(\cfrac{nm}{ij})\\
&=\sum\limits_{k\mid nm}f(k)g(\cfrac{nm}{k})\\
&=(f\times g)(nm)
\end{aligned}</script><p>关于上面的第四个等号。时刻注意$n\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。</p>
<p>再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。</p>
<p>设有一个积性函数$f$，它的逆是$g$。</p>
<p>当$nm=1$时，$g(1)=1$。</p>
<p>当$nm&gt;1$时，我们假设对于任意$n^{\prime}m^{\prime}&lt;nm$，都有$g(n^{\prime}m^{\prime})=g(n^{\prime})g(m^{\prime})$。此时</p>
<script type="math/tex; mode=display">\begin{aligned}
g(nm)&=-\sum\limits_{k\mid nm,k\neq 1}f(k)g(\cfrac{nm}{k})\\
&=-\sum\limits_{i\mid n,j\mid m,ij\neq 1}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\
&=g(n)g(m)-\sum\limits_{i\mid n,j\mid m}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\
&=g(n)g(m)-(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\
&=g(n)g(m)-\epsilon(n)\epsilon(m)\\
&=g(n)g(m)
\end{aligned}</script><p><del>其实上面这些全都是抄来的（</del></p>
<h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="正向反演"><a href="#正向反演" class="headerlink" title="正向反演"></a>正向反演</h2><p>定义$\mu$为$1$的逆。也就是说，$\mu\times 1=\epsilon$。</p>
<p>如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：</p>
<blockquote>
<p>首先地，$\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\mu(n)=(-1)^{k}$。否则，$\mu(n)=0$。</p>
</blockquote>
<p>那么，这两种定义等价吗？</p>
<p>考虑到$\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成</p>
<script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>我们就有</p>
<script type="math/tex; mode=display">\mu(n)=\prod\limits_{i=1}^{N}\mu(p_{i}^{r_{i}})</script><p>因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。</p>
<p>设有一个质数$p$。不难发现</p>
<script type="math/tex; mode=display">\mu(p)=-\mu(1)=-1</script><script type="math/tex; mode=display">\mu(p^{2})=-\mu(1)-\mu(p)=-1+1=0</script><script type="math/tex; mode=display">\mu(p^{3})=-\mu(1)-\mu(p)-\mu(p^{2})=-1+1+0=0</script><script type="math/tex; mode=display">\vdots</script><p>至此，不难看出上文给出的两种定义是等价的。</p>
<p>那么这个东西有什么用呢？</p>
<p>我们设</p>
<script type="math/tex; mode=display">F(n)=\sum\limits_{i\mid n}f(i)</script><p>或者等价地说，$F=f\times 1$。我们可以得到</p>
<script type="math/tex; mode=display">\begin{aligned}
F&=f\times 1\\
F\times\mu&=f\times 1\times\mu\\
F\times\mu&=f
\end{aligned}</script><p>像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说</p>
<script type="math/tex; mode=display">f(n)=\sum\limits_{i\mid n}F(i)\mu(\cfrac{n}{i})</script><h2 id="反向反演"><a href="#反向反演" class="headerlink" title="反向反演"></a>反向反演</h2><p>有些时候我们还需要用到像下面这样反过来的莫比乌斯反演</p>
<script type="math/tex; mode=display">F(n)=\sum\limits_{n\mid d}f(d)⇔f(n)=\sum\limits_{n\mid d}F(d)\mu(\cfrac{d}{n})</script><p>我们可以定义一种新的运算</p>
<script type="math/tex; mode=display">(f\otimes g)(n)=\sum\limits_{n\mid d}f(d)g(\cfrac{d}{n})</script><p>我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有</p>
<script type="math/tex; mode=display">F=f\otimes 1⇔F\otimes\mu=f</script><p>于是就有了上面的反向反演。</p>
<blockquote>
<p>Updated on 2018-12-03</p>
<p>例题……还是算了吧（</p>
<p>发现反演常用的套路都忘的差不多了，还是别丢人了（</p>
</blockquote>
<h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><h2 id="实现与模板题"><a href="#实现与模板题" class="headerlink" title="实现与模板题"></a>实现与模板题</h2><p>接下来才是主要内容。</p>
<p>现在，我们要求一个积性函数的前$n$项和。$n\leqslant 10^{10}$。</p>
<p>我们定义</p>
<script type="math/tex; mode=display">S(n)=\sum\limits_{i=1}^{n}f(i)</script><p>再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{i=1}^{n}(f\times g)(i)&=\sum_{i=1}^{n}\sum_{j\mid i}f(j)g(\cfrac{i}{j})\\
&=\sum_{i=1}^{n}g(i)\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}f(j)\\
&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)
\end{aligned}</script><p>然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（</p>
<p>因为$g$也是积性函数，有$g(1)=1$，所以</p>
<script type="math/tex; mode=display">\begin{aligned}
S(n)&=g(1)S(n)\\
&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\\
&=\sum_{i=1}^{n}(f\times g)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)
\end{aligned}</script><p>就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。</p>
<p>如果说我们选择的$g$可以让我们迅速地求出$f\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。</p>
<p>关于后面的$g(i)S(\lfloor\cfrac{n}{i}\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。</p>
<p>我们来分析一下$\lfloor\cfrac{n}{i}\rfloor$。如果$1\leqslant i\leqslant\sqrt{n}$，因为$i$只有$\sqrt{n}$种不同的取值，$\lfloor\cfrac{n}{i}\rfloor$同样也只有$\sqrt{n}$种不同的取值。如果$\sqrt{n}&lt;i\leqslant n$，$1\leqslant\lfloor\cfrac{n}{i}\rfloor&lt;\sqrt{n}$，又因为要向下取整，自然也只有$\sqrt{n}$种不同的取值。如果我们能够把$\lfloor\cfrac{n}{i}\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\sqrt{n})$。</p>
<p>大体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于$r$的这个上界是怎么来的，我并不会证（</p>
<p>这样一来，要计算$S(n)$，我们需要调用所有的$\lfloor\cfrac{n}{x}\rfloor$，分别是$\lfloor\cfrac{n}{1}\rfloor,\lfloor\cfrac{n}{2}\rfloor,\cdots,\lfloor\cfrac{n}{\sqrt{n}}\rfloor,\sqrt{n},\sqrt{n}-1,\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\sqrt{n})$的。那么这样一来，总体的时间复杂度就是</p>
<script type="math/tex; mode=display">\begin{aligned}
O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{i}+\sqrt{\lfloor\cfrac{n}{i}\rfloor})&=O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{i}\rfloor})\\
&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{x}\rfloor}dx)\\
&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\cfrac{n}{x}}dx)\\
&=O(2n^{\frac{1}{2}}(n^{\frac{1}{4}}-1))\\
&=O(n^{\frac{3}{4}})
\end{aligned}</script><p>因为相比之下$\sqrt{\lfloor\cfrac{n}{i}\rfloor}$很明显要大一些，我们就可以将$\sqrt{i}$舍去。然后去掉取整符号并用积分近似。</p>
<p>这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\cfrac{n}{\sqrt{m}})$，当$m=n^{\frac{2}{3}}$时取得最小值$O(n^{\frac{2}{3}})$。</p>
<p>举个例子，就比如说我们要求</p>
<script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\varphi(i)</script><p>我们取$f=\varphi,g=1$，这样根据$\varphi$的性质，$f\times g=id$。不难看出$g$与$f\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=maxn)</span><br><span class="line">        <span class="keyword">return</span> phi[n];</span><br><span class="line">    <span class="comment">//phi是提前线性筛好的前缀和</span></span><br><span class="line">    <span class="keyword">if</span>(ans.count(n))</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    <span class="comment">//ans用来实现记忆化的哈希表，比如说unordered_map</span></span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1L</span>L*n*(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//f*g的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//注意要从2开始</span></span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        res-=(r-l+<span class="number">1</span>)*getSum(n/l);</span><br><span class="line">        <span class="comment">//r-l+1是g的前缀和</span></span><br><span class="line">        <span class="comment">//像这样递归+记忆化求解f的前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[n]=res;</span><br><span class="line">    <span class="comment">//返回的时候不要忘记存一下</span></span><br><span class="line">    <span class="comment">//就比如说我就忘过一次（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及，不用哈希表也是可以的。因为我们查询的数都是形如$\lfloor\cfrac{n}{x}\rfloor$的，当这个值大于$n^{\frac{2}{3}}$，即$x&lt;n^{\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令<code>ans[x]</code>表示$S(\lfloor\cfrac{n}{x}\rfloor)$。具体代码我就不写了（</p>
<p>再举个例子，求</p>
<script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\mu(i)</script><p>取$f=\mu,g=1,f\times g=\epsilon$。代码和上面差不多。</p>
<p>如果您理解了上面两个函数，这道<a href="https://www.luogu.org/problemnew/show/P4213">模板题</a>您就可以切了。</p>
<h2 id="其他题"><a href="#其他题" class="headerlink" title="其他题"></a>其他题</h2><h3 id="「Luogu-P3768」简单的数学题"><a href="#「Luogu-P3768」简单的数学题" class="headerlink" title="「Luogu-P3768」简单的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3768">「Luogu-P3768」简单的数学题</a></h3><p>快乐地推式子：</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum\limits_{i=1}^{n}i\sum\limits_{j=1}^{n}j\text{gcd}(i,j)&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j[i\perp j]\\
&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j\sum\limits_{x\mid i,x\mid j}\mu(x)\\
&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}x^{2}\mu(x)\text{Sum}^{2}(\lfloor\cfrac{n}{dx}\rfloor)\\
&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\sum\limits_{j\mid i}j\mu(\cfrac{i}{j})\\
&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\varphi(i)
\end{aligned}</script><p>其中</p>
<script type="math/tex; mode=display">\text{Sum}(n)=\sum\limits_{i=1}^{n}i</script><p>最后一步是因为</p>
<script type="math/tex; mode=display">\begin{aligned}
id\times\mu&=\varphi\times 1\times\mu\\
&=\varphi\times\epsilon\\
&=\varphi
\end{aligned}</script><p>理解不了上面的式子的话就多看看吧（</p>
<p>不难发现我们是要求$f(n)=n^{2}\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？</p>
<p><del>枚举瞎蒙（</del></p>
<p>考虑$g(n)=n^{2}$。</p>
<script type="math/tex; mode=display">\begin{aligned}
(f\times g)(n)&=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})\\
&=\sum\limits_{i\mid n}i^{2}\varphi(i)\cfrac{n^{2}}{i^{2}}\\
&=n^{2}\sum\limits_{i\mid n}\varphi(i)\\
&=n^{3}
\end{aligned}</script><p><del>其实我都不知道我当时是怎么想到这种操作的（</del></p>
<p>然后就和上面一样了。</p>
<h3 id="「Luogu-U18201」分析矿洞"><a href="#「Luogu-U18201」分析矿洞" class="headerlink" title="「Luogu-U18201」分析矿洞"></a><a href="https://www.luogu.org/problemnew/show/U18201">「Luogu-U18201」分析矿洞</a></h3><p>不知道从哪翻出来的题（</p>
<p>是某场个人邀请赛的$\text{T}1$<del>，从某种意义上也能看出那场比赛有多么神仙</del>。</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\varphi(\text{gcd}^{2}(i,j))&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}[i\perp j]\\
&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{x\mid i,x\mid j}\mu(x)\\
&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\lfloor\cfrac{n}{dx}\rfloor^{2}\\
&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}\varphi(j^{2})\mu(\cfrac{i}{j})\\
&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}j\varphi(j)\mu(\cfrac{i}{j})
\end{aligned}</script><p>设$f_1(n)=n\varphi(n),f_2(n)=\mu(n)$，考虑筛$f=f_1\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\times g$的前缀和。一种较优的方案是，令$g=1$，$f\times g=(id\cdot\varphi)\times\mu\times 1=id\cdot\varphi$，这样，我们还需要筛出$f_1(n)=n\varphi(n)$的前缀和。</p>
<p>怎么办？</p>
<p>再套一层杜教筛！</p>
<p>然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（</p>
<p>以及，像这种$n$爆了<code>int</code>的，一定要注意经常取模。<del>因为这个WA了好几次（</del></p>
<p>最后，源文件$17\text{KB}​$祭，blog翻页祭。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2018游记」夢の終わるところ</title>
    <url>/noip-2018-notes/</url>
    <content><![CDATA[<p><del>€€£：禁赛警告。</del></p>
<a id="more"></a>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>自从一周前放假回来以后，我就开始一颓不振：</p>
<p><img src="https://i.loli.net/2018/11/09/5be4e6d8c122f.png" alt=""></p>
<p>明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废<del>，同时看着其他dalao随手切神仙题</del>。然后我看到yemdalao写了一篇<a href="https://www.cnblogs.com/taduro/p/9933329.html">NOIp2018<del>禁赛记</del>游记</a><del>，想着禁赛真有趣</del>，我就写下了这篇游记。</p>
<blockquote>
<p>其他dalao都在机房补文化课而我在颓blog（</p>
<p>于是，此处以下，Updated on 2018-11-12。</p>
<blockquote>
<p>Updated on 2018-11-14</p>
<p>看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。</p>
<p>但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃</p>
</blockquote>
</blockquote>
<p>中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。</p>
<p>然后一抽考场发现是外校，赛前先<code>rp--</code>。</p>
<p>然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（</p>
<p>下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（</p>
<p>除那之外就没啥了，算是颓了一个下午。</p>
<p>晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（</p>
<p>试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。</p>
<p>反正板子是不可能打炸的，这辈子都不可能的。</p>
<p>因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。</p>
<p>然后一打开E盘发现被清了，只有题目。</p>
<p>Day1的解压密码是不是就我一个人不懂啊（</p>
<p>那么于是，到了8：30，我点开今天的题目，定神一看……</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5019">T1</a></h2><p>智障单调栈，有不开数组的做法，不过我懒得细想了，反正<code>score+=100</code>。</p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5020">T2</a></h2><p>稍微想一想不难想到完全背包，<code>score+=100</code>。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5021">T3</a></h2><p>神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。</p>
<p>估分100+100+25=225。</p>
<p>出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（</p>
<p>前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（</p>
<p>那我可真是太菜了（</p>
<p>下午日常发呆，然后晚上是快乐的颓废时间。</p>
<p>中午买的零食一个下午就全吃完了（</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>早上莫名起不来，然后就没吃早饭。</p>
<p>这次我东西是真的带全了（</p>
<p>Day2的解压密码依然不懂，然后是今天的题目：</p>
<h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5022">T1</a></h2><p>NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。</p>
<p>现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点<code>std::sort</code>一遍。然后维护一个邻接矩阵处理断边（</p>
<p>为什么不直接用邻接矩阵呢（</p>
<h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5023">T2</a></h2><p>神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（</p>
<h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5024">T3</a></h2><p>究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。</p>
<p>估分100+65+44=204（不存在的，肯定比这个低）。</p>
<p>这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……</p>
<p>不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（</p>
<p>好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……</p>
<p>下午请假回家开心地颓废。</p>
<h1 id="Extra-Notes"><a href="#Extra-Notes" class="headerlink" title="Extra Notes"></a>Extra Notes</h1><p>果然是等到NOIp结束后才更新的。</p>
<p>以及，我比较菜，第一次写游记，写的<del>可能</del>一定很菜，所以……算了，告辞。</p>
<blockquote>
<p>Updated on 2018-11-26</p>
<p>好像有些晚的更新。</p>
<p>出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（</p>
<p>具体成绩差不多是100+100+20+100+65+36=421。</p>
<p>以上。</p>
</blockquote>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>NOIp</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P5009」毒瘤分块题</title>
    <url>/luogu-p5009-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5009">传送门</a></p>
<a id="more"></a>
<p>从来没做过这么毒瘤的题qaq</p>
<p>就算看了题解现在还是一脸懵逼qaq</p>
<p>首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq</p>
<p>对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\prime$使得$v_i^\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\prime$，然后查询的时候我们就可以直接返回$v_i^\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\prime=v_i-t_1xb_i$。</p>
<p>需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\Sigma v_i^\prime+t\Sigma (a_i+x+z)(b_i+y)=\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$，即$\Sigma v_i^\prime=\Sigma v_i-tz\Sigma (b_i+y)$。</p>
<p>不过，上式中$tz\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\Sigma b_i$，考虑到每层节点的$\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\Sigma v_i+=B\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。</p>
<p>然后是毒瘤的下推标记。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];</span><br><span class="line"><span class="comment">//就是上面这句qaq现在还是一脸懵逼qaq</span></span><br><span class="line">A[son]+=A[father];</span><br><span class="line">B[son]+=B[father];</span><br><span class="line">adda[son]+=adda[father];</span><br><span class="line">addb[son]+=addf[father];</span><br></pre></td></tr></table></figure>
<p>其实我也不知道我上面在扯些啥，所以以下是代码<del>，反正应该没人能看懂我的清奇写法（</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 100000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> sumv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],suma[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sumb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sump[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> A[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],B[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> addv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],adda[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],addb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> ln,<span class="keyword">int</span> rn)</span></span>&#123;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addv[cur]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*ln%mod)%mod;</span><br><span class="line">    suma[cur&lt;&lt;<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*adda[cur]%mod)%mod;</span><br><span class="line">    sumb[cur&lt;&lt;<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addb[cur]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">    A[cur&lt;&lt;<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">    B[cur&lt;&lt;<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">    adda[cur&lt;&lt;<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">    addb[cur&lt;&lt;<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addv[cur]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*rn%mod)%mod;</span><br><span class="line">    suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*adda[cur]%mod)%mod;</span><br><span class="line">    sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addb[cur]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">    A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">    B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">    adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">    addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">    A[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    sumv[cur]=(sumv[cur&lt;&lt;<span class="number">1</span>]+sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    suma[cur]=(suma[cur&lt;&lt;<span class="number">1</span>]+suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    sumb[cur]=(sumb[cur&lt;&lt;<span class="number">1</span>]+sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    sump[cur]=(sump[cur&lt;&lt;<span class="number">1</span>]+sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        cltstream::read(sumv[cur]);</span><br><span class="line">        cltstream::read(suma[cur]);</span><br><span class="line">        cltstream::read(sumb[cur]);</span><br><span class="line">        sumv[cur]=(sumv[cur]%mod+mod)%mod;</span><br><span class="line">        suma[cur]=(suma[cur]%mod+mod)%mod;</span><br><span class="line">        sumb[cur]=(sumb[cur]%mod+mod)%mod;</span><br><span class="line">        sump[cur]=<span class="number">1L</span>L*suma[cur]*sumb[cur]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        build(cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)</span><br><span class="line">        <span class="keyword">return</span> (sumv[cur]+<span class="number">1L</span>L*t*sump[cur]%mod)%mod;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>,l,mid))%mod;</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r))%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyV</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        sumv[cur]=(sumv[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">        addv[cur]=(addv[cur]+x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyA</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        suma[cur]=(suma[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">        sump[cur]=(sump[cur]+<span class="number">1L</span>L*sumb[cur]*x%mod)%mod;</span><br><span class="line">        B[cur]=(B[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">        addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*addb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        adda[cur]=(adda[cur]+x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyB</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*suma[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        sumb[cur]=(sumb[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">        sump[cur]=(sump[cur]+<span class="number">1L</span>L*suma[cur]*x%mod)%mod;</span><br><span class="line">        A[cur]=(A[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">        addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*adda[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        addb[cur]=(addb[cur]+x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,t,l,r,x;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(t);</span><br><span class="line">        cltstream::read(l);</span><br><span class="line">        cltstream::read(r);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cltstream::write(query(l,r,t,<span class="number">1</span>,<span class="number">1</span>,n),<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                modifyA(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                modifyB(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                modifyV(l,r,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概是我太菜了不适合做这种毒瘤题吧qaq</p>
<p><img src="https://i.loli.net/2018/11/08/5be38edf529ca.jpg" alt=""></p>
<p>距 <strong>在NOIp2018爆零</strong> 还剩 <strong>1 天</strong>。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>状态压缩动态规划学习笔记</title>
    <url>/status-compression-learning-notes/</url>
    <content><![CDATA[<p><del>把标签和分类连在一起读就是标题了（</del></p>
<p><del>好像上一篇珂朵莉树学习笔记也是这样（</del></p>
<p><del>马上就要复赛了，但反正我已经退役预定了来颓blog吧。</del></p>
<a id="more"></a>
<p>首先我们来看一道例题，<a href="https://www.luogu.org/problemnew/show/P1879">「USACO06NOV」玉米田Corn Fields</a>。</p>
<p>首先，我们想到定义<code>f[i][...]</code>表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……<code>f[i][0/1]...(省略10个[0/1])...[0/1]</code>，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。</p>
<p>但是等等……$13$维的状态……</p>
<p><img src="https://i.loli.net/2018/10/24/5bd07656b885a.jpg" alt=""></p>
<p>注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。</p>
<p>于是，现在我们定义<code>f[i][S]</code>表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义<code>a[i]</code>表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。<code>valid[S]</code>表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。<code>a[i]</code>在读入时就可以处理出来，至于<code>valid[S]</code>，我们可以通过这样的一个循环处理出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    valid[i]=valid[i&gt;&gt;<span class="number">1</span>]&amp;(~(i&amp;(i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>用人话来讲就是<code>[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]</code>。</p>
<p>在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是<code>(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i])==a[i]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    (f[i][j]+=f[i<span class="number">-1</span>][k])%=mod;</span><br></pre></td></tr></table></figure>
<p>粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个<code>if</code>剪掉，因而实际运行跑得比谁都快（</p>
<p>为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，<a href="https://www.luogu.org/problemnew/show/P2704">「NOI2001」炮兵阵地</a>。</p>
<p>因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用<code>f[i][S1][S2]</code>表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录<code>a[i]</code>和<code>valid[S]</code>，不过，这次<code>valid[s]</code>的预处理过程差不多是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">    valid[i]=(i&amp;<span class="number">1</span>)?valid[i&gt;&gt;<span class="number">3</span>]&amp;((~i)&gt;&gt;<span class="number">2</span>)&amp;((~i)&gt;&gt;<span class="number">1</span>):valid[i&gt;&gt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg" alt=""></p>
<p><del>看起来</del>有些<del>非常</del>复杂，用人话来讲就是……诶我当时是不是写错了（</p>
<p>……不好像又没写错……</p>
<p>好吧没写错。</p>
<p>如果$S$的最后一位是$1$，则<code>[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]</code>，否则<code>[S是否合法]=[S&gt;&gt;1是否合法]</code>。</p>
<p>因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>转移过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">            <span class="keyword">if</span>((j|a[<span class="number">2</span>])==a[<span class="number">2</span>]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    f[<span class="number">2</span>][i][j]=cnt[i]+cnt[j];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i<span class="number">-2</span>])==a[i<span class="number">-2</span>]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span>&lt;&lt;m);++l)</span><br><span class="line">                        <span class="keyword">if</span>((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==<span class="number">0</span>&amp;&amp;(l&amp;k)==<span class="number">0</span>)</span><br><span class="line">                            f[i][k][l]=max(f[i][k][l],f[i<span class="number">-1</span>][j][k]+cnt[l]);</span><br></pre></td></tr></table></figure>
<p>时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\text{won’t TLE})$（</p>
<p>我们再来看一个状压的应用，<a href="https://www.spoj.com/problems/MMINPAID/">「SP3953」MMINPAID - Paid Roads</a>，或者您也可以<del>反正我就是</del>在<a href="https://www.luogu.org/problemnew/show/SP3953">洛谷</a>上提交。</p>
<p>大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义<code>dis[u][S]</code>为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，<code>dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)</code>，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。</p>
<p>这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。</p>
<p><del>我是不会说我把impossible打成Impossible然后交上去WA了一发的（</del></p>
<p>一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\leqslant 20$，就很有可能是状压题<del>或者也有可能是神仙剪枝题</del>。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。</p>
<p><img src="https://i.loli.net/2018/10/25/5bd13984b8601.jpg" alt=""></p>
<p>以上，我觉得我的状压讲的差不多了（</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>珂朵莉树学习笔记</title>
    <url>/chtholly-tree-learning-notes/</url>
    <content><![CDATA[<p><del>还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。</del></p>
<p><del>话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。</del></p>
<p>总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。</p>
<a id="more"></a>
<p>我们先来看一道<del>毒瘤</del>例题，<a href="http://codeforces.com/contest/896/problem/C">「CF896C」Willem, Chtholly and Seniorious</a>。</p>
<p>如果只看前三个操作的话<del>，虽然我不会写也没写过</del>，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？</p>
<p>这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于<code>std::set</code>的暴力数据结构<del>，虽然您也可以手写一颗平衡树</del>，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：</p>
<blockquote>
<p>珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。</p>
</blockquote>
<p>那么怎么推平呢？不急，我们慢慢讲。</p>
<p>珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="comment">//这里的mutable是为了让我们在之后的修改过程中可以修改val的值</span></span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">//调用时_r或_val不填的话默认-1，为了后面split时方便</span></span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以初始化了。对于这道题，我们可以像这样初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>初始化完了？</p>
<p>初始化完了。</p>
<p>然后就是珂朵莉树的核心操作<del>之一</del>，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::&lt;<span class="built_in">set</span>&gt;::<span class="function">iterator <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br></pre></td></tr></table></figure>
<p>作用是分离出一个左端点为<code>pos</code>的区间并返回它的迭代器。它的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="comment">//上面这句手打非常麻烦，建议宏定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="comment">//找第一个左端点大于等于pos的区间</span></span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    <span class="comment">//如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器</span></span><br><span class="line">    --it;</span><br><span class="line">    <span class="comment">//否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内</span></span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">    <span class="comment">//将区间[l,r]删除，并插入区间[l,pos)和[pos,r]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。</p>
<p><code>insert</code>函数的返回值类型是<code>std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;</code><del>，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了</del>，因此我们需要加个<code>.first</code>。</p>
<p><code>std::set</code>内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\operatorname{log}n)$的。</p>
<p>然后是一个同样很核心的操作，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure>
<p>将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="comment">//注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内</span></span><br><span class="line">    <span class="comment">//后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器</span></span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    <span class="comment">//将[itl,itr)内所有区间删除</span></span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">    <span class="comment">//用一个大区间取代它们</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就完了？</p>
<p>这就完了。</p>
<p><code>assign</code>操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得<code>set</code>的大小迅速减小，并最终趋于$\operatorname{log}n$。本题的操作二就只需调用一次<code>assign(l,r,x)</code>即可。</p>
<p>然后是剩下的三个操作<del>，一个比一个暴力</del>。</p>
<p>操作一，一个一个区间地拿出来加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这么几行？</p>
<p>就这么几行。</p>
<p>操作三，把所有区间取出来，然后直接调用<code>std::sort</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作四，暴力快速幂。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？</p>
<p>这是我在CodeForces上的提交记录：</p>
<p><img src="https://i.loli.net/2018/10/14/5bc28b1443ea5.png" alt=""></p>
<p>这是我之前提到的那位<del>不愿意透露姓名的</del>珂学家的跑得最快的一次提交记录：</p>
<p><img src="https://i.loli.net/2018/10/14/5bc28c7ecfe96.png" alt=""></p>
<p><img src="https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg" alt=""></p>
<p>珂幻.jpg</p>
<p>因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了<a href="http://codeforces.com/contest/915/problem/E">「CF915E」Physical Education Lessons</a>，然而……</p>
<p><img src="https://i.loli.net/2018/10/14/5bc297890bbc6.png" alt=""></p>
<blockquote>
<p>Updated on 2018-11-01</p>
<p>后来我卡了卡常数过了……</p>
<p>以及，删掉了某些内容（</p>
</blockquote>
<p>于是，接下来是珂朵莉树的完整板子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">        <span class="keyword">char</span> str[size+<span class="number">1</span>],*head=str,*tail=str;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">                tail=(head=str)+fread(str,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(head==tail)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="string">' '</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];<span class="built_in">putchar</span>(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,seed,maxval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=seed;</span><br><span class="line">    seed=(<span class="number">7L</span>L*seed+<span class="number">13</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; l,<span class="keyword">int</span>&amp; r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=l;</span><br><span class="line">    l=r;</span><br><span class="line">    r=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> res=cltpow(x,y&gt;&gt;<span class="number">1</span>,mod);</span><br><span class="line">    res=<span class="number">1L</span>L*res*res%mod;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">        res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAssign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//就是之前提到的assign</span></span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    cltstream::read(seed);</span><br><span class="line">    cltstream::read(maxval);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt=rnd()%<span class="number">4</span>+<span class="number">1</span>,l=rnd()%n+<span class="number">1</span>,r=rnd()%n+<span class="number">1</span>,x,y;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            swap(l,r);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAdd(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAssign(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                x=rnd()%(r-l+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXth(l,r,x),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                y=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXpow(l,r,x,y),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2009」虔诚的墓主人</title>
    <url>/luogu-p2154-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2154">传送门</a></p>
<a id="more"></a>
<p>几个月前某学姐给我推荐的<del>毒瘤</del>题之一。然而我直到现在也只切掉两道<del>，我真是太菜了</del>。</p>
<p>首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是</p>
<script type="math/tex; mode=display">C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}</script><p>考虑到墓地不能和常青树重合，又有$k\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为</p>
<script type="math/tex; mode=display">C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\sum\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})</script><p>怎么快速地查询与修改后面那个$\Sigma$所涉及到的值？树状数组啊<del>当然如果您非要写些乱七八糟的数据结构也没人拦着您</del>。</p>
<p>坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NOIp</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> RP,score;</span><br><span class="line">&#125;;</span><br><span class="line">NOIp NOIp2018;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        NOIp2018.RP++;</span><br><span class="line">        NOIp2018.score++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊<del>但是我实在是太菜了</del>qaq。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>SDOI</tag>
        <tag>2009</tag>
        <tag>离散化</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P4900」食堂</title>
    <url>/luogu-p4900-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4900">传送门</a></p>
<a id="more"></a>
<p><del>闲着没事写篇题解（</del></p>
<p>简单来说，就是要求</p>
<script type="math/tex; mode=display">\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\pmod{998244353}</script><p>其中$\lbrace x\rbrace$表示取$x$的小数部分。</p>
<p>稍加思索，我们不难发现</p>
<script type="math/tex; mode=display">\begin{aligned}
&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\\
\equiv&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\\
\equiv&\sum\limits_{i=1}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}-\sum\limits_{i=1}^{A-1}\sum\limits_{j=1}^{i}i\%j\times j^{-1}
\pmod{998244353}
\end{aligned}</script><p>因此，我们只需要关注下式的值</p>
<script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}</script><p>我们可以参考一下<a href="https://www.luogu.org/problemnew/show/P3708">这道题</a></p>
<p>在这道题中，我们定义了</p>
<script type="math/tex; mode=display">f(x)=\sum\limits_{i=1}^{n}x\%i</script><p>首先，如果不考虑$x\%i=0$的情况，我们有</p>
<script type="math/tex; mode=display">x\%i=(x-1)\%i+1</script><script type="math/tex; mode=display">f(x)=f(x-1)+n</script><p>如果$x\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此</p>
<script type="math/tex; mode=display">f(x)=f(x-1)+n-\sigma(x)</script><p>我们可以类似地定义</p>
<script type="math/tex; mode=display">g(x)=\sum\limits_{i=1}^{n}x\%i\times i^{-1}\pmod{998244353}</script><script type="math/tex; mode=display">h(x)=\sum\limits_{i\mid x}i\times i^{-1}\equiv\sum\limits_{i\mid x}1\equiv d(x)\pmod{998244353}</script><p>从而我们有</p>
<script type="math/tex; mode=display">g(x)\equiv g(x-1)+\sum\limits_{i=1}^{n}i^{-1}-d(x)\pmod{998244353}</script><p>然而我们需要的是</p>
<script type="math/tex; mode=display">\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>其中</p>
<script type="math/tex; mode=display">ans(x)=\sum\limits_{i=1}^{x}x\%i\times i^{-1}\pmod{998244353}</script><p>不难发现当$i&lt;j$时$i\%j=i$，从而</p>
<script type="math/tex; mode=display">\begin{aligned}
&g(x)-ans(x)\\
\equiv&\sum\limits_{i=x+1}^{n}x\%i\times i^{-1}\\
\equiv&\sum\limits_{i=x+1}^{n}x\times i^{-1}
\pmod{998244353}
\end{aligned}</script><p>最终，我们得到</p>
<script type="math/tex; mode=display">ans(x)\equiv g(x)-x\sum\limits_{i=x+1}^{n}i^{-1}</script><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\equiv\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-P3924」康娜的线段树</title>
    <url>/luogu-p3924-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3924">传送门</a></p>
<a id="more"></a>
<p>读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：</p>
<blockquote>
<p>对于$70\%$的数据，保证$1\leqslant n,m\leqslant 10^{5}$。</p>
<p>对于$100\%$的数据，保证$1\leqslant n,m\leqslant 10^{6}$。</p>
</blockquote>
<p><del>也就是说，上述做法<strong>最多</strong>只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。</del></p>
<blockquote>
<p>Updated on 2018-10-09</p>
<p>不好意思时间复杂度算错了我太菜了。</p>
<p>但反正线段树需要卡常才能过（</p>
</blockquote>
<p>我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。</p>
<p>定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。</p>
<p>稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。</p>
<p>以及，最后一句话。</p>
<p>这道题卡精度。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu-T47720」孤立元</title>
    <url>/luogu-t47720-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/T47720">传送门</a></p>
<a id="more"></a>
<p>自己出的第一道<del>毒瘤</del>数论题。</p>
<p>对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\notin B$且$i+1\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为</p>
<script type="math/tex; mode=display">\frac{\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}</script><p>将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式</p>
<script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\frac{m(n+1)(n-m)}{n(n-1)}</script><blockquote>
<p>Updated on 2018-10-10</p>
<p>之前公式写错了，分子上的$m$全都漏掉了（</p>
<p>以及，我们还可以将上式继续整理：</p>
<script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}</script><p><del>以及，顺便测试了一下新的快读板子，然后发现<code>#ifdef</code>真没用也可能是我太菜了（</del></p>
<blockquote>
<p>Updated on 2018-10-16</p>
<p>好吧我当时并不会用<code>#ifdef</code>（</p>
</blockquote>
<p>以及，标程经过一系列<del>丧心病狂的</del>卡常卡到了$1861\text{ms}$，最慢的一个点只跑了$300\text{ms}$不到。截至本日，另外两个切掉这道题的$\text{dalao}$最慢的一个点也只跑了$400\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？<del>所以说为什么我当初在本地测的时候平均每个点$500\text{ms}$，是我们机房的电脑太菜了吗（</del></p>
</blockquote>
<p>于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。</p>
<p>但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>总算是搞出来了一个自己觉得海星的blog……</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
